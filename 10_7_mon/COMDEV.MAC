TITLE	COMDEV -  MONITOR DEVICE DEPENDENT CODE, SYMBOLS, AND DATA - V1511
SUBTTL	T. HASTINGS/PH/TWE/DAL/JBS/EGF	22-OCT-90

	SEARCH	F,S,DEVPRM
IFN FTNET!M.ANF,<SEARCH NETPRM>
IFN M.KL10,<SEARCH DTEPRM>
IFN FTDECNET!M.DECN,<SEARCH D36PAR>

	$RELOC
	$LOW


;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED
;  OR COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION
; 1973,1974,1975,1976,1977,1978,1979,1980,1982,1984,1986,1988,1990.
;ALL RIGHTS RESERVED.

.CPYRT<1973,1990>


XP VCOMDV,1511		;PUT VERSION NUMBER IN GLOB AND LOADER STORAGE MAP
SUBTTL	TABLE OF CONTENTS

;               TABLE OF CONTENTS FOR COMDEV
;
;
;                        SECTION                                   PAGE
;    1. TABLE OF CONTENTS.........................................   2
;    2. CONVERT MONGEN SYMBOLS....................................   5
;    3. DEFAULT SYMBOLS...........................................   8
;    4. TERMINAL DATA BASE........................................  10
;    5. TERMINAL DATA BASE
;         5.1   TERMINAL CHARACTERISTICS DEFINITION...............  22
;         5.2   POINTERS FOR CURSOR SEQUENCES.....................  23
;         5.3   CURSOR CONTROL SEQUENCES..........................  24
;    6. NETWORK SYMBOLS FOR NON-NETWORK SYSTEMS...................  25
;    7. HARDWARE DEVICES
;         7.1   CARD PUCHES.......................................  26
;         7.2   CARD READERS......................................  27
;         7.3   DECTAPES..........................................  29
;         7.4   DISKS.............................................  30
;         7.5   DEC TEN-ELEVEN INTERFACE..........................  31
;         7.6   ETHERNET..........................................  32
;         7.7   LINE PRINTERS.....................................  33
;         7.8   MAGTAPES..........................................  34
;         7.9   PAPER TAPE PUNCHES................................  35
;         7.10  PAPER TAPE READERS................................  36
;         7.11  PLOTTERS..........................................  37
;         7.12  SYSTEM COMMUNICATIONS ARCHITECTURE................  38
;    8. SOFTWARE DEVICES/FUNCTIONS/PROTOCOLS
;         8.1   LOCAL AREA TERMINALS..............................  39
;         8.2   PSEUDO TERMINALS..................................  40
;    9. GLOBAL NETWORK DEFINITIONS................................  41
;   10. ANF-10 NETWORK DATA BASE
;        10.1   FEATURE TEST CHECK................................  43
;        10.2   PROTOTYPE DDB.....................................  44
;        10.3   PROTOTYPE NDB.....................................  45
;        10.4   NDT GENERATION....................................  46
;        10.5   CARD READERS......................................  47
;        10.6   DDCMP DEVICE......................................  48
;        10.7   LINE PRINTERS.....................................  49
;        10.8   MCR...............................................  50
;        10.9   REMOTE DATA ENTRY TERMINALS.......................  51
;        10.10  PAPER TAPE PUNCH..................................  52
;        10.11  PAPER TAPE READER.................................  53
;        10.12  PLOTTER...........................................  54
;        10.13  TASKS.............................................  55
;        10.14  VIRTUAL TERMINALS.................................  56
;        10.15  ETHERNET SUPPORT..................................  57
;        10.16  MONGEN PARAMETERS.................................  58
;        10.17  OBJECT TABLES.....................................  60
;        10.18  MISCELLANEOUS STORAGE.............................  61
;        10.19  DUMMY GLOBALS.....................................  62
;   11. DECNET NETWORK DATA BASE
;        11.1   FEATURE TEST CHECK................................  63
;        11.2   MONGEN PARAMETERS.................................  64
;        11.3   NOTES ON MONGEN PARAMETER SELECTION...............  66
;        11.4   INTERLOCKS........................................  67
;        11.5   LINE INITIALIZATION...............................  68
;        11.6   THE "NOBODY" KONTROLLER...........................  69
;        11.7   DUMMY GLOBALS.....................................  70
;   12. DECTAPE DATA BASE FOR DTASER..............................  71
;   13. INTERRUPT HEAD FOR DT'X...................................  72
;   14. DA28 DATA BASE (XTCSER)...................................  78
;   15. Database for RX20s on 2020s...............................  79
;   16. DEFINITIONS FOR DISPLAY AND LIGHT PEN.....................  80
;   17. ROUTINES COMMON TO PDP11 COMM FRONT-END'S ON DL10'S.......  83
SUBTTL	CONVERT TO OLD-STYLE MONGEN SYMBOLS

IFNDEF MONORG,<EXTERN MONORG>	;MAY APPEAR IN SYSCNF.MAC

XP JOBN,M.JOB+1

IFE	M.XTC,<XP M.XTL,0>

DEFINE TDMAC(X),<
	XP	DT'X'N,M.DT'X
M.DTXN==M.DTXN+M.DT'X
>
ZZ=="A"
M.DTXN==0
REPEAT M.TD10,<
	TDMAC(\"ZZ)
ZZ==ZZ+1
>

IFN FTKS10,<
    DEFINE RX2MAC(X),<
	XP	RX'X'N,M.RX'X
    M.RXXN==M.RXXN+M.RX'X
    >
    ZZ=="A"
    M.RXXN==0
    REPEAT M.RX20,<
	RX2MAC(\"ZZ)
    ZZ==ZZ+1
    >
>;End FTKS10
ND TTXTRA,0
XP	TTD28N,M.XTL
ND M.TTDN,0
IFN M.KS10,<
XP	KLILIN,M.TLTL+M.RTTY	;LINE NO. FOR KS10 KLINIK
>
XP	CTYLIN,<M.TLTL+M.RTTY+M.XTL+M.CPU+IFN M.KS10,<1>>
XP	FRCLIN,CTYLIN-M.CPU
	DEFINE	OPRL(LINE),<
IFIDN <LINE> <CTY>,<SIXBIT /CTY/>
IFDIF <LINE> <CTY>,<SIXBIT /TTY'LINE/>
>

DEFINE	DSASOC,<
	XLIST

	DEFINE	L(M,N,P),<
IFIDN <M> <CTY>,<
	ZZBEG==CTYLIN
	ZZDATA==CTYLIN
>
IFDIF <M> <CTY>,<
	ZZBEG==M
	ZZDATA==M
>
IFB <P>,<
	ZZEND==ZZBEG
	ZZLINE==N
>
IFNB <P>,<
	ZZEND==N
	ZZLINE==P
>

REPEAT ZZEND-ZZBEG+1,<
	GENLIN	(\ZZDATA,ZZLINE)
ZZDATA==ZZDATA+1
ZZLINE==ZZLINE+1
>>	;END REPEAT AND DEFINITION OF L

	LIST
>	;END DEFINITION OF DSASOC
SUBTTL DEFAULT SYMBOLS
;THE FOLLOWING STANDARD SYMBOLS CAN BE SUPERSEDED BY A CUSTOMER HAVING
; PREVIOUSLY DEFINED THEM ON THE HDWGEN.MAC FILE USING THE MONGEN PROGRAM....
;**********************************************************************
;ADD NEW SYMBOLS AT END SO EASY TO UPDATE MONGEN APPENDIX	      *
;**********************************************************************
ND	FLCDEF,1		;FILLER CLASS CODE TO USE IF NOT SPECIFIED
				;FOR A TTY LINE
ND	TTYWID,^D80		;DEFAULT SETTING OF TTY WIDTH IS 80.
ND	TTYRMT,1		;DEFAULT SETTING OF TTY REMOTE IS ON
ND	TTYLCT,1		;DEFAULT SETTING OF TTY LC IS OFF
ND	CTYLCT,TTYLCT		;MATCH DEFAULT SETTING OF CTY LC WITH TTY LC
XP CTYLTB,<FLCDEF*TTVFLC+CTYLCT*TTVLCT+0*TTVRMT>	;CTY 'LINTAB' BITS
XP TTYLTB,<FLCDEF*TTVFLC+TTYLCT*TTVLCT+TTYRMT*TTVRMT>	;TTY 'LINTAB' BITS

;PARAMETERS THAT CONTROL THE AUTO-DISCONNECT FEATURE.

ND	IDLSEC,^D90		;ANY TERMINAL IDLE THIS LONG GETS DISCONNECTED
ND	M.AIDL,IDLSEC		;ANF-10 DEFAULT IDLE TIME
ND	M.NIDL,IDLSEC		;NRT/CTERM DEFAULT IDLE TIME
ND	M.DIDL,IDLSEC		;DATASET MAXIMUM IDLE TIME
ND	M.LIDL,IDLSEC		;LAT TERMINAL IDLE-MAX
SUBTTL TERMINAL DATA BASE
;THE FOLLOWING SECTION DESCRIBES THE TELETYPE LINES,GLOBALS, AND
;DATA STRUCTURES OF THE MONITOR.

;THE FOLLOWING ARE SUPPLIED BY MONGEN


;M.DC10	=NUMBER OF DC10'S
;M.DC68	=NUMBER OF DC68'S
;M.DC76 =NUMBER OF DC76'S

;M.D7KN =NUMBER OF LINES ON DC76 K
;M.68LK	=NUMBER OF LINES ON DC68 K
;M.TTGK	=NUMBER OF LINES ON DC10 K
;M.DSGK	=NUMBER OF DC10E'S ON DC10 K
;M.TLTL	=TOTAL LOCAL TTY LINES

ND M.LCST,0		;DEFAULT TO NO CUSTOMER WORDS
IFG	M.LCST,<
  LDBCST==:LDBLEN##-M.LCST	;DEFINE START OF CUSTOMER AREA
>

;DEFINE SYMBOLS FOR CPUS OTHER THAN 0 UNTIL WE GET MONGEN WORKING

DEFINE CXDEF(SYM)<
IRP SYM,<
IFNDEF M0'SYM,<M0'SYM==M.'SYM>
IFNDEF M1'SYM,<M1'SYM==0>
IFNDEF M2'SYM,<M2'SYM==0>
IFNDEF M3'SYM,<M3'SYM==0>
IFNDEF M4'SYM,<M4'SYM==0>
IFNDEF M5'SYM,<M5'SYM==0>
>>

CXDEF(<TTG0,TTG1,68L0,68L1,D70N,D71N,D72N,D73N>)
CXDEF(<D74N,D75N,D76N,D77N,DZNL,TTDN>)

;THE FOLLOWING MAY BE SUPPLIED FOR LINTAB, WHERE THE LINE NUMBER
; IS CONCATENATED ON THE END (0 IN THIS CASE):

;DSD0 MEANS LINE 0 IS A DATASET LINE


;ALSO A MACRO IS DEFINED FOR DC10E-CONTROLLED DATASETS, WHICH
;DEFINES THE CORRESPONDENCE BETWEEN THE DC10E CONTROL LINE NUMBER
;(WHICH CONTROLS THE DATASET ENABLES, RINGING, ETC) AND THE
;CORRESPONDING DC10B LINE NUMBER (I.E., TTYN AS THE SYSTEM SEES
;IT). FOR EXAMPLE, FOR A SYSTEM WITH TWO DATASETS CONTROLLED
;BY DC10E LINES 27 AND 26, AND WITH DATA ON TTY17 AND TTY16 RESPECTIVELY,
;	DEFINE DSASOC <
;		GENLIN 27,17
;		GENLIN 26,16
;	>


;THE FOLLOWING ARE USED IN THE PREDEFINED LINE TABLES

DEFINE LINMAC (BITS) <
IRP BITS,<
LINMC1 (BITS,\LIN)
>
		LIN==LIN+1
>
DEFINE LINMC1 (B,N) <
B'N==:1
>
;THE FOLLOWING GLOBALS ARE USED IN VARIOUS ROUTINES SUCH AS
;ONCE,SCNSER,DLSINT,BTHINT,ETC.


ND M.DTEN,0
XP HGHLIN,M.TLTL+M.XTL		;HIGHEST LINE ON SCANNERS, BEFORE TCONLN
XP TCONLN,CTYLIN		;LINE NUMBER FOR CTY (NOT ON SCANNER)

XP DL0MXD,<10*M.TTG0>-1		;HIGHEST DC10 LINE WHICH IS REAL DATA
XP DL0MXL,<10*M.DSG0>+DL0MXD	;HIGHEST LINE ON DC10 (MAY BE DC10E)
XP DL0OFS,0			;OFFSET FROM LINTAB TO HARDWARE
XP DL1MXD,<10*M.TTG1>-1		;NUMBER OF DATA LINES ON DC10 #1
XP DL1MXL,<10*M.DSG1>+DL1MXD	;HIGHEST LINE ON DC10 #1
XP DL1OFS,<10*M.TTG0>		;ADD TO GO FROM HARDWARE TO LINTAB
XP CC0OFS,DL1OFS+<M.TTG1*10>	;OFFSET TO GET TO CCI0
XP CC1OFS,CC0OFS+M.68L0		;OFFSET TO GET TO CCI1
XP D70OFS,CC1OFS+M.68L1		;OFFSET FOR FIRST DC76
XP D71OFS,D70OFS+M.D70N		;OFFSET FOR SECOND DC76
XP D72OFS,D71OFS+M.D71N		;OFFSET FOR THIRD DC76
XP D73OFS,D72OFS+M.D72N		;OFFSET FOR FOURTH DC76
XP D74OFS,D73OFS+M.D73N		;OFFSET FOR FIFTH DC76
XP D75OFS,D74OFS+M.D74N		;OFFSET FOR SIXTH DC76
XP D76OFS,D75OFS+M.D75N		;OFFSET FOR SEVENTH DC76
XP D77OFS,D76OFS+M.D76N		;OFFSET FOR EIGHT DC76
XP DZOFS,D77OFS+M.D77N		;OFFSET FOR DZ11 TTY'S
XP TTDLAL,DZOFS+M.DZNL		;OFFSET FOR ALL TTD (RSX-20F) LINES
XP NETOFS,TTDLAL+M.TTDN		;OFFSET TO NETWORK TTY'S
XP D28OFS,NETOFS+M.RTTY		;OFFSET FOR DA28 LINES
XP DSCOF0,DL0MXD+1		;NUMBER TO SUBTRACT FROM LINE # TO
				; GET DCSTAB INDEX FOR DC10#0
XP DSCOF1,DL1MXD+1-<DL0MXL-DL0MXD> ;DITTO FOR DC10 #1

IFG <M.PTY-^D512>,<PRINTX ?512 OR MORE PTY'S EXCEEDS FIELD OF DDB>
XP TTPLEN,TCONLN+M.PTY+1	;LENGTH OF TRANSLATOR TABLE
				;INCLUDES ALL SCNANNERS, CTY, AND PTY'S
IFG <TTPLEN-^D512>,<PRINTX ?MORE THAN 512. TTYS+PTYS EXCEEDS FIELD OF DDB>
IFN M.DZNL,<

	EXTERN	DZINT	;LOAD SERVICE ROUTINE

;TABLE OF OUTPUT CHARACTERS FOR EACH DZ11 LINE
DZCHTB::BLOCK	M.DZNL

;TABLE OF DATASET STATUS FOR EACH DZ11
DZDSTB::BLOCK	<<M.DZNL+7>/10>

;TABLE OF LINE STATUS FOR AUTOBAUD FRONT END

DZTTQN::EXP	0
DZMSTS::BLOCK	M.DZNL

DEFINE X (N) <
DZ'N'VA::EXP	0		;JSR HERE ON INTERRUPT
	EXP	0,IC.UOU,.+1

	EXCH	T1,DZ'N'VA	;GET PC WE CAME FROM
	MOVEM	T1,SCNCHL##	;SAVE IT FOR SCNSAV
	MOVE	T1,DZ'N'VA+1	;SECOND WORD
	MOVEM	T1,SCNCHL##+1

	MOVE	T1,DZ'N'VA	;RESTORE T1
	JSR	SCNSAV##	;SAVE REGISTERS
	MOVE	P1,[DZ11BA+<N*10>]
	JRST	DZVECA##
DZ'N'VB::EXP	0		;JSR HERE ON INTERRUPT
	EXP	0,IC.UOU,.+1

	EXCH	T1,DZ'N'VB	;GET PC WE CAME FROM
	MOVEM	T1,SCNCHL##	;SAVE IT FOR SCNSAV
	MOVE	T1,DZ'N'VB+1	;SECOND WORD
	MOVEM	T1,SCNCHL##+1

	MOVE	T1,DZ'N'VB	;RESTORE REGISTER
	JSR	SCNSAV##	;SAVE REGISTERS
	MOVE	P1,[DZ11BA+<N*10>]
	JRST	DZVECB##
>
	ZZ=0
	REPEAT <<M.DZNL+7>/10>,<
	X	\ZZ
	ZZ=ZZ+1
	>
>;IFN M.DZNL
;DEFINE ALL DL10 SYMBOLS

	DLX.CK(0)		;MACRO DEFINED IN S.MAC
	INTERN	DL10XI		;FOR UUOCON


ND M.DN6S,0
;TELETYPE LINE CHARACTERISTICS (FORMER LH OF LINTAB)
;USED BY SCNSER

XP TTVRMT,1			;REMOTE LINE
XP TTVHLF,2			;HALF DUPLEX LINE (DC10C OR TWX)
XP TTVINI,4			;RUN INITIAL CUSP
XP TTVDSD,10			;DATASET DATA LINE
XP TTVDIS,20			;2741 ON DC10 (OBSOLETE)
XP TTVNFC,40			;NO FREE CRLF AT 72 COLUMNS
XP TTVFRM,100			;FORM FEED IN HARDWARE
XP TTVLCP,200			;LOCAL COPY, BUT NOT HALF DUPLEX
XP TTVTAB,400			;TAB HARDWARE (8 COLUMNS PER)
XP TTVLCT,1000			;LOWER CASE TRANSLATE TO UPPER
XP TTVSLV,2000			;SLAVE TTY
XP TTVFLC,4000			;TWO BITS OF FILLER CLASS CODE

	DEFINE	CALLM(NAME,LINE),<
	NDL NAME'LINE,1
>

	DEFINE	TTYMAC(TYPE),<
	XLIST

	DEFINE	L(A,B),<
IFB <B>,<IFE	<SIXBIT/A/>-<SIXBIT/CTY/>,<
			ZZBEG==FRCLIN+1
			ZZEND==TCONLN>
	IFN	<SIXBIT/A/>-<SIXBIT/CTY/>,<ZZBEG==<ZZEND==A>>
>
IFNB <B>,<
	ZZBEG==A
	ZZEND==B
>
ZZLINE==ZZBEG
IFGE ZZEND-FRCLIN,<ZZEND==FRCLIN-1>	;DON'T NEED TO INCLUDE PTYS
IFG ZZEND-ZZBEG+1,<
REPEAT ZZEND-ZZBEG+1,<
	CALLM	(TYPE,\ZZLINE)
ZZLINE==ZZLINE+1
>>>	;END IFG, REPEAT AND DEFINITION OF L
	MAC'TYPE
	LIST
>	;END DEFINITION OF TTYMAC
	.XCREF
	TTYMAC	DSD
	.CREF
;NOW DEFINE THE LINE TABLE FOR STORING LDB ADDRESSES.

$HIGH
LINTAB::
REPEAT TTPLEN,<
EXP	0
XLIST>
LIST
$LOW

;NOW THE DATASET CONTROLLER INFO FOR ANY DC10E'S


;CONSTRUCT THE DATASET CONTROLLER TABLE

DEFINE GENLIN(CON,DATA)<

ZZ==0
IFLE <CON-DL0MXD>,<ZZ==1>
IFG <CON-DL0MXL>,<ZZ==1>
IFG <DATA-DL0MXD>,<ZZ==1>		;CHECK RANGE OF ARGUMENT

IFN ZZ,<PRINTX ? SPECIFICATION ERROR - DSCTAB>
IFE ZZ,<
DSA'CON==1
DSB'CON==DATA
>
>

IFG M.DSG0,<
DSASOC
MACCR0			;INVOKE THE MACRO
>
DSCTAB::.INDEX==DL0MXD+1
DEFINE GENLIN(N)<
ZZ==0
IFDEF DSA'N,<IFN DSA'N,<ZZ==DL0OFS+DSB'N>>
	EXP	ZZ		;DATA SET N
.INDEX==.INDEX+1
>
REPEAT <DL0MXL-DL0MXD>,<GENLIN(\.INDEX)>

IFDEF	MACCR1,<	;ONLY IF 2 DC10'S

DEFINE GENLIN(CON,DATA)<

ZZ==0
IFLE <CON-DL1MXD>,<ZZ==1>
IFG <CON-DL1MXL>,<ZZ==1>
IFG <DATA-DL1MXD>,<ZZ==1>		;CHECK RANGE OF ARGUMENT

IFN ZZ,<PRINTX ? SPECIFICATION ERROR - DSCTAB>
IFE ZZ,<
DSA'CON==1
DSB'CON==DATA
>
>

DSASOC
MACCR1			;INVOKE THE MACRO
	.INDEX==DL1MXD+1
DEFINE GENLIN(N)<
ZZ==0
IFDEF DSA'N,<IFN DSA'N,<ZZ==DL1OFS+DSB'N>>
	EXP	ZZ		;DATA SET N
.INDEX==.INDEX+1
>
XALL
DSCTB1:REPEAT <DL1MXL-DL1MXD>,<GENLIN(\.INDEX)>
> ;END IFDEF MACCR1

ZZ==CC0OFS
	XP	DSCNDX,<.-DSCTAB>
	XP	CC0DSO,CC0OFS-<<M.TTG0+M.TTG1>*10>+DSCNDX
	XP	CC1DSO,CC1OFS-<<M.TTG0+M.TTG1>*10>+DSCNDX
	XP	D70DSO,D70OFS-<<M.TTG0+M.TTG1>*10>+DSCNDX
	XP	D71DSO,D71OFS-<<M.TTG0+M.TTG1>*10>+DSCNDX
	XP	D72DSO,D72OFS-<<M.TTG0+M.TTG1>*10>+DSCNDX
	XP	D73DSO,D73OFS-<<M.TTG0+M.TTG1>*10>+DSCNDX
	XP	D74DSO,D74OFS-<<M.TTG0+M.TTG1>*10>+DSCNDX
	XP	D75DSO,D75OFS-<<M.TTG0+M.TTG1>*10>+DSCNDX
	XP	D76DSO,D76OFS-<<M.TTG0+M.TTG1>*10>+DSCNDX
	XP	D77DSO,D77OFS-<<M.TTG0+M.TTG1>*10>+DSCNDX
	XP	DZDSO,DZOFS-<<M.TTG0+M.TTG1>*10>+DSCNDX
	XP	TTDDAL,TTDLAL-<<M.TTG0+M.TTG1>*10>+DSCNDX
REPEAT M.68L0+M.68L1+M.D70N+M.D71N+M.D72N+M.D73N+M.D74N+M.D75N+M.D76N+M.D77N+M.DZNL+M.TTDN,<	EXP ZZ
ZZ==ZZ+1

>
	MDSLN==:DSCTAB-.

;SYMBOL CONTROLLING WHETHER INITIA RUNS ON DATASET LINES
	ND	DSDRIC,1	;ZERO NOT TO RUN INITIA, NON-ZERO TO RUN IT


;DEFINE SOME CHUNK SIZE PARAMETERS AND MASKS

ND TTCHKS,8			;DEFAULT SIZE IN WORDS OF A TTY CHUNK
IFL TTCHKS-4,<TTCHKS==4>	;MUST BE AT LEAST 4
XP TTCHKS,<1B<^L<TTCHKS>>>	;WORDS IN A CHUNK (MUST BE POWER OF TWO)
XP CK.BDY,TTCHKS-1		;MASK FOR END OF CHUNK
XP CK.BTH,-CK.BDY		;OFFSET FOR START OF CHUNK
XP CK.CPC,CK.BDY*CK.CPW		;CHARACTERS PER CHUNK

;THE FOLLOWING SLIDING SCALE DEFINES THE LENGTH OF THE TTY FREE LIST

IFNDEF TTCHKN,<
IFNDEF TTCHKK,<
XP TTCHKK,<<TTYWID-1>/CK.CPC>+5	;ENSURE AT LEAST TTYWID CHARACTERS PER LDB
IFL TTPLEN-40,<XP TTCHKK,TTCHKK+1>	;MORE IF FEW LINES
IFL TTPLEN-20,<XP TTCHKK,TTCHKK+1>	;DITTO
IFL TTPLEN-10,<XP TTCHKK,TTCHKK+1>	;AND DITTO
> ;END OF IFNDEF TTCHKK

XP TTCHKN,TTCHKK*TTPLEN		;AT LAST, USE THIS CONSTANT TO GET TTCHKN

> ;END OF IFNDEF TTCHKN

TTCHKN==:TTCHKN			;MAKE SURE THIS SHOWS IN THE LISTING
TTCHKK==:TTCHKN/TTPLEN		;THIS ONE, TOO


;SCNSER'S INPUT WARNING/LIMIT LEVELS

ND TTYMIC,^D60				;MAXIMUM INPUT CHARS/MESSAGE
					;*** SHOULD MATCH DN8X DNCNFG.P11 ***

ND TTIBRK,^D132				;DEFAULT ASCII/IMAGE LINE "BREAK" LEVEL
ND TTIWRN,^D200				;DEFAULT ASCII/IMAGE XOFF WARNING LEVEL
ND TTIMAX,<TTIWRN+<5*TTYMIC>>		;DEFAULT ASCII/IMAGE MAXIMUM LEVEL
ND TTPBRK,^D132				;DEFAULT PIM MODE LINE "BREAK" LEVEL
ND TTPWRN,^D500				;DEFAULT PIM MODE XOFF WARNING LEVEL
ND TTPMAX,<TTPWRN+<5*TTYMIC>>		;DEFAULT PIM MODE MAXIMUM LEVEL


IFG M.XTC,<		;GENERATE TABLE FOR DA28 POOL
TTLTAB::BLOCK	TTD28N		;KON,,UNIT
XP MTTD28,-TTD28N		;MINUS # OF DA28 LINES
>

;DEFINE A BIT TABLE SHOWING WHICH LINES WERE MONGEN'ED AS DATASETS
DSDTAB::
SALL
DEFINE GENLIN(N),<
.XCREF
IFDEF DSD'N,<IFN DSD'N,<DSDW==DSDW!ZZZ>>
.CREF
> ;END DEFINE GENLIN
	ZZ==0			;STARTING LINE NUMBER
REPEAT <M.TLTL+^D31>/^D32,<
ZZZ==1B0
DSDW==0
REPEAT ^D32,<
GENLIN(\ZZ)
ZZZ==ZZZ_-1
ZZ==ZZ+1
>
EXP DSDW
> ;END OF BUILDING DSDTAB
;SCNSER QUEUED PROTOCOL HEADERS
DEFINE QHED(N)<
IFN M'N'TTG0,<DL0TQ'N::EXP 0,0>
IFN M'N'TTG1,<DL1TQ'N::EXP 0,0>
IFN M'N'68L0,<CC0TQ'N::EXP 0,0>
IFN M'N'68L1,<CC1TQ'N::EXP 0,0>
IFN M'N'D70N,<D70TQ'N::EXP 0,0>
IFN M'N'D71N,<D71TQ'N::EXP 0,0>
IFN M'N'D72N,<D72TQ'N::EXP 0,0>
IFN M'N'D73N,<D73TQ'N::EXP 0,0>
IFN M'N'D74N,<D74TQ'N::EXP 0,0>
IFN M'N'D75N,<D75TQ'N::EXP 0,0>
IFN M'N'D76N,<D76TQ'N::EXP 0,0>
IFN M'N'D77N,<D77TQ'N::EXP 0,0>
IFN M'N'DZNL,<DZTQ'N::EXP 0,0>
>
IFN M.XTL,<XTTQUE::EXP 0,0>

ZZ=0
REPEAT M.CPU,<
	QHED(\ZZ)
ZZ==ZZ+1
>

IFN M.RMCR,<MCRRTQ::EXP 0,0>	;NETWORK TERMINALS CAN RUN ON ANY CPU
				; HENCE THEY HAVE A QUEUE OF THEIR OWN.
IFN M.RVTM,<VTMQUE::EXP 0,0>	;SPECIAL QUEUE FOR NETWORK VIRTUAL TERMINALS
NULQUE::			;RANDOM QUEUE FOR UNUSED ALLOCATABLE LINES.
IFN M.RTTY,<EXP 0,0>
FRCQUE::EXP 0,0			;FORCE COMMAND LDB FAKE OUTPUT HEADER
;HERE ONCE A TICK TO START TERMINAL OUTPUT

DEFINE TTSTRT(FT,QH,RT),<
IFN FT,<
IFNB <QH>,<
	MOVEI	T1,QH
>
	PUSHJ	P,RT##
>>
DEFINE STRG(N),<

SC'N'TIC::SE1ENT
	TTSTRT(M'N'TTG0,DL0TQ'N,DL0STO)
	TTSTRT(M'N'TTG1,DL1TQ'N,DL1STO)
	TTSTRT(M'N'68L0,CC0TQ'N,CC0STO)
	TTSTRT(M'N'68L1,CC1TQ'N,CC1STO)
	TTSTRT(M'N'D70N,D70TQ'N,D76STO)
	TTSTRT(M'N'D71N,D71TQ'N,D76STO)
	TTSTRT(M'N'D72N,D72TQ'N,D76STO)
	TTSTRT(M'N'D73N,D73TQ'N,D76STO)
	TTSTRT(M'N'D74N,D74TQ'N,D76STO)
	TTSTRT(M'N'D75N,D75TQ'N,D76STO)
	TTSTRT(M'N'D76N,D76TQ'N,D76STO)
	TTSTRT(M'N'D77N,D77TQ'N,D76STO)
	TTSTRT(M'N'DZNL,DZTQ'N,DZSTO)
	TTSTRT(FTKS10,,CTYSTO)
	TTSTRT(FTKL10,,TTDSTO)
	TTSTRT(M.RMCR,,NETSTO)
	TTSTRT(M.DNVT,,NRTSTO)
	TTSTRT(M.LAT,,LATSTO)
	POPJ	P,
>
$HIGH
ZZ==0
REPEAT M.CPU,<
	STRG(\ZZ)
ZZ==ZZ+1
>
;HERE ONCE A SECOND FROM SCNSER
;ONLY ENTRIES HERE ARE ONES WHOSE ISR DISPATCH DOES SOMETHING

DEFINE TTSECN(FT,DSP),<
IFN FT,<PUSHJ P,DSP##+ISRCHK>
>

DEFINE STRG(N),<
SC'N'SEC::SE1ENT
	TTSECN(M'N'TTG0,DL0DSP)
	TTSECN(M'N'TTG1,DL1DSP)
	TTSECN(M'N'68L0,CC0DSP)
	TTSECN(M'N'68L1,CC1DSP)
	TTSECN(M'N'DZNL,DZDSP)
	TTSECN(FTKL10,CTYDSP)
	TTSECN(M.DNVT,NRTDSP)
	TTSECN(M.LAT,LATDSP)
	POPJ	P,
>
ZZ==0
REPEAT M.CPU,<
	STRG(\ZZ)
ZZ==ZZ+1
>
;THE TTY COMMAND MAP HAS 1 BIT PER LINE ARRANGED 32 BITS PER WORD
;THUS LINE 0 IS BIT 0 OF WORD 0, LINE 37(8) IS BIT 31 OF WORD 0,
; LINE 40(8) IS BIT 0 OF WORD 1, AND SO ON.
$LOW
TTMAPN==:<TTPLEN/^D32>+1
CMDMAP::BLOCK	TTMAPN		;TTY COMMAND BIT MAP
$HIGH

REPEAT	0,<			;FOR HISTORICAL REASONS
;TTYCMD IS CALLED ON EVERY CLOCK TICK TO LOOK FOR A COMMAND. IF THERE
; IS A COMMAND WAITING IT CALLS COMCON TO PROCESS IT. COMCON IN TURN
; CALLS TTFCOM WHICH SCANS CMDMAP TO FIND THE COMMAND.  THE ENTIRE
; PROCESS IS VERY FAST AND IS NOT ERROR PRONE.
TTYCMD::	;HERE TO TEST FOR A COMMAND
	ZZ==0
REPEAT TTMAPN,<
	SKIPE	CMDMAP+ZZ	;ANY COMMANDS IN THIS GROUP?
	PJRST	COMMAND##	;YES--CALL COMCON
	ZZ==ZZ+1
	XLIST
>;END REPEAT
	LIST
	POPJ	P,0
>  ;END REPEAT 0
	SUBTTL	TERMINAL DATA BASE -- TERMINAL CHARACTERISTICS DEFINITION

DEFINE CUSTRM,<		;CUSTOMER TERMINAL TYPES
	SPCCLS		;MONGEN CUSTOMER TERMINAL TYPES
	SPCCLX		;MONGEN CUSTOMER TERMINAL EXTENSIONS
TERMCR	(LA34,LA34,<OVR>,,132,0,0,1,0,0,0,<TAB,LC,XON>)
>

DEFINE DECTRM,<    ;DEC TERMINAL TYPES
TERMCR	(.FORCE,.FORCE,<8BT>,,255,0,0,0,0,0,0,<TAB,FF,LC>) ;;MUST BE FIRST!!**
TERMCR	(LT33,LT33,,,72,0,1,0,0,0,0,<ALT,CRLF,XON>)
TERMCR	(TTY33,LT33)
TERMCR	(TTY,LT33)
TERMCR	(LT35,LT35,,,72,0,1,0,0,0,0,<FF,TAB,ALT,CRLF,XON>)
TERMCR	(TTY35,LT35)
TERMCR	(VT05,VT05,<DIS>,,72,20,2,0,0,VT06EP,VTXXBP,<TAB,DIS,CRLF,XON>)
TERMCR	(VT06,VT06,<DIS>,,72,25,1,0,0,VT06EP,VT06BP,<DIS,CRLF,XON>)
TERMCR	(VT50,VT50,<DIS,V52>,,80,12,0,0,0,VTXXEP,VTXXBP,<TAB,XON,CRLF>)
TERMCR	(VT52,VT52,<DIS,V52>,,80,24,0,0,0,VTXXEP,VTXXBP,<TAB,LC,XON,CRLF>)
TERMCR	(VT61,VT52,<LID,CID>)
TERMCR	(DAS21,VT52)
TERMCR	(LA30,LA30,<OVR>,,72,0,1,0,0,0,0,<CRLF,XON>)
TERMCR	(LA36,LA36,<OVR>,,132,0,0,0,0,0,0,<XON,LC>)
TERMCR	(LA38,LA38,<OVR>,,132,0,0,1,1,0,0,<XON,LC,TAB>)
TERMCR	(LA120,LA120,<OVR>,,132,0,0,1,1,0,0,<XON,LC,TAB,FF>)
TERMCR	(LA180,LA180,<OVR,NKB>,,132,0,0,1,1,0,0,<XON,TAB,FF>)
TERMCR	(VT100,VT100,<SRM,DIS,AVO,VFW,V52>,,80,24,0,1,1,V100EP,VTXXBP,<TAB,LC,XON,CRLF>)
TERMCR	(VT101,VT100,,<AVO>)
TERMCR	(VT102,VT100,<LID,CID,PPO>)
TERMCR	(VT131,VT100,<BMT>)
TERMCR	(VT125,VT100,<GPO,SXL>)
TERMCR	(VT180,VT100)
TERMCR	(VT185,VT100,<GPO,SXL>)
TERMCR	(VT103,VT100)
TERMCR	(VK100,VT100,<GPO>,<SRM>)
TERMCR	(GIGI,VT100,<GPO>,<SRM>)
TERMCR	(VT200,VT200,<DIS,SEM,8BA,LID,CID,SRM,AVO,PPO,VFW,V52,NRC>,,80,24,0,2,2,V100EP,VTXXBP,<TAB,LC,XON,CRLF>)
TERMCR	(VT220,VT200)
TERMCR	(VT240,VT200,<GPO,SXL,UDK,RCS,TEK>)
TERMCR	(VT241,VT200,<GPO,SXL,UDK,RCS,TEK,CLR>)
TERMCR	(LN01S,LN01S,<NKB>,,80,66,0,1,1,0,0,<FF,TAB,LC,XON>)
TERMCR	(LN03,LN03,<NKB,8BA>,,80,66,0,2,1,0,0,<FF,TAB,LC,XON>)
TERMCR	(VT300,VT300,<DIS,8BA,LID,CID,SRM,AVO,PPO,VFW,VFL,V52,BMT,BTA,ESL,GAT,HSR,NRC,ISO,SEM,SRM,SSU,SXL,GPO,TCS,TSI,UDK,RCS,UWN,TEK>,,80,24,0,3,3,V100EP,VTXXBP,<TAB,LC,XON,CRLF>)
TERMCR	(VT320,VT300,,<SXL,GPO,TEK,BMT,BTA,GAT>)
TERMCR	(VT330,VT300)
TERMCR	(VT340,VT300,<CLR>)
>

DEFINE	TERMCR(NAME,CLASS,ATRON,ATROFF,WIDTH,LENGTH,FILL,ANSLVL,DECLVL,BPERAS,BPRUBO,CHARS),<
IFIDN<NAME><CLASS>,<.'CLASS:!EXP SIXBIT |CLASS|>
>

;EXPAND TERMINAL CLASS NAMES

CCNTAB::CUSTRM
TCNTAB::DECTRM
TCNLIM==:.-1		;FOR GETTAB

DEFINE	TERMCR(NAME,CLASS,ATRON,ATROFF,WIDTH,LENGTH,FILL,ANSLVL,DECLVL,BPERAS,BPRUBO,CHARS),<
IFIDN<NAME><CLASS>,<
ZZ==0
IRP ATRON,<ZZ==ZZ!TA.'ATRON>
IRP ATROFF,<ZZ==ZZ&<^-<TA.'ATROFF>>>
EXP	<%'CLASS==ZZ>
>>

;EXPAND TERMINAL CLASS ATTRIBUTES

CCATAB::CUSTRM
TCATAB::DECTRM

DEFINE	TERMCR(NAME,CLASS,ATRON,ATROFF,WIDTH,LENGTH,FILL,ANSLVL,DECLVL,BPERAS,BPRUBO,CHARS),<
IFIDN<NAME><CLASS>,<
ZZ==0
IRP CHARS,<
 IFE <SIXBIT/FF/>-<SIXBIT/CHARS/>,<ZZ==ZZ!<1_9>>
 IFE <SIXBIT/TAB/>-<SIXBIT/CHARS/>,<ZZ==ZZ!<1_8>>
 IFE <SIXBIT/LC/>-<SIXBIT/CHARS/>,<ZZ==ZZ!<1_7>>
 IFE <SIXBIT/XON/>-<SIXBIT/CHARS/>,<ZZ==ZZ!<1_6>>
 IFE <SIXBIT/ALT/>-<SIXBIT/CHARS/>,<ZZ==ZZ!<1_5>>
 IFE <SIXBIT/CRLF/>-<SIXBIT/CHARS/>,<ZZ==ZZ!<1_4>>
>
ZZ==ZZ^!<<1_7>!<1_5>!<1_4>>	;;LCT, ALT, AND NFC ARE BACKWARDS
BYTE	(8)^D'WIDTH,^D'LENGTH(2)FILL(4)^D'ANSLVL,^D'DECLVL(10)ZZ
>>

;EXPAND TERMINAL CLASS CHARACTERISTICS

CCCTAB::CUSTRM
TCCTAB::DECTRM

DEFINE	TERMCR(NAME,CLASS,ATRON,ATROFF,WIDTH,LENGTH,FILL,ANSLVL,DECLVL,BPERAS,BPRUBO,CHARS),<
IFIDN<NAME><CLASS>,<
IF2,<	.IF	BPRUBO,NEEDED,<EXTERN BPRUBO>
	.IF	BPERAS,NEEDED,<EXTERN BPERAS>
>
	XWD	BPRUBO,BPERAS
>>

;EXPAND TERMINAL CLASS BYTE POINTER TABLES

CCBTAB::CUSTRM
TCBTAB::DECTRM

DEFINE	TERMCR(NAME,CLASS,ATRON,ATROFF,WIDTH,LENGTH,FILL,ANSLVL,DECLVL,BPERAS,BPRUBO,CHARS),<
	EXP	SIXBIT	|NAME|
>

;EXPAND TERMINAL TYPES (FOR COMCON)

CTTWDT::CUSTRM
TTTWDT::DECTRM
TTTWDN==:.-CTTWDT

DEFINE	TERMCR(NAME,CLASS,ATRON,ATROFF,WIDTH,LENGTH,FILL,ANSLVL,DECLVL,BPERAS,BPRUBO,CHARS),<
ZZ==%'CLASS
IRP ATRON,<ZZ==ZZ!TA.'ATRON>
IRP ATROFF,<ZZ==ZZ&<^-<TA.'ATROFF>>>
ZZ==%'CLASS^!ZZ
IFN ZZ,<XWD .'CLASS-CCNTAB,[ZZ]>
IFE ZZ,<XWD .'CLASS-CCNTAB,0>
>

;EXPAND TERMINAL TYPE ATTRIBUTES

CTATAB::CUSTRM
TTATAB::DECTRM

PURGE	ZZ
	SUBTTL	TERMINAL DATA BASE -- POINTERS FOR CURSOR SEQUENCES

VT06BP:	POINT	9,VT06TB
	POINT	9,VT06TB+2,8
	POINT	9,VT06TB+4,17
	POINT	9,VT06TB+6,26
	POINT	9,VT06TB+10,35
	POINT	9,VT06TB+13,8
	POINT	9,VT06TB+15,17
	POINT	9,VT06TB+17,26

VT06EP:	POINT	9,VT06EL
	POINT	9,VT06E1
	POINT	9,VT06E2
	POINT	9,VT06E3

VTXXBP:	POINT	9,VTXXTB
	POINT	9,VTXXTB,26
	POINT	9,VTXXTB+1,17
	POINT	9,VTXXTB+2,8
	POINT	9,VTXXTB+2,35
	POINT	9,VTXXTB+3,26
	POINT	9,VTXXTB+4,17
	POINT	9,VTXXTB+5,8

VTXXEP:	POINT	9,VTXXEL
	POINT	9,VTXXE1
	POINT	9,VTXXE2
	POINT	9,VTXXE2,17

V100EP:	POINT	9,VTXXEL
	POINT	9,V100E1
	POINT	9,V100E2
	POINT	9,V100E2,17
	SUBTTL	TERMINAL DATA BASE -- CURSOR CONTROL SEQUENCES

VT06TB:	BYTE	(9)	177,177,177,010,040,177,177,177
	BYTE	(9)	010,177,177,177,010,040,177,177
	BYTE	(9)	177,010,177,177,177,010,040,177
	BYTE	(9)	177,177,010,177,177,177,010,040
	BYTE	(9)	177,177,177,010,177,177,177,010
	BYTE	(9)	040,177,177,177,010,177,177,177
	BYTE	(9)	010,040,177,177,177,010,177,177
	BYTE	(9)	177,010,040,177,177,177,010,177
	BYTE	(9)	177,177,010,040,177,177,177,010
	BYTE	(9)	0

VT06EL:	BYTE	(9)	015,177,177,177,0
VT06E1:	BYTE	(9)	30,177,177,177,0
VT06E2:	BYTE	(9)	30,177,177,177
VT06E3:	BYTE	(9)	36,177,177,177,0

VTXXTB:	BYTE	(9)	010,040,010,010,040,010,010,040
	BYTE	(9)	010,010,040,010,010,040,010,010
	BYTE	(9)	040,010,010,040,010,010,040,010
	BYTE	(9)	0

VTXXEL:	BYTE	(9)	015,0
VTXXE1:	BYTE	(9)	33,103,0
VTXXE2:	BYTE	(9)	33,103,33,113,0

V100E1:	BYTE	(9)	233,103,0
V100E2:	BYTE	(9)	233,103,233,113,0

	$LOW
	SUBTTL	NETWORK SYMBOLS FOR NON-NETWORK SYSTEMS

IFE M.DN6S,<
IFN M.KL10,<
D6SDDS==:EATDSP##
D6SUSR==:DFKUSR##
>
D60UP==:CPOPJ##
D60DWN==:CPOPJ##
>
IFN M.KL10,<
IFE M.DN6S,<
D6SED==:ECOD2##
D6SQ11==:ECOD2##
DWND6S==:STOTAC##
D6STMO==:CPOPJ##
>
IFE M.DN6D,<
D6DED==:ECOD2##
D6DQ11==:ECOD2##
>
>;END IFN M.KL10

IFN M.KL10,<
IFE <M.ANF*M.DN8S>,<
NCLDSP==:EATDSP##
D8SUSR==:DFKUSR##
> ;END IFE <M.ANF*M.DN8S>
> ;END IFN M.KL10

ND M.KDUP,0
ND M.DMRN,0
ND M.DN6K,0
ND M.DN6R,0
SUBTTL	HARDWARE DEVICES -- CARD PUCHES


ND CDPSIZ,41			;DEFAULT BUFFER SIZE

CDPMDT::MDCP10			;CARD PUNCH PARAMETERS


;DUMMY GLOBALS
IFE M.CDP,<
> ;END IFE M.CDP
SUBTTL	HARDWARE DEVICES -- CARD READERS


IFN M.CDR!M.RCDR,<

ND DCRMAX,1			;MAXIMUM NUMBER OF CARD READERS PER DTE

	PCDRAS==:700		;ASCIZ BYTE POINTER
	PCDRBI==:1400		;BINARY AND IMAGE BYTE POINTER
	PCDRSI==:4400		;SUPER IMAGE BYTE POINTER

CR1MDT::MDCR10			;I/O BUS CARD READER PARAMETERS
DCRMDT::MDDCR			;FRONT-END CARD READER PARAMETERS
CR2MDT::MDCR20			;UNIBUS CARD READER PARAMETERS

> ;END IFN M.CDR!M.RCDR


;DUMMY GLOBALS
IFE M.CR10,<
> ;END IFE M.CR10

IFE M.DCR,<
IFN M.KL10,<EQUATE (GLOBAL,EATDSP##,<FCRDSP>)>
> ;END IFE M.DCR

IFE M.CR20,<
> ;END IFE M.CR20
IFN M.CDR!M.RCDR,<		;LOCAL OR REMOTE CARD READERS?

;THE CHARACTER TRANSLATION TABLES:
	$HIGH
CRCVPT::XWD	350700+T2,CRCVTB
	XWD	260700+T2,CRCVTB
	XWD	170700+T2,CRCVTB
	XWD	100700+T2,CRCVTB

;CODE CONVERSION FOR THE 029 KEYPUNCH
;THE FOLLOWING EQUIVALENCES ARE ARTIFICIALLY DEFINED

;029 KEYTOP	;ASCII 35	;ASCII 37
;CENT		[		[
;0-8-2		]		]
;VERT BAR	^		HAT = L.C. VERT BAR
;UNDERBAR	_		UNDERBAR
;NEGATION	\		TILDE = L.C. NEGATION

	;CHARACTERS	;ZONE/DIGITS
CRCVTB:	ASCII	/ 123/		;N/N-3
	ASCII	.0/ST.		;0/N-3
	ASCII	/-JKL/		;11/N-3
	ASCII	/HI[./		;12,8/N-3
	ASCII	/&ABC/		;12/N-3
	ASCII	/QR]$/		;11,8/N-3
	ASCII	/YZ\,/		;0,8/N-3
	ASCII	/89:#/		;8/N-3
	ASCII	/4567/		;N/4-7
	ASCII	/UVWX/		;0/4-7
	ASCII	/MNOP/		;11/4-7
	ASCII	/<(+!/		;12,8/4-7
	ASCII	/DEFG/		;12/4-7
	ASCII	/*);^/		;11,8/4-7
	ASCII	/%_>?/		;0,8/4-7
	ASCII	/@'="/		;8/4-7

;CODE FOR THE 026 KEYPUNCH A LA H HYMAN

	ASCII	/ 123/		;N/N-3
	ASCII	.0/ST.		;0/N-3
	ASCII	/-JKL/		;11/N-3
	ASCII	/HI?./		;12,8/N-3
	ASCII	/+ABC/		;12/N-3
	ASCII	/QR:$/		;11,8/N-3
	ASCII	/YZ;,/		;0,8/N-3
	ASCII	/89_=/		;8/N-3
	ASCII	/4567/		;N/4-7
	ASCII	/UVWX/		;0/4-7
	ASCII	/MNOP/		;11/4-7
	ASCII	/)]<!/		;12,8/4-7
	ASCII	/DEFG/		;12/4-7
	ASCII	/*[>&/		;11,8/4-7
	ASCII	/("#%/		;0,8/4-7
	ASCII	/@^'\/		;8/4-7
	$LOW
>	;END OF IFN RCDRN+M.RCDR
SUBTTL	HARDWARE DEVICES -- DECTAPES


REPEAT 0,<
IFN M.TD10,<

IFNDEF SAVDMP,<SAVDMP==:'SAV'>	;EXTENSION FOR SAVED FILES

TD1MDT::MDTD10			;TD10 PARAMETERS

> ;END OF IFN M.TD10


IFE M.TD10,<

;DUMMY GLOBALS
EQUATE	(GLOBAL,CPOPJ##,<DTADDB,DTASEC,DTXFRE,OWNDTC,SCDDT>)
EQUATE	(GLOBAL,0,<DCONS,DSCON,DTADSP,DTXINI,LVFLAG,USEWRD>)

UNWDTC::SETZ	T3,
	POPJ	P,

> ;END IFE M.TD10
> ;END REPEAT 0
SUBTTL	HARDWARE DEVICES -- DISKS


	EXTERN	FILFND,	FILIO,	FILUUO ;LOAD DRIVER INTERFACE AND UUO SERVICE

;GENERATE MONGEN'ED DEVICE TABLES FOR DISKS
DPXMDT::MDDPX		;DP (RP10 MEMOREX)
DRXMDT::MDDRX		;DR (FUTURE DRUM)
FHXMDT::MDFHX		;FH (RC10/RM10B BURROUGHS DISK OR BRYANT DRUM)
FSXMDT::MDFSX		;FS (RH10)
MDXMDT::MDMDX		;MD (BRYANT MASS [MOBY] DISK)
RAXMDT::MDRAX		;RA (CI20/HSC)
RNXMDT::MDRNX		;RN (RH20/DX20/RP20CT)
RPXMDT::MDRPX		;RP (RH10/RH11/RH20)
			;*** EXAMPLE OF CUSTOMER DEFINITION
DSXMDT::MDDSX		;DS (SA10/IBM 3330/3331)


;DUMMY GLOBALS
IFE M.DPX,<
> ;END IFE M.DPX

IFE M.DRX,<
> ;END IFE M.DRX

IFE M.FHX,<
> ;END IFE M.FHX

IFE M.FSX,<
> ;END IFE M.FSX

IFE M.MDX,<
> ;END IFE M.MDX

IFE M.RAX,<
EQUATE	(GLOBAL,0,<RAKCTI,RAXDDT,RAXKON>)
> ;END IFE M.RAX

IFE M.RNX,<
EQUATE	(GLOBAL,0,<RNVNMR,RNVSMR>)
> ;END IFE M.RNX

IFE M.RPX,<
> ;END IFE M.RPX
SUBTTL	HARDWARE DEVICES -- DEC TEN-ELEVEN INTERFACE


IFN M.KL10,<
	.XCREF

	PRMMIN==65
IFL VDTPRM-PRMMIN,<PRINTX ?PLEASE USE LATEST VERSION OF DTEPRM
			PASS2
			END>

;GENERATE FRONT END DEVICE BLOCKS
	FEDGEN

;GENERATE HEADER FOR COMM REGION
	ETHEAD

;GENERATE COMM REGION ITSELF
	ETREGN

;GENERATE DTE CONTROL BLOCKS
	ETDGEN

;GENERATE TABLE OF CORRESPONDENCE BETWEEN CPU#,DTE# AND DTE CONTROL BLOCKS
	.CREF
	ETDTBX

;TABLE FOR MASTER DTE CONTROL BLOCK ADDRESS FOR EACH CPU
DEFINE	DFLMAS	(C),<EXP	ETD'C'1B>

DTEMAS::
N10==0
REPEAT M.CPU,<
	DFLMAS	\N10
	N10==N10+1
>


;MACROS FOR RSX-20F DEVICE SYMBOLS AND STORAGE
DEFINE	RSX20F	<
	N10==0				;;INDEX FOR -10 CPU #
	REPEAT	M.CPU,<			;;DO FOR EACH CPU ON SYSTEM
		RSXCPU	\N10		;;CALL CPU MACRO
		N10==N10+1		;;STEP TO NEXT CPU
	>
>

DEFINE	RSXCPU	(C)	<
	N11==0				;;INDEX FOR -11 CPU (DTE) #
	REPEAT	4,<			;;DO FOR ALL DTE'S
		RSXDTE	\C,\N11		;;CALL CURRENT DTE MACRO
		N11==N11+1		;;STEP TO NEXT -11 (DTE)
	>
>
> ;END M.KL10
SUBTTL	HARDWARE DEVICES -- ETHERNET


IFN M.ENET,<

ND %ETUPQ,4			;USER PORTAL JOB QUOTA
ND %ETBQT,<4,,10>		;USER PORTAL DATAGRAM BUFFER QUOTAS
				; (LH=TRANSMIT QUOTA, RH=RECEIVE QUOTA)
ND M.ETSZ,3000			;FREE CORE ALLOCATION POOL SIZE FOR ETHERNET
IFE M.LAT,<M.LASZ==0>		;ALLOWANCE IF NO LAT
IFN M.LAT,<ND M.LASZ,15000>	;ALLOWANCE IF LAT
   ETHSIZ==M.ETSZ+M.LASZ	;TOTAL SIZE OF POOL
   ETHSIZ==:<^D144*<<ETHSIZ+^D143>/^D144>>
   ETHBTL==<ETHSIZ+^D143>/^D144 ;SIZE OF THE BIT MAP

IFN M.KL10,<
ND M.KNSZ,3000			;FREE CORE ALLOCATION POOL SIZE FOR KLNI
   KNISIZ==:<^D144*<<M.KNSZ+^D143>/^D144>>
   KNIBTL==<KNISIZ+^D143>/^D144 ;SIZE OF THE BIT MAP
> ;END IFN M.KL10

	EXTERN	ETHUUO		;FORCE LOADING OF ETHERNET UUO SERVICE
IFN M.KL10,<
	EXTERN	KNISER		;FORCE LOADING OF KLNI DEVICE SERVICE
IFN FTEMOP,<
	EXTERN	LLMINI		;KLNI MAINTENANCE PROTOCOL SERVICE
>; END IFN FTEMOP
> ;END IFN M.KL10
IFN M.KS10,<EXTERN UNASER>	;FORCE LOADING OF DEUNA DEVICE SERVICE

;GENERATE MONGEN'ED DEVICE TABLES FOR ETHERNET
IFN FTKL10,<KNIMDT::MDENET>	;NIA20 (KLNI)
IFN FTKS10,<UNAMDT::MDENET>	;DEUNA

IFN M.KS10!<^-FTEMOP>,<
EQUATE	(GLOBAL,CPOPJ##,<ULLMOP,LLMINI,LLMMIN>)
LLMPSI::!SETZ	T2,
	 POPJ	P,
> ;END IFN M.KS10 OR NOT FTEMOP

ETHLOC::EXP	0		;STARTING ADDRESS OF ETHERNET FREE CORE
ETHPTR::XWD	-ETHBTL,.+1	;AOBJN POINTER TO ETHERNET FREE CORE BIT MAP
	BLOCK	ETHBTL		;THE MAP ITSELF

IFN M.KL10,<
KNILOC::EXP	0		;STARTING ADDRESS OF KLNI FREE CORE
KNIPTR::XWD	-KNIBTL,.+1	;AOBJN POINTER TO KLNI FREE CORE BIT MAP
	BLOCK	KNIBTL		;THE MAP ITSELF
LLMACT::BLOCK	1		;LLMOP IDENTIFY-SELF TIMER WORD
> ;END IFN M.KL10
> ;END IFN M.ENET

IFE M.ENET,<
EQUATE	(GLOBAL,CPOPJ##,<ENTRST,ETHINI,UETHNT,ETHSEC,UKNIBT,ULLMOP,D8EINI>)
EQUATE	(GLOBAL,0,<ETHLOC,ETHMXL,ETHPTR,ETHSIZ>)
EQUATE	(GLOBAL,NULGTB##,<ETHGTB>)
EQUATE	(GLOBAL,0,<KNISIZ>)

IFN M.KL10,<
EQUATE	(GLOBAL,CPOPJ##,<KNISYS>)
EQUATE	(GLOBAL,0,<KNILOC,KNIPTR>)
> ;END IFN M.KL10

ETHSER::!
DLLUNI::!MOVEI	T1,1			;RETURN ERROR UNIFC% (ILLEGAL FUNCTION)
	 POPJ	P,			;...
LLMPSI::!
ENTPSI::!SETZ	T2,			;RETURN DUMMY STATUS CODE
	 POPJ	P,			;...

IFN M.KL10,<
EQUATE	(GLOBAL,CPOPJ##,<KNIDED,KNILDR,KNIINI,KNIMOF,KNIMON,KNIRMV>)
EQUATE	(GLOBAL,CPOPJ##,<KNIRST,KNISEC,KNITIC,LLMINI,LLMMIN,DAEINI>)
KNIDIA==:ECOD13##			;DIAG. UUO ERROR ILLEGAL FUNCTION
> ;END IFN M.KL10

> ;END IFE M.ENET
SUBTTL	HARDWARE DEVICES -- LINE PRINTERS


IFN M.LPT,<

ND LPTSIZ,^D27+2		;DEFAULT BUFFER SIZE
ND DLPMAX,2			;MAXIMUM NUMBER OF PRINTERS PER DTE

LPTMDT::MDLP10			;I/O BUS LINE PRINTER PARAMETERS
DLPMDT::MDDLP			;FRONT-END LINE PRINTER PARAMETERS
LP2MDT::MDLP20			;UNIBUS LINE PRINTER PARAMETERS

> ;END OF IFN M.LPT


;DUMMY GLOBALS
IFE M.LP10,<
> ;END IFE M.LP10

IFE M.DLP,<
IFN M.KL10,<EQUATE (GLOBAL,EATDSP##,<DLPDSP>)>
> ;END IFE M.DLP

IFE M.LP20,<
> ;END IFE M.LP20
SUBTTL	HARDWARE DEVICES -- MAGTAPES


IFN M.TAPE,<

ND DSETIM,^D320			;MAXIMUM TIME TO DO A DATA SECURITY ERASE
ND MTSIZ,^D128			;DEFAULT BUFFER SIZE
ND MTELOG,-1			;LOG ERRORS THAT REQUIRED MORE THAN 1 RETRY
ND MTDAEM,10			;NUMBER OF TIMES PER REEL TO CALL DAEMON
ND MTDLTP,LT.BLP		;DEFAULT LABEL TYPE
ND MTFILE,1			;USE HARDWARE SKIP FILE FUNCTIONS
ND NOISE,^D12			;NOISE RECORD LENGTH IN BYTES
ND MQUANT,^D10			;CONSECUTIVE RECORDS
ND TAPTIM,^D60			;MAXIMUM TIME TO SKIP 10 RECORDS
ND TKBICT,2			;INITIAL FAIRNESS COUNT FOR QUEUED REQUEST

	EXTERN	TAPSER,	TAPUUO	;LOAD DRIVER INTERFACE AND UUO SERVICE

;GENERATE MONGEN'ED DEVICE TABLES FOR MAGTAPES
TM2MDT::MDTM02			;TM02/TM03
TX1MDT::MDTX01			;DX10/TX01/TX02
TD2MDT::MDDX20			;DX20/TX01/TX02
T78MDT::MDTM78			;TM78
TMXMDT::MDTM10			;TM10B
TCXMDT::MDTC10			;TC10C
				;*** EXAMPLE OF CUSTOMER DEFINITION
TS1MDT::MDTS10			;SA10/IBM CHANNEL MAGTAPES

IFE M.TX01,<CCHJGO==:1B2+1B3>	;DX10 CHANNEL GO & JUMP BITS FOR MAKLST

> ;END OF IFN M.TAPE


IFE M.TAPE,<

;DUMMY GLOBALS
EQUATE	(GLOBAL,CPOPJ##,<TAPMIN,TAPSEC,TAPTIC>)
EQUATE	(GLOBAL,CPOPJ##,<TPMCTT,TPMREA,TPMRES,TPMDVS,TPDSIA>)
EQUATE	(GLOBAL,CPOPJ##,<UTAPOP,MTARID,MTACHR,MTAPE0>)
EQUATE	(GLOBAL,CPOPJ##,<TPCLSX,TPFREE,TPSTAT,TPSKPW>)
EQUATE	(GLOBAL,CPOPJ1##,<TPMSIL>)
EQUATE	(GLOBAL,0,<MTSIZ,TUYLTP,TDVUDB,TUBCRD>)
EQUATE	(GLOBAL,ZPOPJ##,<TAPCPI>)
EQUATE	(GLOBAL,COMERR##,<MTADEN,MTABLK,MTAMOD,MTARTY>)
	CCHJGO==:1B2+1B3	;DX10 CHANNEL GO & JUMP BITS FOR MAKLST

> ;END IFE M.TAPE
SUBTTL	HARDWARE DEVICES -- PAPER TAPE PUNCHES


ND PTPSIZ,41			;DEFAULT BUFFER SIZE

PTPMDT::MDPTP			;PAPER TAPE PUNCH PARAMETERS


;DUMMY GLOBALS
IFE M.PTP,<
> ;END IFE M.PTP
SUBTTL	HARDWARE DEVICES -- PAPER TAPE READERS


ND PTRSIZ,41			;DEFAULT BUFFER SIZE

PTRMDT::MDPTR			;PAPER TAPE READER PARAMETERS


;DUMMY GLOBALS
IFE M.PTR,<
> ;END IFE M.PTR
SUBTTL	HARDWARE DEVICES -- PLOTTERS


IFN M.PLT,<

ND PLTSIZ,^D36			;DEFAULT BUFFER SIZE

PLTMDT::MDXY10			;I/O BUS PLOTTER PARAMETERS

> ;END OF IFN M.PLT


;DUMMY GLOBALS
IFE M.XY10,<
> ;END IFE M.XY10
SUBTTL	HARDWARE DEVICES -- SYSTEM COMMUNICATIONS ARCHITECTURE


IFN M.SCA,<

	EXTERN	MSCCOM,	KLPSER	;LOAD MSC AND CI20 DRIVERS
	EXTERN	SCSUUO		;LOAD UUO SERVICE

KLPMDT::MDSCA			;CI20 PARAMETERS

>; END IFN M.SCA

IFE M.SCA,<

;DUMMY GLOBALS
EQUATE	(GLOBAL,CPOPJ##,<BHDINI,REVFUL>)
EQUATE	(GLOBAL,CPOPJ##,<MSCCUS,MSCGBF,MSCINI,MSCUON>)
EQUATE	(GLOBAL,CPOPJ##,<SC.INI,SC.SEC,SC.TIC>)
EQUATE	(GLOBAL,CPOPJ##,<SCS,SCSCLK,SCSLGO,SCSPOP,SCSRST>)
EQUATE	(GLOBAL,CPOPJ##,<PPDCLR,PPDINX,PPDMFL,PPDMOD,PPDRMV,PPDRHD>)
EQUATE	(GLOBAL,CPOPJ##,<PPDSEC,PPDTIC,PPDMON>)
EQUATE	(GLOBAL,DIAACI##,<DIACTR,DIAEDP,DIARMD,DIARRS,DIASRS,DIAWMD>)
EQUATE	(GLOBAL,0,<BHDPGS,BSDPGS>)

SCSPSI::SETZ	T2,
	POPJ	P,

BHDADR::
BSDADR::EXP	0

>; END IFE M.SCA
SUBTTL	HARDWARE DEVICES -- SYSTEMS CONCEPTS IBM CHANNEL


IFN M.SA10,<

SAXMDT::MDSA10			;SA10 PARAMETERS

>; END IFN M.SA10

IFE M.SA10,<

;DUMMY GLOBALS

>; END IFE M.SCA
SUBTTL	SOFTWARE DEVICES/FUNCTIONS/PROTOCOLS -- LOCAL AREA TERMINALS


IFE M.ENET,<M.LAT==:0>		;DEPENDENT UPON ETHERNET SERVICE
ND M.LAT,0			;DEFAULT IS OFF
IFN M.LAT,<EXTERN LATINI>	;FORCE LOADING OF LAT SERVICE ROUTINES

IFE M.LAT,<
EQUATE	(GLOBAL,CPOPJ##,<LATINI,.LATOP,CWHLAT,LATRST>)
EQUATE	(GLOBAL,NOPDNC##,<NETDIL>)
EQUATE	(LOCAL,0,<M.LNAM>)

IFE M.ENET,<LATPSI==:ENTPSI>	;IF NO ETHERNET SERVICE AT ALL
IFN M.ENET,<LATPSI==:ENTPSI##>	;IF ETHERNET SERVICE, BUT NO LAT

> ;END IFE M.LAT

IFN M.LAT,<		;ONLY GENERATE IF WANT LATSER
;SOME SPACE FOR A SLOT ALLOCATION BIT TABLE FOR LAT TERMINALS
NTTLAH==:M.RTTY			;SAME AS NUMBER OF NETWORK TTYS
SBBWDS==:<NTTLAH+^D35>/^D36	;ONE BIT FOR EACH SLOT WE COULD HAVE
SBBITS::BLOCK	SBBWDS
MAXCIR==:M.LAMC			;MAXIMUM NUMBER OF CIRCUITS

;TABLE OF DESIRED INITIAL GROUPS FOR LAT SERVICE

DEFINE	LATGRP(ARG),<IRP ARG,<LATGR1(ARG)>>	;STRIP OFF ANGLES
DEFINE	LATGR1(ARG),<LATGR2(ARG,ARG)>		;MORE ANGLE BRACKETS
DEFINE	LATGR2(LOGRP,HIGRP,XX,YY),<
	.ZZ==^D'LOGRP
	REPEAT ^D<HIGRP-LOGRP+1>,<
		.ZZW==.ZZ/^D32			;;WORD OFFSET IN BLOCK
		.ZZB==1B<7-<.ZZ&7>>_-<8*<<.ZZ/8>&3>>	;;BIT TO SET
		CONC(LATGW,\.ZZW,<==.ZZB!LATGW>,\.ZZW)	;;SET IT
		.ZZ==.ZZ+1			;;ADVANCE TO NEXT GROUP
	>				;;REPEAT OVER GROUPS IN LIST
> ;END DEFINE LATGR?

LATGW7==<LATGW6==<LATGW5==<LATGW4==<LATGW3==<LATGW2==<LATGW1==<LATGW0==0>>>>>>>
	SPCGRP					;GET MONGEN'ED LAT GROUPS

LATIGE::EXP	LATGW0,LATGW1,LATGW2,LATGW3,LATGW4,LATGW5,LATGW6,LATGW7

IF2,<
 PURGE .ZZ,.ZZW,.ZZB,LATGW0,LATGW1,LATGW2,LATGW3,LATGW4,LATGW5,LATGW6,LATGW7
>

> ;END IFN M.LAT
SUBTTL	SOFTWARE DEVICES/FUNCTIONS/PROTOCOLS -- MULTIPLEXED CHANNELS


IFN M.MPX,<
	EXTERN	MPXSER			;FORCE LOADING OF MPX SERVICE
MPXMDT::MDCPUN	(00,00,00,00,00,00)	;DUMMY MPX PARAMETERS
	MDTERM
> ;END IFN M.MPX

;DUMMY GLOBALS
IFE M.MPX,<
EQUATE	(GLOBAL,CPOPJ##,<CLRST,CONECT,ERLST,SENSE>)
EQUATE	(GLOBAL,CPOPJ##,<DEVUDX,LGLMPX,MOVHDR,MSGBFE,MSGOUT,TSTMPX,ZAPMPX>)
EQUATE	(GLOBAL,CPOPJ##,<MPXIOD,MPXIOS,MPXDIS,MPXWAT,MPXWAI>)
EQUATE	(GLOBAL,CPOPJ1##,<CHKMPX,MPXACT>)
> ;END IFE M.MPX
SUBTTL	SOFTWARE DEVICES/FUNCTIONS/PROTOCOLS -- PSEUDO TERMINALS


IFN M.PTY,<
ND PTYRMT,0			;DEFAULT TO LOCAL
ND PTYLCT,0			;NOT LOWER CASE
	PTYLTB==:<0*TTVFLC+PTYLCT*TTVLCT+PTYRMT*TTVRMT>	;LINTAB BITS
PTYOFS==:TCONLN+1		;OFFSET FOR PTY-DRIVEN TTY'S

	EXTERN	PTYSER			;FORCE LOADING OF PTY SERVICE
PTYMDT::MDCPUN	(00,00,00,00,00,00)	;DUMMY PTY PARAMETERS
	MDTERM

PTYTAB::BLOCK	M.PTY			;ADDRESSES OF THE PTY DDBS
> ;END IFN M.PTY

;DUMMY GLOBALS
IFE M.PTY,<
EQUATE	(GLOBAL,CPOPJ##,<CTLJOB,UJBSTS,PTYPE,PTMNMZ,PTYOW,PTMNMD>)
EQUATE	(GLOBAL,CPOPJ1##,<PTPTCH>)
EQUATE	(GLOBAL,0,<PTYLTB>)

CTLJBU::!SETZM	U
CTLJB::!
CTLJBD::MOVNI	T1,1
	POPJ	P,
> ;END IFE M.PTY
SUBTTL	SOFTWARE DEVICES/FUNCTIONS/PROTOCOLS -- TERMINALS


SCNN==:JOBN+TTXTRA+M.DTEN		;NUMBER OF TTY DDBS TO BE BUILT

	EXTERN	SCNSER			;FORCE LOADING OF SCANNER SERVICE
SCNMDT::MDCPUN	(00,00,00,00,00,00)	;DUMMY SCANNER PARAMETERS
	MDTERM
SUBTTL	GLOBAL NETWORK DEFINITIONS


IFE M.NET,<
EQUATE	(GLOBAL,0,<M.ANF,M.DECN,M.LAT,M.RTTY>)
	M.SNAM==:<SIXBIT/CENTRA/>
> ;END IFE M.NET

IFE M.RTTY,<
EQUATE	(GLOBAL,0,<M.RMCR,M.RVTM,M.DNVT,M.LAT>)
>

IFE M.ANF,<
EQUATE	(GLOBAL,0,<M.ANAM,M.ANUM>)
> ;END IFE M.ANF

IFE M.DECN,<
EQUATE	(GLOBAL,0,<M.DNAM,M.DNUM,M.DHOM,M.DRTY,M.DNVT>)
> ;END IFE  M.DECN

	$LOW

STANAM::EXP	M.SNAM		;SYSTEM-WIDE NODE NAME
ANFNAM::EXP	M.ANAM		;ANF-10 STATION NAME
ANFNUM::EXP	M.ANUM		;ANF-10 STATION NUMBER
DCNNAM::EXP	M.DNAM		;DECNET NODE NAME
DCNNUM::EXP	<%RTADR==:M.DNUM> ;DECNET NODE NUMBER
DCNHOM::EXP	<%RTHOM==:M.DHOM> ;DECNET HOME AREA NUMBER
DCNRTY::EXP	<%RTRTY==:M.DRTY> ;DECNET ROUTING TYPE
LATNAM::EXP	M.LNAM		;LAT SERVICE NAME
IFE M.KS10,<
EQUATE	(GLOBAL,0,<M.DMRN,M.KDUP>)
> ;END IFE M.KS10

IFE M.KDUP,<
EQUATE	(GLOBAL,CPOPJ##,<KDPONC,UKDP,KDPLDR,KDPDSP>)
EQUATE	(GLOBAL,0,<M.DN6K>)
> ;END IFE M.KDUP

IFE M.DMRN,<
EQUATE	(GLOBAL,CPOPJ##,<DMRONC,DMRDSP>)
EQUATE	(GLOBAL,0,<M.DN6R>)
> ;END IFE M.DMRN

IFE M.DN6K,<
EQUATE	(GLOBAL,CPOPJ##,<D6KK2D>)
> ;END IFE M.DN6K

IFE M.DN6R,<
EQUATE	(GLOBAL,CPOPJ##,<D6RK2U>)
> ;END IFE M.DN6R
SUBTTL	ANF-10 NETWORK DATA BASE -- FEATURE TEST CHECK


IFN M.ANF,<
IFE FTNET,<
	PRINTX ? ANF-10 will not work with FTNET = 0
	PRINTX ? ANF-10 will not be included in this monitor
	M.ANF==:0
> ;END IFN FTNET

	EXTERN	NETSER		;LOAD NETWORK SERVICE
> ;END IFN M.ANF
SUBTTL	ANF-10 NETWORK DATA BASE -- PROTOTYPE DDB


IFN M.ANF,<

DEFINE	X	(OFFSET,EXPR),<	;;MACRO TO SET SELECTED LOCATIONS IN THE BLOCK
	RELOC	NETDDB+OFFSET	;;GO TO THE RIGHT WORD
	EXPR			;;ASSEMBLE IN THE EXPRESSION
> ;END DEFINE X

	$LOW

NETDDB::X	DEVCHR,<XWD <6*HUNGST>+DVC2IO,0>
	X	DEVSER,<XWD 0,NETDSP##>	;DEFINE NETWORK DISPATCH VECTOR
	X	DEVSTA,<XWD .TYMCR*.TYEST+DEPLEN,DEPEVM> ;VAR LEN BUF, NO EVM
	X	DEVCPU,<EXP 707B8>	;SET DEYPCL SO WILL RUN ON ANY CPU.
	X	NETLEN,		;RESERVE ENOUGH SPACE FOR ENTIRE DDB

	PURGE	X		;FLUSH THE MACRO

	$HIGH
SUBTTL	ANF-10 NETWORK DATA BASE -- PROTOTYPE NDB


DEFINE	X	(OFFSET,EXPR),<	;;MACRO TO SET SELECTED LOCATIONS IN THE BLOCK
	RELOC	NETNDB+OFFSET	;;GO TO THE RIGHT WORD
	EXPR			;;ASSEMBLE IN THE EXPRESSION
> ;END DEFINE X

	$LOW
NETNDB::X	NDBSID,<XWD SYSDAT##,CONFIG##>	;CREATION DATE,LONG-NAME
	X	NDBSNM,<XWD NETNDB+NDBSN2,NCLVER> ;SHORT-NAME,VERSION
	X	NDBFLG,<XWD NDB.UP,0>	;MAKE SURE WE DON'T TRY A STARTUP SEQ
	X	NDBFEK,<XWD 0,NL0FEK##>	;POINT TO OUR "NULL" FEK (CPU 0)
	X	NDBMOM,<EXP 10>	;MAXIMUM OF 10 OUTSTANDING MSGS
	X	NDBDEV,<BYTE	(9)1,M.TLTL,0,0,0,0,0,0,M.DTXN,M.RJOB,0,0>
	X	NDBLEN,		;RESERVE ENOUGH SPACE FOR THE ENTIRE NDB

	PURGE	X		;FLUSH THE MACRO

.GTNDA::BLOCK NODMAX+1		;GETTAB TABLE=173 INDEXED BY NODE NUMBER
NDAMXL==:<.-.GTNDA-1>_^D9	;LENGTH OF GETTAB TABLE
	$HIGH
SUBTTL	ANF-10 NETWORK DATA BASE -- NDT GENERATION


DEFINE	NDT	(XDEV,XIDEV,BUFSZ,CHR,DCM,DVT,SPL)<
	ND	N'XIDEV'BSZ,<BUFSZ>
NDT'XDEV:
	BYTE	(18)<(SIXBIT /XDEV/)>,<(SIXBIT /XIDEV/)>
	XWD	CHR,XDEV'MOD
	BYTE	(10)DCM(8)OBJ.'XIDEV(2)0(16)DVT
	BYTE	(6).TY'XDEV(12)N'XIDEV'BSZ(8)SPL(10)0
	IFIW	N'XDEV'CI##
	IFIW	@NDEV'XIDEV##(T4)
	IFIW	@'XDEV'NDP##(T1)

	.ORG	NDTTBL+OBJ.'XIDEV
	EXP	NDT'XDEV
	.ORG
> ;END DEFINE NDT


DEFINE	X	(A,B,C),<ZZ==ZZ+1>
	ZZ==0			;INIT COUNTER
	OBJTYP			;COUNT UP THE OBJECT TYPES
NDTTBL::BLOCK	ZZ		;RESERVE SPACE FOR NDT BLOCK POINTERS
NDTXWD::XWD	-ZZ,NDTTBL	;AOBJN POINTER TO TABLE
> ;END IFN M.ANF
SUBTTL	ANF-10 NETWORK DATA BASE -- CARD READERS


IFE M.ANF,<M.RCDR==:0>		;NO CARD READER SERVICE IF NO ANF-10

IFN M.RCDR,<
	EXTERN	NETCDR
	CDRMOD==1_A+1_AL+1_I+1_IB+1_B
	NDT(CDR,CD,34,<DVIN!DVCDR>,<DCM.DI>,0,.SPCDR)
> ;END IFN M.RCDR

;DUMMY GLOBALS
IFE M.RCDR,<
> ;END IFE M.RCDR
SUBTTL	ANF-10 NETWORK DATA BASE -- DDCMP DEVICE


IFE M.ANF,<M.RDDP==:0>		;NO DDCMP DEVICE SERVICE IF NO ANF-10

IFN M.RDDP,<
	EXTERN	NETDDP
	DDPMOD==1_BYTMOD
	NDT(DDP,DP,<<MSGMAD+3>/4>,<DVIN!DVOUT>,<DCM.IM>,0,0)
> ;END IFN M.RDDP

IFE M.RDDP,<
EQUATE	(GLOBAL,CPOPJ##,<DDPDSP,DDPUUO,TSTDDP,ZAPDDP>)
> ;END IFE M.RDDP
SUBTTL	ANF-10 NETWORK DATA BASE -- LINE PRINTERS


IFE M.ANF,<M.RLPT==:0>		;NO LINE PRINTER SERVICE IF NO ANF-10

IFN M.RLPT,<
	EXTERN	NETLPT
	LPTMOD==1_A+1_AL+1_A8+1_I
	NDT(LPT,LP,33,<DVOUT!DVLPT>,<DCM.CP!DCM.AS>,0,.SPLPT)
> ;END IFN M.RLPT

;DUMMY GLOBALS
IFE M.RLPT,<
> ;END IFE M.RLPT
SUBTTL	ANF-10 NETWORK DATA BASE -- MCR


IFE M.ANF,<M.RMCR==:0>		;NO MCR SERVICE IF NO ANF-10

IFN M.RMCR,<
	EXTERN	NETMCR
	OBJ.MC==OBJ.TT		;DUMMY "MCR" OBJECT TYPE TO MATCH NAMES
	MCRMOD==0		;NOT AVAILABLE AS I/O DEVICE
	NDT(MCR,MC,23,<DVIN!DVOUT>,<DCM.AS!DCM.IM>,0,0)
> ;END IFN M.RMCR


;DUMMY GLOBALS
IFE M.RMCR,<
EQUATE	(GLOBAL,ECOD4##,<D85DSC>)
EQUATE	(GLOBAL,NOPDNC##,<NETDIA>)
IFN M.ANF,<
EQUATE	(GLOBAL,CPOPJ##,<NMCSEC,MCRJIF,HOST.U,ASGTTY,MCRCHK>)
EQUATE	(GLOBAL,CPOPJ1##,<TRMXDC>)
EQUATE	(GLOBAL,TTYNDP,<MCRNDP>)
> ;END IFN M.ANF
> ;END IFE M.RMCR
SUBTTL	ANF-10 NETWORK DATA BASE -- REMOTE DATA ENTRY TERMINALS


IFE M.ANF,<M.RDX==:0>		;NO REMOTE DATA ENTRY SERVICE IF NO ANF-10

IFN M.RDX,<
	EXTERN	NETRDX
	RDAMOD==1_BYTMOD+1_PIMMOD+1_A+1_AL
	NDT(RDA,RD,101,<DVIN!DVOUT>,<DCM.AS>,0,0)
> ;END IFN M.RDX

IFE M.RDX,<
EQUATE	(GLOBAL,CPOPJ##,<TSTRDX>)
> ;END IFE M.RDX
SUBTTL	ANF-10 NETWORK DATA BASE -- PAPER TAPE PUNCH


IFE M.ANF,<M.RPTP==:0>		;NO PAPER TAPE PUNCH SERVICE IF NO ANF-10

IFN M.RPTP,<
	EXTERN	NETPTP
	PTPMOD==1_B+1_AL+1_I+1_IB+1_A
	NDT(PTP,PP,41,<DVOUT!DVPTP>,<DCM.AS!DCM.IM>,0,.SPPTP)
> ;END IFN M.RPTP

;DUMMY GLOBALS
IFE M.RPTP,<
> ;END IFE M.RPTP
SUBTTL	ANF-10 NETWORK DATA BASE -- PAPER TAPE READER


IFE M.ANF,<M.RPTR==:0>		;NO PAPER TAPE READER SERVICE IF NO ANF-10

IFN M.RPTR,<
	EXTERN	 NETPTR
	PTRMOD==1_B+1_AL+1_I+1_IB+1_A
	NDT(PTR,PR,41,<DVIN!DVPTR>,<DCM.AS!DCM.IM>,0,0)
> ;END IFN M.RPTR

;DUMMY GLOBALS
IFE M.RPTR,<
> ;END IFE M.RPTR
SUBTTL	ANF-10 NETWORK DATA BASE -- PLOTTER


IFE M.ANF,<M.RPLT==:0>		;NO PLOTTER SERVICE IF NO ANF-10

IFN M.RPLT,<
	EXTERN	NETPLT
	PLTMOD==1_B+1_AL+1_I+1_IB+1_A
	NDT(PLT,PL,41,<DVOUT>,<DCM.AS!DCM.IM>,0,.SPPLT)

> ;END IFN M.RPLT

;DUMMY GLOBALS
IFE M.RPLT,<
> ;END IFE M.RPLT
SUBTTL	ANF-10 NETWORK DATA BASE -- TASKS


IFE M.ANF,<M.RJOB==:0>		;NO TASK SERVICE IF NO ANF-10

IFN M.RJOB,<
	EXTERN	NETTSK
	TSKMOD==1_B+1_I+1_IB+1_A+1_AL+1_BYTMOD
	NDT(TSK,TK,101,<DVIN!DVOUT!DVLNG!DVDIR>,<DCM.AS!DCM.IM>,0,0)
> ;END IFN M.RJOB


;DUMMY GLOBALS
IFE M.RJOB,<
EQUATE	(GLOBAL,CPOPJ##,<UTSK,TSTTSK,TSKSEC>)
> ;END IFE M.RJOB
SUBTTL	ANF-10 NETWORK DATA BASE -- VIRTUAL TERMINALS


IFE M.ANF,<M.RVTM==:0>		;NO VIRTUAL TERMINALS IF NO ANF-10

IFN M.RVTM,<
	EXTERN	NETVTM
	TTYMOD==1_A+1_AL+1_A8+1_PIMMOD+1_I
	NDT(TTY,TY,23,<DVIN!DVOUT>,<DCM.AS!DCM.IM>,0,0)
> ;END IFN M.RVTM

;DUMMY GLOBALS
IFE M.RVTM,<
EQUATE	(GLOBAL,CPOPJ##,<VTMREC,VTMJIF,VTMENQ,VTMSPD>)
EQUATE	(GLOBAL,CPOPJ##,<VTMDSF,VTMDSO,VTMPRL,VTMFRE>)
IFN M.RMCR,<XP VTMHST,MCRCSH##>
IFN M.ANF,<
	REPEAT 5,<POPJ P,>
TTYNDP::REPEAT 5,<POPJ P,>
> ;END IFN M.ANF
> ;END IFE M.RVTM
SUBTTL	ANF-10 NETWORK DATA BASE -- ETHERNET SUPPORT


;ANF ETHERNET PROTOCOL AND MULTICAST ADDRESS
;
; NOTE:	THE ANF ETHERNET DRIVER (D8EINT) WILL BE LOADED IF AND ONLY IF
;	THE SYMBOL ANFNIP IS DEFINED NON-ZERO (E.G., VIA MONGEN).

ND ANFNIP,NCLNIP		;DEFAULT TO EXCLUDE ANF-10 FROM THE ETHERNET
ND ANFNIM,<<<ANFNIP>B15>>	;DEFAULT MULTICAST ADDRESS

IFE ANFNIP!ANFNIM,<		;IF TO BE EXCLUDED,
	D8EINI==:CPOPJ##	;NULL D8EINT SERVICE (SYSINI DUMMY)
> ;END IFE ANFNIP
SUBTTL	ANF-10 NETWORK DATA BASE -- MONGEN PARAMETERS


IFN M.ANF,<

;MAXIMUM MESSAGE SIZE TO BE SEEN FROM THE NETWORK
ND MSGMAX,^D512			;WHAT IT USED TO BE IN TERMS OF PCBLMX
	MSGMAW==:<MSGMAX+3>_-2	;MAX MESSAGE SIZE MOD -10 WORD SIZE
IFN M.ENET,<			;ETHERNET?
	MSGMAW==:MSGMAW+2	;ALLOW FOR 2-BYTE COUNT + 4-BYTE CRC
> ;END IFN M.ENET

	MSGMAD==:MSGMAX-20	;MAX MESSAGE SIZE (DISCOUNTING NCL OVERHEAD)
				;  E.G., FOR DATA MESSAGES THIS IS HOW MUCH
				;  DATA CAN BE FIT IN A SINGLE MESSAGE


;MAXIMUM SIZE THE -10 WILL KNOWINGLY TRANSMIT
ND MSGXMX,MSGMAX		;MAKE AS BIG AS POSSIBLE
	MSGXMW==:<MSGXMX+3>_-2	;MAX TRANSMITTABLE MOD -10 WORD SIZE

IFG MSGXMX-MSGMAX,<
	PRINTX	? MSGXMX greater than MSGMAX!
	MSGXMX==:MSGMAX		;LIMIT MAXIMUM TRANSMITTABLE
> ;END IFG MSGXMX-MSGMAX


IFL NETLNH-<^D36-^L<MSGMAX>>+1,<
	PRINTX	% NETLNH too small for MSGMAX
	PRINTX	% Network message length histogram table won't be accurate
> ;END IFL NETLNH-<STUFF>


IFN M.KDUP,<
IFG MSGMAX-<4*KDLMMS>,<
	PRINTX	? KDLMMS too small, incoming KMC/DUP messages won't fit!
> ;END IFN MSGMAX-<STUFF>
> ;END IFN M.KDUP


IFN M.DMRN,<
IFG MSGMAX-<4*DMRMMS>,<
	PRINTX	? DMRMMS too small, incoming DMR messages won't fit!
> ;END IFN MSGMAX-<STUFF>
> ;END IFN M.DMRN

> ;END IFN M.ANF
IFN M.ANF,<

;ALLOCATION "GRANULARITY" (POWER OF TWO; USED FOR LSH'S)
ND MSGAGN,^D03			;ALLOCATE BY 8-WORD BLOCKS
	MSGAGW==:<1_MSGAGN>	;ALLOCATION GRANULARITY BY WORDS
	MSGALN==:<MSGMAW+MSGAGW-1>_-MSGAGN  ;ALLOCATION TABLE LENGTHS


;MAXIMUM NUMBER OF DATA-REQUESTS THAT MAY BE SENT (FOR INPUT DEVICES ONLY)
ND MAXODR,6			;6 SEEMS LIKE ENOUGH...


;SIZE OF A "TERMINAL PCB"  MUST BE A POWER OF 2, AND .LE. ^D32
ND NTTPLN,^D32			;SIZE OF A TERMINAL PCB


> ;END IFN M.ANF

;LINK ADDRESS TABLE.  ONE ENTRY FOR EACH NETWORK CONNECTION
IFE M.ANF,<M.CONN==:0>		;NO LINK ADDRESS IF NO ANF-10
IFE M.CONN,<LATLEN==:0>		;LINK ADDRESS TABLE LENGTH IF NO CONNECTS
IFN M.CONN,<LATLEN==:M.CONN+1>	;LENGTH OF TABLE (MAXIMUM NUMBER OF CONNECTS
SUBTTL	ANF-10 NETWORK DATA BASE -- OBJECT TABLES


IFN M.ANF,<
;TABLE INDEXED BY OBJECT TYPE.  THE FORMAT OF THIS TABLE IS:
;	BYTE (12)0 (6)TYPE (18)SIXBIT/NAME/
;
DEFINE	X	(A,B,C),<	;;MACRO CALLED BY OBJTYP
	XWD	C,SIXBIT /   A/	;;MAKE THE ENTRY
> ;END DEFINE X

OBJTAB::OBJTYP			;MAKE DEVICE DESCRIPTORS
AOTMXL==:<.-OBJTAB-1>_^D9	;LENGTH OF ANF-10 OBJECT TRANSLATION TABLE


;A BYTE POINTER TO THE TYPE FIELD IN OBJTAB.

	OB%TYP==:<POINT 6,0,17>	;POINT TO TYPE FIELD IN OBJTAB ENTRY


;A TABLE OF POINTERS INTO CONFIGURATION TABLE OF AN NDB.
; INDEXED BY W (THE STANDARD NDB POINTER)

DEFINE	X	(A,B,C),<	;;MACRO CALLED IN OBJTYP
	POINT	9,NDBDEV+<B/4>(W),8+<<3&B>*9>
> ;END DEFINE X
NETCNF::OBJTYP			;MAKE THE BYTE POINTERS



;A TABLE OF NDTS BASED ON OBJECT TYPE
;ENTRIES ARE ADDRESS OF NDT FOR THAT OBJECT TYPE, OR 0 IF NOT SUPPORTED

DEFINE	X	(A,B,C),<	;;MACRO CALLED BY OBJTYP
	IFDEF	NDT'A,<Z NDT'A>	;;ADDRESS OF NDT FOR THIS OBJECT TYPE
	IFNDEF	NDT'A,<Z>	;;OR 0 IF UNKNOWN/UNSUPPORTED
> ;END DEFINE X
NDTTAB::OBJTYP			;MAKE NDT ADDRESSES

> ;END IFN M.ANF
SUBTTL	ANF-10 NETWORK DATA BASE -- MISCELLANEOUS STORAGE


	$LOW
NETLAT::XWD	0,NETDDB	;POINT TO THE DDB (EXEC PROCESS)
	BLOCK	M.CONN		;REST OF THE TABLE

	$HIGH

IFNDEF NETOFS,<NETOFS==0>
NETRTY::XWD	-M.RTTY,NETOFS	;POINTER TO NETWORK SECTION OF LINTAB

;NETSER'S FREE-PCB MANAGEMENT LISTS (INDEXED BY BUFFER SIZE "MOD" MSGAGN)
	$LOW
IFN M.ANF,<
NTFREC::BLOCK	MSGALN+1	;COUNT OF FREE PCB'S ON EACH FREE LIST
NTFREF::BLOCK	MSGALN+1	;POINTER TO FIRST FREE PCB ON EACH LIST
NTFREL::BLOCK	MSGALN+1	;POINTER TO LAST FREE PCB ON EACH LIST
> ;END IFN M.ANF
SUBTTL	ANF-10 NETWORK DATA BASE -- DUMMY GLOBALS


	$LOW

IFE M.ANF,<

EQUATE	(GLOBAL,CPOPJ##,<NTLCKJ,NTCHCK,NTLERR,NETSEC,NTDSTP,CLRTTY,SRCNDB>)
EQUATE	(GLOBAL,CPOPJ##,<NTDIDA,TSTNET,ZAPNET>)
EQUATE	(GLOBAL,CPOPJ##,<NETINI,NETDEV,TYPNDB,D8EINI,KDP.>)
EQUATE	(GLOBAL,CPOPJ##,<GENNET,NET2ND,NETCTC,STBSCA>)
EQUATE	(GLOBAL,CPOPJ##,<BRKFEK,FEKINT,FEKCPS,FEKCPW>)
EQUATE	(GLOBAL,CPOPJ##,<CWHANF,NODE.A,NODE.S,NODE.U,HOST.U>)
EQUATE	(GLOBAL,CPOPJ1##,<NETOPR,NETASG>)

EQUATE	(GLOBAL,0,<NETDDB,NETNDB,NDBMXL,NDBSNM,NDAMXL,AOTMXL>)
EQUATE	(GLOBAL,0,<NETDSP,NETCHN,NTFCHN,NDBNNM,.NTMXL>)

EQUATE	(GLOBAL,NULGTB##,<.GTNDA,OBJTAB,NETGTT,NDBTBL>)

STBOPR::PUSH	P,U		;SAVE LDB
	MOVE	U,OPRLDB##	;GET CENTRAL (ONLY) OPR LDB
	LDB	T1,LDPLNO##	;GET LINE NUMBER
	PJRST	UPOPJ##		;RESTORE AC AND RETURN.
> ;END IFE M.ANF

;FLAG WHICH INDICATES A CATASTROPHIC ERROR HAS OCCURED (PAR ERR,
;NXM, ETC.)  USED BY ERRCON AND ZAPNET TO PREVENT WEM STOPCODES
;MUST BE DEFINED AND USABLE IN ALL MONITORS
NETZAP::EXP	0
SUBTTL	DECNET NETWORK DATA BASE -- FEATURE TEST CHECK


IFN M.DECN,<

IFE FTDECNET,<
	PRINTX ? DECnet will not work with FTDECNET = 0
	PRINTX ? DECnet will not be included in this monitor
	M.DECN==:0
> ;END IFN FTDECNET

;FORCE LOADING DECNET
	EXTERN	D36INI,	NTMAN,	SCUUUO,	SCTNSF
	EXTERN	RTRINI,	DNDINI,	NSPINI

IFN M.DNVT,<EXTERN NRTINI>	;FORCE LOADING NRT/CTERM
IFE M.DNVT,<
	EQUATE	(GLOBAL,CPOPJ##,<NRTLFC,NRTNFL,NRTINI>)
	NETDID==:NOPDNC##
	CWHNRT==:CWHNCN##
NRTCHP::!
NRTSJP::EXP	0
> ;END IFE M.DNVT

IFN FTCIDNET,<EXTERN CIDLL>	;FORCE LOADING DECNET/CI
> ;END IFN M.DECN
SUBTTL	DECNET NETWORK DATA BASE -- MONGEN PARAMETERS


	$LOW

IFN M.DECN,<

;EXTENSIBLE BITMAP MEMORY REQUIREMENTS FOR DECNET

ND M.DNCS,4			;CHUNK SIZE IN WORDS
ND M.DNSZ,30000			;INITIAL ALLOCATION AMOUNT IN WORDS
ND M.DNTH,4000			;THRESHOLD ALLOCATION AMOUNT IN WORDS
ND M.DNIN,4000			;INCREMENTAL ALLOCATION AMOUNT IN WORDS
ND M.DNMN,10000			;MINIMUM ALLOCATION AMOUNT IN WORDS
ND M.DNMX,100000		;MAXIMUM ALLOCATION AMOUNT IN WORDS

XP DCNSIZ,<PAGSIZ*<<M.DNSZ+PG.BDY>/PAGSIZ>>
XP DCNMAX,<PAGSIZ*<<M.DNMX+PG.BDY>/PAGSIZ>>


;DECNET ALLOCATION CONTROL BLOCK

	.LINK	.LKACB,DCNACB	;ADD TO SYSTEM-WIDE LINKED LIST
DCNACB::EXP	0		;ADDRESS OF NEXT ALLOCATION CONTROL BLOCK
	SIXBIT	/DECNET/	;ALLOCATION USER
	EXP	M.DNCS		;CHUNK SIZE IN WORDS
	Z	(MS.DCN)	;SECTION NUMBER OF ALLOCATION
	EXP	0		;CURRENT USED AMOUNT IN WORDS
	EXP	0		;HIGH WATER MARK IN WORDS
	EXP	DCNSIZ		;INITIAL ALLOCATION AMOUNT IN WORDS
	EXP	M.DNTH		;THRESHOLD ALLOCATION AMOUNT IN WORDS
	EXP	M.DNIN		;INCREMENTAL ALLOCATION AMOUNT IN WORDS
	EXP	M.DNMN		;MINIMUM ALLOCATION AMOUNT IN WORDS
	EXP	DCNMAX		;MAXIMUM ALLOCATION AMOUNT IN WORDS
	EXP	0		;ADDRESS OF ALLOCATION HEADER BLOCK
> ;END IFN M.DECN
IFN M.DECN,<

	RADIX 10		;NETWORK MANGLEMENT IS DECIMAL

ND %RTMXN,1023			;MAXIMUM NODE NUMBER
ND %RTMX3,255			;DEFAULT MAXIMUM NODE ADDRESS FOR ROUTER
ND %RTTM3,15*1000		;DEFAULT HELLO FREQUENCY TIMER
ND %RTTM4,30*1000		;DEFAULT NODE LISTENER TIMER
ND %RTITM,1*60*1000		;INITIALIZATION TIMER
ND %RTT3M,2			;HELLO TIMER MULTIPLIER FOR NON-BROADCAST
ND %RTB3M,3			;HELLO TIMER MULTIPLIER - BROADCAST ADJACENCIES
ND %RTCTS,1			;DEFAULT COST FOR TST DEVICE
ND %RTCDT,3			;DEFAULT COST FOR DTE DEVICE
ND %RTCKD,4			;DEFAULT COST FOR KDP DEVICE
ND %RTCDD,5			;DEFAULT COST FOR DDP DEVICE
ND %RTCCI,2			;DEFAULT COST FOR CI DEVICE
ND %RTCET,1			;DEFAULT COST FOR ETHERNET DEVICE
ND %RTCDM,2			;DEFAULT COST FOR DMR DEVICE
ND %RTMXR,16			;DEFAULT MAXIMUM NUMBER OF ROUTERS ON AN NI
ND %RTBRA,32			;MAXIMUM NUMBER OF BROADCAST ROUTER ADJACENCIES
ND %RTBEA,64			;MAXIMUM NUMBER OF END NODE ADJACENCIES
ND %RTCTO,60*1000		;ENDNODE CACHE TIMEOUT
ND %RTPRI,5			;OUR PRIORITY TO BE THE DESIGNATED ROUTER
ND %RTMXC,100			;MAXIMUM LINE COST
ND %RTMXH,16			;MAXIMUM HOPS
ND %RTMXV,20			;DEFAULT MAXIMUM VISITS
ND %RTTM1,10*60*1000		;DEFAULT MAXIMUM ROUTING MSG INTERVAL (P-P)
ND %RTBT1,40*1000		;DEFAULT MAXIMUM ROUTING MESSAGE INTERVAL (NI)
ND %RTBSZ,576			;PUBLISHED EXECUTOR DEFAULT BLOCK SIZE (BYTES)
IFNDEF %RTXPW,<DEFINE %RTXPW,<RTRPW <DECNET20>>> ;DEFAULT ROUTER PASSWORD


DEFINE RTRPW(PW),<
	.ZZN==0
	IRPC PW,<.ZZN==.ZZN+1>;;COUNT CHARS IN PWD
	IFG .ZZN-RTRXPM,<PRINTX ?ROUTER PASSWORD TOO LONG>
	.ZZW==<.ZZN>B7;;	LEADING BYTE COUNT
	.ZZC==1;;		CHAR POSITION OF NEXT CHAR
	IRPC PW,<.ZZW==.ZZW!<"PW">B<7+<.ZZC*8>>
		IFE .ZZC-3,<EXP .ZZW
			    .ZZW==0
			    .ZZC==-1>
		.ZZC==.ZZC+1>
	IFN .ZZC,<EXP .ZZW>
	PURGE .ZZN,.ZZW,.ZZC
> ;END DEFINE RTRPW

	RTRXPM==^D64		;MAXIMUM NUMBER OF BYTES IN A VERIFICATION PSWD
RTRXPW::%RTXPW
	BLOCK	<<RTRXPM+1+3>/4>-<.-RTRXPW>;ALLOCATE FOR MAX
;THESE ARE LLINKS DEFAULT PARAMETER VALUES:

ND %NSDLY,3*16			;DELAY FACTOR
ND %NSWGT,10			;DELAY WEIGHT
ND %NSINA,120			;INACTIVITY TIMER
ND %NSRTH,10			;RETRANSMISSION THRESHOLD
ND %NSFLR,1000			;DELAY FLOOR
ND %NSRUF,10000			;DELAY ROOF
ND %NSADL,2			;ACK DELAY IN SECONDS


;THESE ARE SESSION CONTROL DEFAULT PARAMETER VALUES:

ND %SCINT,30*1000		;INCOMING TIMER VALUE
ND %SCOTT,1*60*1000		;OUTGOING TIMER VALUE


;THESE ARE THE DATA LINK LAYER DEFAULT PARAMETER VALUES:

ND %DLBSZ,576			;DEFAULT MAXIMUM BUFFER SIZE (BYTES)


	RADIX 8			;LCG IS OCTAL
SUBTTL	DECNET NETWORK DATA BASE -- NOTES ON MONGEN PARAMETER SELECTION


COMMENT	~

This novel is intended in guiding network managers who want to fine tune
their networks for performance. A word of caution before we start:  The
parameters as currently defaulted were what we had set during field
test. We know that in the majority of cases, these parameters work to
most DEC systems even though not with optimal performance.  Modifying these
parameters can cause disaster, so understand what you are attempting
beforehand, and be conservative in modifying them.  Be aware that DEC may
not agree with your settings, and will request them be set back to standard
values before debugging any problems in your network.

The critical timer in this case is the AVERAGE DELAY to a node.  This is
kept by LLINKS by timestamping each data message it sends, and waiting
for the ACK to come back.  When it has the ack, it has the delay for that
particular message, and it averages that delay into the average delay.

This delay time is used as a base in computing when to retransmit, and
when to decide that a link has gone sour, and as such is the single most
important timer as far as performance is concerned.  Below is a description
of some parameters controlling how this delay is calculated.

%NSFLR - Changing this will probably only affect nodes which are relatively
	close to this node.  The desirable effect of lowering this is to
	speed up recovery after a lost message, since the lost message will
	be re-trasmitted much sooner.  The undesirable effect is that links
	will break if the delay changes much.

%NSRUF - Changing this will probably only affect problems involving congestion.
	Lowering this will decrease the effect that congestion has on a link,
	but will increase the number of messages sent, which can aggravate
	the congestion.  If congestion gets too bad, not enough messages get
	through to keep the link alive, and it breaks.

%NSWGT - This affects how much a single delay will affect the average delay.
	Increasing this causes the delay to change more slowly, lowering it
	causes the delay to track reality more closely.  Tremble before you
	change this one - Lowering it can cause positive feedback in your
	network with delay and retransmissions oscillating out of control,
	while increasing it can cause links to be unable to adapt to changing
	conditions.

%NSRTH - Retransmission threshold.  This controls the number of times we
	re-send a message before giving up.  Increasing this will give the
	other side a better chance of keeping your link alive, but can
	aggravate congestion problems.

%NSDLY - Delay factor.  This multiplied by the average delay to a node is
	used as the retransmission timer.  Note that this factor is kept in
	1/16ths, so the default is 3 even though network management says
	48.

The main theme throughout this novel is congestion.  If congestion did not
exist, we would recommend lowering %NSFLR and %NSWGT, and increasing %NSRTH.
The term congestion, as used in this novel, indicates the situation where
some node, possibly an intermediate, possibly a destination, does not have
buffers for all the messages that he is receiving, and must discard some.
The destination does not receive these messages, the source does not receive
an ack for them, so must eventually retransmit them.

The reasons congestion can occurr are numerous; Some of the more common ones
are:

1) A node with a high speed line and a low speed line:  Messages are coming
   in the high speed line to be retransmitted on the low speed line faster
   than the low speed line can handle.  The messages pile up, and eventually
   some of them are dropped.

2) A node with cross-traffic.  Messages going from node A to node B through
   node C have no trouble, until messages from node D going to node E also
   through node C eat up buffers.

3) Many links to same node.  Since flow control is managed on a per-link basis,
   there is nothing to keep many links from transmitting their limit all at
   the same time.  If the source and destination are the same type of system,
   often this isn't a problem since they both have the same limit on the number
   of buffers.  When they are of different type, and the source has more
   buffers available than the destination, the destination cannot process them
   all in time.

We cannot predict all situations in the field, but here are some suggested
scenarios, and suggestions as to ways of improving performance:

Scenario A: TOPS10 - DTE - DN20/MCB - DMR(56kb) - VAX
	Continual file transfer activity, spurts of NRT (terminal)
	activity.  Occasional congestion loss caused by the spurts of
	NRT activity (reason 3).

	In this case, it could be possible to act as if congestion didn't
	exist, and lower %NSFLR, %NSWGT, and %NSDLY. Since congestion is
	fleeting, the retransmissions will occurr after the congestion
	has gone away (the user has stopped banging away at his terminal)
	and should not cause problems.

Scenario B: KL - DTE - DN20/MCB - DMR(56kb) - VAX
				\ KDP(9600) - RSX
	File transfer activity from KL to RSX and VAX.  NRT activity, but
	irrelevant.  High congestion loss to RSX due to low speed line from
	DN20 to RSX.

	In this case, congestion is the dominant theme.  The DN20's buffer
	space is always going to be busy, since every time the RSX system
	sends data requests (credits, permissions) the KL will be able to
	fill the MCB before the MCB will have a chance to finish transmitting
	a single message.  Depending on the number of buffers in the MCB,
	this will probably work fine until other network activity occurs.
	When other network activity occurrs (such as file transfer to the
	vax, or terminal activity), congestion loss will start up.  In this
	case, since the actual delay of messages isn't increasing, you want
	to increase %NSWGT to avoid changing wildly every time a message is
	retransmitted.  You also want to set %NSRUF to provide an upper limit
	on how high the delay can get. The danger here is setting it so low
	that congestion hasn't been relieved by the time we retransmit, or
	setting it so high that performance goes to zero.

Scenario C: TOPS10 - DTE - DN20/MCB - DMR(56kb) - DN20/MCB - TOPS20
	File transfer activity from TOPS10 to TOPS20.  Performance varies
	wildly depending on load on TOPS20 system, including broken links
	if the load gets too high on the TOPS20 system.

	The dominant theme here is the fact that TOPS20 (5.1 and 6.0) will
	vary the delay for message response.  If the load is light, and the
	job receiving messages is runnable, the turnaround will be fast.  If
	the job gets blocked or pages out, the acks will not be forthcoming
	until the job unblocks and receives the messages, which can be a
	long time.  We have observed cases where the delay to a TOPS20 system
	was less that 200 milliseconds, and suddenly a message didn't receive
	an ack for over 20 seconds - Apparantley the job was paged out, and
	there were other processes with higher priority running.

	In this case, the only thing you can do is to protect yourself against
	the delay changing drastically.  We would suggest that you should limit
	yourself to attempting to keep the link open and not worry about speed.
	In this case, increase %NSFLR to something large, which will cause
	retransmissions to take a long time, but will allow the link to survive
	long periods with no activity.  ALso increase %NSRTH, to increase even
	further the odds of living through a drought of messages.

These scenarios provide idealized situations.  Customers are likely to have
a combination of the above situations, or something else entirely, and
possibly the above mentioned controls are not enough.  A situation where a
customer needs different controls over different nodes might occur, for
example.  The routine in LLINKS is UPDELAY, and the location of interest
to anyone wanting to patch this is UPDLY1, where we have in T1 the new delay
to the node.  At this point we are about to range check against NSPFLR and
NSPRUF, and then store it away.  If you are attempting to insert some extra
site-dependant knowledge into this algorithm, this would be the place to
do it.

There are two tools supplied which should help you understand what is
happening in your network - DNSNUP/DNTATL and DCNSPY.  DNSNUP will write out
to disk EVERY message that passes through ROUTER.  This output can be later
be converted to readable form with DNTATL, so you can analyze where messages
got lost and possibly why.  DCNSPY is a DPY tool which allows you to watch
links in real time.  The fields displayed are defined in D36PAR, where the
convention is:  Five character name, first two characters are the name of
the structure, last three characters are the name of the field.  The structure
is found as "BEGSTR xx", and the field within is found as either "WORD xxx"
or "FIELD xxx", depending on its size.

There are a limited number of comments/detailed descriptions for the fields
available within DCNSPY with the COMMENT switch.  Since these descriptions
are at least two years old, it may be possible to find a more up-to-date
or complete description in D36PAR itself.

END COMMENT ~
SUBTTL	DECNET NETWORK DATA BASE -- INTERLOCKS


;D36PIN AND D36PIF - TAKE AND RELEASE THE DECNET INTERLOCK.
;CALL:	JSP	CX,D36PIF/D36PIN
;	<RETURN>	;WITH/WITHOUT THE INTERLOCK
;
;PRESERVES ALL ACS EXCEPT CX
;NOTE - CX IS A DECNET SCRATCH AC WHICH IS HARDWIRED TO BE R

	CX==R

D36PIF::CONO	PI,NETPIF##	;MAKE SURE NOONE ON THIS CPU INTERRUPTS US
	SKIPGE	D36LCK		;GIVE OTHER CPUS A CHANCE
	AOSE	D36LCK		;MAKE SURE NOONE ON ANOTHER CPU GETS US
	JRST	.-2		;WAIT
	APRID	D36AID		;RECORD WHO HAS THE INTERLOCK
	MOVEM	CX,D36PPC	;SAVE CALLING PC FOR TRACKING PURPOSES
	JRST	(CX)		;RETURN TO CALLER WITH INTERLOCK SET

D36PIN::SETZM	D36AID		;WE NO LONGER OWN THE INTERLOCK
	SETOM	D36LCK		;ALLOW OTHER CPU IN
	CONO	PI,NETPIN##	;ALLOW PENDING INTERRUPTS ON THIS CPU IN
	JRST	(CX)		;RETURN

	$LOW

D36LCK::-1			;ACTUAL AOSED WORD
D36AID::-1			;KEEPS TRACK OF WHICH CPU HAS THE INTERLOCK
D36PPC::-1			;KEEPS TRACK OF WHERE WE GOT THE INTERLOCK

	PURGE	CX
SUBTTL	DECNET NETWORK DATA BASE -- LINE INITIALIZATION


;ROUTINES TO INITIALIZE LINES, AND ASK ROUTER TO INTIALIZE DECNET LINES

DEFINE DEFLIN,<
IFN FTKS10,<
	DEFKS
	>
IFN FTKL10,<
	CPUNN=0
	REPEAT M.CPU,<
	IFN FTKL10,DEFKL(\CPUNN)
		CPUNN==CPUNN+1
		> ;END OF REPEAT M.CPU
	> ;END OF IFN FTKL10
> ;END OF DEFINE DEFLIN

DEFINE DEFKL(CPU),<
> ;END OF DEFINE DEFKL

DEFINE DEFKS,<
KDPNN==0
REPEAT M.KDUP,<
	DEFKDP(\KDPNN)
	KDPNN==KDPNN+1
	>
DMRNN==0
REPEAT M.DMRN,<
	DEFDMR(\DMRNN)
	DMRNN==DMRNN+1
	>
> ;END OF DEFINE DEFKS

DEFINE DEFKDP(KDPNO),<
IFE M.'KDPNO'KDP-DD.DEC,<
	MOVEI	T1,DC.IOC	;;FUNCTION INITIATIZE CIRCUIT BLOCK
	SETZ	T2,		;;NO DNADLL ID
	MOVE	T3,[1B0+<LD.KDP_9+0,,KDPNO_9+0>] ;;GET CURRENT LINE ID
	SNCALL	(KDIPPI##,MS.HGH) ;;TELL DNADLL ABOUT THIS LINE
	  JFCL			;;IGNORE ERROR
	>
> ;END DEFINITION OF DEFKDP

DEFINE DEFDMR(DMRNO),<
IFE M.'DMRNO'DMR-DD.DEC,<
	MOVEI	T1,DC.IOC	;;FUNCTION INITIATIZE CIRCUIT BLOCK
	SETZ	T2,		;;NO DNADLL ID
	MOVSI	T3,(1B0+<LD.DMR_9+DMRNO,,0>) ;;GET CURRENT LINE ID
	SNCALL	(DMIPPI##,MS.HGH) ;;TELL DNADLL ABOUT THIS LINE
	  JFCL			;;IGNORE ERROR
	>
> ;END DEFINITION OF DEFDMR

	$XHIGH

D36LIN::DEFLIN			;DEFAULT THE LINES WHICH HAVE TO BE
	POPJ	P,		;RETURN
	$HIGH
SUBTTL	DECNET NETWORK DATA BASE -- THE "NOBODY" KONTROLLER


;NOBDSP SERVES BASICALLY AS A PLACE-HOLDER FOR THE VARIOUS LINE
;DRIVERS TO DISPATCH TO FOR USER "NOBODY".

NOBDSP::
NOBSTP:	STOPCD	CPOPJ##,DEBUG,NOB,  ;++ "NOBODY" KONTROLLER DISPATCH GOT CALLED
>;END OF IFN M.DECN
SUBTTL	DECNET NETWORK DATA BASE -- DUMMY GLOBALS


IFE M.DECN,<

EQUATE	(GLOBAL,CPOPJ##,<.SAV1,.SAV2,.SAV3,.SAV4,DDIINE>)
EQUATE	(GLOBAL,CPOPJ##,<DCNMOV,DCNSEC,DCNJIF,DDIPPI,DTIPPI,KDIPPI,DMIPPI>)
EQUATE	(GLOBAL,CPOPJ##,<NTMAN,SCUUUO,SCTPSI,SCURST,SCUPOP,SCULGO,RTRDSP>)
EQUATE	(GLOBAL,CPOPJ##,<DNET,D36INI,D36LIN,NETDID>)
EQUATE	(GLOBAL,CPOPJ##,<CWHNRT,NODE.D>)

EQUATE	(GLOBAL,0,<DCNGTL>)
EQUATE	(GLOBAL,NULGTB##,<DCNGTB>)
EQUATE	(GLOBAL,MONORG,<DCNLOC,DCNAEB>)

EQUATE	(GLOBAL,S..NDL,<DNCPYW,DNLENG,RTNSLS,NOBDSP>)
EQUATE	(GLOBAL,DCNZER,<RTRHOM,RTRADR,RTRHIO>)

;THIS STOPCODE CALLED IF WE TRY TO CALL A DECNET ROUTINE WITH NO DECNET
	STOPCD	.,STOP,NDL	;++ NO DECNET LOADED

DCNZER:	EXP	0

> ;END IFE M.DECN
SUBTTL	DECTAPE DATA BASE FOR DTASER

	$LOW

;DECTAPE ENTRY POINT AND BIT DEFINITIONS

IFG M.DTXN,<
	EXTERN	DTASER		;TD10 WITH NEW FORMAT
> ;END IFG M.DTXN

IFE M.DTXN,<
;IF NO DECTAPES, SATISFY GLOBALS BY DEFINING DUMMIES
	DTASEC==:CPOPJ##
	DTADDB==:CPOPJ##	;THIS WORKS BECAUSE SYSINI DOES A
				;	MOVEI W,DTADDB##
	DTXINI==:0		; FOLLOWED BY AN       XCT DTXINI##(W)
	DSCON==:0
	LVFLAG==:0
	USEWRD==:0
	DCONS==:0
	DTADSP==:0

	OWNDTC==:CPOPJ##
	SCDDT==:CPOPJ##
	DTXFRE==:CPOPJ##

	$HIGH
UNWDTC::
	SETZ	T3,
	POPJ	P,
	$LOW

>
DEFINE	DTDDB(X,Y,CPUN)<

SUBTTL INTERRUPT HEAD FOR DT'X
			;FLAGS LEVEL CODE
;CONTROL DEPENDENT PORTION OF DECTAPE SERVICE
DEFINE CDC (C,B) <

C=:.-DT'X'DDB	;RELATIVE LOCATION WITHIN CONTROL BLOCK
	B>

;MODEL DEVICE DATA BLOCK
DTXDDB=:.-DT'X'DDB

DT'X'DDB::SIXBIT	/DT'X'0/ ;(0) - DEVNAM
	XWD	<^D6*HUNGST>,200 ;(1) - DEVCHR
	0			;(2) - DEVIOS
	EXP	DTADSP##	;(3) - DEVSER
	XWD	1107,154403	;(4) - DEVMOD
	0			;(5) - DEVLOG
	0			;(6) - DEVBUF
	0			;(7) - DEVIAD
	0			;(10) - DEVOAD
	0			;(11) - DEVSTS
	XWD	.TYDTA*.TYEST,0	;(12) - DEVSTA
	0			;(13) - DEVXTR
	0			;(14) - DEVEVM
	0			;(15) - DEVPSI
	0			;(16) - DEVESE
	0			;(17) - DEVHCW
	BYTE	(3)CPUN(33)0	;(20) - DEVCPU
	0			;(21) - DEVISN
	0			;(22) - DEVDRV
	0			;(23) - DEVJOB
	0			; - DEVFIL
	0			; - DEVEXT
	0			; - FSTBLK
	DT'X'DIR+DT'X'DDB	; - DLOC
	0			; - IBLK
	0			; - OBLK
	0			; - DISPAD
	0			; - DMPLST
	0			; - SVDWRD
	0			; - DJOTOP
	0			; - DJOBOT
	0			; - BADCOM
	0			; - DTXBLK
	0			; - DTXRID
	0			; - DTXWRD
	0			; - DTXWWT
	0			; - DTXEST
	0			; - DTXEFL
	0			; - DTXEBK


DT'X'DIR==:.-DT'X'DDB
	BLOCK	200
	XP	DT'X'DDS,.-DT'X'DDB
;DATA LEVEL CODE...CHANNEL 1 OR 2 USUALLY

D'X'DINT::CONSO	DAS,1		;DATA INTERRUPT FOR THIS CONTROL?
	JRST	.		;NO- PROCEED DOWN CHAIN
	SKIPN	DT'X'USE	;EXPECTING AN INTERRUPT?
	JRST	D'X'DINT+1	;NO, IGNORE IT

	SKIPE	D'X'DSRC	;ARE WE SEARCHING FOR BLOCK NUMBERS?
	JRST	D'X'SRCH	;YES
D'X'IOWD:BLKI	DAC,DT'X'PNT	;EXECUTE BLKI OR BLKO FOR THIS UNIT
	JRST	D'X'DTHR	;POINTER RAN OUT
D'X'DCTN:JFCL			;GOING REVERSE?
	XJEN	D'X'DCHL##

	SOS	DT'X'PNT	;YES- DECREMENT POINTER
	SOS	DT'X'PNT	;TWICE
	XJEN	D'X'DCHL##

D'X'DTHR:SKIPE	D'X'DDMP	;DUMP MODE POINTER RAN OUT?
	JRST	D'X'DMPA	;YES- ADVANCE POINTER
D'X'DFNS:CONO	DAS,770001	;SEND OUT FUNCTION STOP IF THROUGH
	XJEN	D'X'DCHL##


D'X'DSRC:CDC	DTXSRC,0	;SET NEGATIVE WHEN READING BLOCK NUMBERS

;HERE WHEN READING BLOCK NUMBERS AT DATA INTERRUPT LEVEL

D'X'SRCH:JSR	D'X'DSAV##	;SAVE ACS
D'X'CCNC:CONI	DAC,W		;READ FLAGS REGISTER
	HRLZS	W		;PUT MOST FLAGS INTO LEFT HALF
	HRRI	W,DT'X'DDB	;POINT TO THIS CONTROL BLOCK
	JRST	SRCH##		;DO THE SEARCH

D'X'DMPA:JSR	D'X'DSAV##	;SAVE ACS
	HRRZI	W,DT'X'DDB	;POINT TO CONTROL A
	JRST	DMPADV##	;PROCESS THE EXHAUSTED BLKI/O

	XP	DTSFNS,D'X'DFNS-DT'X'DDB
	XP	DXDINT,D'X'DINT-DT'X'DDB
	XP	DXIOWD,D'X'IOWD-DT'X'DDB
	XP	DXDCTN,D'X'DCTN-DT'X'DDB
D'X'CNUM:CDC	DXCNUM,<<DAC>B11>;CONTROL NUMBER
;FLAGS LEVEL INTERRUPT HEAD...
DT'X'INT::CONSO	DAS,770000	;INTERRUPT FOR THIS CONTROL?
	JRST	.		;NO- PROCEED DOWN CHAIN
	SKIPN	DT'X'USE
	JRST	DT'X'INT+1
	JSR	DT'X'SAV##	;YES- SAV ACCUMULATORS FOR THIS LEVEL
	CDC	DXCCNT,<CONI DAC,T1>;READ FLAGS INTO T1
	CDC	DTSCNI,<CONI DAS,T4>;READ STATUS INTO T4
	HRLZI	W,(T1)		;PUT FLAGS (RH) INTO W (LH)
	HRRI	W,DT'X'DDB	;ADDRESS OF CONTROL DEPENDANT BLOCK
	JRST	DTXINT##	;TO NON-CONTROL DEPENDANT SECTION

	CDC	DTSCN2,<CONI DAS,T1>;STATUS REGISTER INTO T1

;CONSTANTS REQUIRED FOR EACH CONTROL...
	CDC	BFPNTR,<IOWD 200,D'X'BUF+1>
DT'X'USE:CDC	USEWRD,0
	CDC	ADRPRG,0
DT'X'PNT:CDC	PNTR,0
	CDC	DISTNC,0
	CDC	BLOCK,0
	CDC	QUANTM,0
	CDC	DSCON,0
	CDC	RVERS,0
	CDC	ERRCNT,0
	CDC	FNDTMP,0
	CDC	IOWRIT,0
	CDC	TURNCT,0
	CDC	BLKWRD,0
	CDC	LVFLAG,0
	CDC	BLKCNT,0
	CDC	SVPNTR,0
	CDC	USPNTR,0
	CDC	DIRCTN,0
	DT'X'BUF=.-DT'X'DDB
D'X'BUF:CDC	BUF,<BLOCK 200>	;A CONTROL MONITOR BUFFER
	CDC	DTXCON,<CONO DAC,(T1)>	;CONDITIONS OUT - A CONTROL A
	CDC	DTXSTP,<CONO DAC,400000>	;STOP SELECTED TAPE
	CDC	DTXTRN,<CONO DAC,DTTURN##>	;TURN SELECTED TAPE AROUND
	CDC	DTSCO2,<CONO DAS,2(T4)>
	CDC	DTSENJ,<CONO DAS,670000>	;ENABLE JOB DONE

	CDC	DTXREQ,-1		;# OF WAITERS
	CDC	DTXWAT,0		;REQUEST INTERLOCK FOR THIS CONTROL

D'X'DDMP:CDC	DTXDMP,0	;SET TO -1 WHEN READING IN DUMP MODE
	XP	DTXIOG,.-DT'X'DDB
	CONO	DAC,DTBOTH##(T2)	;START UP DECTAPE
	CONO	DAS,770000	;ENABLE INTERRUPT CONDITIONS
	POPJ	P,		;RETURN
	CDC	DTXSF,<CONSZ DAC,100000>	;SKIP IF GOING FORWARD
	CDC	DTXDSL,<CONO DAC,410000>	;STOP AND DESELECT TAPE
	CDC	DTXDST,<CONO DAC,10000>	;DESELECT TAPE
	CDC	DTXSTO,<CONO DAC,430000(T1)>	;STOP AND DESELECT
	CDC	DTXTR2,<CONO DAC,230200(T1)>	;TURN TAPE, SEARCH FOR BLOCKS
	CDC	DTXINI,<CONO DAC,0>	;SHUT DOWN CONTROL
	CDC	DTXDTI,<DATAI DAC,T1>	;READ A BLOCK NUMBER

	XP	DCONS,.-DT'X'DDB
>;END DEFINE DTDDB

DEFINE	GENDTA(CPU,CPUN)<
	ZZZZ==0
	REPEAT	M'CPU'TD10,<
		IFE ZZZZ&1,<DAC==320>
		IFN ZZZZ&1,<DAC==330>
		DAS==DAC+4
		DTDDB (\"ZZZ,\<ZZZ&7>,CPUN)
		ZZZ==ZZZ+1
		ZZZZ==ZZZZ+1
	>;END REPEAT M'CPU'TD10
>;END DEFINE GENDTA

ZZ==0
ZZZ=="A"
REPEAT	M.CPU,<
	GENDTA (\ZZ,ZZ)
	ZZ==ZZ+1
>;END REPEAT M.CPU

KONEND::		;END OF KONTROLLER DATA BLOCKS


;DDB MAGIC CELLS
FSTBLK==:DEVPPN
DLOC==:FSTBLK+1	;LH==BLOCK# DURING DEAD RECKONING,RH==ADDRESS OF DIR
IBLK==:FSTBLK+2	;LH==INDEX OF INPUT FILE(1-27),RH==BLOCK# TO READ NEXT
OBLK==:FSTBLK+3
DISPAD==:FSTBLK+4
DMPLST==:FSTBLK+5
SVDWRD==:FSTBLK+6
DJOTOP==:FSTBLK+7
DJOBOT==:FSTBLK+10
BADCOM==:FSTBLK+11
DTXBLK==:BADCOM+1		;NUMBER OF LAST I/O BLOCK,,CONI DTS BITS
DTXRID==:DTXBLK+1		;SIXBIT REEL ID
DTXWRD==:DTXRID+1		;WORDS READ
DTXWWT==:DTXWRD+1		;WORDS WRITTEN
DTXEST==:DTXWRD+1		;ERROR STATUS (CONI DTS,)
DTXEFL==:DTXEST+1		;ERROR FLAGS (CONI DTC,)
DTXEBK==:DTXEFL+1		;ERROR BLOCK (DATAI DTC,)

SUBTTL	DA28 DATA BASE (XTCSER)


IFN	M.XTC,<


XP	MX11BF,^D129	;MAXIMUM PDP-11 IMAGE BINARY BUFFER SIZE
DEFINE	XTCDEF	(X),<
	IFNDEF	XT'X'S,<XT'X'S==420+X*10>
	IFNDEF	XT'X'C,<XT'X'C==:424+X*10>
XP	XKBSKP,400450

XT'X'INT:: CONSO	XT'X'C,XKBSKP	;EXTERNAL PROCESSOR INTERRUPT?
	JRST	.-1		;NO, GO DOWN THE SKIP CHAIN
	JSR	XT'X'SAV##	;SAVE ALL THE AC'S
	PUSHJ	P,SAVE4##	; ..
	JSP	W,XTCINT##	;CALL XTCSER

XP	XTCCHN,XT'X'CHN##

DEFINE	XTLNK	(A) <
	IFN	A-M.XTC,<
XKBKDB::!EXP	XKB'A'		;LINK TO NEXT KDB
>
	IFE	A-M.XTC,<
XKBKDB::!EXP	0		;NO MORE KDB'S
>
>
XP	XKBINT,<XT'X'INT-.>

Z=X+1
XKB'X::	PHASE	0		;BEGIN CONTROLLER DATA BLOCK
XKBNAM::!XWD	'EPA'+X,0	;EP NAME
	XTLNK	\Z		;LINK TO NEXT KDB
XKBUDB::!BLOCK	21		;SPACE FOR LINKS TO UDBS
XTSCNO::!CONO	XT'X'S,(T1)
XTCCNO::!CONO	XT'X'C,(T1)
XTSCNI::!CONI	XT'X'S,T1
XTCCNI::!CONI	XT'X'C,T1
XTSDTI::!DATAI	XT'X'S,T1
XTCDTI::!DATAI	XT'X'C,T1
XTCDTO::!DATAO	XT'X'C,T1
XTSDTO::!DATAO	XT'X'S,T2
XTCBSY::!CONSZ	XT'X'C,20
XKBLOK::!EXP	-1		;INTERLOCK
XKBDDB::!BLOCK	1		;POINTER TO DDB WAITING FOR INTRPT
XKBIUN::!BLOCK	1		;POINTER TO UDB WAITING FOR INTERRUPT
XKBDAC::!BLOCK	1		;INFO FROM LAST CONI DAC
XKBDAS::!BLOCK	1		;INFO FROM LAST CONI DAS
XKBTIM::!BLOCK	1		;COUNTER FOR TIMEOUT
XKBIOW::!BLOCK	1		;IOWD FOR DAC OR PNTR TO IOLIST
XKBCUR::!BLOCK	1		;CUR PNTR TO IOLIST (KI10 ONLY)
XKBGRB::!Z			;0 IF FREE 1 IF GRABBING
				;CONTROL -1 IF GRABBED
XKBPAC::!BLOCK	1		;# OF PSEUDO ACTIVE DDB'S ON THIS
				; CONTROLLER
XKBREQ::!BLOCK	1		;OLDEST JOB # REQUESTING USE OF UDB
XKBMBF::!BLOCK	<MX11BF*3>/2	;MONITOR BUFFER
	DEPHASE

>
	ZZ=0
	IFE	M.XTC,<
XTUUO==:CPOPJ##			;NO XTUUO IF NO XTCSER
XTKLDB==:CPOPJ##		;ALSO NO DDB KILLER
XTCTTY::AOS	(P)		;DOUBLE SKIP
	JRST	CPOPJ1##
XTCTYP==:CPOPJ##
>

	IFN	M.XTC,<EXTERN XTCSER>		;LOAD XTCSER IF NEEDED

	REPEAT	M.XTC,<
	XTCDEF	(\ZZ)
	ZZ=ZZ+1
>
>
	SUBTTL	Database for RX20s on 2020s

IFE M.KS10,<M.RX20==:0>
IFN M.RX20,<

	EXTERN	RX2SER			;Load device driver

	;Macro to define prototype DDB for each RX20 CTLlr (RXA,RXB,...)

	DEFINE	RX2DDB(x,CPU),<

RX'x'INT::EXP	0,0,IC.UOU,.+1		;Vectored interrupts XPCW here
	EXCH	T1,RX'x'INT		;Get interrupt PC
	MOVEM	T1,RX'x'CHL##		;Save for RESn
	MOVE	T1,RX'x'INT+1		;;Second word of PC
	MOVEM	T1,RX'x'CHL##+1		;;...
	MOVE	T1,RX'x'INT		;Restore state
	JSR	RX'x'SAV##		;Save ACs
	JSP	F,RX2INT##		;Set up F and join RX2SER
RX'x'DDB::PHASE	0
	EXP	<SIXBIT/RX'x'0/>	;(0) DEVNAM for prototype DDB this CTL
	XWD	<^D5*HUNGST>,201	;(1) DEVCHR
	EXP	0			;(2) DEVIOS
	EXP	RX2DSP##		;(3) DEVSER
	XWD	DVLNG!DVIN!DVOUT,^D<1B<35-I>> ;(4) DEVMOD
	EXP	0			;(5) DEVLOG
	EXP	0			;(6) DEVBUF
	EXP	0			;(7) DEVIAD
	EXP	0			;(10) DEVOAD
	EXP	0			;(11) DEVSTS
	XWD	DEPLEN!<.TYRX2*.TYEST>,DEPEVM	;(12) DEVSTA
	EXP	0			;(13) DEVXTR
	EXP	0			;(14) DEVEVM
	EXP	0			;(15) DEVPSI
	EXP	0			;(16) DEVESE
	EXP	0			;(17) DEVHCW - Hard errors,,Soft errors
	BYTE	(3)CPU(33)0		;(20) DEVCPU
	EXP	0			;(21) DEVISN (Must leave space)
	EXP	0			;(22) DEVDRV
	EXP	0			;(23) DEVJOB
	EXP	0			;(24) DEVFIL
	EXP	0			;(25) DEVEXT
	EXP	0			;(26) DEVPPN
DEVRXO::!EXP	0			;(27) DEVRXO
DEVRXI::!EXP	0			;(30) DEVRXI
DEVRXQ::!EXP	0,0,0,0			;(31) DDB and CSR queue element
RX'x'DDS::!				;End of device DDB
DEVRXS::!EXP	0			;DEVRXS ;Start of CTL data
DEVRXV::!EXP	RX21IV+<<"x"-"A">*4>	;Interrupt vector
DEVRXC::!EXP	RX21BA+<<"x"-"A">*10>	;CSR address
DEVRXM::!EXP	0			;UBA mapping reg addr (2 slots/RX)
DEVRXE::!EXP	0			;11 address of mapped buffer
DEVRXJ::!XPCW	RX'x'INT		;Instruction to set up vector table with
	Dephase
>;End of define RX2DDB
DEFINE	GENRX2(CPU,CPUN)<
	ZZZZ==0
	REPEAT	M'CPU'RX20,<
		RX2DDB (\"ZZZ,CPUN)
		ZZZ==ZZZ+1
		ZZZZ==ZZZZ+1
	>;;End repeat
>;End define

ZZ==0
ZZZ=="A"
REPEAT	M.CPU,<
	GENRX2 (\ZZ,ZZ)
	ZZ==ZZ+1
>;End repeat
>;End M.RX20
SUBTTL	DEFINITIONS FOR DISPLAY AND LIGHT PEN
;DISPLAY AND LITE PEN

	IFG	M.DIS, <
	IFN	M.VP10, <DIS==134>
	EXTERN	DISSER
XP DISJSR,DISBLK##+1		;DIS JSR LOCATION IN LOWER CORE
XP ONDIS,DISBTH##+100
XP NONDIS,DISBTH##
XP OFFDIS,0
XP DISPON,2000+DISBIT##		;CONO PI, TURNS DIS PI CHANNEL ON
XP DISPOF,1000+DISBIT##		;CONO PI, TURNS DIS PI CHANNEL OFF


DISCON:

IFN M.340, <EXP ONDIS

DISBSY==77
XP PENON,7400

SETCON::CONO	DIS,100		;PARAMETER MODE
	JRST	DISIN1##

PENINT::CONSO	DIS,0		;CHECK FOR CONI FLAGS
	JRST	PENINT		;THIS WILL BE PART OF THE LINKED INTERRUPT CHAIN.
	CONSZ	DIS,400		;STOP FLAG UP
	JRST	STPFLG		;YES
	CONSZ	DIS,2000	;PEN FLAG UP
	DATAI	DIS,PENLOC##	;YES-STORE CURRENT LITE PEN LOCATION
	CONO	DIS,NONDIS	;CLEAR FLAGS
	XJEN	PENCHL##


;"STPFLG" SERVICES STOP FLAGS (DISPLAY PROGRAMMED) BY DOING A CLOSE ON THE DISPLAY

STPFLG:	JSR	PENSAV
	JRST	DISDSP##+DCL	;DO A CLOSE


ENDCHK::TRNN	T1,-1
	JRST	EXIT1##
	JRST	EXIT0##
>	;END OF IFN M.340
IFE M.340, <Z

DISBSY==20000
PENON==10000

SETCON::MOVEI	T1,PENCHN##	;SET UP CONO WORD
	ASH	T1,3		;WITH PROPER CHANNEL ASSIGNMENTS
	ADDI	T1,DISCHN##
IFN M.VP10, <TRO T1,4300>	;SET DISPLAY READY BIT & BRIGHTNESS = 3.
	MOVEM	T1,DISCON
	JRST	DISIN1##

PENINT::CONSO	DIS,0		;CHECK FOR CONI FLAGS
	JRST	PENINT		;THIS INSTRUCTION CHANGED TO LINK IN INTERRUPT CHAIN.
	DATAI	DIS,PENLOC##	;CLEAR PEN INTERRUPT
	MOVEM	T1,PENLOC##	;SAVE AC T1
	MOVE	T1,DISBKO##	;GET ABSOLUTE ADDRESS OF NEXT DATA ELEMENT
	SUB	T1,DISREL##	;MAKE RELATIVE
	HRRZS	T1		;CLEAR OUT GARBAGE IN LH
	EXCH	T1,PENLOC##	;SAVE ADDRESS IN PENLOC
	XJEN	PENCHL##



ENDCHK::JUMPE	T1,EXIT1##	;END OF LIST?
	TRNE	T1,-1		;NO, CHANGE INTENSITY COMMAND?
	JRST	EXIT0##		;NO
	MOVSS	T1		;YES, LH HAS USER CONO BITS
	DPB	T1,INPNT	;DEPOSIT FOR CONO
	CONO	DIS,@DISCON	;SET NEW INTENSITY
	JRST	DISNX1##
INPNT:	IFN	M.VP10, <POINT 2,DISCON,28>
>	;END OF IFE M.340

DISCNA::CONO	DIS,@DISCON
DISCZA::CONSZ	DIS,@DISCON
BLKLIT::BLKO	DIS,DISBKO##
DISCNO::CONO	DIS,OFFDIS
DISCNI::CONI	DIS,DISSTS##

DISTST::CONO	DIS,DISCHN##
>	;END OF IFG M.DIS


IFN M.VBXC,<EXTERN	VBCSER>
IFN FTKL10,<;DO THIS STUFF ONLY FOR KL CPU'S

;DEFINE SYMBOLS AND STORAGE FOR RSX-20F ASYNC TERMINALS

	$HIGH				;THIS PART INTO THE HIGH SEGMENT

DEFINE	RSXDTE(C,D),<
   IFE D,<
	EXP	$TTOFS
	$TTOFS==$TTOFS+M'C'TTDN
   >
>

	$TTOFS==TTDLAL		;INITIALIZE SYMBOL USED IN FOLLOWING MACRO
TTDOFS::RSX20F			;TABLE OF TTD LINE TABLE OFFSETS
	EXP	$TTOFS		;FIRST LINE AFTER DTE DRIVEN LINES
TTDLOM==:TTDOFS+1		;BASE OF RANGE CHECK TABLE
TTDDSO==:<TTDLAL-TTDDAL>	;TRANSLATION FOR DSCTAB ENTRIES
>;END IFN FTKL10
SUBTTL	ROUTINES COMMON TO PDP11 COMM FRONT-END'S ON DL10'S

IFN PDP11N,<
	DLMAP
	$HIGH

;SUBROUTINE TO PROCESS THE COMMAND:
;	.SET NOMESSAGE PDP11 N
;CALL WITH:
;	PUSHJ	P,D76SIL
;	RETURN HERE OR JRST COMERA
D76SIL::PUSHJ	P,DECIN##	;READ A DECIMAL NUMBER
	  JRST	D76SIP		;NO NUMBER ASSUME ZERO
	  CAIA			;ILLEGAL CHARACTER MAYBE
	  JRST	D76SIP		;OK GOT A DIGIT
	CAIE	T3,"*"		;WILD CARD
	JRST	COMERA##	;NO, ERROR
	MOVEI	T2,7		;YES, SET SIL ON ALL PDP11'S
	PUSHJ	P,D76SIA	;CONTINUE
	  JFCL			;IGNORE IF NOT THERE
	SOJGE	T2,.-2		;CONTINUE
	POPJ	P,		;RETURN
D76SIP:	PUSHJ	P,D76SIA	;GO SILENCE THIS 76
	  JRST	COMERA##		;LOST, GIVE ERROR
	POPJ	P,		;RETURN

D76SIA:	SKIPL	T2		;.LT. 0 IS WRONG.
	CAIL	T2,10		;SKIP IF PORT .LT. 8
	POPJ	P,		;INVALID PORT #
IFN M.DAS78,<
	CAILE	T2,M78HPO##	;SEE IF THIS PORT EXISTS ON A DAS78
	JRST	D76SI1		;NO, TRY OTHER 11S
	SKIPE	T1,M78BAT##(T2)	;IF A DAS78 THEN
	JRST	D76SI0		; ALL SET
> ;END IFN M.DAS78

D76SI1:	SKIPE	T1,DLXBAT##(T2)	;IF NO KNOWN PORT OR
	SKIPN	T1,DLXWIN##(T1)	; NO WINDOW ASSIGNED THEN
	POPJ	P,		; COMPLAIN
D76SI0:	SKIPG	DWN(T1)		;IS THE PDP11 DOWN?
	SETOM	DWN(T1)		;YES--TURN OFF THE MESSAGE
	JRST	CPOPJ1##	;RETURN
	$LOW
>	;END OF IFN PDP11N
IFN <PDP11N-DLX.78>,< ;IF ANY DL10 BASED 11S BUT NOT DAS78S

;ROUTINE TO GET ERROR STATUS AND CALL DAEMON FOR AN ERROR
;ON A DC76, DN85 OR DN60
;ARGUMENTS	T1=PORT # OF 11 WITH ERROR
DLB==60	;DEVICE CODE FOR DL10
DLC==64	;DEVICE CODE FOR DL10

DLBREG==3	;NUMBER OF HIGHEST CONI DLB, WE DO
DLBEDT==0	;VALUE OF R FOR DATAI DLB, WE WANT TO SAVE

	$HIGH

DL10EL::PUSHJ	P,SAVT##	;SAVE SOME ACS
	MOVEM	T1,DLEPRT	;SAVE THE PORT OF THE 11 WITH ERROR
	MOVE	T2,DLXNMT##(P2)	;GET NAME
	MOVEM	T2,DLEPGM	;SAVE
	HRLZ	T2,DLXTYP##(P2)
	MOVEM	T2,DLESTS
	MOVE	T2,DLXWIN##(P2)
	MOVE	T2,HLT(T2)
	HRRM	T2,DLESTS
	CONI	DLC,DLCCNI	;GET THE DLC CONI
	DATAI	DLC,DLCDTI	; AND DATAI
	MOVEI	T1,DLBREG	;GET NUMBER OF REGS TO SAVE OF DLB
DLBLUP:	DPB	T1,[POINT 2,DLBDTO,5]	;PUT REG INTO DATAO
	DATAO	DLB,DLBDTO	;AND DO DATAO SO CONI GETS RIGHT REG
	CONI	DLB,DLBCNI(T1)	;GET THIS DLB CONI
	CAIN	T1,DLBEDT	;IS THIS THE DATAI WE WANT?
	DATAI	DLB,DLBDTI	;YES, GET IT
	SOJGE	T1,DLBLUP	;AND LOOP BACK FOR NEXT REG
	SETZ	T1,		;FLAG WE NEED TO ALLOCATE THE BLOCK
	XMOVEI	T2,DLETBL	;POINT TO TRANSFER TABLE
	PUSHJ	P,XFRSEB##	;FILL AND QUEUE UP RECORD
	  JFCL			;NO CORE
	POPJ	P,		;RETURN

	$LOW
DLBDTO:	XWD	1,0		;BITS FOR DATAO DLB,
DLEBLK:-DLELEN,,DLEPRT		;AOBJN POINTER FOR ERROR BLOCK
DLEPRT:	BLOCK	1		;PORT OF 11 WITH ERROR
DLCCNI:	BLOCK	1		;CONI DLC AT ERROR
DLCDTI:	BLOCK	1		;DATAI DLC AT ERROR
DLBCNI:	BLOCK	4		;BLOCK FOR CONI DLB'S
DLBDTI:	BLOCK	1		;DATAI DLB WITH R=0 AT ERROR
DLEPGM:	BLOCK	1		;SIXBIT PROGRAM NAME
DLESTS:	BLOCK	1		;HALT STATUS
DLELEN==.-DLEPRT


;TRANSFER TABLE
DLETBL:	SEBTBL	(.ERDLE,DLEEND,<EX.QUE!EX.SYE!EX.DEL>)
	SETZ			;(R00) DEVICE NAME
	SETZ			;(R01) CONTROLLER TYPE, ETC.
	SETZ			;(R02) PPN
	SETZ			;(R03) PROGRAM NAME
	MOVE	[-DLELEN,,DLEPRT] ;(R04) WORDS IN SUB-BLOCK,,OFFSET
	MOVE	DLEPRT		;(R05) PORT IN ERROR
	MOVE	DLCCNI		;(R06) CONI DLC,
	MOVE	DLCDTI		;(R07) DATAI DLC,
	MOVE	DLBCNI+0	;(R10) CONI DLB, FOR REGISTER 0
	MOVE	DLBCNI+1	;(R11) CONI DLB, FOR REGISTER 1
	MOVE	DLBCNI+2	;(R12) CONI DLB, FOR REGISTER 2
	MOVE	DLBCNI+3	;(R13) CONI DLB, FOR REGISTER 3
	MOVE	DLBDTI		;(R11) DATAI DLB,
	MOVE	DLEPGM		;(R12) SIXBIT PROGRAM NAME
	MOVE	DLESTS		;(R13) HALT STATUS
DLEEND:!

> ;END IFN <PDP11N-DLX.78>
;COME HERE ONCE A SECOND.

IFN FTKS10*M.DN60,<
DLXSEC::PUSH	P,P1		;SAVE P1 FOR A BIT
IFN M.DN6K*M.KDUP,<		;IF ON A KS10 WITH IBM COMM
	MOVE	P1,[XWD -M.KDUP,KDPBAS] ;GET AN AOBJN POINTER TO THE BASE TABLE
DLXSE1:	MOVE	W,(P1)		;GET THE NEXT LINE
	PUSHJ	P,D6KSEC##	;SET DN60 TIME OUT THE CALL11 FUNCTIONS
	AOBJN	P1,DLXSE1	;LOOP OVER ALL LINES
>;M.DN6K
IFN M.DN6R*M.DMRN,<		;IF ON A KS10 WITH IBM COMM
	MOVE	P1,[XWD -M.DMRN,DMRBAS] ;GET AN AOBJN POINTER TO THE BASE TABLE
DLXSE2:	MOVE	W,(P1)		;GET THE NEXT LINE
	PUSHJ	P,D6KSEC##	;SET DN60 TIME OUT THE CALL11 FUNCTIONS
	AOBJN	P1,DLXSE2	;LOOP OVER ALL LINES
>;M.DN6R
	POP	P,P1		;RESTORE P1
	POPJ	P,		; AND RETURN
>; END IFN FTKS10
IFE FTKS10*M.DN60,<		;IF NOT ON A KS10 WITH IBM COMM
IFE DL10XI,<DLXSEC==:CPOPJ##>
IFN DL10XI,<
DLXSEC::
IFN M.CPU-1,<
	SKIPE	.CPCPN##	;DL10'S CAN ONLY BE ON CPU0
	POPJ	P,
>
	PUSHJ	P,SAVE3##	;SAVE P1-P3
	MOVSI	P1,-10		;AOBJN POINTER
D76SC1:	SKIPN	P2,DLXBAT##(P1)	;GET BASE ADDRESS OF THIS PDP11
	JRST	D76S1L		;NO.
	SKIPN	P3,DLXWIN##(P2)	;HAS IT A WINDOW?
	JRST	D76S1L		;NO WINDOW IS NO GOOD
	SKIPG	DLXDWN##(P3)	;IS THIS PDP11 UP?
	JRST	D76NTR		;NO.
	SKIPN	DLXHLT##(P3)	;YES, IS IT HALTED?
	JRST	D76S2L		;NO.
D76DWN:	SKIPG	DLXDWN##(P3)	;DO I THINK THE PDP11 IS UP?
	JRST	D76S1L		;NO.
	XCT	DLXCLR##(P2)	;YES, CLEAR ITS ENABLE.
	SETZM	DLXDWN##(P3)	;AND MARK IT DOWN.
	XCT	DLXPRG##(P2)	;DO ANY NECESSARY CLEAN UPS
	MOVE	T1,P1		;GET PORT #
	PUSHJ	P,DL10EL	;LOG ERROR

	MOVSI	T1,(JFCL)	;DISABLE ITS SERVICE ROUTINE
	MOVEM	T1,DLXINI##(P2)
	SETZM	DLXCAL##(P2)
	MOVEM	T1,DLXPRG##(P2)
D76S1L:	AOBJN	P1,D76SC1	;TRY NEXT PDP11.
	POPJ	P,		;NO MORE, ALL DONE.

D76S2L:	AOS	T1,DLXOK##(P3)	;COUNT THE "OK" COUNTER
	CAIL	T1,^D10		;IS THE PDP11 STILL OK?
	JRST	D76DWN		;NO, IT HAS GONE DOWN.
	JRST	D76S1L		;YES, GO ON TO NEXT PDP11.

;COME HERE IF A PDP11 IS NOT RUNNING.

D76NTR:	XCT	DLXCNI##(P2)	;CONI DLC,T1
	MOVEI	T2,22220	;PORT ENABLE BITS
	ANDCM	T2,T1		;T2 GETS A 1 FOR EACH PDP11
				;  NOT ENABLED
	LSH	T2,-1		;MOVE TO INTERRUPT BIT
	AND	T2,T1		;1 FOR EACH PDP11 LOADED BUT NOT
				;  YET STARTED.
	AND	T2,DLXMSK##(P2)	;MASK OFF BITS FOR OTHER PDP11S
	JUMPE	T2,D76S1L	;JUMP IF NOT OUR PDP11
	SETZM	DLXOK##(P3)	;NOT CRASHED YET
	SETZM	DLXHLT##(P3)	;NOR HALTED
	SETZM	TTP(P3)		;CLEAR THE Q'S
	SETZM	TTG(P3)		;CLEAR THE Q'S
	SETZM	TEP(P3)		;CLEAR THE Q'S
	SETZM	TEG(P3)		;CLEAR THE Q'S
	SETZM	DLXCEU##(P2)	;NO CAL11. USER
	MOVSI	T1,767760	;BUILD SIX BIT DL10 BYTE POINTER
	HRRI	T1,DLXNMT##(P2)	;INTO DL10 BASE TABLE
	SETZM	(T1)		;ZAP OLD NAME
	MOVEM	T1,DLXNAM##(P3)	;STORE POINTER TO NAME
	MOVEI	T1,2		;KILL IF NO RESPONSE IN 2 SEC
	MOVEM	T1,DLXDWN##(P3)	; BY MARKING PDP11 AS UP
	MOVE	T1,[PUSHJ P,D76CKN]	;CHECK NAME ON INTERRUPT
	MOVEM	T1,DLXINI##(P2)
	XCT	DLXKAX##(P2)	;SPECIFY KA10 INTERRUPTS (IN CASE NOT DONE ALREADY)
	XCT	DLXSWA##(P2)	;SET WINDOW ADDRESS
	XCT	DLXENB##(P2)	;ENABLE PORT
	JRST	D76S1L		;WAIT FOR INTERRUPT
>; END IFN DL10XI CONDITIONAL
>; END IFE FTKS10*M.DN60
IFN PDP11N,<
;COME HERE ON NEXT DL10 INTERRUPT FOR THIS PDP11.

D76CKN:	SKIPN	T1,DLXNMT##(W)	;NAME SPECIFIED YET?
	POPJ	P,		;NO.
IFN M.DC75,<
	CAMN	T1,[SIXBIT /DC75/]	;YES, DC75?
	JRST	D75III##	;YES, START UP DC75.
>
IFN M.DC76,<
	CAMN	T1,[SIXBIT /DC76/]	;NO, DC76?
	JRST	D76III##	;YES, START UP DC76.
>
IFN DLX.60,<IFN M.DN6D,<
	CAMN	T1,[SIXBIT /DN60/] ;NO, DN60?
	JRST	D60III##	;YES, START UP DN60
>>
	POPJ	P,		;NO, IGNORE IT.

;COME HERE ONCE A MINUTE.

IFE DL10XI,<D76MIN==:CPOPJ##>
IFN DL10XI,<
D76MIN::SKIPGE	DEBUGF##	;DEBUGGING
	POPJ	P,		;YES, NO MESSAGE
	PUSHJ	P,SAVE3##	;SAVE P1-P3
	MOVE	P1,SYSUPT##	;GET UPTIME
	CAMGE	P1,TICMIN##	;MORE THAN 1 MINUTE
	POPJ	P,		;NO--TOO EARLY
	MOVSI	P1,-10		;MAXIMUM NUMBER OF PORTS
D76MLP:	SKIPE	P2,DLXBAT##(P1)	;IS THIS PDP11 DEFINED?
	SKIPN	P3,DLXWIN##(P2)	;YES, HAS IT A WINDOW?
	JRST	D76MNX		;NO, LOOK AT NEXT PDP11
	SKIPE	DLXDWN##(P3)	;IS IT UP OR SILENCED?
	JRST	D76MNX		;YES.
	MOVE	T1,STATES##	;SCHED SETTINGS
	TRNE	T1,ST.NOP	;IS THERE AN OPR IN ATTENDANCE?
	SETOM	DLXDWN##(P3)	;NO, ONLY REPORT THE ERROR ONCE
	MOVE	U,OPRLDB##	;NO, PRINT MESSAGE ON OPR'S TTY
	PUSHJ	P,INLMES##
	ASCIZ	/
%%PDP-11 number /
	MOVE	T1,DLXEPN##(P3)	;ELEVEN PORT NUMBER
	PUSHJ	P,RADX10##	;PRINT THAT OUT
	SKIPE	DLXHLT##(P3)	;HALTED?
	JRST	D76HLT		;YES.
	PUSHJ	P,INLMES##	;NO, JUST SAY NOT UP.
	ASCIZ	/ is not running.
/
	JRST	D76MNX		;CHECK NEXT PDP11

;STILL IN IFN DL10XI AND IFN PDP11N CONDITIONALS
;COME HERE IF THE PDP11 IS ACTUALLY HALTED.

D76HLT:	PUSHJ	P,INLMES##
	ASCIZ	/ halted at /
	MOVE	T1,DLXHLT##(P3)	;GET HALT PC (OR STOP CODE)
	PUSHJ	P,OCTPNT##	;TYPE IT OUT
	PUSHJ	P,INLMES##	;END WITH A DOT
	ASCIZ	/.
/
D76MNX:	AOBJN	P1,D76MLP	;CHECK THE REST OF THE PDP11S
	POPJ	P,		;DONE THEM ALL--RETURN.

	$LOW
>	;END OF IFN DL10XI CONDITIONAL
>	;END OF IFN PDP11N
SUBTTL	TTY INIT SETUP TABLE

	$INIT

;THE FOLLOWING TABLE DESCRIBES FOR LINKTT (IN SCNSER) HOW TO SETUP
; THE LINE DATA BLOCKS FOR THEIR ASSOCIATED DRIVERS.

;FORMAT OF A TABLE ENTRY:
;	-# OF LINES,,CPU #
;	QUEUE HEADER,,ISR
;	LDBISB BITS,,LTLUSE OR 0

	EXTERN	LIL7BT,LILCFE,LTLUSE	;DECLARE THE FLAGS WE CAN SET

LNKTTB::
DEFINE	TTDSPX(DSP,ADDON,CLEVER,ALLOC,QUEUE,CPU,DUMB<Y>),<
IFN ADDON,<
IF2,<	.IF DSP,NEEDED,<EXTERN DSP>
	.IF QUEUE,NEEDED,<EXTERN QUEUE>
>
	XWD	-ADDON,CPU
	XWD	QUEUE,DSP
XXY==<XXZ==0>
IFIDN <CLEVER><Y>,<XXY=XXY!LILCFE>	;;DC76
IFIDN <DUMB><Y>,<XXY=XXY!LIL7BT>	;;TOO DUMB TO HANDLE 8-BIT ASCII
IFIDN <ALLOC><Y>,<XXZ=XXZ!LTLUSE>	;;NOT A REMOTE (ALLOCATABLE) LDB
	XWD	XXY,XXZ			;;FLAGS
>> ;END OF DEFINE TTDSPX

DEFINE	TTSPCP(CPU),<
	DC10N0==10*M'CPU'TTG0
	DC10N1==10*M'CPU'TTG1
	TTDSPX(DL0DSP,DC10N0,N,Y,DL0TQ'CPU,CPU)
	TTDSPX(DL1DSP,DC10N1,N,Y,DL1TQ'CPU,CPU)
	TTDSPX(CC0DSP,M'CPU'68L0,N,Y,CC0TQ'CPU,CPU)
	TTDSPX(CC1DSP,M'CPU'68L1,N,Y,CC1TQ'CPU,CPU)
	TTDSPX(DC760D,M'CPU'D70N,Y,Y,D70TQ'CPU,CPU)
	TTDSPX(DC761D,M'CPU'D71N,Y,Y,D71TQ'CPU,CPU)
	TTDSPX(DC762D,M'CPU'D72N,Y,Y,D72TQ'CPU,CPU)
	TTDSPX(DC763D,M'CPU'D73N,Y,Y,D73TQ'CPU,CPU)
	TTDSPX(DC764D,M'CPU'D74N,Y,Y,D74TQ'CPU,CPU)
	TTDSPX(DC765D,M'CPU'D75N,Y,Y,D75TQ'CPU,CPU)
	TTDSPX(DC766D,M'CPU'D76N,Y,Y,D76TQ'CPU,CPU)
	TTDSPX(DC767D,M'CPU'D77N,Y,Y,D77TQ'CPU,CPU)
	TTDSPX(DZDSP,M'CPU'DZNL,Y,Y,DZTQ'CPU,CPU,N)
	TTDSPX(TTDDSP,M'CPU'TTDN,Y,Y,.C'CPU'CTQ,CPU)
>
;GENERATE LDB'S FOR LOCAL LINES
ZZ==0
REPEAT	M.CPU,<
	TTSPCP(\ZZ)
ZZ==ZZ+1
>
;NOW GENERATE A POOL OF LDB'S FOR NETWORK TTYS
;ASSUME ALL ARE ON CPU0 SINCE NETWORK LDB'S ARE DYNAMICALLY ALLOCATED
; FROM THE POOL AND THE CORRECT OUTPUT QUEUE, CPU NUMBER, AND DISPATCH
; ARE FILLED IN BY THE NETWORK MODULE WHEN THE LDB IS USED

	TTDSPX(ERRDSP,M.RTTY,N,N,NULQUE,7,N)

;NOW GENERATE THE POOL FOR XTCSER
	TTDSPX(XTTDSP,M.XTL,N,Y,XTTQUE,0)

;KS10 KLINIK LINE
IFN M.KS10,<
DEFINE TTSPCP(CPU),<
	TTDSPX(CTYDSP,1,N,Y,.C'CPU'CTQ,CPU)
>
ZZ==M.CPU-1
REPEAT M.CPU,<
	TTSPCP(\ZZ)
ZZ==ZZ-1
>
>;END IFN M.KS10

;NOW GENERATE AN LDB FOR INTERNAL FORCED COMMANDS

	TTDSPX(ERRDSP,1,N,Y,FRCQUE,7,N)

;NOW GENERATE LDB'S FOR THE CTYS

DEFINE	TTSPCP(CPU),<
CT'CPU'LIN==:CTYLIN-CPU
	TTDSPX(CTYDSP,1,N,Y,.C'CPU'CTQ,CPU)
>
ZZ==M.CPU-1
REPEAT	M.CPU,<
	TTSPCP(\ZZ)
ZZ==ZZ-1
>
IFN TCONLN-CT0LIN,<PRINTX ?TTDSPX IS IN ERROR>

;NOW FOR THE PTYS

	TTDSPX(ERRDSP,M.PTY,N,Y,FRCQUE,7,N)

;FINALLY, DEFINE THE TABLE LENGTH FOR SCNSER
LNKTTL==:.-LNKTTB

PURGE	XXY,XXZ,ZZ
SUBTTL	IPA20 CHANNEL I/O -- IPAICD - PROTOTYPE CONSO SKIP CHAIN CODE


	$CSUB

IFN M.KL10&<M.SCA!M.ENET>,<
IPAICD::!PHASE	0
	SKIPA	IPABIT		;(00) A LITTLE TROUBLE TO CHECK FOR PI FLAGS
IPAJRS:!JRST	.		;(01) TRY NEXT DEVICE ON CHAIN
	MOVEM	T1,IPAST1	;(02) SAVE T1 A BIT
	CONI	0,T1		;(03) GET CONI BITS
	TDNE	T1,IPABIT	;(04) INTERRUPT FOR THIS DEVICE?
	JRST	IPAEXC		;(05) YES
	MOVE	T1,IPAST1	;(06) GET SAVED T1
	JRST	IPAJRS		;(07) TRY NEXT DEVICE ON CHAIN
IPAEXC:!EXCH	T1,IPAST1	;(10) GET SAVED T1 BACK, SAVE CONI STATUS BITS
	JSR	PIERR##		;(11) SAVE AC'S, SET UP PDL
	MOVE	T1,IPAST1	;(12) GET BACK CONI STATUS BITS
	SKIPA	W,.+1		;(13) GET KDB ADDRESS
	EXP	0		;(14) KDB ADDRESS
	XJRST	.+1		;(15) CALL INTERRUPT HANDLER
	EXP	0		;(16) INTERRUPT HANDLER ADDRESS
IPAST1:!EXP	-1		;(17) HOLDS T1 WHILE TESTING CONI BITS
IPABIT:!EXP	-1		;(20) CONI BITS
	DEPHASE			;END OF PHASED CODE
IPAICL==:.-IPAICD		;LENGTH OF CONSO SKIP CHAIN CODE

> ;END IFN M.KL10&<M.SCA!M.ENET>
SUBTTL	IPA20 CHANNEL I/O -- LDIPA - LOAD IPA20 CRAM


;ROUTINE TO LOAD AN IPA20 CRAM
;CALL:	MOVE	T1, ADDRESS OF MICROCODE STORAGE
;	PUSHJ	P,LDIPA
;	  <NON-SKIP>		;MICROPROCESSOR IS RUNNING
;	<SKIP>			;CHANNEL LOADED

IFN M.KL10&<M.SCA!M.ENET>,<
	$XSENT	(LDIPA::)
	PUSHJ	P,SAVE3##	;SAVE SOME ACS
	SETZ	P1,		;INITIAL CRAM ADDRESS
	MOVSI	P2,(<POINT 12,,>!1B12) ;TWO-WORD BYTE POINTER
	MOVE	P3,T1		;INCLUDE MICROCODE STORAGE ADDRESS

LDIPA1:	MOVEI	T1,5		;5 BYTES PER CRAM MICROWORD
	SETZB	T2,T3		;START WITH EMPTY WORDS

LDIPA2:	ILDB	T4,P2		;GET A BYTE
	LSHC	T2,^D12		;APPEND IT TO THE WORD
	ADD	T3,T4		;...
	SOJN	T1,LDIPA2	;LOOP BACK FOR ALL 5 BYTES
	MOVE	T1,P1		;GET CRAM ADDRESS
	LSHC	T2,6		;SEPARATE CRAM HALFWORDS
	LSH	T3,-6		;...
	PUSHJ	P,WTIPA		;WRITE THIS WORD INTO CRAM
	  POPJ	P,		;CHANNEL IS RUNNING
	CAIE	P1,MAXCRA	;AT END OF IPA20 CRAM?
	AOJA	P1,LDIPA1	;NO, LOOP BACK FOR ENTIRE CRAM
	JRST	CPOPJ1##	;RETURN

	$HIGH
> ;END IFN M.KL10&<M.SCA!M.ENET>
SUBTTL	IPA20 CHANNEL I/O -- DMPIPA - DUMP IPA20 DRAM


;ROUTINE TO DUMP THE IPA20 DRAM.
;CALL:
;	W/ KDB ADDRESS
;	PUSHJ	P,DMPIPA
;RETURN:
;	  <NON-SKIP>		;DUMP FAILED (MICROPROCESSOR RUNNING/NO BUFFER)
;	<SKIP>			;DUMP SUCCEEDED

IFN M.KL10&<M.SCA!M.ENET>,<
	$XSENT	(DMPIPA::)
	PUSHJ	P,SAVE2##	;FREE UP P1 - P2
	SETZ	P1,		;INIT DRAM ADDRESS TO ZERO
	SKIPN	P2,IPKDDB(W)	;IS THERE A DUMP BUFFER?
	POPJ	P,		;NO, SORRY, WE TRIED
	MOVEI	T1,DRMSIZ-1	;CLEAR THE BUFFER FIRST
	AOS	T3,P2		;GET DESTINATION FOR XBLT
	SOS	T2,P2		;GET SOURCE
	SETZM	(T2)		;CLEAR FIRST WORD
	EXTEND	T1,[XBLT]	;ZERO REST OF BUFFER
	MOVEI	T1,CO.CPT	;NOW FORCIBLY HALT THE CRITTER
	XCT	KDBCNO(W)	;...
DMPIP1:	MOVE	T1,P1		;COPY DRAM ADDRESS
	PUSHJ	P,READRM	;READ DRAM CONTENTS
	MOVEM	T2,(P2)		;STORE IN BUFFER
	ADDI	P2,1		;BUMP BUFFER ADDRESS
	CAIGE	P1,MAXDRA	;DONE ALL WORDS?
	AOJA	P1,DMPIP1	;LOOP FOR REMAINDER
	MOVE	T1,KDBNAM(W)	;GET KDB NAME FOR USE AS FILE NAME
	MOVE	T2,IPKDDB(W)	;GET BUFFER ADDRESS
	MOVEI	T3,MAXDRA	;AND WORD COUNT
	PUSHJ	P,AUTDMP##	;CAUSE DUMP BUFFER TO BE WRITTEN TO DISK
	JRST	CPOPJ1##	;RETURN
> ;END IFN M.KL10&<M.SCA!M.ENET>
;ROUTINE TO READ A WORD OF THE IPA20 DRAM
;CALL:
;	T1/ DRAM ADDRESS
;	W/ KDB ADDRESS
;	PUSHJ	P,READRM
;	<ONLY RETURN>		;T2/ DRAM CONTENTS

IFN M.KL10&<M.SCA!M.ENET>,<
READRM:	MOVE	T2,[000001,,400073] ;CREATE MICRO INSTRUCTION TO READ DRAM
	MOVE	T3,[002000,,220040] ;...
	DPB	T1,[POINT 10,T2,29] ;INSERT DRAM ADDRESS
	SETZ	T1,		;MAKE SURE RUN FLOP IS CLEAR
	XCT	KDBCNO(W)	;...
	PUSHJ	P,DRMPAR	;COMPUTE PARITY BIT
	MOVEI	T1,0		;CRAM ADDRESS
	PUSHJ	P,WTIPA		;WRITE THE CRAM DATA
	  JFCL			;SHOULDN'T FAIL
	MOVE	T2,[000001,,600443] ;GET SECOND MICRO INSTRUCTION
	MOVE	T3,[001000,,005040] ;...
	PUSHJ	P,DRMPAR	;COMPUTE PARITY BIT
	MOVEI	T1,1		;CRAM ADDRESS
	PUSHJ	P,WTIPA		;WRITE THE CRAM DATA
	  JFCL			;SHOULDN'T FAIL
	MOVSI	T2,(.DOLRA+<INSVL.(0,DO.RAR)>) ;SELECT MICROCODE START ADDRESS
	XCT	KDBDTO(W)	;...
	MOVEI	T1,CO.MRN	;START MICROCODE
	XCT	KDBCNO(W)
	SETZ	T1,		;STOP MICROCODE
	XCT	KDBCNO(W)
	MOVEI	T1,CO.DTE	;SET DIAG_TEST_EBUF
	XCT	KDBCNO(W)
	XCT	KDBDTI(W)	;READ RESULTING VALUE (DRAM CONTENTS)
	POPJ	P,		;RETURN
> ;END IFN M.KL10&<M.SCA!M.ENET>
;ROUTINE TO COMPUTE PARITY FOR A IPA20 MICROINSTRUCTION.
;CALL:
;	T2&T3/ MICROINSTRUCTION
;	PUSHJ	P,DRMPAR
;ONLY RETURN

IFN M.KL10&<M.SCA!M.ENET>,<
DRMPAR:	PUSHJ	P,SAVE2##	;SAVE P1-P2
	DMOVE	P1,T2		;SAVE ORIGINAL MICROWORD CONTENTS
	TDZ	P1,[000000,,400000] ;CLEAR PARITY BIT
	SETZ	T3,		;INITIALIZE BIT COUNT
	MOVE	T1,P1		;GET FIRST MICROWORD
	MOVN	T2,T1		;NEGATE
	TDZE	T1,T2		;ANY ONE BITS LEFT?
	AOJA	T3,.-2		;YES, LOOP BACK TO COUNT THEM UP
	MOVE	T1,P2		;GET SECOND MICROWORD
	MOVN	T2,T1		;NEGATE
	TDZE	T1,T2		;ANY ONE BITS LEFT?
	AOJA	T3,.-2		;YES, LOOP BACK TO COUNT THEM UP
	TRNN	T3,1		;IS MICROWORD EVEN PARITY?
	TDO	P1,[000000,,400000] ;YES, SET PARITY BIT
	DMOVE	T2,P1		;GET MICROWORD BACK WITH CORRECT PARITY
	POPJ	P,		;RETURN
> ;END IFN M.KL10&<M.SCA!M.ENET>
;ROUTINE TO ALLOCATE A DRAM DUMP BUFFER FOR AN IPA20 DEVICE.  SINCE
;THE DRAM IS 2 PAGES LONG, WE NORMALLY *DON'T* ALLOCATE THE BUFFER.
;PATCHING THE POPJ BELOW TO A JFCL WILL ENABLE DUMP BUFFERS.

IFN M.KL10&<M.SCA!M.ENET>,<
	$XSENT	(IPAADB::)
	POPJ	P,		;***PATCH TO JFCL TO ALLOCATE DUMP BUFFER
	MOVEI	T1,(MS.MEM)	;PICK A SECTION, ANY SECTION
	MOVEI	T2,DRMSIZ	;NUMBER OF WORDS IN BUFFER
	MOVEI	T3,GFWNZN##	;ASSUME DONE DURING SYSTEM INITIALIZATION
	SKIPN	DINITF##	;GOOD GUESS?
	MOVEI	T3,GFWNZS##	;NOPE, WE DID OUR BEST
	PUSHJ	P,(T3)		;CALL THE ROUTINE
	  POPJ	P,		;SORRY, COULDN'T HACK IT
	MOVEM	T1,IPKDDB(W)	;STUFF AWAY THE BUFFER
	MOVE	T2,T1
	AOS	T3,T1		;BUILD A BLT WORD TO ZERO BUFFER
	MOVEI	T1,DRMSIZ-1	;NUMBER OF WORDS TO MOVE
	SETZM	(T2)		;ZERO FIRST WORD
	EXTEND	T1,[XBLT]	;ZERO REMAINDER OF BUFFER
	POPJ	P,		;RETURN

	$HIGH
>; END IFN FTKL10&<FTENET!FTSCA>
SUBTTL	IPA20 CHANNEL I/O -- RDLAR - READ LATCHED ADDRESS REGISTER


;ROUTINE CALLED TO READ CONTENTS OF LATCHED ADDRESS REGISTER
;CALL:	MOVE	W, KDB ADDRESS
;	PUSHJ	P,RDLAR
;	  <NON-SKIP>		;CHANNEL IS RUNNING
;	<SKIP>			;T1 CONTAINS CRAM ADDRESS

IFN M.KL10&<M.SCA!M.ENET>,<
	$XSENT	(RDLAR::)
	PUSHJ	P,AUTOWN##	;DO WE OWN THE DATA BASE INTERLOCK?
	  JRST	RDLAR1		;NO--DO NORMAL STUFF
	PUSHJ	P,SAVW##	;SAVE W
	XMOVEI	W,.CPCNI##-KDBCNI ;FAKE KDB I/O INSTRUCTIONS

RDLAR1:	XCT	KDBCNI(W)	;CONI DEV,T1
	TRNE	T1,CO.MRN	;CHANNEL RUNNING?
	POPJ	P,		;ERROR
	MOVEI	T1,CO.LAR	;SET LATCHED ADDRESS REGISTER FLAG
	XCT	KDBCNO(W)	;CONO DEV,(T1)
	PUSH	P,T2		;SAVE T2
	XCT	KDBDTI(W)	;READ CONTENTS OF REGISTER
	SETZ	T1,		;MAKE SURE CO.LAR IS CLEAR
	XCT	KDBCNO(W)	;...
	LDB	T1,[POINTR (T2,DT.LAR)] ;GET CORRECT FIELD
	POP	P,T2		;RESTORE T2
	PJRST	CPOPJ1##	;RETURN

	$HIGH
> ;END IFN M.KL10&<M.SCA!M.ENET>
SUBTTL	IPA20 CHANNEL I/O -- TYIPA - READ PORT TYPE


;IN THE IDEAL WORLD IT WOULD BE POSSIBLE TO INSTALL THE NIA20  OR
;CI20  IN EITHER OF THE MODIFIED INTERNAL CHANNEL BACKPLANE SLOTS
;IN THE KL10.  UNFORTUNATELY, THERE IS NO EASY WAY  TO  TELL  THE
;TWO  TYPES  OF  DEVICES  APART.  THOSE WHO ARE FOOLISH ENOUGH TO
;BELIEVE THE DOCUMENTATION  MIGHT  DISAGREE,  BUT  THE  ENGINEERS
;NEVER  STRAPPED THE NIA20 AND CI20 TO RETURN DIFFERENT PORT TYPE
;FIELDS AS THE DOCUMENTATION LEADS ONE TO BELIEVE.
;
;DETERMINING  THE  PORT  TYPE  IS REALLY A FAIRLY STRIGHT FORWARD
;PROCESS.  ON THE OFF BEAT CHANCE THAT THE PORT BOARDS  ARE  EVER
;ECO'ED,  THE PORT TYPE FIELD IS THE FIRST THING CHECKED.  IF THE
;VALUE RETURNED IS KNOWN, THEN THE APPROPRIATE CODE IS  RETURNED.
;OTHERWISE,  AN  ATTEMPT TO FIGURE OUT THE PORT TYPE WILL BE MADE
;BASED ON THE BEHAVIOR OF THE DEVICE.  IF THIS  FAILS,  THEN  THE
;MONGEN'ED  DEVICE  TABLE  IS  USED  TO INDICATE THE DEVICE CODE,
;THEREBY TELLING THE AUTOCONFIGURATION ROUTINES IF THEY HAVE
;FOUND THE RIGHT DEVICE.
;CALL:	PUSHJ	P,TYIPA
;	  <NON-SKIP>			;UNKNOWN
;	<SKIP>				;KNOWN (T1 = TYPE CODE)

IFN M.KL10&<M.SCA!M.ENET>,<
	$XSENT	(TYIPA::)
	XCT	.CPCNI##	;READ CHANNEL STATUS
	LDB	T1,[POINTR (T1,CI.TYP)] ;GET PORT TYPE FIELD
	CAIE	T1,.CIKNI	;KLNI?
	CAIN	T1,.CIKLP	;KLIPA?
	JRST	CPOPJ1##	;YES
;*** ADD CODE TO FIGURE OUT PORT TYPE
	POPJ	P,		;RETURN

	$HIGH
> ;END IFN M.KL10&<M.SCA!M.ENET>
SUBTTL	IPA20 CHANNEL I/O -- RDIPA - READ CRAM


;READ THE CONTENTS OF A CRAM LOCATION
;CALL:	MOVE	W,  KDB ADDRESS		;IF NORMAL TIMESHARING
;	MOVE	T1, CRAM ADDRESS
;	PUSHJ	P,RDIPA
;	  <NON-SKIP>			;CHANNEL IS RUNNING
;	<SKIP>				;T2 & T3 HAS THE CRAM CONTENTS
;
;ALL ACS ARE PRESERVED

IFN M.KL10&<M.SCA!M.ENET>,<
	$XSENT	(RDIPA::)
	PUSHJ	P,AUTOWN##	;DO WE OWN THE DATA BASE INTERLOCK?
	  JRST	RDIPA1		;NO--DO NORMAL STUFF
	PUSHJ	P,SAVW##	;SAVE W
	XMOVEI	W,.CPCNI##-KDBCNI ;FAKE KDB I/O INSTRUCTIONS

RDIPA1:	PUSH	P,T1		;SAVE CRAM ADDRESS
	XCT	KDBCNI(W)	;CONI DEV,T1
	TRNN	T1,CO.MRN	;CHANNEL RUNNING?
	JRST	RDIPA2		;NO--ALL IS WELL
	JRST	TPOPJ##		;RETURN

RDIPA2:	SETZB	T1,T2		;MAKE SURE CO.LAR IS CLEAR
	XCT	KDBCNO(W)	;CONO DEV,(T1)
	MOVE	T1,(P)		;GET CRAM ADDRESS BACK
	DPB	T1,[POINTR (T2,DO.RAR)] ;PUT ADDRESS INTO CORRECT FIELD
	TLO	T2,(.DOLRA!DO.LHW) ;SET UP TO READ LEFT HALF CRAM MICRO-WORD
	PUSH	P,T2		;SAVE ARGUMENT
	XCT	KDBDTO(W)	;SELECT LH CRAM ADDRESS
	XCT	KDBDTI(W)	;READ LEFT HALF CRAM MICRO-WORD
	AND	T2,[DT.CRM]	;KEEP ONLY LH CRAM DATA WORD
	EXCH	T2,(P)		;SAVE LH CRAM MICRO-WORD & RETRIEVE ARGUMENT
	TLZ	T2,(DO.LHW)	;SET UP TO READ RIGHT HALF CRAM MICRO-WORD
	XCT	KDBDTO(W)	;SELECT RH CRAM ADDRESS
	XCT	KDBDTI(W)	;READ RIGHT HALF CRAM MICRO-WORD
	AND	T2,[DT.CRM]	;KEEP ONLY RH CRAM DATA WORD
	MOVE	T3,T2		;COPY RH CRAM MICRO-WORD
	POP	P,T2		;RETRIEVE LH CRAM MICRO-WORD
	POP	P,T1		;RESTORE CRAM ADDRESS
	PJRST	CPOPJ1##	;AND RETURN

	$HIGH
> ;END IFN M.KL10&<M.SCA!M.ENET>
SUBTTL	IPA20 CHANNEL I/O -- WTIPA - WRITE CRAM


;WRITE THE CONTENTS OF A CRAM LOCATION
;CALL:	MOVE	W,  KDB ADDRESS		;IF NORMAL TIMESHARING
;	MOVE	T1, CRAM ADDRESS
;	MOVE	T2, LEFT HALF CRAM MICRO-WORD
;	MOVE	T3, RIGHT HALF CRAM MICRO-WORD
;	PUSHJ	P,RDIPA
;	  <NON-SKIP>			;CHANNEL IS RUNNING
;	<SKIP>				;CRAM WORD WRITTEN
;
;ALL ACS ARE PRESERVED

IFN M.KL10&<M.SCA!M.ENET>,<
	$XSENT	(WTIPA::)
	PUSHJ	P,AUTOWN##	;DO WE OWN THE DATA BASE INTERLOCK?
	  JRST	WTIPA1		;NO--DO NORMAL STUFF
	PUSHJ	P,SAVW##	;SAVE W
	XMOVEI	W,.CPCNI##-KDBCNI ;FAKE KDB I/O INSTRUCTIONS

WTIPA1:	PUSH	P,T1		;SAVE CRAM ADDRESS
	XCT	KDBCNI(W)	;CONI DEV,T1
	TRNN	T1,CO.MRN	;CHANNEL RUNNING?
	JRST	WTIPA2		;NO--ALL IS WELL
	JRST	TPOPJ##		;RETURN

WTIPA2:	PUSH	P,T2		;SAVE LH CRAM MICRO-WORD
	PUSH	P,T3		;SAVE RH CRAM MICRO-WORD
	SETZB	T1,T2		;MAKE SURE CO.LAR IS CLEAR
	XCT	KDBCNO(W)	;CONO DEV,(T1)
	MOVE	T1,-2(P)	;GET CRAM ADDRESS BACK
	DPB	T1,[POINTR (T2,DO.RAR)] ;PUT ADDRESS INTO CORRECT FIELD
	TLO	T2,(.DOLRA!DO.LHW) ;SET UP TO WRITE LEFT HALF CRAM MICRO-WORD
	PUSH	P,T2		;SAVE ARGUMENT
	XCT	KDBDTO(W)	;SELECT LH CRAM ADDRESS
	MOVE	T2,-2(P)	;GET LH CRAM MICRO-WORD
	AND	T2,[DT.CRM]	;KEEP ONLY RH CRAM DATA WORD
	XCT	KDBDTO(W)	;WRITE IT
	POP	P,T2		;GET ARGUMENT BACK
	TLZ	T2,(DO.LHW)	;SET UP TO WRITE RIGHT HALF CRAM MICRO-WORD
	XCT	KDBDTO(W)	;SELECT RH CRAM ADDRESS
	MOVE	T2,(P)		;GET RH CRAM MICRO-WORD
	AND	T2,[DT.CRM]	;KEEP ONLY RH CRAM DATA WORD
	XCT	KDBDTO(W)	;WRITE IT
	POP	P,T3		;RESTORE RH CRAM MICRO-WORD
	POP	P,T2		;RESTORE LH CRAM MICRO-WORD
	POP	P,T1		;RESTORE CRAM ADDRESS
	JRST	CPOPJ1##	;AND RETURN

	$HIGH
> ;END IFN M.KL10&<M.SCA!M.ENET>
	SUBTTL	DX20 ADAPTER I/O -- DOCUMENTATION

;TECHNICAL INFORMATION AND TECHNIQUES FOR PROGRAMMING THE VARIOUS DEVICES
;MAY BE FOUND IN THE FOLLOWING DOCUMENTS:
;
;  DX10 DATA CHANNEL MAINTENANCE MANUAL ADDENDUM, CHAPTERS 4-6,
;	DOCUMENT NUMBER EK-DX10-AD-001, JUN 77
;
;  DX20 PROGRAMMED DEVICE ADAPTER TECHNICAL MANUAL,
;	DOCUMENT NUMBER EK-0DX20-TM-001, FEB 78
;
;  DX20-V100 FUNCTIONAL SPECIFICATION MICROCODE,
;	DOCUMENT NUMBER 105-220-001-00,  MAR 78
;
;  DX20-V100 MAGNETIC TAPE SUBSYSTEM MICRO-CODE,
;	DOCUMENT NUMBER MAINDEC-10-DXMCA-A-D, SEP 77
;
;  RH20 MASSBUS CONTROLLER UNIT DESCRIPTION,
;	DOCUMENT NUMBER EK-RH20-UD-001, AUG 76
	SUBTTL	DX20 ADAPTER I/O -- REGISTER DEFINITIONS

IFN M.KL10&<M.RNX!M.DX20>,<

.DXMTR==03B5			;MAINTENANCE REGISTER
	MR.SCY==1B31		;MICROPROCESSOR SINGLE CYCLE
	MR.STR==1B33		;MICROPROCESSOR START
	MR.RES==1B34		;MICROPROCESSOR RESET

.DXDTR==06B5			;DRIVE TYPE REGISTER

.DXMIR==30B5			;MICROCONTROLLER INSTRUCTION REGISTER

.DXPCR==31B5			;MICROPROCESSOR PC REGISTER
	PC.IRE==1B20		;INSTRUCTION REGISTER ENABLE
	PC.MSE==1B21		;MICROSTORE ENABLE
	PC.PCE==1B22		;PC ENABLE
	PC.PCI==1B23		;PC AUTO INCREMENT
	PC.MPC==7777B35		;MICROPROCESSOR PC

.DXIBR==36B5			;DIAGNOSTIC REGISTER 7
	DX.IBR==377		;CONTENTS OF THE BR REGISTER

.DXIPE==37B5			;DIAGNOSTIC REGISTER 7
	DX.IPE==1B22		;INSTRUCTION REGISTER PARITY ERROR

.CRM10==10			;LOCATION IN THE CRAM CONTAINING A CODE
				;  CHECKED BY THE DRIVERS TO SEE IF THE
				;  MICROCODE IS VALID

.DXSAD==1			;FULL START ADDRESS FOR ALL VERSIONS
				;  OF THE DX20 MICROCODE
>; END IFN M.KL10&<M.RNX!M.DX20>
	SUBTTL	DX20 ADAPTER I/O -- DXLOAD - LOAD DX20 MICROCODE

IFN M.KL10&<M.RNX!M.DX20>,<

;ROUTINE TO CLEAR, LOAD, AND VERIFY, AND START THE MICROCODE FOR A DX20.
;CALL:
;	T1/ADDRESS OF MICROCODE LOADER BLOCK
;	PUSHJ	P,DXLOAD
;RETURN CPOPJ IF UNSUCCESSFUL
;	CPOPJ1 WITH MICROCODE LOADED BUT NOT STARTED

DXLOAD::PUSHJ	P,SAVE4##	;SAVE SOME ACS
	PUSHJ	P,SAVU##	;SAVE U
	MOVE	U,T1		;COPY MICROCODE LOADER BLOCK ADDRESS
	PUSHJ	P,BTUCOD##	;FIND ADDRESS
	  JRST	DXLOA1		;NOT AVAILABLE
	PUSHJ	P,MPRES		;RESET THE MICROPROCESSOR
	PUSHJ	P,DXCLR		;CLEAR THE CRAM AND WORKING MEMORY
	PUSHJ	P,LOAD		;LOAD THE MICROCODE
	  JRST	DXLOA1		;FAILED
	PUSHJ	P,VERIFY	;VERIFY THE MICROCODE THAT WE JUST LOADED
	  JRST	DXLOA1		;FAILED
	PUSHJ	P,MPCHK		;DO A FINAL CHECK ON THE MICROSTORE
	  JRST	DXLOA1		;FAILED
	PUSHJ	P,RDCRM0	;READ THE VERSION NUMBER FROM CRAM LOC 0
	LDB	T1,[POINT 6,T2,25] ;GET MAJOR VERSION
	LSH	T1,30		;POSITION
	TRZ	T2,777600	;ISOLATE EDIT LEVEL
	IOR	T2,T1		;FORM STANDARD DEC-10 VERSION NUMBER
	PUSH	P,T2		;SAVE IT
	PUSHJ	P,DXSTRT	;START THE DX20
	POP	P,.ULVER(U)	;SET VERSION IN MICROCODE LOADER BLOCK
	MOVE	T1,U		;POINT TO THE MICROCODE LOADER BLOCK ADDRESS
	PUSHJ	P,BTURPT##	;REPORT A SUCESSFUL LOAD
	JRST	CPOPJ1##	;GIVE SKIP RETURN
DXLOA1:	MOVEI	T2,.CRM10	;WRITE A 0 INTO CRAM LOCATION 10
	MOVEI	T3,0		;  SO THAT ATTEMPTS TO START THIS DX20
	PUSHJ	P,WRCRAM	;  WILL FAIL
	MOVE	T1,U		;COPY MICROCODE LOADER BLOCK ADDRESS
	PJRST	BTURPT##	;REPORT LOAD ERROR AND RETURN


;It might occur to someone to call BTURPT before DXSTRT to save the
;PUSH and POP of the microcode version number.  It is done that way
;to waste enough KL CPU time to give the DX20 microprocessor enough
;time to get through its full initialization and get to the idle
;loop before a massbus init or a call to the reset routine stops
;it again.  If the DX20 doesn't finish its initialization, the
;restart of the microprocessor (at a different start address than
;that used by DXSTRT) will cause strange things to happen.
;ROUTINE TO LOAD OR VERIFY THE MICROCODE IN A DX20.
;CALL:
;	U/ADDRESS OF MICROCODE LOADER BLOCK
;	PUSHJ	P,LOAD/VERIFY
;RETURN CPOPJ IF ERROR
;	CPOPJ1 WITH FUNCTION PERFORMED SUCCESSFULLY

LOAD:	PUSH	P,[.DXPCR!PC.MSE!PC.PCE] ;DATAO BITS TO WRITE CRAM
	PUSH	P,[IFIW LDCRAM]	;ROUTINE TO LOAD CRAM
	PUSH	P,[IFIW LDWM]	;ROUTINE TO LOAD DRAM
	PUSH	P,[.UEDRL,,.UECRL] ;DRAM,,CRAM ERROR CODES
	JRST	FUNC		;ENTER COMMON CODE

VERIFY:	JRST	CPOPJ1##
	PUSH	P,[.DXPCR!PC.IRE!PC.PCE] ;DATAO BITS TO READ CRAM
	PUSH	P,[IFIW VFCRAM]	;ROUTINE TO VERIFY CRAM
	PUSH	P,[IFIW VFWM]	;ROUTINE TO VERIFY DRAM
	PUSH	P,[.UEDRV,,.UECRV] ;DRAM,,CRAM ERROR CODES

FUNC:	PUSH	P,[EXP 0]	;RESERVE SPACE FOR CRAM LOCATION 0
	MOVSI	P2,-3777	;AOBJN POINTER
	MOVSI	P3,(<POINT 18,,>!1B12) ;MAKE A TWO WORD BYTE POINTER
	MOVE	P4,.ULADR(U)	;GET UCODE ADDRESS
FUNC1:	ILDB	T1,P3		;GET A BYTE OF DATA
	HRRZ	T2,P2		;GET CRAM ADDRESS
	SKIPE	T3,.ULMAG(U)	;HAVE A MAGIC NUMBER TRANSLATION TABLE?
	PUSHJ	P,MAGIC		;YES--SEE IF A SUBSTITUTION IS NECESSARY
	IOR	T2,-4(P)	;INCLUDE DATAO BITS TO READ/WRITE CRAM
	PUSHJ	P,WTMBR##	;INITIALIZE ADDRESS OF CRAM LOCATIONS
	PUSHJ	P,@-3(P)	;DISPATCH TO CRAM FUNCTION ROUTINE
	  JRST	FUNC3		;ERROR
	AOBJN	P2,FUNC1	;LOOP
	PUSHJ	P,RDCRM0	;READ THE CONTENTS OF CRAM LOCATION 0
	HRRZM	T2,(P)		;SAVE ON STACK
	MOVSI	P2,-1777	;AOBJN POINTER
	MOVSI	P3,(<POINT 8,,>!1B12) ;MAKE A TWO WORD BYTE POINTER
	MOVE	P4,.ULADR(U)	;GET ADDRESS OF UCODE STORAGE
	ADDI	P4,2000		;OFFSET TO THE DRAM DATA
FUNC2:	HRRZ	T2,P2		;GET WORKING MEMORY ADDRESS
	PUSHJ	P,LDMAR		;SET MAR/MARX TO THAT VALUE
	ILDB	T1,P3		;GET A BYTE OF DATA
	ANDI	T1,377		;KEEP ONLY 8 BITS
	PUSHJ	P,@-2(P)	;DISPATCH TO WORKING MEMORY FUNCTION ROUTINE
	  JRST	FUNC4		;ERROR
	AOBJN	P2,FUNC2	;LOOP
	MOVEI	T2,0		;RESTORE THE VALUE THAT WAS IN CRAM LOCATION
	POP	P,T3		;GET PREVIOUS CONTENTS OF CRAM LOCATION 0
	PUSHJ	P,WRCRAM	;  LOADING WORKING MEMORY
	ADJSP	P,-4		;PHASE STACK
	JRST	CPOPJ1##	;RETURN
FUNC3:	SKIPA	T1,-1(P)	;CRAM LOAD/VERIFY ERROR
FUNC4:	HLRZ	T1,-1(P)	;DRAM LOAD/VERIFY ERROR
	DPB	T1,ULBEBP##	;STORE
	ADJSP	P,-5		;PHASE STACK
	POPJ	P,		;RETURN
;ROUTINE TO CLEAR THE CRAM AND WORKING MEMORY OF A DX20.
;CALL:
;	U/ADDRESS OF MICROCODE LOADER BLOCK
;	PUSHJ	P,DXCLR
;RETURN CPOPJ ALWAYS

DXCLR:	POPJ	P,
	PUSH	P,F		;SAVE F
	MOVSI	F,-4000		;4000 LOCATIONS TO CLEAR IN THE CRAM
DXCLR1:	HRRZ	T2,F		;GET THE ADDRESS TO WRITE
	MOVEI	T3,0		;PUT A ZERO IN IT
	PUSHJ	P,WRCRAM	;WRITE THE CRAM LOCATION
	AOBJN	F,DXCLR1	;WRITE THEM ALL

	MOVEI	T2,0		;SET THE MAR/MAR EXTENSION
	PUSHJ	P,LDMAR		;  TO 0
	MOVEI	F,2000		;2000 LOCATIONS IN THE WORKING MEMORY
DXCLR2:	MOVEI	T2,11400	;LDMEM 0,I MICROINSTRUCTION
	PUSHJ	P,DXXCT		;CLEAR NEXT LOCATION IN WORKING MEMORY
	SOJG	F,DXCLR2	;DO THEM ALL
	JRST	FPOPJ##		;RESTORE F AND RETURN


;ROUTINE TO START THE DX20 MICROPROCESSOR AT THE FULL START ENTRY
;POINT.
;CALL:
;	U/ADDRESS OF MICROCODE LOADER BLOCK
;	PUSHJ	P,DXSTRT
;RETURN CPOPJ ALWAYS

DXSTRT:	PUSHJ	P,MPRES		;MAKE SURE THE PROCESSOR IS RESET
	MOVE	T2,[.DXPCR!PC.IRE!PC.PCE!PC.PCI!INSVL.(.DXSAD,PC.MPC)]
	PUSHJ	P,WTMBR##	;SET THE PC TO THE FULL START ADDRESS
	MOVE	T2,[.DXMTR!MR.STR] ;MAINTENANCE REGISTER+START BIT
	PJRST	WTMBR##		;START THE MICROPROCESSOR AND RETURN
;ROUTINE TO READ THE CONTENTS OF CRAM LOCATION 0.
;CALL:
;	U/ADDRESS OF MICROCODE LOADER BLOCK
;	PUSHJ	P,RDCRM0
;RETURN CPOPJ ALWAYS WITH:
;	T2/CONTENTS OF CRAM LOCATION 0

RDCRM0:	MOVE	T2,[.DXPCR!PC.IRE!PC.PCE!INSVL.(0,PC.MPC)] ;SET TO READ
	PUSHJ	P,WTMBR##	;  CRAM LOCATION 0
	MOVSI	T2,(.DXMIR)	;READING THIS REGISTER RETURNS THE VALUE
	PJRST	RDMBR##		;  THAT IS ADDRESSED BY THE PC REGISTER


;ROUTINE TO WRITE A WORD INTO A DX20 CRAM LOCATION.
;CALL:
;	T2/ADDRESS OF LOCATION TO WRITE
;	T3/DATA TO BE WRITTEN
;	U/ADDRESS OF MICROCODE LOADER BLOCK
;	PUSHJ	P,WRCRAM
;RETURN CPOPJ ALWAYS

WRCRAM:	PUSH	P,T3		;SAVE THE DATA TO BE WRITTEN
	TDO	T2,[.DXPCR!PC.MSE!PC.PCE] ;PC REGISTER+BITS TO ENABLE
	PUSHJ	P,WTMBR##	;  MICROSTORE AND PC WRITES
	POP	P,T2		;RESTORE THE DATA TO BE WRITTEN
	HRLI	T2,(.DXMIR)	;WRITES INTO THE IR GO INTO THE CRAM LOCATION
	PJRST	WTMBR##		;  ADDRESSED BY THE PC REGISTER


;ROUTINE TO LOAD THE DX20 MEMORY ADDRESS AND ADDRESS EXTENSION REGISTERS
;(MAR AND MARX) WITH A VALUE.
;CALL:
;	T2/ADDRESS TO LOAD
;	U/ADDRESS OF MICROCODE LOADER BLOCK
;	PUSHJ	P,LDMAR
;RETURN CPOPJ ALWAYS

LDMAR:	PUSH	P,T2		;SAVE THE ADDRESS TO LOAD
	ANDI	T2,377		;KEEP LOW 8 BITS
	TRO	T2,1000		;ADD A LDMAR MICROINSTRUCTION
	PUSHJ	P,DXXCT		;EXECUTE IT
	POP	P,T2		;RESTORE THE ADDRESS TO LOAD
	LSH	T2,-^D8		;GET 2 HIGH ORDER BITS
	TRO	T2,400		;ADD A LDMARX MICROINSTRUCTION
	PJRST	DXXCT		;EXECUTE THAT AND RETURN
;ROUTINE TO CAUSE THE DX20 TO EXECUTE AN INSTRUCTION.
;CALL:
;	T2/MICROINSTRUCTION TO EXECUTE
;	U/ADDRESS OF MICROCODE LOADER BLOCK
;	PUSHJ	P,DXXCT
;RETURN CPOPJ ALWAYS

DXXCT:	PUSH	P,T2		;SAVE THE INSTRUCTION TO EXECUTE
	MOVE	T2,[.DXMTR!MR.SCY] ;GET MAINTENANCE REGISTER AND SINGLE CYLCLE
	PUSHJ	P,WTMBR##	;FORCE THE DX20 INTO SINGLE CYCLE MODE
	MOVEI	T2,0		;STORE THE INSTRUCTIN TO EXECTUTE IN CRAM LOC 0
	POP	P,T3		;RESTORE THE INSTRUCTION TO EXECUTE
	PUSHJ	P,WRCRAM	;WRITE IT INTO THE CRAM
	MOVE	T2,[.DXPCR!PC.IRE!PC.PCI] ;PC REG+IR ENABLE+PC AUTO INCR
	PUSHJ	P,WTMBR##	;SETUP TO EXECUTE THE INSTRUCTION
	MOVE	T2,[.DXMTR!MR.SCY!MR.STR] ;MAINT REG+SINGLE CYCLE+START
	PUSHJ	P,WTMBR##	;EXECUTE THE INSTRUCTION
	MOVSI	T2,(.DXMTR)	;CLEAR SINGLE CYCLE AND LEAVE START OFF
	PJRST	WTMBR##		;CLEAR START AND RETURN
;ROUTINE TO LOAD DATA INTO A CRAM LOCATION.
;CALL:
;	T1/16 BITS OF DATA TO WRITE
;	U/ADDRESS OF MICROCODE LOADER BLOCK
;	PUSHJ	P,LDCRAM
;RETURN CPOPJ1 ALWAYS

LDCRAM:	HRRZ	T2,T1		;MOVE DATA TO THE RIGHT AC
	HRLI	T2,(.DXMIR)	;ADD THE REGISTER THAT WE WANT
	PUSHJ	P,WTMBR##	;DO THE DATAO THAT CAUSES THE WRITE
	JRST	CPOPJ1##	;GIVE SKIP RETURN


;ROUTINE TO LOAD DATA INTO A WORKING MEMORY LOCATION.
;CALL:
;	T1/8 BITS OF DATA TO WRITE
;	U/ADDRESS OF MICROCODE LOADER BLOCK
;	PUSHJ	P,LDWM
;RETURN CPOPJ1 ALWAYS

LDWM:	HRRZ	T2,T1		;GET DATA INTO THE WRITE AC
	TRO	T2,11400	;ADD A LDMEM N,I MICROINSTRUCTION
	PUSHJ	P,DXXCT		;EXECUTE THE INSTRUCTION
	JRST	CPOPJ1##	;GIVE SKIP RETURN
;ROUTINE TO VERIFY THE DATA IN A CRAM LOCATION.
;CALL:
;	T1/16 BITS OF CRAM DATA
;	U/ADDRESS OF MICROCODE LOADER BLOCK
;	PUSHJ	P,VFCRAM
;RETURN CPOPJ IF NO MATCH
;	CPOPJ1 IF MATCH

VFCRAM:	MOVSI	T2,(.DXMIR)	;READ THIS REGISTER TO GET THE DATA
	PUSHJ	P,RDMBR##	;READ THE DATA
	CAIN	T2,(T1)		;MATCH WITH WHAT IT SHOULD BE?
	AOS	(P)		;YES--SKIP
	POPJ	P,		;RETURN


;ROUTINE TO VERIFY THE DATA IN A WORKING MEMORY LOCATION
;CALL:
;	T1/8 BITS OF DATA
;	U/ADDRESS OF MICROCODE LOADER BLOCK
;	PUSHJ	P,VFWM
;RETURN CPOPJ IF NO MATCH
;	CPOPJ1 IF MATCH

VFWM:	MOVEI	T2,043411	;GET A MOVMEM BR,I MICROINSTRUCTION
	PUSHJ	P,DXXCT		;EXECUTE IT
	MOVSI	T2,(.DXIBR)	;REGISTER TO READ THE BR
	PUSHJ	P,RDMBR##	;READ THE REGISTER
	ANDI	T2,DX.IBR	;KEEP ONLY THE BR OUTPUT
	CAIE	T2,(T1)		;MATCH?
	POPJ	P,		;NO
	JRST	CPOPJ1##	;YES, GIVE SKIP RETURN


;ROUTINE TO SUBSTITUTE A MAGIC NUMBER
;CALL:
;	T2/LOAD ADDRESS
;	T3/MAGIC TRANSLATION TABLE
;	PUSHJ	P,MAGIC
;RETURN	CPOPJ ALWAYS WITH T1 CONTAINING POSSIBLY UPDATED DATA

MAGIC:	MOVE	T4,(T3)		;GET A WORD
	AOJE	T4,CPOPJ##	;RETURN IF END OF TABLE
	HRRZ	T4,(T3)		;GET AN ADDRESS
	CAIE	T4,(T2)		;MATCH?
	AOJA	T3,MAGIC	;LOOP
	HLRZ	T1,(T3)		;GET ASSOCIATED MAGIC VALUE
	POPJ	P,		;AND RETURN
;ROUTINE TO RESET THE DX20 MICROPROCESSOR
;CALL:
;	U/ MICROCODE LOADER BLOCK ADDRESS
;	PUSHJ	P,MPRES
;RETURN CPOPJ ALWAYS

MPRES:	MOVE	T2,[.DXMTR!MR.RES] ;SET RESET BIT IN MAINT REG
	PJRST	WTMBR##		;RESET THE DX20


;ROUTINE TO CHECK THE STATUS OF THE MICROPROCESSOR
;CALL:
;	U/ADDRESS OF MICROCODE LOADER BLOCK
;RETURNS CPOPJ IF CONSISTANCY CHECKS FAIL OR CPOPJ1 IF OK

MPCHK:	MOVE	T2,[.DXPCR!PC.IRE!PC.PCE!PC.PCI!7] ;REGISTER TO WRITE+
				;  IR ENABLE+PC ENABLE+PC AUTO INCR+PC TO READ
	PUSHJ	P,WTMBR##	;WRITE THE REGISTER
	MOVSI	T2,(.DXMIR)	;POINT AT DIAGNOSTIC REGISTER 0
	PUSHJ	P,RDMBR##	;READ THE CONTENTS
	PUSH	P,T2		;SAVE FOR COMPARE
	MOVSI	T2,(.DXDTR)	;POINT AT DRIVE TYPE REGISTER
	PUSHJ	P,RDMBR##	;READ THAT
	POP	P,T3		;RESTORE CRAM LOCATION 7
	CAME	T2,T3		;HAVE TO BE THE SAME
	POPJ	P,		;ERROR IF NOT
	MOVSI	T2,(.DXIPE)	;POINT AT DIAGNOSTIC REGISTER 7
	PUSHJ	P,RDMBR##	;READ IT
	TRNN	T2,DX.IPE	;IR PARITY ERROR ON LAST READ?
	AOS	(P)		;NO, GIVE SKIP RETURN
	POPJ	P,		;   AND RETURN
>; END IFN M.KL10&<M.RNX!M.DX20>
	$LIT

COMEND:	END
