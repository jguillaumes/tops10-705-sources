TITLE COMMON - MONITOR COMMON DATA AREA AND CONFIGURATION DEFINITION -V2420
SUBTTL PART 6 COMMON.MAC - T. HASTINGS/PH/TWE/DAL/EVS/JBS/EGF	7-NOV-90

	SEARCH	F,S,DEVPRM
IFN FTNET,<SEARCH NETPRM>

	$RELOC
	$ABS

;COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION
; 1973,1974,1975,1976,1977,1978,1979,1980,1982,1984,1986,1988,1990.
;ALL RIGHTS RESERVED.
;
;
;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
;ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH LICENSE AND WITH THE
;INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER
;COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
;OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF THE  SOFTWARE  IS  HEREBY
;TRANSFERRED.
;
;THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT  NOTICE
;AND  SHOULD  NOT  BE  CONSTRUED  AS A COMMITMENT BY DIGITAL EQUIPMENT
;CORPORATION.
;
;DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY  OF  ITS
;SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.


XP VCOMMN,2420		;PUT VERSION NUMBER IN GLOB AND LOADER STORAGE MAP
	SUBTTL	SET PSECT ORIGINS

;MONITOR PSECT ORIGINS MAY BE CHANGED BY EDITTING THE FOLLOWING DEFINITIONS.
;THE DEFINITIONS OF THE ORIGINS MAY APPEAR IN THE HARDWARE CONFIGURATION FILE
;SYSCNF.MAC TO OVER-RIDE THE DEFAULT ORIGINS DEFINED BELOW.

IFN FTXMON,<
ND	CSBORG,330000		;ORIGIN OF COMMON SUBROUTINES
>; END IFN FTXMON
IFN M.KL10,<
ND	MONORG,340000		;ORIGIN OF HIGH SEGMENT ON KL
>; END IFN M.KL10
IFN M.KS10,<
ND	MONORG,340000		;ORIGIN OF HIGH SEGMENT ON KS
>; END IFN M.KS10
IFE FTXMON,<
XP	CSBORG,MONORG		;JUST FOR THOSE WHO CARE
>; END IFE FTXMON
IFN FTXMON,<
ND	XHIORG,<MS.HGH+630000>	;ORIGIN OF EXTENDED HIGH SEGMENT
>; END IFN FTXMON


;NOW SET THE PSECT ORIGINS BEFORE ANY CODE IS GENERATED.

				;*** .HIGH. MUST BE FIRST DUE TO A LINK BUG ***
	.PSECT	.HIGH.,MONORG	;HIGH SEGMENT
	.ENDPS
IFN FTXMON,<
	.PSECT	.CSUB.,CSBORG	;COMMON SUBROUTINES
	.ENDPS
>; END IFN FTXMON
	.PSECT	.INIT.,FYSORG	;INITIALIZATION CODE OVERLAYS FUNNY SPACE
	.ENDPS
	.PSECT	.TWIC.,.UPMAP	;USER MODE DISK ONCE-ONLY
	.ENDPS
IFN FTXMON,<			;IF EXTENDED MONITOR
	.PSECT	.XHGH.,XHIORG	;EXTENDED HIGH SEGMENT
	.ENDPS
	.PSECT	.SYMS.,MS.HGH	;EXTENDED SYMBOL TABLE
	.ENDPS
>; END IFN FTXMON


;TELL LINK WHERE TO PUT SYMBOL TABLE.  FOR SINGLE SECTION MONITOR SYMBOLS
;GO IN PSECT .LOW., FOR MULTI SECTION MONITOR SYMBOLS GO IN EXTENDED HIGH
;SEGMENT (AT BEGINNING OF THAT SECTION).

IFE FTXMON,<
	.TEXT	"/SYMSEG:PSECT:.LOW."
>; END IFE FTXMON
IFN FTXMON,<
	.TEXT	"/SYMSEG:PSECT:.SYMS."
>; END IFN FTXMON

;*** CODE TO SET PSECT LIMITS IS AT THE END OF COMMON.MAC ***
SUBTTL	HISTORICAL NOTES

REPEAT 0, <
;THE COMMON SUBPROGRAM CONSISTS OF 6 FILES ASSEMBLED TOGETHER AS ONE SUBPROGRAM
	1. F.MAC -- FEATURE TESTS (OUTPUT OF MONGEN).
	2. S.MAC -- THE USUAL SYSTEM SYMBOL DEFINITIONS ASSEMBLED WITH
		    EVERY MONITOR SUBPROGRAM
	3. SYSCNF.MAC -- SYSTEM CONFIGURATION
	4. COMMON.MAC - THE REST OF THIS PROGRAM WHICH IS THE SAME SOURCE FOR
	ALL	CONFIGURATIONS.  HOWEVER, THE ASSEMBLIES ARE CONDITIONED BY
	SYMBOLS	AND MACROS DEFINED IN 2.

	THE	FOLLOWING SYMBOLS AND TABLES ARE GENERATED BELOW:

	A. MONITOR STARTUP LOCATIONS (400-407), HENCE LOAD THIS FIRST.
	B. JOB TABLES - LENGTH DEPENDENT ON MAXIMUM NUMBER OF JOBS ALLOWED
	C. ALL VARIABLE STORAGE NOT ASSOCIATED WITH A PARTICULAR DEVICE
	D. COMMON SUBROUTETURNS
	E. COMMON BYTE POINTERS
	F. TABLE OF SERVICE ROUTINE INTERRUPT LOCS TO BE LINKED BY ONCE ONLY CODE
	G. TABLE OF DEVICE DATA BLOCK ADDRESSES AND NUMBER TO BE USED BY ONCE TO
		LINK THEM TOGETHER AND GENERATE MULTIPLE COPIES.
	H. ASSIGNMENT OF PI CHANNELS
	I. PI CHANNEL SAVE AND RESTORE ROUTINES
	J. UUO TRAP LOCATIONS 40/41, 60/61
	K. APR INTERRUPT LOCATIONS CPU0,1, KA10/KI10
	L. SYSTEM CRASH STOP CONI'S.
	NOTE:  SEE COMDEV FOR DEVICE DEPENDENT CODE, DATA, AND SYMBOLS


LEVEL D DISK SERVICE PARAMETERS:

	ALL	SYMBOLS ANAS ONATIONS ARE IN A SEPARATE FILE CALLED
	COMMOD.MAC WHICH IS ALSO ASSEMBLED WITH S AND CONFIG (BUT NOT WITH FEATURS FILES).
	THE	SEPARATE FILE IS FOR TWO REASONS:	1.  ANTICIPATING MULTIPROCESSING SYSTEMS WHICH SHARE DISKS AND 1 16K MEMORY
	(THE DATA MUST BE IN THE COMMON MEMORY)
	2.  ELIMINATE THE NEED TO ASSEMBLE COMMOD IF NOT A DISK SYSTEM
	(COMMOD.MAC TAKES LOTS OF CORE FOR ITS COMPLICATED MACROS)

>
IFE FTNET,<IFN M.NET,<PRINTX ?ASSEMBLE SOURCES WITH FTNET=-1
			M.NET==0>>

;Verify that the correct version of MONGEN was used in making the SYSCNF
;files.
;
;Every time that MONGEN is edited, the following check "M.GEN-nnn" should
;also be updated to reflect the new MONGEN edit level (symbol 'EDITNO' in
;MONGEN.MAC).

IFN	M.GEN-331,<
	PRINTX	? Wrong version of MONGEN was used in SYS dialog
	PASS2
	END
>
IFN FTEMRT,<IFE M.KL10,<PRINTX ? CPU MUST BE A KL10 TO SELECT EBOX/MBOX RUNTIME>>
IFN FTCIDSK!FTCITAP,<IFE FTSCA,<PRINTX ?ASSEMBLE SOURCES WITH FTSCA=-1
				XP FTCIDSK,0	;FORCE MULTIPLY DEFINED GLOBALS
				XP FTCITAP,0>>
IFN M.ENET,<IFE FTENET,<PRINTX ?ASSEMBLE SOURCES WITH FTENET=-1
			XP M.ENET,0>>
IFE M.NET,<EQUATE (GLOBAL,0,<M.ENET,M.LAT,M.DECN,M.ANF,M.RTTY>)>
IFE M.ANF,<EQUATE (GLOBAL,0,<M.RMCR,M.RVTM>)>
SUBTTL CONVERT MONGEN SYMBOLS

;THIS SECTION CONVERTS NEW MONGEN SYMBOLS TO OLD MONGEN SYMBOLS
;SO THAT THE REST OF COMMON AND MONITOR CAN STILL USE THE OLD
;SYMBOLS.  THIS WAS DONE RATHER THAN CONVERTING ALL OF THE
;MONITOR TO NEW SYMBOLS FOR TWO REASONS:
; 1.  IT IS EASIER AND FASTER AND LESS LIKELY TO INTRODUCE BUGS, AND
; 2.  IT ALLOWS CUSTOMERS TO USE OLD MONGEN WITH A MINIMUM
;OF TROUBLE: ONLY A FEW EXTRA SYMBOLS MUST BE DEFINED.
;THE MONITOR WILL PROBABLY BE CONVERTED TO THE NEW MONGEN SYMBOLS
;AFTER THE 5.04 RELEASE.  THE ORDER HERE PARALLELS THE OLD
;MONGEN ORDER.

XP JOBN,M.JOB+1

IFG	JOBN-^D512,<XP JOBN,^D512
		PRINTX %NUMBER OF JOBS REDUCED TO MAX=511>
XP PDP10N,1
XP SEGN,MD.SEG

XP VBCN,M.VBXC
XP XTCN,M.XTC

IFE	M.XTC,<
XP M.XTL,0
XP XTTDSP,CPOPJ
XP XTKLDB,CPOPJ
XP XTUUO,CPOPJ
XP XTCTTY,CPOPJ2
XP XTCIOS,CPOPJ
XP XTCSEC,CPOPJ
XP XTCLNK,CPOPJ
>

IFE M.DAS78,<			;IF NO DAS78 SUPPORT
	CALL78==:CPOPJ		;CAL78. UUO IS A NOOP
	D78SEC==:CPOPJ		;NO ONCE-A-SECOND CODE
	D78MIN==:CPOPJ		;NO ONCE-A-MINUTE CODE
	CWHD78==:CWHNCN##	;NOT CONNECTED IF NO DRIVER
> ;END IFE M.DAS78
IFN M.DAS78,<			;IF DAS78 SUPPORT
	M.D78L==:M0D78L		;HACK FOR D78INT
> ;END IFN M.DAS78


XP DISN,M.DIS
XP PENN,M.DIS
XP T340N,M.340
XP TVP10N,M.VP10
XP T30N,0		;NO TYPE 30
;DEFINE ALL DL10 SYMBOLS

	DLX.CK(1)		;MACRO DEFINED IN S.MAC
	INTERN	DL10XI		;FOR UUOCON

IFN M.KL10!DLX.78,<
IFE M.KL10,<
	PRINTX	?DEFINING A DAS78 REQUIRES FTKL10 TO BE ON
PDP11N==PDP11N-DLX.78
DLX.78=0			;ACTUAL NUMBER
> ;END IFE M.KL10
> ;END IFN M.KL10!DLX.78

IFN DLX.76,<EXTERN D76INT>
IFE PDP11N,<
	XP	D76MIN,CPOPJ
	XP	D76SIL,CPOPJ
>
IFE PDP11N!M.KL10!M.DN60!M.KDUP!M.DMRN,<
	XP	CALL11,CPOPJ
	XP	DLXSEC,CPOPJ
	XP	DLXWIN,0
> ; END IFE PDP11N!M.DN60!M.KDUP!M.DMRN
IFE DL10XI,<
	XP	DLXBAT,0
 IFN PDP11N,<
	XP	DLXDWN,0	;;IF NO PDP-11S ON DL10'S
>>; END OF IFE DL10XI AND IFN PDP11N
DEFINE TDMAC(X),<
	XP	DT'X'N,M.DT'X
M.DTXN==M.DTXN+M.DT'X
>
ZZ=="A"
M.DTXN==0
REPEAT	M.TD10,<
	TDMAC(\"ZZ)
ZZ==ZZ+1
>
IFN FTKS10,<
    DEFINE RX2MAC(X),<
	XP	RX'X'N,M.RX'X
    M.RXXN==M.RXXN+M.RX'X
    >
    ZZ=="A"
    M.RXXN==0
    REPEAT M.RX20,<
	RX2MAC(\"ZZ)
    ZZ==ZZ+1
    >
>;End FTKS10
ND M.TTDN,0
XP TTD28N,M.XTL
IFN M.KS10,<
XP	KLILIN,M.TLTL+M.RTTY	;LINE NO. FOR KS10 KLINIK
>

	DEFINE	OPRL(LINE),<
IFIDN <LINE> <CTY>,<SIXBIT /CTY/>
IFDIF <LINE> <CTY>,<
	SIXBIT	/TTY'LINE/
	IFG LINE-M.TLTL,<PRINTX %OPR LINE NOT DEFINED TO BE A LOCAL TTY>
>;END IFDIF <LINE><CTY>
>
SUBTTL DEFAULT SYMBOLS
;THE FOLLOWING STANDARD SYMBOLS CAN BE SUPERSEDED BY A CUSTOMER HAVING
; PREVIOUSLY DEFINED THEM ON THE HDWGEN.MAC FILE USING THE MONGEN PROGRAM....
;**********************************************************************
;ADD NEW SYMBOLS AT END SO EASY TO UPDATE MONGEN APPENDIX	      *
;SYMBOLS SHOULD APPEAR HERE IN COMMON (AND NOT IN COMDEV, OR COMMOD)  *
; UNLESS THEY REFER TO NON-DISK DEVICES OR DISKS RESPECTIVELY.        *
; IF A SYMBOL IS IN COMDEV OR COMMOD, IT SHOULD NOT APPEAR HERE.      *
;**********************************************************************
ND	XPANDN,0		;FORCE NO EXPANSION OF MACROS
				; UNLESS XPANDN IS DEFINED NON-ZERO WITH MONGEN

ND	M.C0SN,0		;SERIAL NUMBER OF ARITHMETIC PROCESSOR

				;STANDARD MAG TAPE DENSITY IN BITS PER INCH
ND	STDENS,5		;STANDARD = 6250 BPI
				;1=200, 2=556, 3=800, 4=1600, 5=6250

				;NUMBER OF TIMES TO TRY ON DECTAPE ERRORS
ND	DTTRY,4			;STANDARD == 4 TRIES

				;NUMBER OF NANO-SECONDS PER MEMORY CYCLE
ND	NSPMEM,^D1000		;STANDARD == 1000 NANO-SECONDS PER MEMORY CYCLE

ND	M.LPOK,1		;DEFAULT IS TO LOG POKE UUOS VIA DAEMON

ND	M.EDIT,0		;TTY EDITOR EXCLUSION
ND	TTXTRA,0		;NUMBER OF EXTRA TTY DDBS FOR SLAVE LINES
				; AND THE LIKE

ND	M.CRSH,<SIXBIT/CRSCPY/>	;NAME OF PROGRAM TO COPY CRASHES
	EXTERN	MONBTS

ND	M.MAIL,<SIXBIT/MS/>	;NAME OF MAIL PROGRAM

ND	M.DTCK,0		;OPR MUST VERIFY DATE/TIME IF NON-ZERO
;FREE CORE ALLOCATION REQUIREMENTS FOR SCA'S RANDOM SIZED POOL.

IFE M.SCA,<			;IF NO SCA SUPPORT
XP SCASIZ,0			;NO SCA FREE POOL
>; END IFE M.SCA
IFN M.SCA,<			;IF SCA SUPPORT
ND M.SCSZ,4000			;CAN BE REDEFINED AT MONGEN TIME
XP SCASIZ,<^D144*<<M.SCSZ+^D143>/^D144>>
>; END IFN M.SCA
;FREE CORE ALLOCATION REQUIREMENTS FOR DISK
; DEVICE DATA BLOCKS AND ACCESS TABLE ENTRIES.

XP CORSIZ,4			;NO. OF WORDS IN MONITOR FREE CORE BLOCKS

ND	LOGSIZ,^D41		;STANDARD == 20K (CURRENT SIZE OF LOGIN CUSP)
				;MINIMUM AMOUNT OF VIRTUAL CORE WHICH CAN REMAIN
				; AND STILL LET THE SYSTEM PERMIT LOG-INS.  MUST
				; BE AT LEAST AS BIG AS LOGIN CUSP IN K.
XP MAXLVL,5			;ABSOLUTE MAX LEVEL OF NESTED SFD'S

ND	INDPPN,0		;NON-ZERO IF CUSTOMER WANTS PROGRAMMER NOS
				; IN PROJECT X TO BE INDEPENDENT OF THOSE IN
				; PROJECT Y

IF1,<
IFNDEF SYSSEG,<XP SYSSEG,-1>	;MINUS ONE FOR FAST GETSEG FROM SYS
				; WITH SOMEWHAT DIFFERENT BEHAVIOR
				; WHEN SHR FILES ARE SUPERCEDED
IFDEF	SYSSEG,<IFN	<SYSSEG+1>,<XP SYSSEG,0>>
XP SYSSEG,SS.SYS&SYSSEG		;SYSSEG=:0 OR SS.SYS
>
ND	CTYDCR,0		;DELAY FOR CR ON LA36 CTY DURING ONCE
ND	CTYDLF,0		;DELAY FOR LF ON LA36 CTY DURING ONCE
ND	RLDTIM,^D112		;TIME TO AUTO-RELOAD
ND	M.STOF,0		;FREQUENCY TO CALL START TERMINAL OUTPUT
				; (SHOULD BE 2**N-1)
ND	M.RCMP,0		;DEFAULT TO PERMISSIVE ACCESS
				;SET TO 1 FOR MORE SECURE ACCESS
ND	M.NPPC,0		;DEFAULT TO PRIMARY PROTOCOL ON DTE'S
				;SET TO 1 TO DISABLE PRIMARY PROTOCOL
ND	M.NRQT,0		;NUMBER OF TICKS BETWEEN CALLS TO CALCULATE
				; WANT-TO-RUN TIME FOR ALL JOBS.  ZERO IMPLIES
				; NO (EXPENSIVE) CALCULATION.
ND	MINMAX,^D1024*^D12	;SMALLEST LEGAL CORMAX
;NOTE--IN ORDER TO RESERVE PI-CHANNELS FOR
;NON-STANDARD USAGE, FOR EACH CHANNEL (SAY N)
;DEFINE SYMBOL UNIQN==1 VIA MONGEN.  FOR
;EXAMPLE, TO RESERVE CHANNEL 4, DEFINE
;UNIQ4==1.

;MOST OF THE SLAVE PROCESSOR CHANNELS ARE BUSIED OUT TO PREVENT CORE
;FROM BEING WASTED FOR CHANNEL SAVE ROUTINES

IFNDEF CPTOS,<XP CPTOS,0>	;CPTOS EQUAL TO ZERO MAKES CPU0 TRAP TO 40-61, CPU1 TO 140-161
				;CPTOS NON-ZERO MAKES CPU0 TRAP TO 140-161, CPU1 TO 40-61

IFNDEF SFC0,<XP	SFC0,^D20>	;CPU0 SCHEDULER FAIRNESS COUNT.  PICK A JOB OUT OF
				;PQ2 INSTEAD OF PQ1 IF 'SFC0' PICKS IN A ROW HAVE COME FROM PQ1 AND NULL JOB DID NOT RUN.

IFNDEF SFC1,<XP	SFC1,^D20>	;CPU1 SCHEDULER FAIRNESS COUNT
				;PICK THIS MANY JOBS TO RUN ON CPU0.  WHICH
				; CAME FROM CPU1 UUOS BEFORE PICKING OTHER JOBS

IFNDEF IFC0,<XP IFC0,^D5>	;SWAPPER FAIRNESS COUNT MAXIMUM


IFNDEF UFC0,<XP	UFC0,^D10>	;UUO FAIRNESS COUNTER MAXIMUM

IFNDEF UFC1,<XP	UFC1,^D10>	;UUO FAIRNESS COUNTER FOR SLAVE
				;PICK UFC1 JOBS TO RUN ON CPU1
				;WHICH CAME FROM CPU0 AND JUST FINISHED
				;A UUO
IFNDEF MEMITL,<XP MEMITL,^D4>	;NUMBER OF WAYS MEMORY CAN BE INTERLEAVED
IFNDEF	MLACTS,<XP MLACTS,^D39>  ;MAXIMUM LENGTH OF THE ACCOUNT STRING
				; IF NOT DEFINED, 39 CHARACTERS
IFNDEF SCHEDN,<SCHEDN==0>	;SCHEDULE VALUE
SCHEDN==SCHEDN&777777		;ONLY A RIGHT HALF NUMBER
IFNDEF	PAVJSP,<XP PAVJSP,^D20>	;PREDICTED AVERAGE JOB SIZE
IFG	MLACTS-^D39,<XP MLACTS,^D39>  ;MAXIMUM LENGTH IS 39 CHARACTERS
IFL	MLACTS,<XP MLACTS,0>
IFG	MLACTS,<XP ACTSTL, MLACTS/^D5+1> ;LENGTH OF ACCOUNT STRING IN WORDS
IFE	MLACTS,<XP ACTSTL,0>
XP MACTSL,-ACTSTL
XP MAXACS,^D8		;MAX LENGTH OF ACCOUNT STRING
IFNDEF M.CBAT,<XP M.CBAT,^D10>	;NO. OF BAD ADDRESSES IN PER CPU BAD
				; ADDRESS TABLE FOR MEMORY PARITY RECORDING
IFNDEF M.BMAX,<XP M.BMAX,^D13>	;MAX. NO. OF SIMULTANEOUS BATCH JOB STREAM'S
				; INITIATES LOC BATMAX, CHECKED BY BATCON
IFNDEF M.BMIN,<XP M.BMIN,0>	;MIN. NO. OF GUARRANTEED BATCH JOBS
IFNDEF M.EXE,<XP M.EXE,1>	;SYMBOL WHICH DETERMINES TYPE OF FILE
				; CREATED ON "SAVE".  IF OFF, NORMAL (SAV,HGH,
				; LOW,..), IF ON AN EXE FILE IS CREATED
IFNDEF M.JMAX,<XP M.JMAX,M.JOB-M.BMIN>	;MAX. NO. OF SIMULTANEOUS INTERACTIVE JOBS
IFNDEF M.WCH,<XP M.WCH,JW.WMT>	;WATCH BITS USED TO SET INITIAL
				; WATCHING. SINCE LOGIN SETS JBTWCH
				; THIS IS USEFUL ONLY FOR LINES WHICH
				; DON'T NEED LOGIN - INITIA.
				;200000 = TIME OF DAY STARTED TO WAIT
				;100000 = RUN TIME
				;40000 = WAIT TIME
				;20000 = BLOCKS READ
				;10000 = BLOCKS WRITTEN
				;4000 = VERSION NOS.
				;2000 = MTA STATISTICS
IFNDEF M.CMCT,<XP M.CMCT,^D32>	;NO. OF CALLS TO CHKTAL ROUTINE
				; BEFORE DOING 5 M.S. OF OVERHEAD
				; CHECKING CORE TABLES. I.E. ONLY
				; EVERY 32 TIME IS OVERHEAD PERFORMED
				;THIS REDUCES CPU TIME FOR
				; CORE, GETSEG, RUN UUOS
				; SYMBOL CANNOT EXCEED 262,000.
IFNDEF M.EBPS,<XP M.EBPS,^D12500000> ;DEFAULT # EBOX TICKS PER SECOND
					  ; (ACCT METER COUNTS AT 1/2 SYSTEM CLOCK RATE)
					  ; SYSTEM CLOCK RATE IS 25MHZ

IFNDEF M.MBPS,<XP M.MBPS,^D9750000> ;DEFAULT MBOX REFS/SECOND
				     ; THIS NUMBER WAS EXPERIMENTALLY
				     ; DETERMINED AT A CPU CLOCK RATE
				     ; OF 25MHZ SUCH THAT THE CPU TIME
				     ; OF A JRST . MATCHED ELAPSED TIME.
				     ; JRST . WAS ASSUMED TO BE A BEST CASE CONDITION.

				     ; THIS TERM MAKES EBOX/MBOX RUNTIME
				     ; PER REAL TIME UNIT DEPENDENT ON
				     ; CACHE HIT RATE, ALTHOUGH INSTRUCTIONS
				     ; PER E/MBOX RUNTIME UNIT SHOULD REMAIN CONSTANT.

IFNDEF M.EMRT,<XP M.EMRT,0>	;DEFAULT IS REGULAR RUNTIME
IFNDEF M.XPI,<XP M.XPI,0>	;AND INCLUDE PI TIME IN USER RUNTIME
IFNDEF M.ITA,<XP M.ITA,0>	;DEFAULT IS TO USE INTERVAL TIMER

IFNDEF M.XFFA,<XP M.XFFA,0>	;DO FILE ACCESS PROTACTION CHECKING ON [1,2] AND JACCT

IFN FTNSCHED,<
	ND	M.CLSN,^D16	;DEFAULT NUMBER OF CPU CLASSES FOR SCHEDULER
	ND	M.CLSS,1	;DEFAULT SCHEDULER IS CLASS SYSTEM SCHEDULER.
				; IF THIS MONGEN SYMBOL IS DEFINED
				; TO BE ZERO, THEN THE SCHEDULER WILL
				; RUN IN WMU MODE.

	ND	M.DCLS,0	;DEFAULT SCHEDULER CLASS FOR NEW JOBS.
				; CAN OBTAIN THIS FROM GETTAB OR SCHED UUO
IFG M.DCLS-M.CLSN,<PRINTX VALUE OF M.DCLS EXCEEDS M.CLSN.
			M.DCLS==M.CLSN-1>

>;END IFN FTNSCHED
IFE FTNSCHED,<
	ND	M.CLSN,1
	ND	M.CLSS,0
	ND	M.DCLS,0
	XP	SCHED.,CPOPJ	;NO SCHED. UUO
>;END IFE FTNSCHED

IFN FTKL10,<
ND	TTDMOS,^D16		;MAXIMUM OUTPUT STRING
				; DEFINES THE NUMBER OF CHARACTERS THAT CAN
				; BE SENT TO -20F IN A SINGLE BUFFER
>  ;END OF FTKL10

ND	HIGHXC,^D80		;HIGHEST EXTENDED CHANNEL
IFG HIGHXC-^D512,<PRINTX HIGHEST EXTENDED CHANNEL IS GREATER THAN 512
	PRINTX	REDUCING IT TO 512
	XP	HIGHXC,^D512>

ND	MAXNBP,^D64		;MAXIMUM NUMBER OF SNOOP UUO
				; BREAK POINTS ALLOWED
ND	M.OMSM,^D60		;NUMBER OF MINUTES BETWEEN CALLS
				; TO BIGBEN TO TYPEOUT MONITOR NAME,
				; UPTIME, AND DATE/TIME
				;SET TO <-1>_-1 TO NEVER PRINT
ND	M.DTLS,^D90		;CPU TIME LIMIT (SECONDS) TO SET
				; ON A FORCED DETACH (.BYE) COMMAND
ND	LIM1MS,4		;LIMIT OF STOPCD'S IN ANY 1 MINUTE PERIOD
ND	LIM8MS,7		;LIMIT OF STOPCD'S IN ANY 8 MINUTE PERIOD
ND	LIM1HS,^D30		;LIMIT OF STOPCD'S IN ANY 1 HOUR PERIOD

ND	SEBAGE,^D10		;MAXIMUM AGE IN MINUTES FOR A SYSTEM ERROR BLOCK
				; BEFORE WE DELETE EVEN IF DAEMON HASN'T SEEN IT
;THESE SYMBOLS DEFINE THE VALUES OF VERSION FROM MONGEN

AXXWHO==2
IFNDEF	A00CVN,<IFNDEF A00CLH,<AXXWHO=0>>
ND	A00CVN,0		;CUSTOMER VERSION NUMBER (36-BITS)
ND	A00MVN,705		;MAJOR VERSION OF MONITOR--UPDATED AT
				;  START OF DEVELOPMENT CYCLE (9-BITS)
ND	A00SVN,0		;SOUP NUMBER--UPDATED AT START
				;  OF EACH SOUP DEVELOPMENT CYCLE (6-BITS)
ND	A00MCO,^D14328   	;HIGHEST MCO IN THIS LOAD (26-BITS)
ND	A00CLH,0		;CUSTOMER LH (%CNVER) (18-BITS)
ND	A00DLN,0		;DEC LOAD NUMBER (6-BITS)
				; SET TO ZERO FOR ANY RELEASE, ELSE
				; 1-7 IF SOUP, 10-77 IF DEVELOPMENT
ND	A00WHO,AXXWHO		;DEC LAST EDITED (3-BITS)

AXXVER==< BYTE (18) A00CLH (12) A00MVN-IFE A00SVN,<IFN A00DLN,<1>> (6) IFGE A00DLN*<A00DLN-10>,<A00DLN>>

ND	A00VER,AXXVER		;DEFINES %CNVER

AXXDVN== BYTE (3) A00WHO (9) A00MVN (6) A00SVN (18) A00MCO

;DEFINE DAEVER TO BE THE SIXBIT NAME OF THE MONITOR VERSION IN THE
;LEFT HALF, AND THE BINARY MONITOR VERISON IN THE RIGHT HALF. THE
;SYMBOL BECOMES THE VALUE OF THE %CNDAE GETTAB WHICH DAEMON USES TO
;DETERMINE IF IT IS COMPATIBLE WITH THIS MONITOR. IF THE PROGRAM
;DECIDES IT ISN'T COMPATIBLE BY RANGE CHECKING THE RIGHT HALF, IT
;WILL USE THE LEFT HALF TO DETERMINE THE NAME OF THE PROGRAM TO RUN.
DEFINE ..CNFD(VERSION),<XWD SIXBIT \   VERSION\,VERSION>
DAEVER==..CNFD(705)

;DEFINE CTHR TO BE THE CTERM HOST REVISION STRING FOR NRTSER (AND GETTABS).
;THIS STRING IS ALWAYS EIGHT (8-BIT) BYTES IN LENGTH, AND IS OF THE FOLLOWING
;FORM:
;
;	7.03BK42
;
;WHERE THE "7.03" BYTES ARE TAKEN FROM A00MVN, THE "BK" BYTES ARE THE TRANSLATED
;FORM OF A00SVN, AND THE "42" BYTES ARE FROM A00DLN.  THE A00SVN AND A00DLN
;FIELDS WILL BE BLANKS IF THEIR VALUES ARE ZERO.

IFN M.DECN,<
CCLEAR (CTHR)			;CLEAR OUT THE STRING ACCUMULATION
CONCAT (CTHR,<BYTE (8) ">)	;START OFF THE STRING
CONCAT (CTHR,\<A00MVN/100>)	;GET FIRST DIGIT
CONCAT (CTHR,<",".",">)		;ADD THE DOT FILLER
CONCAT (CTHR,\<<A00MVN/10>&7>)	;GET THE SECOND DIGIT
CONCAT (CTHR,<",">)		;MOVE TO NEXT BYTE FIELD
CONCAT (CTHR,\<A00MVN&7>)	;GET THE THIRD DIGIT
CONCAT (CTHR,<",">)		;MOVE TO NEXT BYTE
IFN A00SVN,<
 IFG A00SVN-^D26,<
  CONCAT (CTHR,\"<<A00SVN/^D26>+"A">)	;ADD IN FIRST OF 2-CHAR MINOR VERSION
  CONCAT (CTHR,<",">)		;MOVE TO NEXT BYTE
 >
 CONCAT (CTHR,\"<A00SVN-1-<<A00SVN-1>/^D26>*^D26+"A">)	;ADD MINOR VERSION
 IFLE A00SVN,<CONCAT (CTHR,<"," >)>	;PAD IF SHORT MINOR VERSION
 CONCAT (CTHR,<",">)		;MOVE TO NEXT BYTE
> ;END OF IFN A00SVN
IFE A00SVN,<CONCAT (CTHR,< "," ",">)>	;PAD WITH SPACES IF NO MINOR VERSION
IFN A00DLN,<
CONCAT (CTHR,\<A00DLN/10>)	;ADD FIRST DIGIT OF LOAD NUMBER
CONCAT (CTHR,<",">)		;MOVE TO NEXT BYTE
CONCAT (CTHR,\<A00DLN&7>)	;ADD LAST DIGIT OF LOAD NUMBER
CONCAT (CTHR,<">)		;CLOSE THE STRING
>
IFE A00DLN,<
CONCAT (CTHR,< "," ">)		;PAD WITH SPACES IF NO LOAD NUMBER
>
				;"CTHR" STRING COMPLETE

;DEFINE THE VALUE OF THE HIGH-AVAILABILITY OPTION FOR CTERM AS WELL

IFG M.CPU-1,<XP CTHOPT,1>	;ON IF MULTI-CPU
IFLE M.CPU-1,<XP CTHOPT,0>	;OFF IF SINGLE

> ;END OF IFN M.DECN


;DEFINE THE PFH TIMER TRAP INTERVAL IN TICKS
IFNDEF	M.PFHT,<M.PFHT==:^D60>

;DEFINE DEFAULT VALUE OF DEBUGF TO STOP ON STOPCD'S DURING FIELD-TEST,
; BUT NOT TO STOP IN RELEASED VERSIONS OF MONITOR.
IFNDEF DEFDEB,<DEFDEB==0>

; DEFINE DEFAULT CPU MASK FOR EDDT.  THIS MASK INDICATES WHICH CPUS
; MAY ENTER EDDT VIA THE UNSOLICITED BREAKPOINT FACILITY.
	ZZ==<1+<ZZZ==-1>>
	REPEAT M.CPU,<ZZ==<ZZ!<DF.BP0_-<ZZZ==ZZZ+1>>>>
IFNDEF DEFBPT,<DEFBPT==ZZ>

IFNDEF BPTBIT,<XP BPTBIT,0>	;VALUE OF JS.BPT FOR NEW JOBS

;PRIV BITS TO ALLOW CHGPPN TO WORK IF ALREADY LOGGED IN
IFNDEF	CHGPPP,<CHGPPP==:0>	;DEFAULT TO ILLEGAL UNLESS LOGGED OUT

;FLAG TO INDICATE OF DUMPING IS DESIRED WHEN SYSTEM UPTIME IS .LT. 5 MINUTES
IFNDEF	ATODMP,<ATODMP==:1>		;DEFAULT TO DUMP

;ADD NEW MONGEN SYMBOLS HERE (SEE ALSO COMDEV FOR MONGEN SYMBOLS)
SUBTTL	AUTOCONFIGURATION DEFINITIONS


	EXTERN	AUTCON		;FORCE LOADING AUTOCONFIGURATION CODE

IFNDEF M.GENL,<M.GENL==20>	;NUMBER OF FREE GENTAB ENTRIES FOR
				; USE BY AUTCON
IFN M.KL10,<
IFNDEF M.FDVC,<M.FDVC==:034>	;FIRST DEVICE CODE TO SCAN
IFNDEF M.LDVC,<M.LDVC==:574>	;LAST DEVICE CODE TO SCAN
> ;END IFN M.KL10
IFN M.KS10,<
IFNDEF M.FDVC,<M.FDVC==:760000>	;FIRST UNIBUS ADDRESS TO SCAN
IFNDEF M.LDVC,<M.LDVC==:777777>	;LAST UNIBUS ADDRESS TO SCAN
> ;END IFN M.KS10
; CONTEXT SYMBOLS
IFNDEF	M.CTX,<M.CTX==:1>	;LOAD CONTEXT SERVICE BY DEFAULT


; CONSTANTS USED TO MANIPULATE CONTEXT AND JOB NUMBERS IN A JOB/CONTEXT
; HANDLE (JCH).  THE CONTEXT AND JOB MASKS MUST BE ADJACENT BYTES.

CTXMAX==:777			;ABSOLUTE MAXIMUM CONTEXTS PER JOB

CTXMSK==:<CTXMAX>B26		;MASK OF CTX #
JOBMSK==:777B35			;MASK OF JOB #
JCHMSK==:CTXMSK!JOBMSK		;MASK OF JCH #

CTXWID==<^L<-<<CTXMSK>_<^L<CTXMSK>>>-1>> ;WIDTH OF CTX # MASK
JOBWID==<^L<-<<JOBMSK>_<^L<JOBMSK>>>-1>> ;WIDTH OF JOB # MASK
JCHWID==<^L<-<<JCHMSK>_<^L<JCHMSK>>>-1>> ;WIDTH OF JCH # MASK

CTXPOS==<^L<<CTXMSK>&<-<CTXMSK>>>> ;RIGHT MOST BIT IN CTX # MASK
JOBPOS==<^L<<JOBMSK>&<-<JOBMSK>>>> ;RIGHT MOST BIT IN JOB # MASK
JCHPOS==<^L<<JCHMSK>&<-<JCHMSK>>>> ;RIGHT MOST BIT IN JCH # MASK

CTXLSH==:^D36-CTXPOS-1		;BITS TO SHIFT CTX # INTO POSITION
JOBLSH==:^D36-JOBPOS-1		;BITS TO SHIFT JOB # INTO POSITION
JCHLSH==:^D36-JCHPOS-1		;BITS TO SHIFT JCH # INTO POSITION

CTXPTR==:POINT CTXWID,,CTXPOS	;BYTE POINTER TO CTX # (OR WITH ADDR)
JOBPTR==:POINT JOBWID,,JOBPOS	;BYTE POINTER TO JOB # (OR WITH ADDR)
JCHPTR==:POINT JCHWID,,JCHPOS	;BYTE POINTER TO JCH # (OR WITH ADDR)

CTXCBP==:POINT CTXWID,,35	;BYTE POINTER TO A CONTEXT QUOTA
CTXPBP==:POINT <^D36-CTXWID>,,<^D35-CTXWID> ;BYTE POINTER TO PAGE QUOTA

CTXBPW==:^D36/CTXWID		;BYTE PER WORD IN DIRECTORY MAP
CTXMAP==:<CTXMAX/CTXBPW>+1	;SIZE OF A DIRECTORY MAP + TERMINATING NULL
CTXDIR==:POINT CTXWID,,<^D36-<^L<CTXMAX>>-1> ;BYTE POINTER TO A DIRECTORY MAP
IFN M.CTX,<

IFNDEF	M.CTXC,<M.CTXC==:^D4>	;DEFAULT CONTEXT QUOTA
IFNDEF	M.CTXP,<M.CTXP==:^D1000>;DEFAULT SAVED PAGE QUOTA
IFNDEF	M.CTXR,<M.CTXR==:M.JOB/4> ;DEFAULT RESERVED CONTEXT BLOCK COUNT
	EXTERN CTXSER		;FORCE LOADING OF CONTEXT SERVICE

> ;END IFN M.CTX

IFE M.CTX,<			;DEFINE DUMMY GLOBALS IF NOT LOADING CTXSER

CTXTAB==:NULGTB##		;GETTAB TABLE
CTXMXL==:0			;GETTAB TABLE LENGTH
CTXINI==:CPOPJ			;INITIALIZATION AT SYSINI TIME
CTXBLK==:CPOPJ1			;CONTEXT BLOCK CREATION
CTXPRT==:CPOPJ			;CONTROL-T DISPLAY
CTXLGO==:CPOPJ			;DELETE CONTEXT BLOCKS ON LOGOUT
CTXATO==:CPOPJ			;AUTO-SAVE
CTXSCD==:KCORE1##		;SCHEDULER CALL ON SWAP OUT
CTXPOP==:CPOPJ			;AUTO-RESTORE
CTXRUE==:CPOPJ			;RUN UUO ERROR RECOVERY
CTXUUO==:CPOPJ			;CTX. UUO
CTXMIG==:CPOPJ			;NO IDLE CONTEXTS TO MIGRATE
CTXMGN==:CPOPJ			;NO MORE CONTEXTS TO MIGRATE
CTXWKJ==:WAKEJ##		;LET CLOCK1 EXPIRE SLEEP REQUESTS

	$HIGH

CTXJCJ::SKIPA	T1,J		;SET TO CONTEXT 0 FOR THIS JOB
CTXNUM::TDZA	T1,T1		;CURRENT CTX IS ZERO
CTXJCH::JUMPLE	T1,CPOPJ	;NO SUCH JOB
	CAMG	T1,HIGHJB	;IN RANGE?
	AOS	(P)		;YES, RETURN GOODNESS
	POPJ	P,		;RETURN

CTXPSI::PUSHJ	P,CTXVAL	;VALIDITY CHECK
	  POPJ	P,		;NO SUCH JCH
	MOVE	T1,J		;SET TO CONTEXT 0 FOR THIS JOB
	MOVE	T2,JBTPIA(J)	;GET PIT FOR JOB
	JRST	CPOPJ1		;RETURN

CTXVAL::JUMPLE	J,CPOPJ		;NO SUCH JOB
	CAMG	J,HIGHJB	;IN RANGE?
	AOS	(P)		;YES, RETURN CURRENT
	POPJ	P,		;NO, RETURN NONESUCH

CTXIPC::MOVE	J,T1		;SET TO CONTEXT 0 FOR THIS JOB
	PUSHJ	P,FNDPDB##	;FIND THE PDB
	  POPJ	P,		;NO SUCH JOB
	XMOVEI	W,.PDIPC(W)	;POINT TO IPCF DATA BLOCK
	JRST	CPOPJ1		;RETURN

CTXENQ::MOVE	J,T1		;SET TO CONTEXT 0 FOR THIS JOB
	PUSHJ	P,FNDPDB##	;FIND THE PDB
	  POPJ	P,		;NO SUCH JOB
	MOVE	T2,.PDEQJ(W)	;GET ADDR OF QUEUE CHAIN
	JRST	CPOPJ1		;RETURN

CTXJPK::PUSHJ	P,CTXVAL	;VALIDITY CHECK
	  POPJ	P,		;NO SUCH JCH
	MOVE	T1,J		;SET TO CONTEXT 0 FOR THIS JOB
	MOVE	T2,JBTSWP(J)	;GET DISK ADDRESS
	JRST	CPOPJ1		;RETURN

CTXSGN::PUSHJ	P,CTXJCH	;VALIDITY CHECK
	  POPJ	P,		;NO SUCH JCH
	HRRZ	T1,JBTSGN(T1)	;GET JBTSGN
	JRST	CPOPJ1		;RETURN

CTXWAK::PUSHJ	P,WAKJOB##	;WAKE JOB UP
	JRST	CPOPJ1		;RETURN

CTXCMD::
PSHCMD::
POPCMD::JSP	T1,ERRMES##	;CAN'T DO THESE IF CONTEXT SERVICE NOT LOADED
	ASCIZ	/Job contexts not supported/

	$ABS

> ;END IFE M.CTX
SUBTTL COMPUTE SPECIAL SYMBOLS

SEGN=JOBN+SEGN

IFN M.KL10,<

XP EBCPT,10000		;KL10 EBOX CLOCK DOES THIS MANY COUNTS PER EBOX TICK
XP MBCPT,10000		; MBOX CLOCK DOES THIS MANY COUNTS PER MBOX TICK
>;END IFN M.KL10
SUBTTL ABSOLUTE LOCATIONS IN LOWER MEMORY

;DATA STARTING AT 140:

	LOC	41
	JSR	LUUOPC
	LOC	ARSLOC
	HALT	.
	LOC	KAFLOC
	HALT	.
IFN M.KL10,<
	LOC	WRSINS
	HALT	.
>

;SET JOBVER TO SYSTEM VERSION

	LOC	136
	A00CVN			;(136) CUSTOMER
	AXXDVN			;(137) DEC


	COMORG=140		;ORIGIN OF COMMON IS 140
	LOC	COMORG		;MAKE LISTING BE SAME AS LOADING SO IT WILL BE EASY
				; TO EXAMINE SYSTEM LOCATIONS WITH CONSOLE SWITCHES
				; WITHOUT NEEDING A STORAGE MAP

	SYSDSP=:400		;FIRST STARTING LOCATION OF MONITOR

;LOWER CORE FROM 140 UP THRU 410 (START LOCATIONS):
ASCIZ /
THIS SOFTWARE IS FURNISHED UNDER LICENSE AND MAY BE USED
OR COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.

COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1969,1990.
ALL RIGHTS RESERVED.
/
SUBTTL	EXECUTIVE PROCESS TABLE(S)

	DEFINE	EPT(N)<

.E'N'EPT::			;ADDRESS OF EXECUTIVE PROCESS TABLE FOR CPU'N'
	.E'N'MP==:.E'N'EPT	;FOR THOSE WHO CAN'T REMEMBER THE NEW NAME

IFN M.KL10,<
	LOC	.E'N'EPT+.EPLGO
	BLOCK	40		;LOGOUT AREAS FOR INTERNAL CHANNELS
>;END IFN M.KL10

	LOC	.E'N'EPT+.EPUUO
	IOP			;CAUSE AN IOP STOPCD IF A DEVICE INTERRUPTS
				; TO 40
	JSR	LUUOPC		;LUUO HANDLER

	LOC	.E'N'EPT+.EPPII	;STANDARD PRIORITY INTERRUPT INSTRUCTIONS
	ZZ==10*N
REPEAT 7,<
	ZZ==ZZ+1
	INTINS	\ZZ		;NON-VECTORED INTERRUPT LOCATIONS
				; (INTINS GENERATES TWO WORDS PER PI CHANNEL)
>; END REPEAT 7

IFN M.KL10,<
	LOC	.E'N'EPT+.EPCFW	;LOCS USED BY RH20 FOR ZERO-FILL
	0
	0
	0
	0
>;END IFN M.KL10

IFN M.KS10,<
	LOC	.E'N'EPT+.EPVIT	;POINTERS TO UBA INTERRUPT VECTOR TABLES
	VC'N'TB1		;UBA 1
	0			;UBA 2
	VC'N'TB3		;UBA 3
	0			;UBA 4
>;END IFN M.KS10

IFN M.KL10,<
	LOC	.E'N'EPT+.EPDTM	;SCRATCH BUFFER FOR GET DATE/TIME
.E'N'DTM::BLOCK	3		;CAN BE ANYWHERE IN EPT

	LOC	.E'N'EPT+.EPDCB	;START OF DTE0 HARDWARE LOCATIONS
.E'N'DCB::BLOCK	^D8*4		;8 WORDS FOR EACH OF 4 DTE20S
>;END IFN M.KL10

	LOC	.E'N'EPT+.EPETL	;EXEC TRAPS
	JFCL			;ARITHMETIC TRAP
	EXP	SEPDLO##	;PUSH DOWN OVERFLOW TRAP
	JSR	TRP3PC		;TRAP 3 TRAP

IFN M.KS10,<
	LOC	.E'N'EPT+.EPHSB
.E'N'HSB::BLOCK	^D18		;HALT STATUS BLOCK AREA
>; END IFN M.KS10

IFN M.KL10,<
	LOC	.E'N'EPT+.EPDDG	;DTE AREA
.E'N'STD:JRST	DEBUG##		;DIAGNOSTIC START
.E'N'DDT:XCT	SYSDDT		;DDT START
.E'N'STL:XCT	SYSCRH		;LOADER START ADDRESS (BOOTS)
.E'N'STM:XCT	SYSDSP		;START MONITOR

	LOC	.E'N'EPT+.EPDSC	;SECONDARY PROTOCOL DTE CONTROL BLOCK AREA
.E'N'DSC::BLOCK	^D11		;(MASTER FRONT-END ONLY)

	LOC	.E'N'EPT+.EPTMB
.E'N'TMB::BLOCK	2		;TIME BASE WORD
.E'N'PAC::BLOCK	2		;PERFORMANCE COUNTER WORD

	LOC	.E'N'EPT+.EPTII
.E'N'TII::XPCW	TM'N'INT
>;END IFN M.KL10

	LOC	.E'N'EPT+.EPSTB
.E'N'STB::
	EXP	<PM.DCD>B2+PM.WRT+PM.CSH+.E'N'MAP/PAGSIZ
IFN FTXMON,<
	EXP	<PM.DCD>B2+PM.WRT+PM.CSH+.E'N'MAP/PAGSIZ
	EXP	<PM.DCD>B2+PM.WRT+PM.SWB+PM.CSH+<.E'N'MP1/PAGSIZ>
	BLOCK	^D31-<.-.E'N'STB>
	EXP	<PM.DCD>B2+PM.WRT+PM.CSH+<.C'N'MMA/PAGSIZ>
>; END IFN FTXMON

IFN M.KL10,<
;GENERATE TABLE OF CONSTANTS USED BY KL10 MICROCODE FOR OWGBP

	LOC	.E'N'EPT+.EPOWG
.E'N'OWGP:
	EXP	440606360607
	EXP	300610220611
	EXP	140612060613
	EXP	000646441015
	EXP	341016241017
	EXP	141020041055
	EXP	440722350723
	EXP	260724170725
	EXP	100726010762
	EXP	441130331131
	EXP	221132111133
	EXP	001170442235
	EXP	222236002275
	EXP	000000000000
	EXP	464750515253
	EXP	626364656600
	EXP	555657600000
	EXP	707172730000
	EXP	757600000000
>;END IFN M.KL10
;SECTION 0/1 MAP

	LOC	.E'N'EPT+PAGSIZ
.E'N'MAP::

;LOW SEGMENT MAPPING
DEFINE	ONE41,<
	EXP	<PM.DCD>B2+PM.WRT+PM.PUB+<IFE <M.CPU-1>,<ZZCSH>>+ZZ
	ZZCSH==PM.CSH
	ZZ==ZZ+1
>
	ZZ==0
IFN M.KS10,<ZZCSH==0>		;ON KS10, DON'T CACHE PAGE 0
IFE M.KS10,<ZZCSH==PM.CSH>	;OTHERWISE, DO
	XLIST
	REPEAT	CSBORG/PAGSIZ,<ONE41>	;TRADITION HASN'T IT
	LIST

;COMMON SUBROUTINES/HIGH SEGMENT MAPPING
DEFINE	ONE41,<
	EXP	<PM.DCD>B2+PM.WRT+PM.PUB+PM.CSH+ZZ
	ZZ==ZZ+1
>
	LOC	.E'N'MAP+CSBORG/PAGSIZ
	ZZ==CSBORG/PAGSIZ
	XLIST
	REPEAT	<FYSORG-CSBORG-EVAPGS*PAGSIZ>/PAGSIZ,<ONE41>
	LIST

;FUNNY SPACE MAPPING
DEFINE	ONE41,<
	EXP	<PM.ICD>B2+PM.WRT+PM.PUB+PM.CSH+<ZZ+.UMORG>B17+N
	ZZ==ZZ+1
>
	LOC	.E'N'MAP+FYSORG/PAGSIZ
	ZZ==0
	XLIST
	REPEAT	PAGSIZ-<FYSORG/PAGSIZ>,<ONE41>
	LIST

	LOC	.E'N'MAP+PAGSIZ	;GET TO END OF THE MAP

;SECTION 2 MAP

IFN FTXMON,<
	LOC	.E'N'EPT+<2*PAGSIZ>
.E'N'MP1::
DEFINE	ONE41,<
	EXP	<PM.DCD>B2+PM.WRT+<IFE <M.CPU-1>,<PM.CSH>>+ZZ
	ZZ==ZZ+1
>
	ZZ==MS.HGH/PAGSIZ	;BOOT READ THIS IN 1:1
	XLIST
	REPEAT	CSBORG/PAGSIZ,<ONE41>	;MAKE SECTION MAP 1:1
	LIST

DEFINE	ONE41,<
	EXP	<PM.ICD>B2+PM.WRT+PM.PUB+PM.CSH+PM.SWB+<ZZ+.UMORG>B17+N
	ZZ==ZZ+1
>
	LOC	.E'N'MP1+FYSORG/PAGSIZ
	ZZ==0
	XLIST
	REPEAT	PAGSIZ-<FYSORG/PAGSIZ>,<ONE41>
	LIST

	LOC	.E'N'MP1+PAGSIZ
>; END IFN FTXMON
>;END DEFINE EPT
DEFINE	INTINS(X)<
	XPCW	CH'X		;DISPATCH TO START OF CONSO SKIP CHAIN
IFN M.KL10,<IOP>		;CAUSE AN IOP STOPCODE IF BLKO INTERRUPT
IFN M.KS10,<JSR	PIERR##>	;SHOULDN'T GET A BLKO ON THE KS
>; END DEFINE INTINS

;NOW GENERATE EPT'S

IFN M.KL10,<
	LOC	1000		;START AT PAGE 1 (RESERVE PAGE 0 FOR IOWD SPACE)
>
IFN M.KS10,<
	LOC	2000		;START AT PAGE 2 (FE USES PAGE 1 FOR SOFT CRAM
				; PARITY ERROR RECOVERY)
>

IFN XPANDN,<LALL>

	ZZ1==0

REPEAT M.CPU,<
	EPT(\ZZ1)
	ZZ1==ZZ1+1
>; END REPEAT M.CPU

IFE M.CPU-1,<
EPTDIF==:0
>
IFG M.CPU-1,<
EPTDIF==:.E1MAP-.E0MAP
>

	LOC	777000&<.+PG.BDY>	;ROUND UP TO NEXT PAGE BOUNDARY
NLUPMP::			;NULL JOB USER PROCESS TABLE/PAGE MAP GOES HERE
	SUBTTL INITIALIZATION DISPATCH TABLE, STARTING AT LOCATION 400

	LOC	SYSDSP		;ORIGIN START LOCATIONS TO 400

SYSDSP::XJRST	[MCSEC0+SYSTRT]	;(400) INITIALIZE SYSTEM VARIABLES IF CPU0
SYSDDT::XJRST	[MCSEC0+ENTDDT]	;(401) ENTER EXEC DDT
	HALT	.		;(402)
	HALT	.		;(403)
	XJRST	[MCSEC0+STPALL]	;(404) SET CRSHWD TO -1 AND DO A 406
				;  START TO STOP ALL OTHER CPU'S AND
				;  GET TO BOOTS.  MOSTLY FOR DEBUGGING.
	XJRST	[MCSEC0+STPCPU]	;(405) STARTING THE BOOT CPU AT 405 IS THE SAME
				;  AS A 407 START.  ON ALL OTHER CPUS, A 405
				;  START WILL CAUSE THE CPU TO SAVE THE
				;  MACHINE STATE AND JUMP INTO THE AC'S UNTIL
				;  MANUALLY RESTARTED THROUGH 400.
	XJRST	[MCSEC0+STPLDB]	;(406) SET SR.LBH IN .CPSBR AND DO A 407
				;  START TO FORCE BOOTS TO BE LOADED ON
				;  THIS CPU REGARDLESS OF WHO IS THE BOOT
				;  CPU NOW
SYSCRH::XJRST	[MCSEC0+SYSTOP]	;(407) MONITOR CRASH AND RELOAD LOCATION

;START ABSOLUTE LOCATIONS HER TO BE PUBLISHED FOR USERS( UP TO 417)


ABSTAB::EXP	NUMTAB##	;(410) ABSOLUTE LOCATION OF GETAB TABLE TABLE.
				; USED TO BE LOC 151. NEEDED TO DO GETTAB UUO
				; SIMULATION ON A CRASHED MONITOR.
MBTCOM::EXP	0		;(411) ABSOLUTE LOCATION USED FOR MONBTS COMMUNICATION
				;(417) CUSTOMER WORD
	LOC	420		;SKIP RESERVED SPACE
SUBTTL	(NULL JOB AND) USER PROCESS TABLE(S)

;REDEFINE ONE41 FOR GENERATION OF THE NULL JOB'S MAP

DEFINE	ONE41,<
	EXP	<PM.DCD>B2+PM.WRT+PM.PUB+ZZ
	ZZ==ZZ+1
>

	NUPMPP==:NLUPMP/PAGSIZ	;NULL JOB'S UPT PAGE NUMBER

	LOC	NLUPMP+0

	LOC	NLUPMP+.UMORG
NUPPPM::			;PER-PROCESS MAPPING
	ZZ==FYSORG/PAGSIZ
	XLIST
	REPEAT	<.UPMAP/PAGSIZ>-<FYSORG/PAGSIZ>,<ONE41>
	LIST

	LOC	NLUPMP+.UPTVC
NUPPMT::			;USER TRAPS
	EXP	0		;(420) PAGE FAIL WORD (USER OR EXEC)
	JFCL	SAROVF##	;(421) ARITHMETIC TRAP
	EXP	SEPDLO##	;(422) PUSH DOWN LIST OVERFLOW TRAP
	JFCL			;(423) TRAP 3 TRAP
	EXP	0		;(424) MUUO STORED HERE
	EXP	0		;(425) MUUO PC STORED HERE
	EXP	0		;(426) PROCESS CONTEXT WORD
IFE FTXMON,<
	EXP	0		;(427) UNUSED
>; END IFE FTXMON
IFN FTXMON,<
	EXP	LG.LAB+LG.LPC+1B8+1B11 ;(427) LOAD AC BLOCKS AND SET PCS
				; TO DO A USERAC AND LOAD PCS=0 FOR NULL JOB
>; END IFN FTXMON
	EXP	MUUO		;(430) KERNEL NO TRAP MUUO NEW PC
	EXP	KTUUO		;(431) KERNEL TRAP MUUO NEW PC
	EXP	SNTUUO		;(432) SUPERVISOR NO TRAP MUUO NEW PC
	EXP	STUUO		;(433) SUPERVISOR TRAP MUUO NEW PC
	EXP	MUUO		;(434) CONCEALED NO TRAP MUUO NEW PC
	EXP	CTUUO		;(435) CONCEALED TRAP MUUO NEW PC
	EXP	MUUO		;(436) PUBLIC NO TRAP MUUO NEW PC
	EXP	PTUUO		;(437) PUBLIC TRAP MUUO NEW PC

	LOC	NLUPMP+.UPPFW	;GET TO PAGE FAIL WORD
	EXP	0		;(500) PAGE FAIL WORD
	EXP	0		;(501) PAGE FAIL OLD FLAGS/PC DOUBLEWORD
	EXP	0		;(502) ...
	EXP	SEILM##		;(503) PAGE FAIL NEW PC
NUPMPL==:.-NLUPMP

;HARDWARE LOCATIONS
;504 - 507 EBOX/MBOX METERS
;510 - 537 RESERVED

	LOC	NLUPMP+SECTAB
NULSTB::			;SECTION TABLE ORIGIN
	EXP	<PM.DCD>B2+PM.PUB+PM.WRT+NLUPMP/PAGSIZ
	BLOCK	^D31		;RESERVE THE REST

;SOFTWARE LOCATIONS

.USPAT=:.USPAT			;FORCE DEFINITION FROM S

NULASW==:NLUPMP+PAGSIZ		;FIRST LOC AVAIL TO SOFTWARE
	LOC	NULASW
SUBTTL	EXECUTIVE UUO DISPATCHERS

	$HIGH

KTUUO:	JRST	@.USMUE		;E FIELD OF THE MUUO IS TRAP HANDLER ADDRESS
				; N.B., USRIOT ISN'T ON

SNTUUO:	HALT	.		;NOT IMPLEMENTED
STUUO:	HALT	.		;NOT IMPLEMENTED
CTUUO:
PTUUO:
	EXECAC
	HRLZ	T1,.USMUO
	IOR	T1,.USMUE
	JUMPL	T1,ILLTIN##

	CAILE	T1,UP.MLT
	JRST	ILLTIN##
	JRSTF	@UUTDSP(T1)
UUTDSP:	IC.UOU+SEILM##		;PAGE FAULT
	IC.UOU+ILLTIN##		;NOT IMPLEMENTED
	IC.UOU+SEPDLO##		;PUSH DOWN LIST OVERFLOW
	IC.UOU+ILLTIN##		;TRAP 3
	IC.UOU+SUILMX##		;USER ENABLED PAGE FAULT
	IC.UOU+SAROVF##		;USER ENABLED ARITHMETIC OVERFLOW
	IC.UOU+SUPDLO##		;USER ENABLED PDL OVERFLOW
	IC.UOU+ILLTIN##		;NOT IMPLEMENTED
	IC.UOU+ILLTIN##		;NOT IMPLEMENTED
	IC.UOU+PSIAPR		;PSI ENABLED ARITHMETIC OVERFLOW
	$ABS
LUUOPC::0			;JSR HERE ON A LUUO IN EXEC MODE
	EXCH	T1,LUUOPC
	MOVEM	T1,.USMUP
	JRST	UUOERR##
TRP3PC:	0			;JSR HERE ON A TRAP 3 IN EXEC MODE
	HALT	.
SUBTTL	SOME DEFINITIONS FOR KL10'S
IFN M.KL10,<
KLRELC==.
	LOC	420
	IFN	./2*2-.,<0>	;MAKE SURE THEY START ON EVEN LOCATION
FREORG:	BLOCK	1000-.		;ICCW BLOCKS
FRE4LN==<.-FREORG>/4		;NUMBER OF 4-WORD BLOCKS

	LOC	KLRELC
>;END IFN M.KL10
SUBTTL	KS10 UBA INTERRUPT VECTOR TABLES

IFN M.KS10,<
;TABLES FOR DISPATCHING 11-STYLE VECTORED INTERRUPTS FROM THE
;KS10'S UNIBUS ADAPTORS. INITIALLY SET TO ZEROS.
;APPROPRIATE LOCATIONS WILL BE SET UP BY THE DEVICE SERVICE ROUTINES.
;MACRO TO GENERATE THE INTERRUPT VECTOR TABLES

DEFINE	GENVCT(N),<
VC'N'TB1::			;UBA 1 VECTOR TABLE
XLIST
REPEAT ^D128,<0>
LIST
VC'N'TB3::			;UBA 3 VECTOR TABLE
XLIST
REPEAT ^D128,<0>
LIST
>; END DEFINE GENVCT

;NOW GENERATE THE TABLES (ONE PER CPU (HA!))

	N==0			;START WITH CPU0
REPEAT M.CPU,<			;ONCE PER CPU
	GENVCT	(\N)
	N==N+1			;NEXT CPU
>; END REPEAT M.CPU
>;END IFN M.KS10
SUBTTL	VIRTUAL MEMORY DATA

EVTABL==^D512/^D36+1
EVBMAX::0			;FILLED IN BY SYSINI
EVBTAB::BLOCK	EVTABL

ALPHA==1			;FRACTIONAL PART OF TIME CONSTANT
EXPON==^D10			;NEGATIVE EXPONENT OF TIME CONSTANT
.GTVM::
SWPCNT::0			;(0)
SCNCNT::-1			;(1)
SPRCNT::0			;(2) COUNT OF SWAPS + PAGE OPERATIONS IN PROGRESS
				;  (SQREQ IS ONLY SWAPS)
SLECNT::0			;(3) TOTAL NUMBER OF SWPLST ENTRIES
VMTOTL::0			;(4) TOTAL AMOUNT OF VM CURRENTLY IN USE
VMCMAX::0			;(5) MAX ALLOWABLE VALUE OF VMTOTL
VMRMAX::1			;(6) OBSOLETE
VMCNST::ALPHA			;(7) CONSTANT USED TO COMPUTE SWAPPING RATE
VMQJOB::0			;(10) OBSOLETE
JBRMAX::RTUPS/^D10		;(11) OBSOLETE
LSFTIM::0			;(12) TIME OF LAST FAULT
SYSVCT::0			;(13) TOTAL NUMBER OF PAGE FAULTS (OBSOLETE)
	EXP	SWPLST		;(14) LCTN OF SWAP TABLE #1
	EXP	SW2LST		;(15) LCTN OF SWAP TABLE #2
	EXP	SW3LST		;(16) LCTN OF SWAP TABLE #3
VMCEXP::EXPON			;(17) TIME CONSTANT EXPONENT
VMCDIF::EXPON-ALPHA		;(20)
MAXINT::777777			;(21) MAX INTERVAL FOR FAULT-RATE CALCULATION (ABOUT 8 SEC. BETWEEN FAULTS)
IPCCNT::0			;(22) COUNT OF IPCF PAGES BEING SWAPPED OUT
	EXP	.UPJOB	 	;(23) OFFSET OF JOB NUMBER IN UPMP
	EXP	.UPREL		;(24) OFFSET OF END OF LOW SEG IN UPMP
	EXP	.UPLST		;(25) OFFSET OF POINTER TO SWAPABLE
	EXP	.UPMP		;(26) VIRTUAL ADDRESS OF PAGE MAP
	EXP	.UPLNM		;(27) OFFSET OF POINTER TO LOGICAL NAMES
SINCNT::0			;(30) NUMBER OF SWAP INPUT REQUESTS IN SWPLST
	EXP	CSBORG-1	;(31) HIGHEST "UNMAPPED" EXEC ADDRESS
	EXP	.FPPP		;(32) START OF "PER PROCESS" ADDRESS SPACE
	EXP	.LPPP		;(33) END (+1) OF "PER PROCESS" ADDRESS SPACE
	EXP	.JDAT		;(34) "PER PROCESS" ADDRESS OF USER JOBDAT
	EXP	.UPFCC		;(35) OFFSET IN UPMP FOR TMPCOR POINTERS
	EXP	.UPCTA		;(36) OFFSET IN UPMP FOR EXTENDED CHANNEL TABLE POINTER
	EXP	USRJDA		;(37) OFFSET IN UPMP FOR USRJDA
RMCMAX::0			;(40) "REAL" MAXIMUM VALUE OF CORMAX
				;(ADJUSTED FOR FUNNY SPACE)
SYSWLF::0			;(41) SYSTEM WIDE COUNT OF PAGE FAULTS DUE TO
				; WRITES INTO WRITE LOCKED PAGES (TO KEEP TRACK
				; OF MODIFIED PAGES - NOT UWPOFF PAGES)
SYSIWS::0			;(42) SYSTEM "IN WORKING SET" FAULTS
SYSNIW::0			;(43) SYSTEM "NOT IN WORKING SET" FAULTS
	EXP	MS.MEM+PAGTAB	;(44) ADDRESS OF PAGTAB
	EXP	MS.MEM+PT2TAB	;(45) ADDRESS OF PT2TAB
	EXP	MS.MEM+MEMTAB	;(46) ADDRESS OF MEMTAB
EVMPTR::XWD	-EVTABL,EVBTAB	;(47) AOBJN POINTER TO EVM TABLE
PAGPTR::0			;(50) HEAD OF FREE QUEUE
PAGINQ::0			;(51) HEAD OF THE "IN" PAGE QUEUE
PAGINC::0			;(52) COUNT OF PAGES IN THE "IN" QUEUE
PAGSNQ::0			;(53) HEAD OF THE SLOW SWAPPING "IN" PAGE QUEUE
PAGSNC::0			;(54) COUNT OF PAGES IN THE SLOW "IN" QUEUE
PAGIPQ::0			;(55) HEAD OF THE "IN PROGRESS" PAGING QUEUE
PAGIPC::0			;(56) COUNT OF PAGES IN "IP" QUEUE
PAGOUQ::0			;(57) HEAD OF THE "OUT" PAGE QUEUE
PAGOUC::0			;(60) COUNT OF PAGES IN THE "OUT" QUEUE
LOKPTR::0			;(61) HEAD OF LOKCON'S QUEUE
LOKHOL::0			;(62) COUNT OF PAGES IN LOKCON'S QUEUE
LOKTAL::0			;(63) LOKCON'S VERSION OF CORTAL
GTVMXL==:<.-.GTVM-1>B26		;MAXIMUM ENTRY IN GETTAB
SUBTTL	IOWD SPACE ALLOCATION

IFN M.KL10,<
NPAGUC==^D512
IFL <2*M.NKC-^D512>,<NPAGUC==2*M.NKC>
IFNDEF XTR4WD,<XTR4WD==<<NPAGUC+3>/4-<FRE4LN>>>
LTINIT::
IFG FRE4LN,<XWD	FRE4LN,FREORG>
IFG XTR4WD,<XWD	XTR4WD,X4WORG>
	0		;END OF LTINIT XWD'S

XP X4WORG,<<.-1>/4*4+4>
	LOC	X4WORG
IFG XTR4WD,<BLOCK 4*XTR4WD>
IOWNUM==.-FREORG

NOIOWD::EXP	FRE4LN+XTR4WD ;NUMBER OF FREE IOWD BLOCKS

DF10ZR::EXP	0		;GUARANTEED ZERO FOR TERMINATING DF10C CCLS
>;END IFN M.KL10

XP CHKSHF,CPOPJ
XP UPMPSZ,1
XP UPMSZW,PAGSIZ*UPMPSZ
	SUBTTL	COMMON MEMORY FOR KDP (KMC-11/COM-IOP/DUP-11) & DMR11

;NOTE: TO AVOID WASTING SPACE THE VALUE OF "XTR4WD" ON
;  THE LAST PAGE CAN BE ADJUSTED.

;NOTE: KDL PAGES ARE BOTH AS BUFFERS AND COMM REGIONS.  SINCE THEY
;  ARE MAPPED BY THE UBA, IT IS ASSUMED THAT THEY CAN BE TRASHED
;  BY AN ERRANT UNIBUS DEVICE.  FOR THIS REASON, THEY ARE NOT STATICALY
;  INITIALIZED.  INSTEAD, THERE IS CODE IN THE KDP UUO SERVICE
;  TO CLEAR OUT AND INITIALIZE A KDL PAGE.

IFNDEF M.KDUP,<M.KDUP==0>	;MAKE SURE M.KDUP IS DEFINED
IFNDEF M.DMRN,<M.DMRN==0>	;Do the same for DMRs
IFE M.KDUP+M.DMRN,<		;IF NO KMC/DUP-11S THEN
	KDLFST==:0		;  DEFINE THESE TWO SYMBOLS
	KDLLST==:0		;  TO KEEP SYSINI HAPPY
>
IFN M.KDUP+M.DMRN,<		;ONLY ALLOCATE PAGES IF WE HAVE KDP'S or DMRs
	BLOCK	<PAGSIZ-<.&PG.BDY>> ;GO TO A PAGE BOUNDARY
	KDLFST=:.		;DEFINE SYMBOL = TO FIRST LOC OF FIRST PAGE
	BLOCK	KDLLEN * M.KDUP	;ALLOCATE SPACE FOR THE I/O BUFFERS
	BLOCK	PAGSIZ * M.DMRN * DMRPPL ;Allocate space for DMR11 comm region
	KDLLST=:.-1		;REMEMBER LAST ADDRESS USED.
>				;END M.KDUP

	DEFINE KDLDEF(N,V),<	;;MACRO TO DEFINE KDL'N'PG SYMBOLS
	KDL'N'PG=:KDLFST+V
	  ZZZ==.
	  LOC KDL'N'PG+KDLUSR
	  EXP M.'N'KDP
	  LOC ZZZ
>

ZZ=0
Z=0

REPEAT M.KDUP,<
	KDLDEF(\Z,\ZZ)		;DEFINE THE NEXT SYMBOL
	Z=Z+1			;STEP THE KDL INDEX
	ZZ=ZZ+KDLLEN		;STEP THE PAGE ADDRESS
>;END REPEAT

;Do DMRs too
	DEFINE DMRDEF(N,V),<	;;MACRO TO DEFINE DMR'N'PG SYMBOLS
	DMR'N'PG=:KDLFST+V>

Z=0
REPEAT M.DMRN,<
	DMRDEF(\Z,\ZZ)
	Z=Z+1
	ZZ=ZZ+<DMRPPL*1K>
>;End REPEAT (Note the DMRs start after KDPs)
	SUBTTL	COMMON MEMORY FOR PDP10/PDP11

;NOTE: TO AVOID WASTING SPACE BEFORE THE FIRST DL10 WINDOW
;  THE VALUE OF "XTR4WD" ON THE LAST PAGE CAN BE ADJUSTED.

IFN	PDP11N,<
;;THIS MACRO BUILDS THE DL10 MAP FOR A GIVEN PORT.
DEFINE	BLDM76(CPU,PORT),<

;;COMPUTE THE SIZE OF THE MAP
	DEFINE	WORD(A,B),<A==ZZ	;;DEFINE THE OFFSET
	XP	DLX'A,ZZ	;DEFINE GLOBAL SYMBOL
	ZZ==ZZ+1>
	DEFINE	DATA(A,B),<A==ZZ	;;DEFINE THE OFFSET
	XP	DLX'A,ZZ	;DEFINE GLOBAL SYMBOL
	ZZ==ZZ+1>
	DEFINE	PNTR(A,B),<A==ZZ	;;DEFINE THE OFFSET
	XP	DLX'A,ZZ	;DEFINE GLOBAL SYMBOL
	ZZ==ZZ+1>
	DEFINE	BLK(A,B),<
	XP DLX'A,ZZ			;DEFINE GLOBAL SYMBOL
	ZZ==ZZ+B>

;;SIZE OF TO -10 AND TO -11 QUEUES
	TTBS'PORT==:<<M.D7'PORT'N!7>+1>*2
	TEBS'PORT==:<<M.D7'PORT'N*2>!17>+21

;;EXPAND MAP76 TO SEE HOW BIG IT IS
	ZZ==0
	MAP76(CPU,PORT)
REPEAT ^D18,<ZZ==ZZ!<ZZ_<-1>>>

	ZZ==ZZ!<<DLX8K*777>!77>  ;MUST BE BIG ENOUGH
IFN M.DC75,<ZZ=ZZ!177>		;MIN OF 128 WORDS IF MAY BE DC75

	LOC	<<.-1>!ZZ>+1	;LOC TO BEGINNING OF WINDOW
	ZZ==ZZ_<-<6+<3*DLX8K>>>	;SIZE OF BLOCK
	M7'PORT'END==<<<<ZZ+1>_<DLX8K*3>>*^D64>+.-1>
IFN ZZ&777760 <PRINTX ?DL10 MAPPED AREA IS TOO LARGE.>
	XP	M7'PORT'BAM,ZZ	;DL10 WINDOW MASK
	ZZ=ZZ*4			;SHIFT TO PROPER PLACE
	ZZ=ZZ+<PORT&3>		;MASK OUT OVEERFLOW IN PORT

;;NOW LAY OUT THE MAP FOR REAL
DEFINE	WORD(SYM),<
M7'PORT''SYM::	0
>

DEFINE	DATA(SYM,THING),<
IF2,< IFNDEF THING,<EXTERNAL THING>>
M7'PORT''SYM::	THING
>

DEFINE PNTR(SYM,PLACE),<
IF2,< IFNDEF PLACE,<EXTERNAL PLACE>>
M7'PORT''SYM::	<61B5>+PLACE
>

DEFINE BLK(SYM,SIZE),<
M7'PORT''SYM::	BLOCK	SIZE
>

IFNDEF DLXFST,<DLXFST==:.>		;START OF DL10 UNCACHED SPACE

.DL'CPU'PORT'B::	;;FIRST ADDRESS IN COMMON MEMORY
	MAP76(CPU,PORT)
> ;END DEFINITION OF BLDM76
IFN	XPANDN,<LALL>			;EXPAND LISTING IF WANTED FROM MONGEN
	ZZD78L==0			;LINE NUMBER CONCATENATOR

;THIS MACRO USES THE "MAP78" MACRO TO ACTUALLY BUILD THE
;THE WINDOW.  IT CALLS "MAP78" TO FIRST CALCULATE THE WINDOW
;SIZE AND THEN IT CALLS "MAP78" AGAIN TO ACTUALLY BUILD THE
;THE DAS78 WINDOW.
;
DEFINE	BLD78	(CPU,PORT),<

IFN <M'CPU'PORT'D78>,<			;ONLY BUILD IF THERE IS LINES ON PORT

;THESE MACRO'S ARE USED FOR COMPUTING THE SIZE OF THE MAP
;
DEFINE	Q78BLK(A),<
	ZZD78A==ZZD78A+A>
;
DEFINE Q78WRD(A),<
	ZZD78A==ZZD78A+1>
;
DEFINE	Q78DAT(A,B),<
	ZZD78A==ZZD78A+1>
;
DEFINE	Q78SYM(A,B),<
	;A>
DEFINE	Q78INC(A,B),<
	;A==A+B>
;END OF MACRO'S THAT DETERMINE MAP SIZE

	ZZD78A==0			;START WITH 0

IFNDEF	M78FPO,<M78FPO==:PORT>		;FIRST PORT INUSE BY DAS78.
	M78HPO==:PORT			;FIGURE HIGHEST DAS78 PORT.

;CALL MAP78 TO CALCULATE WINDOW SIZE
;
	MAP78	(CPU,PORT)

	ZZD78A==<ZZD78A-1>		;ADJUST TO LAST USED LOCATION

REPEAT ^D18,<ZZD78A==ZZD78A!<ZZD78A_<-1>>>

	ZZD78A==<ZZD78A!<<M78M8K*777>!77>>	;MAKE BIGGER IF 8K DL10

IFN	<.&ZZD78A>,<
	LOC	<.!ZZD78A>+1
>;END IFN <.&ZZD78A>

	ZZD78A==<ZZD78A_<-<6+<3*M78M8K>>>>	;SIZE OF BLOCK
	M8'PORT'END==<<<<ZZD78A+1>_<M78M8K*3>>*^D64>+.-1>

IFN	<ZZD78A&777760>,<PRINTX ?DAS78 DL10 MAPPED AREA TOO LARGE.>
	M8'PORT'BAM==<ZZD78A*4>		;SHIFT TO CORRECT PLACE FOR BASE ADR MASK
DEFINE	Q78BLK(A),<
	BLOCK	A>

DEFINE	Q78WRD(A),<
	A::!Z>

DEFINE	Q78DAT(A,B),<
	A::!B>

DEFINE	Q78SYM(A,B),<
	A'B::>
DEFINE	Q78INC(A,B),<
	A==A+B>
;CALL MAP78 NOW TO ACTUALLY BUILD THE WINDOW
;
.DL'CPU'PORT'B::
	MAP78	(CPU,PORT)

	M78NUM==:<-<M78HPO-M78FPO+1>>	;MINUS NUMBER OF POSSIBLE PDP11'S


	LOC	<M8'PORT'END>+1

>;END OF IFN M'CPU'PORT'D78
>;END OF DEFINITION OF BLD78
; CALCULATE WINDOW SIZE AND BUILD THE PDP11 WINDOW
;
DEFINE	MAPIT	(P),<
	IFN TP.DL'P,<
		IFE M0'P'D78,<BLDM76(0,P)>
		IFN M0'P'D78,<BLD78(0,P)>
	> ;;END IFN TP.DL'P
> ;END MAPIT


ZZZ=0			;FIRST PORT
	REPEAT	10,<
	IFLE	<ZZZ-3>,<
IFNDEF	DLX08K,<DLX08K==0	;;ASSUME JUMPERED FOR 1K MAXIMAL>
IFN	DLX08K,<DLX08K==1	;;FORCE TO 1 IF NOT ZERO>
DLX8K==DLX08K			;;USED BY BLDM76
M78M8K==DLX08K			;;USED BY BLD78
>
	IFG	<ZZZ-3>,<
IFNDEF	DLX18K,<DLX18K==0	;;ASSUME JUMPERED FOR 1K MAXIMAL>
IFN	DLX18K,<DLX18K==1	;;FORCE TO 1 IF NOT ZERO>
DLX8K==DLX18K			;;USED BY BLDM76
M78M8K==DLX18K			;;USED BY BLD78
>
	MAPIT(\ZZZ)	;GET THE RIGHT MAP OR NOTHING
ZZZ=ZZZ+1
>
SUBTTL	DL10 INTERRUPT HANDLING


;INTERRUPT ROUTINE FOR EACH DL10 BASED DAS78
DEFINE	EACH78(PORTN),<
IFN	M0'PORTN'D78,<

IFLE	PORTN-3,<DLBD78=60
	DLCD78=64>			;FIRST DL10
IFG	PORTN-3,<DLBD78=160
	DLCD78=164>			;SECOND DL10

	$ABS

D80'PORTN'KI:				;DL10 FORCES JSR HERE
	EXP	0,0,IC.UOU,<D80'PORTN'IN>

	$HIGH

DEFINE	D8.CH(A,B),<IF2,<A'B>>
IFNDEF	DLXSCC,<DLXSCC:>
D80'PORTN'KA:
	CONSO	DLCD78,1B<32-<3*<PORTN&3>>> ;IS THIS PDP11 INTERRUPTING?
	JRST	DLX'PORTN'NX		;TRY THE NEXT ONE
	CONSO	DLCD78,1B31_<<PORTN&3>*3> ;PORT PORTN ENABLED?
	JRST	.-2			;NO, IGNORE.
	JRST	D80'PORTN'CM		;ENTER COMMON CODE

D80'PORTN'IN:
	CONO	DLCD78,1B19+1B<32-<3*<PORTN&3>>>+XXICHN	;TURN OFF INTERRUPT
	DMOVEM	0,D8.CH(SVAC,\XXICHN)	;SAVE ACS 0 AND 1
	DMOVE	0,D80'PORTN'KI		;GET INPTERRUPT PC DOUBLE WORD
	DMOVEM	0,D8.CH(CH,\XXICHN)	;STORE SO WE CAN USE CHN SAVE ROUTINES
	DMOVE	0,D8.CH(SVAC,\XXICHN)	;RESTORE ACS 0 AND 1

D80'PORTN'CM:
	CONO	DLCD78,1B19+1B<32-<3*<PORTN&3>>>+XXICHN	;TURN OFF INTERRUPT
	JSR	D8.CH(SAV,\XXICHN)	;SAVE THE ACS AND SET UP P
	SKIPE	J,M78BT+PORTN		;J TO POINT TO WINDOW FOR PORT PORTN
	  PUSHJ	P,D78KII##		;GO TO DAS78 INTERRUPT SERVICE ROUTINE
	POPJ	P,			;DISMISS INTERRUPT


;BASE TABLE FOR DAS78 DL10
;
M80'PORTN'BT:
	PHASE	0
M78CPE::!CONO	DLCD78,XXICHN+<1B31_<<PORTN&3>*3>>	;CLEAR PORT ENABLE FOR PORT PORTN
M78I10::!CONSO	DLCD78,1B32_<<PORTN&3>*3>		;SEE IF PDP11 PORTN SET 10 INT
M78I11::!CONO	DLCD78,1B19+1B20+XXICHN+<1B30_<<PORTN&3>*3>>	;SET PDP11 INTERRUPT ON PORTN
M78SWA::!CONO	DLBD78,M8'PORTN'KII!M8'PORTN'BAM!<PORTN&3>	;LOAD ADDRESS FOR PORT PORTN
M78ENP::!CONO	DLCD78,1B20+XXICHN+<1B31_<<PORTN&3>*3>>	;ENABLE PORT PORTN
M78CPI::!CONSO	DLCD78,7			;SEE IF PIA ASSIGNED
M78SPI::!CONO	DLCD78,XXICHN			;GIVE PI CHN ASSIGNMENT
M78PNO::!PORTN,,.DL0'PORTN'B			;;PORT##,,WINDOW
IFN M.PSI,<
M78PSI::!DATAO	DLCD78,[200001,,0]	;KA STYLE INTERRUPTS
>					; SO PSISER CAN FIND THE PC
IFE M.PSI,<
M78PSI::!JFCL
>
M78SER::!DATAO	DLBD78,[<PORTN&3>_^D<35-5>]  ;PUT PORT NUMBER IN THE "R" REGISTER
M78GWA::!CONI	DLBD78,T1	;GET BASE ADDRESS
	DEPHASE

DLX'PORTN'NX::
	$ABS

>;END IFN M0'PORTN'D78
>;END DEFINE EACH78
;INTERRUPT ROUTINE FOR EACH DL10 BASED ANF10 PDP11
DEFINE	EACH76(N)<
IFN TP.DL'N,<			;IF PORT DEFINED
IFE M0'N'D78,<			;AND NOT A DAS78
IFLE N-3,<DLX=DLC
	DLBX=DLB>		;FIRST DL10
IFG N-3,<DLX=DLC2
	DLBX=DLB2>		;SECOND DL10
	$ABS
D70'N'KI:Z			;DL10 FORCES JSR TO HERE
	Z
	IC.UOU
	D70'N'IN

	$HIGH
DEFINE	D7.CH(A,B),<IF2,<A'B>>
IFNDEF	DLXSCC,<DLXSCC==.>	;DEFINE START OF KA SYTLE DL10 CONSO CHAIN
D70'N'KA:CONSZ	DLX,1B32_<<N&3>*3> ;IS THIS -11 INTERRUPTING
	CONSO	DLX,1B31_<<N&3>*3> ;YES, PORT ENABLED ?
	JRST	DLX'N'NX	;NO, TRY THE NEXT -11
	JRST	D70'N'CM	;JOIN COMMON CODE WITH VECTORED STYLE
D70'N'IN:
	DMOVEM	0,D7.CH(SVAC,\SCNCHN)
	DMOVE	0,D70'N'KI
	DMOVEM	0,D7.CH(CH,\SCNCHN)
	DMOVE	0,D7.CH(SVAC,\SCNCHN)

D70'N'CM:CONO	DLX,1B19+<1B32_<<N&3>*3>>+SCNCHN ;TURN OFF INTERRUPT
	JSR	D7.CH(SAV,\SCNCHN) ;SAVE AC'S AND STUFF
	SKIPE	W,DLXBAT+N	;SET UP BASE ADDRESS
	XCT	DLXINI(W)	;TAKE ACTION FOR THIS INTERRUPT
	POPJ	P,		;DISMISS INTERRUPT

	IFE	TP.DL'N-TP.D76,<	;THIS IS A DC76 PORT
DC76'N'D::JRST	[PUSHJ P,SETJ'N	;SET UP J AS BASE ADDRESS
		 PJRST D76TYP##];CALL TYPEOUT ROUTINE
	JRST	[PUSHJ P,SETJ'N
		 PJRST D76DSC##];MODEM CONTROL
	POPJ	P,		;NO PI CHANNEL TO CHECK ON
	POPJ	P,0		;NO INIT
	JRST	[PUSHJ P,SETJ'N
		 PJRST D76CHP##];CHANGE HARDWARE PARAMETERS
	JRST	[PUSHJ P,SETJ'N
		 PJRST D76LPC##];LINE PARAMETER CONTROL
	JFCL
	JFCL
	JRST	[PUSHJ P,SETJ'N
		 PJRST D76OFL##]

SETJ'N:	EXCH	J,(P)		;SAVE J
	MOVEM	J,1(P)		;SAVE RETURN ADDRESS
	MOVE	J,DLXBAT+N	;POINT TO BASE OF MAP
	MOVE	J,DLXWIN(J)	; ..
	PUSHJ	P,@1(P)		;DO FUNCTION
	  PJRST	IPOPJ		;RETURN
	PJRST	IPOPJ1		;ALLOW CPOPJ1
> ;END OF IFE TP.DL'N-TP.D76
DLX'N'NX:
> ;END IFE M0'N'D78
> ;IFN TP.DL'N
> ;END OF DEFINITION OF EACH76
> ;END IFN PDP11N
; PDP11 BASE TABLE OFFSETS
	  PHASE	0		;START BASE TABLE
DLXWIN::! BLOCK	1		;STANDARD XWD CPU#,DTE#
DLXNMT::! BLOCK	1		;FRONT END NAME
DLXSTA::! BLOCK	1		;DTE KNOW'S WHEN THE -10'S ALIVE
DLXINI::! BLOCK	1		;DO THIS ON INTERRUPT
DLXCAL::! BLOCK	1		;POINTER TO CAL11. UUO TABLE
DLXCEU::! BLOCK	1		;CAL11. USER'S JOB NUMBER
DLXPRG::! BLOCK	1		;DO THIS WHEN PDP11 GOES DOWN
DLXTYP::! BLOCK	1		;TYPE OF PDP11 (FOR CALL11)
DLXTIM::! BLOCK	1		;CONTAINS UPTIME OF TIMEOUT, OR 0
DLXPRE::! BLOCK	1		;
DLXCEV::! BLOCK	1		;CAL11. UUO ENTRY VECTOR
DLXFEK::! BLOCK	1		;ADDRESS OF ASSOCIATED FEK
DLXLEN::!			;LENGTH OF COMMON BASE TABLE AREA
	  DEPHASE

IFN FTKL10,<		;DL10 SPECIFIC BASE TABLE OFFSETS
	  PHASE	DLXLEN
DLXMSK::! BLOCK	1		;MASK OF FRONT END BITS
DLXKAX::! BLOCK	1		;INSTRUCTION FOR NON-KA10 STYLE INTERRUPTS
DLXSWA::! BLOCK	1		;WINDOW ADDRESS
DLXENB::! BLOCK	1		;INSTRUCTION TO ENABLE WINDOW AND INTERRUPTS
DLXCLR::! BLOCK	1		;INSTRUCTION TO CLEAR PORT ENABLE
DLXCNI::! BLOCK	1		;INSTRUCTION TO READ DL10 CONDITIONS
DLXI11::! BLOCK	1		;
DLXDBL::!			;LENGTH OF DL10 BASE TABLE
	  DEPHASE
> ;END IFN FTKL10

IFN FTKL10,<			;DTE SPECIFIC BASE TABLE OFFSETS
	  PHASE	DLXLEN
DLXEVM::! BLOCK	1		;REMEMBER NUMBER OF PAGES OF EVM AND THE EXEC
				; VIRTUAL ADDR FOR RETURNING EVM
DLXOCN::! BLOCK	1		;COUNT OF BYTES IN DIRECT OUT MSG
DLXODA::! BLOCK	2		;BYTES TO BE PUT IN THE DIRECT MSG
DLXICI::! BLOCK	1		;# BYTES EXPECTING IN THE INDIRECT INPUT MSG
DLXIBP::! BLOCK	1		;BYTE PTR TO USER BUFFER PASSED TO DTESER
DLXICN::! BLOCK	1		;COUNT OF BYTES RECEIVED IN INPUT DIRECT MSG
DLXIDA::! BLOCK	2		;BYTES FROM THE INPUT DIRECT MSG
DLXETD::! BLOCK	1		;POINTER TO CORRESONDING ETD
DLXSBL::!			;DTE BASE TABLE LENGTH
	  DEPHASE
> ;END IFN FTKL10

IFN FTKS10,<			;KMC/DUP SPECIFIC BASE TABLE OFFSETS
				;D6RINT USES THE SAME OFFSETS...
	  PHASE	DLXLEN
DLXFLG::! BLOCK	1		;GENERAL PURPOSE FLAGS WORD (SEE D6KINT)
DLXICI::! BLOCK	1		;# BYTES EXPECTING IN THE INDIRECT INPUT MSG
DLXIBP::! BLOCK	1		;BYTE POINTER TO USER BUFFER PASSED TO KDPINT
DLXIMQ::! BLOCK	1		;INPUT MESSAGE QUEUE (0 OR 1 LONG)
DLXKBL::!			;KMC/DUP (AND DMR) BASE TABLE LENGTH
	  DEPHASE
> ;END IFN FTKS10
SUBTTL	BASE TABLE GENERATION -- DL10


DEFINE	BASE11	(CPX,N),<	;;CPX = CPU NUMBER, N = PORT NUMBER
IFN TP.DL'N,<			;;IF A PDP11
IFE M'CPX'N'D78,<		;; BUT NOT A DAS78
DL'CPX'N'BS:
	BLOCK	DLXDBL		;;RESERVE SPACE FOR ONE DL10 BASE TABLE

IFLE N-3,<			;;DL10 #0
	DLX=DLC			;;CONTROL REGISTER
	DLBX=DLB		;;BASE ADDRESS REGISTER
>
IFG N-3,<			;;DL10 #1
	DLX=DLC2		;;CONTROL REGISTER
	DLBX=DLB2		;;BASE ADDRESS REGISTER
>

;; MACRO TO LOAD UP TABLE LOCATIONS
DEFINE	X	(OFS,DAT),<
	LOC	DL'CPX'N'BS+OFS
	DAT
>

;; DATA COMMON TO ALL DL10 BASE TABLES
X	DLXWIN,<.DL'CPX'N'B>	;;WINDOW ADDRESS
X	DLXINI,<JFCL>		;;DO THIS ON INTERRUPT
X	DLXPRG,<JFCL>		;;DO THIS WHEN THE -11 GOES DOWN
X	DLXMSK,<777777700007!<70_<<N&3>*3>>>
				;;"AND" OUT OTHER PDP11 BITS
X	DLXKAX,<DATAO	DLX,[XWD 400001,0]>
				;;NON-KA10 STYLE INTERRUPTS
X	DLXSWA,<CONO	DLBX,.DL'CPX'N'B+<M7'N'BAM>_2+<N&3>>
				;;WINDOW ADDRESS
X	DLXENB,<CONO	DLX,1B19+1B20+<1B31_<<N&3>*3>>+SCNCHN>
				;;ENABLE WINDOW AND INTERRUPTS.
X	DLXCLR,<CONO	DLX,1B19+<70_<<N&3>*3>>+SCNCHN>
				;;CLEAR PORT ENABLE
X	DLXCNI,<CONI	DLX,T1>	;;READ DL10 CONDITIONS
X	DLXI11,<CONO	DLX,1B19+1B20+<1B30_<<N&3>*3>>+SCNCHN>
				;;INTERRUPT THE PDP11

IFN M'CPX'N'D85,<		;;ANF10 DC75/DN87 FRONT ENDS
X	DLXSTA,<SETOM DLXTA(P1)>;;MARK -10 AS BEING ALIVE
X	DLXTYP,.C1D75		;;TYPE OF PDP11
X	DLXPRE,<PUSHJ P,D85PRE##>;;
X	DLXCEV,0		;;CAL11. UUO ENTRY VECTOR
X	DLXFEK,<D8'N'FEK>	;;ADDRESS OF ASSOCIATED FEK
>

IFN    M'CPX'N'D60,<		;;DN60 FRONT ENDS
X	DLXSTA,<SETOM DLXTA(P1)>;;MARK -10 AS BEING ALIVE
X	DLXTYP,.C1D60		;;TYPE OF PDP11
X	DLXPRE,<JFCL>		;;
X	DLXCEV,<JRST D60CEV##(P1)> ;;CAL11. UUO ENTRY VECTOR
X	DLXFEK,<D8'N'FEK>	;;ADDRESS OF ASSOCIATED FEK
>

	LOC	DL'CPX'N'BS+DLXDBL
> ;END IFE M'CPX'N'D78
> ;END IFN TP.DL'N
> ;END BASE11 MACRO
SUBTTL	BASE TABLE GENERATION -- DTE


DEFINE	BASDTE	(CPX,DTX),<
DS'CPX'DTX'BS::
	BLOCK	DLXSBL		;;RESERVE SPACE FOR ONE DTE BASE TABLE

; MACRO TO LOAD UP TABLE LOCATIONS
DEFINE	X	(OFS,DAT),<
	LOC	DS'CPX'DTX'BS+OFS
	DAT
>

;; DATA COMMON TO ALL DTE BASE TABLES
X	DLXWIN,<XWD CPX,DTX>	;;CPU#,,DTE#
X	DLXSTA,<JFCL>		;;DTE KNOWS WHEN THE -10'S ALIVE
X	DLXINI,<JFCL>		;;DO THIS ON INTERRUPT
X	DLXPRG,<JFCL>		;;DO THIS WHEN THE -11 GOES DOWN
X	DLXPRE,<JFCL>		;;


X	DLXNMT,<SIXBIT /NOBODY/>;;NAME
X	DLXTYP,.C1CFE		;;FRONT END TYPE
X	DLXFEK,<S'CPX'DTX'FEK>	;;ADDRESS OF ASSOCIATED FEK
X	DLXETD,<CONC(ETD'CPX,\<DTX+1>,B##)> ;;ADDRESS OF ASSOCIATED ETD

	LOC	DS'CPX'DTX'BS+DLXSBL
> ;END BASDTE MACRO
SUBTTL	BASE TABLE GENERATION -- KMC/DUP


DEFINE BASKDP	(KMX,KLX),<	;;KMX = KMC #, KLX = DUP # (KMX == 0)
DK'KMX'KLX'BS:
	BLOCK	DLXKBL		;;RESERVE SPACE FOR ONE KMC/DUP BASE TABLE

; MACRO TO LOAD UP TABLE LOCATIONS
DEFINE	X	(OFS,DAT),<
	LOC	DK'KMX'KLX'BS+OFS
	DAT
>
;; DATA COMMON TO ALL KMC/DUP BASE TABLES
X	DLXWIN,<KDL'KLX'PG>	;;KDL BASE TABLE
X	DLXSTA,<JFCL>		;;KDP KNOWS WHEN THE -10 IS ALIVE
X	DLXINI,<JFCL>		;;DO THIS ON INTERRUPT
X	DLXPRG,<JFCL>		;;DO THIS WHEN THE -11 GOES DOWN
X	DLXPRE,<JFCL>		;;


IFE <M.'KLX'KDP-KD.ANF>,<	;;ANF10 FRONT ENDS
X	DLXNMT,<SIXBIT /ANF10/>	;;NAME
X	DLXTYP,.C1D22		;;TYPE OF PDP11
X	DLXCEV,0		;;CAL11. UUO ENTRY VECTOR
X	DLXFEK,DK'KLX'FEK	;;ADDRESS OF ASSOCIATED FEK
>

IFE <M.'KLX'KDP-KD.DNT>,<	;;DECNET FRONT ENDS
X	DLXNMT,<SIXBIT /DECNET/>;;NAME
X	DLXTYP,.C1D22		;;TYPE OF PDP11
X	DLXCEV,0		;;CAL11. UUO ENTRY VECTOR
X	DLXFEK,0		;;ADDRESS OF ASSOCIATED FEK
>

IFE <M.'KLX'KDP-KD.USR>,<	;;USER FRONT ENDS
X	DLXNMT,<SIXBIT /USER/>	;;NAME
X	DLXTYP,.C1D22		;;TYPE OF PDP11
X	DLXCEV,0		;;CAL11. UUO ENTRY VECTOR
X	DLXFEK,0		;;ADDRESS OF ASSOCIATED FEK
>

IFE <M.'KLX'KDP-KD.IBM>,<	;;DN60 FRONT ENDS
X	DLXNMT,<SIXBIT /DN60/>	;;NAME
X	DLXTYP,.C1D60		;;TYPE
X	DLXCEV,<JRST D6KCEV##(P1)> ;;CAL11. UUO ENTRY VECTOR
X	DLXFEK,0		;;ADDRESS OF ASSOCIATED FEK
>

	LOC	DK'KMX'KLX'BS+DLXKBL
> ;END BASKDP MACRO
SUBTTL	BASE TABLE GENERATION -- DMR


DEFINE BASDMR	(DRX),<	;;DRX = DMR #
DMR'DRX'BS:
	BLOCK	DLXKBL		;;RESERVE SPACE FOR ONE DMR BASE TABLE

; MACRO TO LOAD UP TABLE LOCATIONS
DEFINE	X	(OFS,DAT),<
	LOC	DMR'DRX'BS+OFS
	DAT
>
;; DATA COMMON TO ALL DMR BASE TABLES
X	DLXWIN,<DMR'DRX>	;;DMR BASE TABLE
X	DLXSTA,<JFCL>		;;DMR KNOWS WHEN THE -10 IS ALIVE
X	DLXINI,<JFCL>		;;DO THIS ON INTERRUPT
X	DLXPRG,<JFCL>		;;DO THIS WHEN THE -11 GOES DOWN
X	DLXPRE,<JFCL>		;;


IFE <M.'DRX'DMR-RD.ANF>,<	;;ANF10 FRONT ENDS
X	DLXNMT,<SIXBIT /ANF10/>	;;NAME
X	DLXTYP,.C1D22		;;TYPE OF PDP11
X	DLXCEV,0		;;CAL11. UUO ENTRY VECTOR
X	DLXFEK,DR'DRX'FEK	;;ADDRESS OF ASSOCIATED FEK
>

IFE <M.'DRX'DMR-RD.DNT>,<	;;DECNET FRONT ENDS
X	DLXNMT,<SIXBIT /DECNET/>;;NAME
X	DLXTYP,.C1D22		;;TYPE OF PDP11
X	DLXCEV,0		;;CAL11. UUO ENTRY VECTOR
X	DLXFEK,0		;;ADDRESS OF ASSOCIATED FEK
>

IFE <M.'DRX'DMR-RD.USR>,<	;;USER FRONT ENDS
X	DLXNMT,<SIXBIT /USER/>	;;NAME
X	DLXTYP,.C1D22		;;TYPE OF PDP11
X	DLXCEV,0		;;CAL11. UUO ENTRY VECTOR
X	DLXFEK,0		;;ADDRESS OF ASSOCIATED FEK
>

IFE <M.'DRX'DMR-RD.IBM>,<	;;DN60 FRONT ENDS
X	DLXNMT,<SIXBIT /DN60/>	;;NAME
X	DLXTYP,.C1D60		;;TYPE
X	DLXCEV,<JRST D6RCEV##(P1)> ;;CAL11. UUO ENTRY VECTOR
X	DLXFEK,0		;;ADDRESS OF ASSOCIATED FEK
>

	LOC	DMR'DRX'BS+DLXKBL
> ;END BASDMR MACRO
IFN PDP11N,<	;IF DL10 BASED PDP11S

	$HIGH
IFN M.DAS78,<XXIINT:>		;DAS78 XXI INTERRUPTS HERE
DLXINT:	JRST	DLXSCC		;START OF KA STYLE INTERRUPT CHAIN
	JRST	.-1		;MAKE SYSINI HAPPY

IFN M.DAS78,<
DEFINE	B78BT	(CPU,PORT),<
	IFNDEF	M8'CPU'PORT'BT,<EXP	Z>
	IFDEF	M8'CPU'PORT'BT,<EXP	M8'CPU'PORT'BT>>
	$HIGH
M78BT::
ZZZ=0
	REPEAT	10,<
	B78BT	(0,\ZZZ)
	ZZZ=ZZZ+1>
>;END IFN M.DAS78
	$ABS


ZZZ==0				;GENEATE INTERRUPT ROUTINE FOR EACH
	REPEAT	10,<		; DL10 BASED DAS78
	EACH78	(\ZZZ)
	ZZZ==ZZZ+1
>
ZZZ=0				;GENERATE INTERRUPT ROUTINE FOR EACH
	REPEAT	10,<		; DL10 BASED ANF10 PDP11
	EACH76(\ZZZ)
	ZZZ==ZZZ+1
>
	$HIGH
	JRST	DLXINT+1	;CONSO CHAIN FALLS OUT HERE

	$ABS
;
; GENERATE THE BASE TABLES.  ONE FOR EACH DL10 PDP11 AND ONE
;  FOR EACH PDP11 ON A DTE20 (EXCEPT FOR THE CONSOLE AND
;  DN87S'S)

;FIRST THE DL-10 BASED FRONT ENDS
ZZZ==0				;START WITH #0
    REPEAT 8,<
	BASE11(0,\ZZZ)		;BUILD THE NEXT BASE TABLE
	ZZZ==ZZZ+1>		;STEP TO THE NEXT DL-10 PORT
> ;END OF IFN PDP11N

;NOW THE DTE-20 BASED FRONT ENDS
IFN FTKL10,<
ZZ==0				;CPU #
    REPEAT M.CPU,<		;FOR ALL CPU'S
	ZZZ==0			;DTE NUMBER
	REPEAT 4,<		;FOR ALL DTE'S ON THIS CPU
	    BASDTE(\ZZ,\ZZZ)	;BUILD A BASE TABLE
	ZZZ==ZZZ+1>		;STEP TO THE NEXT DTE
    ZZ==ZZ+1>			;STEP TO THE NEXT CPU
> ;END FTKL10
	$ABS

;BASE TABLES FOR KDP'S (IF USING IBM COMM)
IFN FTKS10,<
    ZZ==0			;START OUT ON LINE ZERO
    REPEAT M.KDUP,<		;FOR ALL LINES
	BASKDP(0,\ZZ)		;BUILD A BASE TABLE
	ZZ==ZZ+1>		; AND STEP TO THE NEXT
    ZZ==0			;START OUT ON LINE ZERO
    REPEAT M.DMRN,<		;FOR THE DMRS TOO
	BASDMR(\ZZ)		;BUILD A BASE TABLE
	ZZ=ZZ+1>		;AND STEP TO THE NEXT
>; END FTKS10
IFN PDP11N,<
	$HIGH
; BUILD THE BASE TABLES FOR ANF10 AND DAS78 FRONT ENDS

DEFINE	B78BAT	(CPU,PORT),<
IFE	TP.DL'PORT,<EXP	0>
IFN	TP.DL'PORT,<
	IFE	M'CPU'PORT'D78,<EXP	0>
	IFN	M'CPU'PORT'D78,<XWD	M8'PORT'DDB,.DL'CPU'PORT'B>
> ;;END IFN TP.DL'PORT
> ;END B78BAT

DEFINE	BLXBAT	(CPU,PORT),<
IFE	TP.DL'PORT,<EXP	0>
IFN	TP.DL'PORT,<
	IFE	M'CPU'PORT'D78,<EXP	DL'CPU'PORT'BS>
	IFN	M'CPU'PORT'D78,<EXP	0>
> ;;END IFN TP.DL'PORT
> ;END BLXBAT

DLXBAT::			;START OF THE ANF10 MAPPING TABLE
ZZZ==0				;PORT COUNTER
    REPEAT 8,<			;FOR ALL POSSIBLE PORTS
	BLXBAT	(0,\ZZZ)	;EXPAND THE MACRO
	ZZZ==ZZZ+1>		;AND STEP TO THE NEXT PORT


IFN M.DAS78,<
M78BAT::			;START OF THE DAS78 MAPPING TABLE
ZZZ==0				;PORT COUNTER
	REPEAT 8,<		;FOR ALL POSSIBLE PORTS
	B78BAT	(0,\ZZZ)	;EXPAND THE MACRO
	ZZZ==ZZZ+1>		;AND STEP TO THE NEXT PORT


	$ABS
; MACRO TO BUILD A TABLE CONTAINING DDB ADDRESSES FOR EACH DAS78
DEFINE	B78DDB	(CPU,PORT),<
IFDEF	M8'PORT'KII,<M8'PORT'DDB::BLOCK	M'CPU'PORT'D78>
> ;END B78DDB
M78DDB::
ZZZ==0
	REPEAT	8,<		;FOR ALL POSSIBLE PORTS
	B78DDB	(0,\ZZZ)	;EXPAND THE MACRO
	ZZZ==ZZZ+1>		;AND STEP TO THE NEXT PORT

	$HIGH
; MACRO TO BUILD A TABLE WHICH CONTAINS THE LAST USED LOCATION IN
; THE DAS78 WINDOW FOR EACH PORT.
DEFINE	B78END	(CPU,PORT),<
	IFNDEF	M'CPU'PORT'END,<EXP	0>
	IFDEF	M'CPU'PORT'END,<EXP	M'CPU'PORT'END>
> ;END B78END

M78END::
ZZZ==0
	REPEAT	8,<
	B78END	(0,\ZZZ)
	ZZZ==ZZZ+1>

; MACRO TO BUILD A TABLE WHICH CONTAINS THE NUMBER OF LINES
; ON EACH DAS78
DEFINE	B78LIN	(CPU,PORT),<EXP	M'CPU'PORT'D78>

M78LIN::
ZZZ==0
	REPEAT	8,<		;FOR ALL POSSIBLE PORTS
	B78LIN	(0,\ZZZ)	;EXPAND THE MACRO
	ZZZ==ZZZ+1>		;AND STEP TO THE NEXT PORT

	$ABS
D78NAM::BLOCK	10		;TABLE OF NAMES FILLED IN BY THE PDP11
				; THROUGH A POINTER IN THE DAS78 WINDOW
> ;END IFN M.DAS78
> ;END OF IFN PDP11N

	$HIGH


;HELPER MACRO FOR SETTING UP THE DTE -- BASE TABLE CORRESPONDENCE MAP
DEFINE	BLXBAT	(CPX,DTX),<EXP DS'CPX'DTX'BS>

DTEBAS::			;START OF THE DTE TO BASE TABLE MAPPING
IFN FTKL10,<
ZZ==0				;CPU COUNTER
    REPEAT M.CPU,<		;FOR ALL CPU'S
	ZZZ==0			;ZERO THE DTE COUNTER
	REPEAT 4,<		;FOR ALL DTE-20S
	    BLXBAT(\ZZ,\ZZZ)	;MAKE THE MAP ENTRY
	    ZZZ==ZZZ+1>		; STEP TO THE NEXT DTE
	ZZ==ZZ+1>		; STEP TO THE NEXT CPU
>


DEFINE BLXBAT(KMX,KLX),<EXP DK'KMX'KLX'BS>	;BASE TABLE ADDRESS

KDPBAS::			;START OF THE KDP BASE TABLES
IFN M.DN60&M.DN6K,<		;IF WE HAVE IBM
    ZZ==0			;START AT THE FIRST LINE
    REPEAT M.KDUP,<		;FOR ALL LINES
	BLXBAT(0,\ZZ)		;EXPAND A POINTER TO THEM
	ZZ==ZZ+1>		;STEP TO THE NEXT
>; END IFN M.DN60&M.DN6K

DEFINE BLXBAT(DRX),<EXP DMR'DRX'BS>	;BASE TABLE ADDRESS

DMRBAS::			;START OF THE DMR BASE TABLES
IFN M.DN60&M.DN6R,<		;IF WE HAVE IBM
    ZZ==0			;START AT THE FIRST LINE
    REPEAT M.DMR,<		;FOR ALL LINES
	BLXBAT(\ZZ)		;EXPAND A POINTER TO THEM
	ZZ==ZZ+1>		;STEP TO THE NEXT
>; END M.DN60&M.DN6R


	$ABS
IFNDEF DLXFST,<DLXFST==:.>		;START OF DL10 UNCACHED SPACE
DLXLST::	;END OF UN-CACHED AREA

	LIT		;FORCE ANY INITIALIZATION LITERALS INTO LOW SEGMENT
SUBTTL	BACKGROUND PERFORMANCE ANALYSIS SELECTION TABLE

IFN	M.KL10&FTRSP,<

	$HIGH		;THE TABLE IS "PURE"

;BPATAB  --  TABLE OF BACKGROUND PERFORMANCE ANALYSIS CONDITIONS
;
;THIS TABLE CONTAINS THE ORDERED LIST OF "ASPECTS" OF THE SYSTEM
;TO WATCH VIA THE PERFORMANCE ANALYSIS METER OF THE KL-10 CPU.
;
;EACH ITEM IN THE BPATAB TABLE HAS A CORRESPONDING 4-WORD BLOCK IN
;THE CDB VARIABLES AREA (SUBTABLE .CPBPV). THE FIRST TWO WORDS ARE
;THE RDTIME TOTAL FOR WHICH THE CONDITION(S) WAS(WERE) WATCHED, AND
;THE SECOND TWO WORDS ARE THE PERFORMANCE METER COUNT FOR THE ENABLED
;CONDITION(S) - EITHER AN INTEGER COUNT IF IN EVENT MODE OR ELAPSED
;TIME IF IN DURATION MODE. THE ORDER OF THE TABLE IS IMPORTANT SINCE
;THE NUMBERS ARE GETTAB'ED OUT OF THE .CPBPV SUBTABLE.
;
;ALTHOUGH THIS TABLE REALLY BELONGS IN APRSER IT MUST APPEAR IN COMMON
;BEFORE THE CDB DEFINITIONS AS THE LENGTH OF THE TABLE IS NEEDED TO
;DEFINE THE CDB VARIABLES SUBTABLE.

BPATAB::PE.CP0!PE.UCI!PE.PRI!PE.CCI!PE.PPI!PE.PCI!PE.CLR	;CH 0
	PE.CP1!PE.UCI!PE.PRI!PE.CCI!PE.PPI!PE.PCI!PE.CLR	;CH 1
	PE.CP2!PE.UCI!PE.PRI!PE.CCI!PE.PPI!PE.PCI!PE.CLR	;CH 2
	PE.CP3!PE.UCI!PE.PRI!PE.CCI!PE.PPI!PE.PCI!PE.CLR	;CH 3
	PE.CP4!PE.UCI!PE.PRI!PE.CCI!PE.PPI!PE.PCI!PE.CLR	;CH 4
	PE.CP5!PE.UCI!PE.PRI!PE.CCI!PE.PPI!PE.PCI!PE.CLR	;CH 5
	PE.CP6!PE.UCI!PE.PRI!PE.CCI!PE.PPI!PE.PCI!PE.CLR	;CH 6
	PE.CP7!PE.UCI!PE.PRI!PE.CCI!PE.PPI!PE.PCI!PE.CLR	;CH 7
	PE.CPI!PE.UCI!PE.PRI!PE.CCI!PE.PP0!PE.PCI!PE.CLR	;PI 0
	PE.CPI!PE.UCI!PE.PRI!PE.CCI!PE.PP1!PE.PCI!PE.CLR	;PI 1
	PE.CPI!PE.UCI!PE.PRI!PE.CCI!PE.PP2!PE.PCI!PE.CLR	;PI 2
	PE.CPI!PE.UCI!PE.PRI!PE.CCI!PE.PP3!PE.PCI!PE.CLR	;PI 3
	PE.CPI!PE.UCI!PE.PRI!PE.CCI!PE.PP4!PE.PCI!PE.CLR	;PI 4
	PE.CPI!PE.UCI!PE.PRI!PE.CCI!PE.PP5!PE.PCI!PE.CLR	;PI 5
	PE.CPI!PE.UCI!PE.PRI!PE.CCI!PE.PP6!PE.PCI!PE.CLR	;PI 6
	PE.CPI!PE.UCI!PE.PRI!PE.CCI!PE.PP7!PE.PCI!PE.CLR	;PI 7

	BPATLN==:.-BPATAB

	$ABS		;BACK TO "IMPURE"
> ;END OF IFN M.KL10&FTRSP
SUBTTL CPU DATA BLOCK(S):

REPEAT 0,<

EACH CPU HAS ITS OWN DATA BLOCK, KNOWN AS A CDB.  ALL .CP??? SYMBOLS ARE
DEFINED RELATIVE TO THE (MAPPED) CDB, .CN??? SYMBOLS ARE ABSOLUTE LOCATIONS.

A FEW LOCATIONS ARE REALLY SYSTEM PARAMETERS (EG. CORTAL), RATHER THAN CPU
PARAMETERS. HOWEVER, THEY WERE IN THE MIDDLE OF A GETTAB (NSWTBL) AND SO
COULD NOT BE SEPARATED OUT WITHOUT INVALIDATING SOME PROGRAMS.


WHEN ADDING CONSTANTS OR VARIABLES TO COMMON, GREAT CARE MUST BE EXERCISED
IN DECIDING WHETHER TO PUT IT IN THE CDB OR IN A SYSTEM DEPENDENT TABLE
(.SYTBL).  IF THE CONTENTS COULD EVER BECOME CPU DEPENDENT IN THE FUTURE,
BE SURE TO PUT IT IN THE CDB INSTEAD OF .SYTBL.  IF A MISTAKE IS MADE, THE
LOCATION WILL HAVE TO APPEAR IN THE CDBS AS WELL AS .SYTBL IN ORDER TO INSURE
COMPATIBLITY.

> ;END REPEAT 0
DEFINE	CDB	(N),<

;;MACRO TO GENERATE CPU DATA BLOCK LOCATIONS
;;ARGUMENTS:
;;	NAM	THREE LETTER SUFFIX FOR SYMBOL
;;	VAL	OPTIONAL VALUE TO STORE IN LOCATION (DEFAULT = ZERO)
;;	LEN	OPTIONAL LENGTH OF STORAGE AREA (DEFAULT = ONE WORD)
;;	LBL	OPTIONAL ALTERNATE LABEL FOR OLD-STYLE CPU0 REFERENCES

DEFINE	CWRD	(NAM,VAL,LEN,LBL,%X<N>),<

IFE %X,<IFNB <VAL>,<IFNB <LEN>,<PRINTX ? CDB location .CP'NAM defined with both a value and a length>>>

IFNB <NAM>,<
.C'%X'NAM::			;;CREATE CPU-SPECIFIC SYMBOL
.CP'NAM=:.-.C'%X'CDB+.EVCDB	;;CREATE GENERIC CDB SYMBOL
> ;;END IFNB <NAM>
IFE %X,<IFNB <LBL>,<LBL=:.>>	;;GENERATE ALTERNATE LABEL
IFB  <LEN>,<VAL>		;;STORE POSSIBLE VALUE
IFNB <LEN>,<REPEAT LEN,<EXP 0>>	;;CREATE STORAGE BLOCK
IFB  <VAL>,<IFB <LEN>,<EXP 0>>	;;IF VALUE AND LENGTH BLANK, STORE A ZERO
> ;;END DEFINE CWRD


;;MACRO TO DEFINE A CONSTANT IF THIS IS THE CPU0 CDB
DEFINE	CCON	(A,B),<IFE N,<A==:B>>


;;MACRO TO DEFINE JSR ENTRY POINT
DEFINE	CJSR	(NAM,ADR),<
	CWRD	(NAM)
	EXP	<ADR>
> ;;END DEFINE CJSR


;;MACRO TO DEFINE AN XPCW ENTRY POINT
DEFINE	CXPC	(NAM,FLG,ADR),<
	CWRD	(NAM,,2)
	EXP	FLG,ADR
> ;;END DEFINE CXPC


;;MACRO TO DETDEFINE A PARAMETER BASED ON THE CPU TYPE
DEFINE	KILS,<
	IFN	M.KL10,<KL>
	IFN	M.KS10,<KS>
> ;;END DEFINE KILS
CPU'N::
;CONSTANTS IN GETTAB UUO.(NOT CLEARED AT STARTUP OR 143 RESTART)

	IFE <M.CPU-N-1>,<.XX==0>
	IFG <M.CPU-N-1>,<.XX==<.C'N'CDB+.CPLEN,,0>>
CWRD (CDB,.XX)			;;(000) LH = ADR OF NEXT CDB
				;;      RH = 0
CWRD (ASN,M.C'N'SN)		;;(001) APR SERIAL NUMBER
CWRD (OK,1)			;;(002) THIS CPU RUNNING OK.
				;;      IF GREATER THAN 0, THIS CPU HAS STOPPED
				;;      RUNNING CORRECTLY.  CONTENTS ARE NO. OF
				;;      JIFFIES CPU HAS BEEN STOPPED.
CWRD (EPT,.E'N'EPT)		;;(003) CONTAINS EPT ADDRESS
CWRD (LOG,<SIXBIT/CPU'N/>)	;;(004) LOGICAL CPU NAME (CPUN)
	DEFINE	KL,<SIXBIT /CPL'N/>
	DEFINE	KS,<SIXBIT /CPS'N/>
CWRD (PHY,<KILS>)		;;(005) PHYSICAL CPU NAME (CPXN)
	DEFINE	KL,<CT.KL>
	DEFINE	KS,<CT.KS>
CWRD (TYP,<KILS>)		;;(006) TYPE OF PROCESSOR
				;;      LH = CUSTOMER DEFINED
				;;      RH = DEC DEFINED
CWRD (MPT,<<M.CBAT-1>B8+.C'N'BAT-.C'N'VBG>) ;;(007) BAD ADDRESS SUBTABLE
CWRD (RTC,0)			;;(010) REAL TIME CLOCK (DK10) DDB
CWRD (RTD,0)			;;(011) DK10 DDB IF HI PREC TIME ACCOUNTING
CWRD (PAR,<<.CPPRL-1>B8+.C'N'LPA-.C'N'VBG>) ;;(012) PARITY SUBTABLE

IFE FTRSP,<.CPAOR==:.CPVBG>	;;NO SUBTABLE IF NO RESPONSE STUFF
IFE FTRSP,<.CPRSL==:1>		;;MAX IS 0
CWRD (RSP,<<.CPRSL-1>B8+.C'N'AOR-.C'N'VBG>) ;;(013) RESPONSE SUBTABLE
CWRD (DKX,0)			;;(014) NUMBER OF DK10S ON THIS CPU

	DEFINE	KL,<M.EBPS>
	DEFINE	KS,<0>
CWRD (EBS,<KILS>)		;;(015) EBOX TICKS PER SECOND

	DEFINE	KL,<M.MBPS>
	DEFINE	KS,<0>
CWRD (MBS,<KILS>)		;;(016) MBOX TICKS PER SECOND
CWRD (NMT,<<.CPNML-1>B8+.C'N'LNA-.C'N'VBG>) ;;(017) NXM SUBTABLE
CWRD (CSB,<<.CPCSL-1>B8+.C'N'APD-.C'N'VBG>) ;;(020) CPU STATUS SUBTABLE
CWRD (DSB,<<.CPDVL-1>B8+.C'N'DVS-.C'N'VBG>) ;;(021) DEVICE STATUS SUBTABLE
	DEFINE	KL,<<.CPSDL-1>B8+.C'N'SBD-.C'N'VBG>
	DEFINE	KS,<0>
CWRD (SDP,<KILS>)		;;(022) SBDIAG SUBTABLE
	IFE	M.KL10&FTRSP,<.XX==0>
	IFN	M.KL10&FTRSP,<.XX==<BPATLN*4>B8+.C'N'BPV-.C'N'VBG>
CWRD (BPA,<.XX>)		;;(023) PERORMANCE SUBTABLE
CWRD (PCB,0)			;;(024) ADDRESS OF CI PORT CONTROL BLOCK
CWRD (NPB,0)			;;(025) ADDRESS OF NI PORT CONTROL BLOCK
	DEFINE	KL,<0>
	DEFINE	KS,<<.CPSML-1>B8+.C'N'SME-.C'N'VBG>
CWRD (MSS,<KILS>)		;(026) SOFT MEMORY ERROR SUBTABLE

;;ADD CONSTANTS TO BE PUBLISHED ABOVE HERE:

CCON (.CPPCL,<<.-.C0CDB>B26>)	;;PUBLISHED CPU DEPENDANT CONSTANTS LENGTH
;UNPUBLISHED CONSTANTS:

CWRD (MAP,.E'N'MAP)		;;ADDRESS OF THIS CPU'S EXEC MAP
CWRD (SPT,<SPTTAB+N>)		;;SPECIAL PAGES TABLE

IFN FTMP,<
CWRD (CHX,0)			;;CACHE SWEEP FLAG FOR MAGTAPES AND DISKS
> ;END IFN FTMP
CWRD (CPN,<EXP N>)		;;CPU NUMBER
	DEFINE CPUDEF(M)<
	IFE N,<
		IFE M,<CAIA>
		IFN M,<CAI>>
	IFN N,<
		IFN M,<CAIA>
		IFE M,<CAI>>
	> ;;END DEFINE CPUDEF
CWRD (SK0,<CPUDEF(0)>)		;;GENERATE SKIP FOR "SKPCPU(0)"
CWRD (SK1,<CPUDEF(1)>)		;;AND FOR "SKPCPU(1)" **MAINTAIN ORDER**
CWRD (OK1,.C0OK)		;;CONTAINS ADR OF OTHER CPU
CWRD (SLF,.C'N'CDB)		;;POINTER TO START OF CDB

	DEFINE	SCNLOC,<
	IFE	N,<SSCAN>
	IFN	N,<SSCAN1>
	>
CWRD (SCN,<SCNLOC>)		;;ADDRESS OF SCHEDULER RUN QUEUE SCAN LIST

	IFN FTNSCHED,<
	DEFINE	SCN,<
	IFE	N,<SSSCAN>
	IFN	N,<SSSCN1>
	>
CWRD (SST,<SCN>);
> ;END IFN M.CPU-1

CWRD (NPD,<MNULPD,,NU'N'PDL>)	;;NULL PDL POINTER
CWRD (EPD,<ERRPLL,,ER'N'PDL>)	;;ERROR PDL POINTER
CWRD (NJD,NU'N'DAT)		;;ADDRESS OF NULL JOB DATA AREA OFFSET BY 20
				;; USED TO SAVE ACS IN 20-37.
CWRD (STO,SC'N'TIC##)		;;SCANNER ONCE A TICK ROUTINE FOR THIS CPU
CWRD (ISR,SC'N'SEC##)		;;SCANNER ONCE A SECOND
IFN FTMP,<
CWRD (DLK,-1)			;;DISK INTERLOCK NESTING FLAG
CWRD (SCD,-1)			;;PER CPU SCHEDULER INTERLOCK FLAG
CWRD (DIE,-1)			;;PER CPU DIE INTERLOCK FLAG
CWRD (RES,<HALT APRPFR##>)	;;RESTORE AFTER POWER FAIL
CWRD (NBI,0)			;;NUMBER OF INTERLOCKS THAT WERE OWNED
				;; BY THIS CPU AND BROKEN BY BRKLOK
> ;END IFN FTMP
	PWFLEN==:3		;;NUMBER OF POWER FAIL DATA WORDS
CWRD (PFD,,PWFLEN)		;;POWER FAIL/RESTART DATA
CWRD (KAF,AP'N'KAF)		;;KEEP-ALIVE FAILURE TRAP ADDRESS
CWRD (SVP,0)			;;SAVED AC P ON KAF
CWRD (KFP,0)			;;KAF PDL
CWRD (EPL,EP'N'PDL)		;;PDL FOR PROCESSING PDL OVF

;;APR DEPENDENT CONSO AND CONO BITS
CWRD (CHL,<AP'N'CHL>)		;;ADDRESS OF INTERRUPT PC FOR APR
CWRD (CKL,<CK'N'CHL>)		;;ADDRESS OF INTERRUPT PC FOR CLOCK
CWRD (APP,<-PDL+1,,AP'N'PD1>)	;;PDP FOR APR CHANNEL
CWRD (CON,AP.CSO)		;;APR CONSO MASK
CWRD (EEB,AP.EEB)		;;EXEC ENABLED BITS
CWRD (IEF,AP.CAE)		;;MASK TO CLEAR APR ERROR BITS
CWRD (MPS,<CP.PXX+CP.PS'N'>)	;;LH=BITS TO REQUEST SCAN
;;DOORBELL WORDS
;CWRD (BIT,<1_M.CPU-1>)		;;CPU'S BIT

	DEFINE	EVENTM(LIST),<
	NARGS==0
	IRP LIST,<NARGS==NARGS+1>
	IFG NARGS*M.CPU-^D36,<PRINTX ?DOORBELL BIT OVERFLOW>
	ZZ==0
	XX2==0
	IRP LIST,<
	XX1==1_<<ZZ*M.CPU>+N>
	XX2==XX2+XX1
CWRD (LIST'S,<<<<1_M.CPU>-1>_<ZZ*M.CPU>>-XX1>)
CWRD (LIST'C,<XX1>)
	ZZ==ZZ+1
	>
CWRD (DBM,XX2)
.C'N'BIT==:.C'N'SCC
.CPBIT=:.C0BIT-.C0CDB+.EVCDB
>
	EVENTM (<SC,QP>)

	DEFINE	KL,<LG.TEN+LG.KLP+.E'N'EPT/PAGSIZ>
	DEFINE	KS,<SG.TEN+SG.KLP+.E'N'EPT/PAGSIZ>
CWRD (EBR,<KILS>)		;;EXEC BASE REGISTER ON THIS CPU
IFN M.KS10,<
CWRD (FEF,0)			;;FLAG SET NON-ZERO WHEN FE INTERRUPTS
> ;END IFN M.KS10
CWRD (CTN,CT'N'LIN##)		;;RH = CTY NUMBER FOR THIS CPU
				;;LH = DLS LINE NUMBER ON DTE
IFN M.KL10,<
CWRD (TTD,M'N'TTDN)		;TTYS ON THIS CFE
CWRD (ETD,<IFIW ETDTB'N'##(F)>)	;;ETD TABLE FOR THIS CPU
CWRD (SPF,0)			;;CFE SECONDARY PROTOCOL FLAGS (^-FEATURES)
CWRD (SCA,-1)			;;SCA INTERLOCK NESTING
IFN M.SCA,<
CWRD (SCP,0)			;;SCA CHANNEL ENABLE STATES
>; END IFN M.SCA
>; END IFN M.KL10
CWRD (SIN,-1)			;;SCNSER INTERLOCK NESTING
IFN M.TAPE,<
CWRD (TPN,-1)			;;MAGTAPE INTERLOCK NESTING
CWRD (TPP,0)			;;MAGTAPE CHANNEL ENABLE STATES
> ;END IFN M.TAPE
IFN FTENET,<
CWRD (ETH,-1)			;;ETHERNET INTERLOCK NESTING
>; END IFN FTENET
CWRD (CA0,,20,CRSHAC)		;AC BLOCK 0 ON A CRASH
	.C'N'CAC==.C'N'CA0	;;YET ANOTHER NAME
	.CPCAC==:.C'N'CA0-.C'N'CDB+.EVCDB ;;...
CWRD (STT,0)			;;TEMP USED BY APRSER FOR TRAP PROCESSING

;;THE FOLLOWING TWO ENTRIES MUST BE CONTIGUOUS
CWRD (ST1,0)			;;PLACE TO SAVE T1 ON PAGE TRAPS
CWRD (ST2,0)			;;PLACE TO SAVE T2 ON PAGE TRAPS

;;THE FOLLOWING TWO ENTRIES MUST BE CONTIGUOUS
CWRD (TPC,0)			;;TEMP USED BY APRSER FOR IME PROCESSING
CWRD (TP1,0)			;;TEMP USED BY APRSER FOR IME PROCESSING
CWRD (TPF,0)			;;TEMP USED BY APRSER FOR IME PROCESSING
CWRD (EJT,0)			;;TEMP USED BY APRSER FOR IME PROCESSING
IFN FTRTTRP,<
IF1,<
CWRD (RCT,,6)			;;REAL TIME PI CHANNEL TABLE
CWRD (RDT,,6)			;;REAL TIME DISMISS TABLE
>
IF2,<
	ZZ==10*N+1

	DEFINE	BLDTB1(ZZ)
	<IFNDEF UNIQ'ZZ,<BLDTB2(ZZ)>
	IFDEF	UNIQ'ZZ,<IFE UNIQ'ZZ,<BLDTB2(ZZ)>
				IFN UNIQ'ZZ,<EXP 0>>>

	DEFINE	BLDTB2(ZZ)
	<IFN CUSD'ZZ,<EXP CH'ZZ>
	IFE	CUSD'ZZ,<XWD 400001,CH'ZZ>>

	DEFINE	BLDTB3(ZZ)
	<IFDEF CHND'ZZ,<XWD RTSV'ZZ,CHND'ZZ>
	IFNDEF	CHND'ZZ,<EXP 0>>

CWRD (RCT,,0)
REPEAT 6,<
	BLDTB1(\ZZ)
	ZZ==ZZ+1>

	ZZ==10*N+1


CWRD (RDT,,0)
REPEAT 6,<
	BLDTB3(\ZZ)
	ZZ==ZZ+1>
> ;;END IF2
> ;;END IFN FTRTTRP
CWRD (CPI,0)			;;PI STATUS

;;THE FOLLOWING TWO ENTRIES MUST BE CONTIGUOUS
CJSR (SVA,<JRST SVSETS>)	;;JSR HERE TO SAVE ALL AC SETS
CWRD (TRP,0)			;;MUUO DURING CRASH
CWRD (RTS,0)			;;TEMP USED DURING RTTRP ERROR PROCESSING
CWRD (RTT,0)			;;RTTRP IN PROGRESS FLAG (DEFINED
				;; HERE BECAUSE IT MUST BE 0 DURING ONCE-ONLY)
CWRD (TML,0)			;;VALUE OF "TIME" AT LAST CLOCK TIC
				;; USED FOR MAINTAINING CLOCK QUEUE AND
				;; SMITHSONIAN DATE
CWRD (OCB,0)			;;0 IF THIS CDB ISN'T OWNED BY ANY CPU
CWRD (DWD,-1)			;;RECURSION INTERLOCK FOR DIE

;;PI SAVE ROUTINES
.C'N'SAV==:.
.CPSAV=:.-.C'N'CDB+.EVCDB
	IFE N,<
		SAV1,,SAV1
		SAV2,,SAV2
		SAV3,,SAV3
		SAV4,,SAV4
		SAV5,,SAV5
		SAV6,,SAV6
	> ;;END IFE N
	IFN N,<
		SAVB'N'1,,SAV'N'1
		SAVB'N'2,,SAV'N'2
		SAVB'N'3,,SAV'N'3
		SAVB'N'4,,SAV'N'4
		SAVB'N'5,,SAV'N'5
		SAVB'N'6,,SAV'N'6
	> ;;END IFN N

;;START OF AUTOCONFIGURE DATA
CWRD (ATR,<-1>)			;;DATA BASE INTERLOCK REQUEST COUNT
CWRD (ATO,<-1>)			;;DATA BASE INTERLOCK OWNER ID
CWRD (ATP,0)			;;SAVED PI SYSTEMS STATE
CWRD (ASC,<-1>)			;;NUMBER OF AUTO-CONFIGURED SOFTWARE CHANNELS
CWRD (DVC,0)			;;DEVICE CODE
CWRD (DRV,0)			;;DRIVER DISPATCH
CWRD (CHA,0)			;;CHANNEL DATA BLOCK ADDRESS
CWRD (TSN,,2)			;;TEMPORARY DRIVE SERIAL NUMBER STORAGE
IFN M.KL10,<
CWRD (CNI,<CONI  000,T1>)	;;CONI
CWRD (CNO,<CONO  000,(T1)>) 	;;CONO
CWRD (DTI,<DATAI 000,T2>)	;;DATAI
CWRD (DTO,<DATAO 000,T2>)	;;DATAO
CWRD (BKI,<BLKI  000,T2>)	;;BLKI
CWRD (BKO,<BLKO  000,T2>)	;;BLKO
>; END IFN M.KL10
IFN M.KS10,<
CWRD (UMR,,MAXUBA)		;;HIGHEST MAPPING REGISTER ASSIGNED ON UBA
>; END IFN M.KS10
;;END OF AUTOCONFIGURE DATA

CWRD (CML,0)			;;LDB ADDRESS OF LINE ON WHICH COMMAND IS BEING
				;; PROCESSED ON THIS CPU
;;KL10 ERROR REPORTING/RECOVERY
IFN M.KL10,<
CWRD (SB0,<100000,,0>)		;;DO SBDIAG 0 HERE ON ERRORS
CWRD (S0A,<0>)			;;ANSWER RETURNED HERE
CWRD (SB1,<100000,,1>)		;;SBDIAG FN 1 DONE HERE
CWRD (S1A,<0>)			;;ANSWER RETURNED HERE
>;END IFN M.KL10

CWRD (TOA,CCTYO##)		;;TYPE OUT ADDRESS FOR THIS CPU (OLD COMTOA)
CWRD (TIV,0)			;;ADDRESS OF VECTOR OF INPUT ROUTINES
CWRD (LFC,0)			;;LAST FORCED COMMAND INDEX FOR JOB IN COMCON
;EXEC DDT WORDS
CWRD (DDT,<BPTNOP>)		;;NOOP OR INSTRUCTION TO ENTER EDDT
				;; THIS WORD MAY BE EXECUTED ANYTIME ANY
				;; ROUTINE WANTS TO ENTER EDDT VIA THE
				;; THE UNSOLICITED BREAKPOINT FACILITY.
				;; SETUP BY CPUDDT.

;;EXEC DATA VECTOR FOR EDDT SYMBOL TABLE HIDING
CWRD (EDV,<XWD 'EDV',.EDLEN>)	;;CODE,,LENGTH OF EXEC DATA VECTOR
DEFINE	HSBDEF<
IFE FTXMON,<.C'N'SYB>
IFN FTXMON,<0>
>
CWRD (ED1,<HSBDEF>)		;;ADDRESS OF THE ADDRESS SWAPPING BLOCK
CWRD (ED2,0)			;;RELOCATED CONTENTS OF .JBSYM
CWRD (ED3,0)			;;RELOCATED CONTENTS OF .JBUSY
CWRD (ED4,<.C'N'HSF>)		;;ADDRESS OF A WORD FOR DDT TO PLAY WITH
	DEFINE	KL,<CT.KL!ED.KLP!ED.XKL>
	DEFINE	KS,<CT.KS!ED.KLP>
CWRD (ED5,<KILS>)		;;CPU/PAGING/HARDWARE DATA
CWRD (ED6,<.E'N'EPT>)		;;PHYSICAL ADDRESS OF THE EPT
CWRD (ED7,<SPTTAB>)		;;PHYSICAL ADDRESS OF THE SPT
CWRD (ED8,0)			;;PHYSICAL ADDRESS OF THE CST
CWRD (ED9,<CPNDDT>)		;;PHYSICAL ADDRESS OF CPNDDT
CWRD (EDA,<-M.CPU,,ASNTAB>) 	;;AOBJN TO CPU SERIAL NUMBERS
CWRD (EDB,.C'N'ACA)		;;PHYSICAL ADDR. OF VIRTUAL ADDR. OF CRASH ACS
	IFE <M.CPU-N-1>,<.XX==.C0EDV>
	IFG <M.CPU-N-1>,<.XX==.C'N'CDB+.CPLEN+<.C'N'EDV-.C'N'CDB>>
CWRD (EDC,.XX)		 	;;VIRTUAL ADDR OF NEXT EDV IN RING
CWRD (HSF,0)			;;DDT SCRATCH PAD
IFE FTXMON,<
CWRD (SYB,<1+4>)		;;# WORDS (INC THIS) IN HIDDEN SYMBOL BLOCK
				;;FIRST SUB-BLOCK
CWRD (SY1,<SYMSIZ>)		;;(0) NUMBER OF WORDS TO SWAP
CWRD (SY2,<.E'N'MAP+<MONORG/PAGSIZ>>) ;;(1) FIRST WORD TO SWAP
CWRD (SY3,SYMBK1)		;;(2) PLACE WHERE NEW MAP MAY BE FOUND
CWRD (SY4,SYMBK2)		;;(3) PLACE TO SAVE OLD CONTENTS
				;;END OF FIRST SUB BLOCK
>;; END IFE FTXMON

CXPC (SPC,<IC.UOU>,PERISH##)	;;XPCW ENTRY TO DIE
				;;STOPCODE OLD FLAGS & PC, NEW FLAGS & PC

IFN M.KL10,<
CWRD (TMI,TM'N'INT)		;;ADDRESS OF TIMER INTERRUPT ROUTINE
>;; END IFN M.KL10

.CPCLN==.-.C0CDB		;;LENGTH OF CONSTANTS AREA
;;VARIABLES AREA FOR CPU0  (ALSO DEFINED SYMBOLS FOR CPU 1)

;;OLD NSWTBL GETTAB HAS SOME VARIABLES WHICH ARE SYSTEM RATHER THAN CPU
;;DEPENDENT.  HOWEVER FOR COMPATIBILITY, THEY ARE KEPT TOGETHER.  .SYTBL
;;HAS NEW SYSTEM VARIABLES DEFINED AFTER 5.03 RELEASE
IFE	N,<
NSWTBL==:.-10			;;GETTAB TABLE NO 12. VARIABLES PERTAINING
				;; TO SWAPPING AND NON-SWAPPING SYSTEMS.
				;; FIRST 10 LOCATION NO LONGER USED.
				;;THE NUMBERS IN () ARE FOR NEW CPU DEPENDENT
				;; GETTAB TABLE .GTC0V.
> ;;END IFE N

LOC==.				;;START LOC AT ABS. BEG OF VARIABLE AREA
				;; LOC USED IN V MACRO AS A LOCATION COUNTER
CWRD (VBG,,0)			;;BEGINING OF VARIABLE AREA

;;START OF SYSTEM VARIABLES
CWRD (,,1,CORMAX)		;;(000) MAXIMUM CORE REQUEST+1 (IE LARGEST
				;;      RELATIVE ADDRESS + 1)
				;;      CAN BE RESTRICTED TO LESS THAN ALL
				;;      OF USER CORE BY BUILD AND/OR ONCE
CWRD (,,1,CORLST)		;;(001) 1 BIT BYTE POINTER TO LAST FREE
				;;      BLOCK POSSIBLE
CWRD (,,1,CORTAL)		;;(002) TOTAL NUMBER OF FREE+DORMANT+IDLE
				;;      CORE BLKS LEFT
CWRD (,,1,SHFWAT)		;;(003) JOB NUMBER SHUFFLER HAS TEMPORARILY
				;;      STOPPED FOR ITS I/O DEVICES TO BECOME
				;;      INACTIVE BEFORE SHUFFLING
CWRD (,0)			;;(004) OBSOLETE
CWRD (UPT)			;;(005) UPTIME FOR THIS CPU
CWRD (,,1,SHFWRD)		;;(006) TOTAL NUMBER OF WORDS SHUFFLED
CWRD (,,1,STUSER)		;;(007) JOB CURRENTLY USING THE SYSTEM TAPE
				;;      NEEDED SO CONTROL C WILL NOT TIE UP
				;;      SYSTEM TAPE
CWRD (,,1,HIGHJB)		;;(010) HIGHEST JOB NUMBER CURRENTLY ASSIGNED
CWRD (,,1,CLRWRD)		;;(011) TOTAL NUMBER OF WORDS CLEARED BY
				;;      'CLRCOR' ROUTINE
CWRD (LST,,1,LSTWRD)		;;(012) LOST TIME ON THIS CPU.  TOTAL NUMBER
				;;      OF CLOCK TICKS WHEN NULL JOB RAN BUT
				;;      OTHER JOBS WANTED TO RUN AND COULD NOT
				;;      DO SO BECAUSE: --
				;;      1. SWAPPED OUT OR ON WAY IN OR OUT
				;;      2. MONITOR WAITING FOR I/O TO STOP SO
				;;         IT CAN SHUFFLE OR SWAP
				;;      3. JOB BEING SWAPPED OUT BECAUSE IT IS
				;;         EXPANDING CORE
CWRD (,,1,MEMSIZ)		;;(013) SIZE OF PHYSICAL MEMORY IN WORDS
CWRD (TPE)			;;(014) TOTAL PARITY ERROR WORDS IN MEMORY
				;;      DETECTED ON DURING ALL CPU SWEEP WHILE
				;;      PROCESSOR WAS IN EXEC OR USER MODE.
CWRD (SPE)			;;(015) TOTAL NON-REPRODUCING PARITY ERRORS
				;;      IN MEMORY.  IE ONES WHICH DID NOT
				;;      REOCCUR WHEN SAME CPU SWEPT THRU CORE.
CWRD (MPC)			;;(016) MEMORY PARITY CONTINUES
				;;      COUNT OF NUMBER OF TIMES OPERATOR
				;;      PUSHED CONTINUE AFTER SERIOUS MEMORY
				;;      PARITY HALT.  LH = -1 IF SERIOUS ERROR
				;;      ON THIS BAD PARITY (MUST HALT)
CWRD (MPA)			;;(017) FIRST BAD PHYSICAL MEMORY ADDRESS
				;;      FOUND WHEN MONITOR SWEPT THRU CORE
				;;      AFTER PROCESSOR DETECTED BAD PARITY
CWRD (MPW)			;;(020) MEMORY PARITY WORD.  CONTENTS OF FIRST
				;;      BAD WORD FOUND BY MONITOR WHEN MONITOR
				;;      SWEPT THRU CORE AFTER FIRST PARITY
CWRD (MPP)			;;(021) PC OF LAST MEMORY PARITY NOT COUNTING
				;;      SWEEP THRU CORE
CWRD (,,1,EPOCNT)		;;(022) NUMBER OF PDL OVERFLOWS AT UUO LEVEL
				;;      IN EXEC MODE NOT RECOVERED
CWRD (,,1,EPOREC)		;;(023) NUMBER OF PDL OVERFLOWS AT UUO LEVEL
				;;      IN EXEC MODE RECOVERED
CWRD (,,1,MAXMAX)		;;(024) HIGHEST LEGAL VALUE OF CORMAX
CWRD (,,1,SYSKTM)		;;(025) KSYS COUNT-DOWN TIMER
CWRD (,,1,CORMIN)		;;(026) LOWER BOUND ON CORMAX.  LOKCON WILL
				;;      NEVER ALLOW CORMAX TO BECOME SMALLER
				;;      THAN THE CONTENTS OF THIS LOCATION
CWRD (ABC)			;;(027) ADDRESS BREAK COUNT
CWRD (ABA)			;;(030) ADDRESS BREAK ADDRESS
CWRD (LJR)			;;(031) LAST JOB RUN ON THIS CPU.  .CPJOB IS
				;;      COPIED TO .CPLJR WHENEVER JOB IS
				;;      CHANGED (INCLUDING TO NULL JOB)
CWRD (ODA,,3)			;;(032) OBSOLETE
CCON (NSWMXL,<<.-NSWTBL-1>B26>)	;;MAXIMUM NSWTBL ENTRY
;;NOTE: NO NEW ENTRIES MAY BE ADDED TO NSWTBL

CWRD (STS)			;;(035) STOP TIME SHARING ON THIS CPU.
				;;      CONTAINS JOB NO. WHICH DID TRPSET UUO.
CWRD (RUN)			;;(036) CPU SCHEDULING BITS (SEE .STRUN)
CWRD (NUL)			;;(037) NULL TIME IN JIFFIES
CWRD (EDI)			;;(040) NUMBER OF EXEC DON'T CARE INTERRUPTS.
				;;      IE USER ENABLED APR INTERRUPTS WHICH
				;;      MONITORS CAUSES (AOV,N,FOV).
				;;      LH = EXEC PC SO WE CAN FIX INEFFICIENT
				;;      CODE
CWRD (JOB)			;;(041) CURRENT JOB ON THIS CPU. REFERENCED
CWRD (OHT)			;;(042) OVERHEAD TIME IN JIFFIES
CWRD (EVM)			;;(043) MAXIMUM AMOUNT OF EXEC VIRTUAL
				;;      ADDRESS SPACE ALLOWED TO BE USED FOR
				;;      MAPPING USER SEGMENTS IN EXEC MODE BY
				;;      THE LOCK UUO.
CWRD (EVU)			;;(044) TOTAL AMOUNT OF EXEC VIRTUAL ADDRESS
				;;      SPACE CURRENTLY BEING USED TO MAP
				;;      USER SEGMENTS.
CWRD (LLC)			;;(045) LOCK LOOP COUNT. NUMBER OF TIMES THE
				;;      CPU HAS LOOPED WAITING FOR OTHER CPUS
CWRD (TUC)			;;(046) NUMBER. OF UUOS FROM EXEC AND USER
				;;      MODE SINCE SYSTEM WAS STARTED
CWRD (TJC)			;;(047) NUMBER OF JOB CONTEXT-SWITCHES
				;;      COUNT FOR THIS CPU INCLUDING NULL JOB
				;;      NULL JOB SINCE SYSTEM WAS STARTED
CWRD (TNE)			;;(050) TOTAL NXM'S THIS CPU
CWRD (SNE)			;;(051) TOTAL NON-REPRODUCIBLE NXM'S THIS CPU
CWRD (NJA)			;;(052) TOTAL JOBS CRASHED THIS NXM
CWRD (MNA)			;;(053) FIRST ADDRESS FOUND WITH NXM
CWRD (EBJ)			;;(054) EBOX TICKS/JIFFY (ONCE COMPUTED)
CWRD (MBJ)			;;(055) MBOX TICK/JIFFY
CWRD (PBA)			;;(056) PHYSICAL ADDR WITH BAD PARITY ON LAST
				;;      AR/ARX PARITY TRAP
CWRD (TBD)			;;(057) CONTENTS OF BAD WORD ON LAST AR/ARX
				;;      PARITY TRAP
CWRD (TGD)			;;(060) GOOD CONTENTS OF WORD AFTER RECOVERED
				;;      AR/ARX PARITY TRAP
CWRD (NPT)			;;(061) TOTAL NUMBER OF AR/ARX PARITY TRAPS
CWRD (AER)			;;(062) RDERA ON PARITY/NXM INTERRUPT
CWRD (PEF)			;;(063) CONI APR, ON PARITY/NXM INTERRUPT
CWRD (PSB,,4)			;;(064-067) OBSOLETE
CWRD (PPC)			;;(070) PC ON LAST AR/ARX PARITY TRAP
CWRD (PFW)			;;(071) PAGE FAIL WD ON LAST AR/ARX PARITY TRAP
CWRD (HPT)			;;(072) NUMBER OF HARD AR/ARX PARITY TRAPS
CWRD (SAR)			;;(073) NUMBER OF SOFT AR/ARX TRAPS
CWRD (PTP)			;;(074) NUMBER OF PAGE TABLE PARITY TRAPS
CWRD (CSN)			;;(075) NUMBER OF CACHE SWEEPS STARTED (CACHE
				;;      SWEEP SERIAL NUMBER)
CWRD (CLN)			;;(076) NUMBER OF TIMES SCHEDULER SKIPPED OVER
				;;      A JOB BECAUSE CACHE SWEEP HAD TO BE
				;;      DONE FIRST
CWRD (CLT)			;;(077) AMOUNT OF TIME IN JIFFIES THAT CPU RAN
				;;      NULL JOB BECAUSE OF STATE OF CACHE
CWRD (CSD)			;;(100) CACHE - SWAPPER DELAY COUNT-INCREMENT
				;;      ON 1088 SYSTEMS IF SWAPPER HAS TO WAIT
				;;      FOR ANOTHER CPU TO SWEEP ITS CACHE
				;;      BEFORE IT CAN START I/O
CWRD (CRN)			;;(101) CACHE SWEEP REQUEST SWEEP COUNT (SIC)
				;;      COMMANDING THIS VALUE TO .CPCSD+.CPCLN
				;;      (NUMBER OF SWEEP REQUESTS MADE) WILL
				;;      INDICATE TO WHAT EXTENT THE REQUEST
				;;      SCHEME IS A BOTTLENECK
CWRD (CEC)			;;(102) COUNT OF NON-RECOVERABLE AR/ARX
				;;      PARITY ERRORS WHICH INVOLVED CACHE.
				;;      AFTER 3 SUCH FAILURES CACHE IS TURNED
				;;      OFF IN TRAP ROUTINE WITH APPROPRIATE
				;;      MESSAGE TO OPERATOR.
CWRD (PTR)			;;(103) RETRY WORD FOR AR/ARX PARITY TRAP
				;;      ROUTINE.  INCLUDES STATUS FLAGS IN LH
				;;      AND RETRY COUNT IN RH.
CWRD (TSD)			;;(104) AR/ARX TRAP ROUTINE HAS ALREADY
				;;      SAVED APR/ERA/SB DIAGS ETC FOR ERROR
				;;      REPORTING.  WON'T BE DONE AGAIN AT
				;;      APR INTERRUPT.
CWRD (REP)			;;(105) USED BY PARITY/NXM RECOVERY ROUTINES
				;;      TO DETERMINE WHICH TYPE ERRORS SHOULD
				;;      BE LISTED.
CWRD (NDB)			;;(106) NUMBER OF TIMES CPU'S DOORBELL WAS RUNG
CWRD (SBR)			;;(107) CPU/DEVICE STATUS BLOCKS READ
				;;      LH = UNUSED
				;;      RH = BITS TELLING WHICH STATUS BLOCKS
				;;           HAVE BEENREAD ON THIS CPU.
CWRD (BPF)			;;(110) BACKGROUND PERFORMANCE ANALYSIS FLAG
				;;      .LT. 0 IF METER ENABLED (SINCE COUNTED
				;;      UP AT CLOCK LEVEL ON EACH CPU.
				;;      PROGRAMS SHOULD CHECK FOR .LE. 0)
CWRD (FBI)			;;(111) FILE BLOCKS INPUT (READ)
CWRD (FBO)			;;(112) FILE BLOCKS OUTPUT (WRITTEN)
CWRD (SBI)			;;(113) SWAPPING BLOCKS INPUT (READ)
CWRD (SBO)			;;(114) SWAPPING BLOCKS OUTPUT (WRITTEN)
CWRD (SNC)			;;(115) NUMBER OF CPU STOPCDS
CWRD (SND)			;;(116) NUMBER OF DEBUG STOPCDS
CWRD (SNJ)			;;(117) NUMBER OF JOB STOPCDS
CWRD (SJN)			;;(120) JOB NUMBER OF LAST STOPCD
CWRD (SNM)			;;(121) NAME OF LAST STOPCD
CWRD (SPN)			;;(122) PROGRAM RUNNING AT LAST STOPCD
CWRD (SPP)			;;(123) PPN RUNNING AT LAST STOPCD
CWRD (STN)			;;(124) TTY NAME AT LAST STOPCD
CWRD (SUP)			;;(125) USER PC AT TIME OF LAST STOPCD
CWRD (SUU)			;;(126) UUO AT TIME OF LAST STOPCD
CWRD (EJN)			;;(127) JOB NUMBER AT LAST PARITY/NXM ERROR
CWRD (EPN)			;;(130) PROGRAM NAME AT LAST PARITY/NXM ERROR
CWRD (PPI)			;;(131) CONI PI, ON PARITY/NXM INTERRUPT
CWRD (TPI)			;;(132) CONI PI, ON PARITY/NXM TRAP
CWRD (RSI)			;;(133) NUMBER OF TIMES SCHEDULER INTERLOCK WAS
				;;      REQUESTED WHEN NOT OWNED
CWRD (TFI)			;;(134) NUMBER OF TAPE FRAMES READ
CWRD (TFO)			;;(135) NUMBER OF TAPE FRAMES WRITTEN
CWRD (SNI)			;;(136) NUMBER OF NODUMP STOPCDS
CWRD (STY)			;;(137) TYPE OF LAST STOPCODE
CWRD (SDT)			;;(140) UDT OF LAST STOPCODE ON THIS CPU
CWRD (ITP)			;;INTERVAL TIMER PATCH INSTRUCTION
CWRD (ITJ)			;;JOB WHICH PATCHED INTERVAL TIMER

;;**********************************************************************
;;PUT NEW PUBLISHED VARIABLES ABOVE HERE
;;**********************************************************************
;;PUT NEW PUBLISHED SUBTABLES BELOW HERE (SO LAST BUT STILL
;;**********************************************************************
;; INSIDE LEGAL RANGE OF VARIABLE GETTAB FOR THIS CDB
;;**********************************************************************

;;RESPONSE SUBTABLE, POINTED TO BY .CPRSP
IFN FTRSP,<
;;INDICIES INTO 3 WORD BLOCKS:
	RSPAXR==:0		;;ACCUMULATE SUM OF RESPONSE
	RSPNXR==:1		;;NO. OF RESPONSES
	RSPHXR==:2		;;SUM OF SQUARES OF RESPONSE(HIGH ORDER HALF)
	RSPLXR==:3		;;SUM OF SQUARES OF RESPONSE(LOW ORDER HALF)

CWRD (AOR)			;;(R00) ACCUMULATED TTY OUTPUT UUO RESPONSE.
				;;      NUMBER. OF JIFFIES USERS HAVE SPENT
				;;      FOR THEIR JOBS TO DO A TTY OUTPUT UUO
				;;      AFTER TYPING INPUT (COMMAND OR USER
				;;      TTY)
CWRD (NOR)			;;(R01) NUMBER OF TTY OUTPUT UUO RESPONSES
CWRD (HOR)			;;(R02) SUM OF SQUARES OF TTY OUTPUT UUO
				;;      RESPONSES -  HIGH ORDER WORD
CWRD (LOR)			;;(R03) SUM OF SQUARES OF TTY OUTPUT UUO
				;;      RESPONSES -  LOW ORDER WORD
CWRD (AIR)			;;(R04) ACCUMULATED TTY INPUT UUO RESPONSES.
				;;      NUMBER OF JIFFIES USERS SPENT WAITING
				;;      FOR THEIR JOBS TO DO A TTY INPUT UUO
				;;      AFTER TYPING INPUT (COMMAND OR USER
				;;      TTY)
CWRD (NIR)			;;(R05) NUMBER OF TTY INPUT UUO RESPONSES
CWRD (HIR)			;;(R06) SUM OF SQUARES OF TTY INPUT UUO
				;;      RESPONSES - HIGH ORDER WORD
CWRD (LIR)			;;(R07) SUM OF SQUARES OF TTY INPUT UUO
				;;      RESPONSES - LOW ORDER WORD
CWRD (ARR)			;;(R10) ACCUMULATED CPU QUANTUM REQUE RESPONSES
				;;      NUMBER OF JIFFIES USERS SPENT WAITING
				;;      FOR THEIR JOBS TO EXCEED CPU QUANTUM
				;;      AFTER TYPING INPUT (COMMAND OR USER
				;;      TTY)
CWRD (NRR)			;;(R11) NUMBER OF CPU QUANTUM REQUEUE RESPONSES
CWRD (HRR)			;;(R12) SUM OF SQUARES OF CPU QUANT. REQUEUE
				;;      RESPONSES - HIGH ORDER WORD
CWRD (LRR)			;;(R13) SUM OF SQUARES OF CPU QUANT. REQUEUE
				;       RESPONSES - LOW ORDER WORD
CWRD (AXR)			;;(R14) ACCUMULATED RESPONSE TERMINATED BY
				;;      FIRST OF ABOVE 3 EVENTS (TTY OUTPUT
				;;      UUO,N, TTY INPUT UUO, OR CPU QUANTUM
				;;      REQUE)
CWRD (NXR)			;;(R15) NUMBER OF SUCH RESPONSES
CWRD (HXR)			;;(R16) SUM OF SQUARES OF ANY OF ABOVE - HIGH
				;;      ORDER WORD
CWRD (LXR)			;;(R17) SUM OF SQUARES OF ANY OF ABOVE - LOW
				;;      ORDER WORD
CWRD (ACR)			;;(R20) ACCUMULATED CPU RESPONSE. NUMBER OF
				;;      JIFFIES USERS HAVE SPENT WAITING FOR
				;;      THIS CPU
CWRD (NCR)			;;(R21) NUMBER OF CPU RESPONSES ON THIS CPU
CWRD (SCR)			;;(R22) HIGH ORDER WORD OF SQUARE OF CPU
				;;      RESPONSES
CWRD (SCL)			;;(R23) LOW ORDER WORD
CWRD (FADL)			;;(R24) NUMBER OF FADL INSTRUCTIONS SIMULATED
CWRD (FSBL)			;;(R25) NUMBER OF FSBL INSTRUCTIONS SIMULATED
CWRD (FMPL)			;;(R26) NUMBER OF FMPL INSTRUCTIONS SIMULATED
CWRD (FDVL)			;;(R27) NUMBER OF FDVL INSTRUCTIONS SIMULATED
CWRD (UFA)			;;(R30) NUMBER OF UFA INSTRUCTIONS SIMULATED
CWRD (DFN)			;;(R31) NUMBER OF DFN INSTRUCTIONS SIMULATED
CWRD (NRI)			;;(R32) NUMBER OF CHARS (EXCLUDING MIC)RECEIVED
CWRD (NXI)			;;(R33) NUMBER OF CHARS(INCLUDING FILL)XMITTED
CWRD (NEI)			;;(R34) NUMBER OF CHARS ECHOED
CCON (.CPRSL,<.-.C0AOR>)	;;SUBTABLE LENGTH
> ;;END FTRSP

;;MORE MEMORY PARITY ANALYSIS SUBTABLE, POINTED TO BY .CPPAR
CWRD (LPA)			;;(R00) LAST (HIGHEST) BAD MEM PARITY ADDRESS
				;;      ON LAST SWEEP OF MEMORY.  USED TO TELL
				;;      OPERATOR RANGE OF BAD MEMORY
CWRD (MPR)			;;(R01) RELATVE. ADDRESS (NOT VIRTUAL) IN HIGH
				;;      OR LOW SEG OF LAST MEMORY PARITY ERROR
CWRD (PTS)			;;(R02) NUMBER OF PARITY ERROR THIS (LAST)
				;;      SWEEP OF CORE SET TO ZERO AT BEGNING
				;;      OF SWEEP
CWRD (PSC)			;;(R03) NUMBER OF PARITY SWEEPS BY MONITOR
CWRD (UEP)			;;(R04) NUMBER OF USER ENABLED PARITY ERRORS
CWRD (PAA)			;;(R05) AND OF BAD ADDRESSES THIS (LAST)
				;;      MEMORY PARITY SWEEP
CWRD (PAC)			;;(R06) AND OF BAD CONTENTS THIS (LAST)
				;;      MEMORY PARITY SWEEP
CWRD (POA)			;;(R07) OR OF BAD ADDRESSES THIS (LAST)
				;;      MEMORY PARITY SWEEP
CWRD (POC)			;;(R10) OR OF BAD CONTENTS THIS (LAST)
				;;      MEMORY PARITY SWEEP
CWRD (PCS)			;;(R11) NUMBER OF SPURIOUS PARITY ERRORS (APR
				;;      SWEEP FOUND NO BAD PARITY BUT CHANNEL
				;;      HAD REQUESTED SWEEP RATHER THAN
				;;      PROCESSOR.  THIS INDICATES A CHANNEL
				;;      MEMORY PORT PROBLEM.
CWRD (MET)			;;(R12) MOS ERROR TIMER
CWRD (MEC)			;;(R13) MOS ERROR COUNTER
CWRD (TME)			;;(R14) TOTAL MOS ERRORS
CCON (.CPPRL,<.-.C0LPA>)	;;SUBTABLE LENGTH

;;BAD ADDRESS SUBTABLE, POINTED TO BY .CPPAR
CWRD (BAT,,M.CBAT)		;;(R00) TABLE OF BAD ADDRESSES ON LAST
				;;      MEMORY PARITY SWEEP.  NOT CLEARED SO
				;;      NUMBER OF VALID ENTRIES KEPT IN .CPPTS

;;MEMORY NXM SUBTABLE, POINTED TO BY .CPNMT
CWRD (LNA)			;;(R00) LAST NXM ADDRESS
CWRD (MNR)			;;(R01) LAST NXM RELATIVE ADDRESS
CWRD (NTS)			;;(R02) NUMBER OF NXM'S FOUND THIS SWEEP
CWRD (NSC)			;;(R03) NUMBER OF NXM SWEEPS DONE
CWRD (UEN)			;;(R04) NUMBER OF USER ENABLED NXM'S
CWRD (NAA)			;;(R05) LOGICAL AND OF BAD ADDRESSES
CWRD (NOA)			;;(R06) INCLOSIVE OR OF BAD ADDRESSES
CWRD (NCS)			;;(R07) NUMBER OF SPURIOUS CHANNEL NXM'S
CCON (.CPNML,<.-.C0LNA>)	;;SUBTABLE LENGTH

;KS10 SOFT MEMORY ERROR TABLE POINTED TO BY .CPMSS
IFN M.KS10,<
CWRD (SME)			;;(R00) NUMBER OF SOFT MEMORY ERRORS
CWRD (SMS)			;;(R01) MEM STATUS REGISTER AT LAST SOFT ERROR
CWRD (HME)			;;(R02) NUMBER OF HARD MEMORY ERRORS
CWRD (HMS)			;;(R03) MEM STATUS REGISTER AT LAST HARD ERROR
CWRD (SMC)			;;(R04) NUMBER OF SOFT ERRORS IN LAST MINUTE
CWRD (MFL)			;;(R05) LAST MEMORY ERROR FLAG (0=SOFT, 1=HARD)
CCON (.CPSML,<.-.C0SME>)	;;SUBTABLE LENGTH
>;; END IFN M.KS10
;APR STATUS SUBTABLE
CWRD (APD,,1,VERSTS)		;;(R000) APRID
CWRD (ACN,,1,APRSTS)		;;(R001) CONI APR,
CWRD (PIC,,1,PISTS)		;;(R002) CONI PI,
CWRD (PGD,,1,UPTSTS)		;;(R003) DATAI PAG,
CCON (LENSTS,<UPTSTS-VERSTS>)	;;SUBTABLE LENGTH

CWRD (PGC,,1,EPTSTS)		;;(R004) CONI PAG,
CWRD (UP0,,4)			;;(R005-R010) UPT LOCS 424-427
CWRD (ERA,,1,ERASTS)		;;(R011) RDERA
CWRD (RHC,,8)			;;(R012-R021) CONI RH20, FOR ALL RH20'S
CWRD (DTC,,4)			;;(R022-R025) CONI DTEN,
CWRD (EP0,,40)			;;(R026-R065) EPT LOCATIONS 0-37
CWRD (EP1,,40)			;;(R066-R125) EPT LOCATIONS 140-177
CWRD (UP1,,4)			;;(R126-R131) UPT LOCS 500-503
CWRD (6,,5)			;;(R132-R136) AC BLOCK 6 REGS 0-3 AND 12
CWRD (7,,3)			;;(R137-R141) AC BLOCK 7 REGS 0 THROUGH 2

IFN M.KL10,<
;;IN ADDITION TO BEING A PART OF THE CPU STATUS BLOCK SUBTABLE, THE
;;SBDIAG BLOCK IS A CDB SUBTABLE IN ITS OWN RIGHT.  POINTER IS .CPSDP.
CWRD (SBD,,50)			;;(R142-R211) SBDIAG DATA
CCON (.CPSDL,<.-.C0SBD>)	;;SUBTABLE LENGTH
> ;END IFN M.KL10
CCON (.CPCSL,<.-.C0APD>)	;;SUBTABLE LENGTH
;;DEVICE STATUS BLOCK ENTRY FOR DEVICES ON THIS CPU.  THE ORDER OF THESE
;;ENTRIES MUST EXACTLY MATCH THE ORDER OF THE INSTRUCTIONS IN DVSXCT THAT
;;FILL THE ENTRIES.

CWRD (DVS,,0)			;;START OF DEVICE STATUS SUBTABLE
IFN M.KL10,<
CWRD (TMR)
CWRD (MTR)
CWRD (TTY)
CWRD (PRA)
CWRD (PPA)
CWRD (DLS)
CWRD (DAC)
CWRD (DAS)
CWRD (CRA)
CWRD (LPT)
CWRD (PLA)
CWRD (TMS)
CWRD (TMC)
CWRD (DX1)
CWRD (DSK)
CWRD (FH2)
CWRD (FSD)
CWRD (FS2)
CWRD (FS3)
CWRD (DPC)
CWRD (DP2)
CWRD (DP3)
CWRD (DP4)
CWRD (2DS)
CWRD (2DC)
CWRD (DLC)
CWRD (DLB)
CWRD (DC2)
CWRD (DB2)
CWRD (CDP)
CWRD (CRB)
CWRD (LPB)
CWRD (LPC)
CWRD (PLB)
CWRD (DAK)
CWRD (DDK)
CWRD (DH2)
CWRD (DFS)
CWRD (DS2)
CWRD (DS3)
CWRD (DDP)
CWRD (DD2)
CWRD (DD3)
CWRD (DD4)
CWRD (DDC)
CWRD (DDB)
CWRD (D2C)
CWRD (D2B)
CWRD (IVI,,10)
> ;;END IFN M.KL10

IFN M.KS10,<
CWRD (TMR)
CWRD (TMB,,2)
CWRD (UB1)
CWRD (UB3)
CWRD (RH1,,2)
CWRD (RH3,,2)
CWRD (LPT,,2)
CWRD (CDR)
CWRD (PRA)
CWRD (PPA)
CWRD (RXA)
> ;;END IFN M.KS10

CCON (.CPDVL,<.-.C0DVS>)	;;SUBTABLE LENGTH

IFN	M.KL10&FTRSP,<
CWRD (BPV,,<<BPATLN*4>>)		;;KL10 BACKGROUND PERFORMANCE NUMBERS
				;; EACH ENTRY IS 4 WORDS LONG
				;;  0'1 := RDTIME TOTAL ELAPSED TIME
				;;  2'3 := TOTAL PERF METER COUNT
> ;;END IFN M.KL10&FTRSP


;;***********************************************************************
;;INSERT NEW SUB TABLES JUST ABOVE HERE - SO AT END OF VARIABLE TABLE
;;INSERT NEW VARIABLES A FEW PAGES BACK - SO NEXT TO OTHER VARIABLES
;;***********************************************************************
CCON (.CPPVL,<<.-.C0VBG>B26>)	;;PUBLISHED CPU DEPENDANT VARIABLE LENGTH
;;UNPUBLISHED CPU DEPENDENT VARIABLES:
CWRD (ADR,,1,JOBADR)		;;XWD PROTECTION, RELOCATION FOR CURRENT
				;; JOB SAME AS JBTADR(JOB) AND AC R
CWRD (REL)			;;LH==0, RH CONTAINS CONTENTS OF PROTECTION
				;; REGISTER LOW ORDER BITS==1777 (HIGHEST
				;; RELATIVE LOC IN CURRENT USER AREA)
CWRD (PC,,2)			;;JOB PC WHEN SCHEDULER IS CALLED
XP USRPRT,JOBPRO
XP USRPR1,,USRPRT+1
XP USRHCU,USRPRT
XP USRPC,USRHCU+1
IFN FTMP,<IFE USRHCU&777774-USRPC&777774,<PRINTX ?USRHCU AND USRPC FALL IN THE SAME CACHE LINE (SEE PDLLEN IN S)>>
XP USRDDT,USRPC+2	;THIS DEPENDS ON JOBDDT-JOBPC=1
XP USRJDA,USRDDT+1
XP USRLO,USRJDA		;FIRST LOC CLEARED BY SETUSR ROUTINE
			; ON A CALL RESET. - ALSO CLEARS USRHCU
XP USRLO1,USRLO+1	;FIRST LOC+1
XP USRHI,USRJDA+17	;LAST LOC CLEARED BY SETUSR ROUTINE
CWRD (XTM)			;;TIME OF LAST SWITCH FROM MONITOR CYCLE TO
				;; OR VICE VERSA IN (SECONDS*RTCSEC)
CWRD (QNT)			;;CURRENT QUANTUM RUN TIME.  FORCE CPUTIM TO
				;; WHEN NEGATIVE TO RECOMPUTE ACTUAL QUANTUM
				;; RUN TIME LEFT
CWRD (LS2)			;;ADDITIONAL LOST TIME, IN JIFFIES*RTCSEC
				;; BEYOND LAST JIFFY
CWRD (NL2)			;;ADDITIONAL NULL TIME, IN JIFFIES*RTCSEC
				;; BEYOND LAST JIFFY
CWRD (OH2)			;;ADDITIONAL OVERHEAD TIME, IN JIFFIES*RTCSEC
				;; BEYOND LAST JIFFY
CWRD (TNT)			;;TIME INTERVAL (TICKS)SINCE LAST @ CLOCK LEVEL
CWRD (HTM)			;;HUNG DEVICE TIME CHECK FOR HUNG IO
CWRD (SEC)			;;NUMBER OF SECONDS LEFT BEFORE DOING ONCE A
				;; MINUTE CODE
IFN FTRTTRP,<
CWRD (RCU,,6)			;;COUNT OF REAL TIME CONSO'S ON SKIP CHAIN
CWRD (RIT,,6)			;;REAL TIME INITIALIZATION TABLE
CWRD (DMI)			;;REAL TIME DISMISS INSTRUCTION FOR CURRENT
				;; INTERRUPT
> ;;END IFN FTRTTRP
;SCHEDULER FLAGS:
CWRD (CKF,,1,CLKFLG)		;;;NON-ZERO WHEN CLK INTERRUPT (PI7) REQUESTED
				;; FOR ANY REASON
CWRD (TMF,,1,TIMEF)		;;NON-ZERO WHEN APR CLOCK TICKED ON THIS CPU.
				;; SET SO CLOCK INTERRUPT ROUTINES WILL KNOW
				;; ANOTHER JIFFY HAS PASTED.  SET BY APRINT,
				;; TESTED AND CLEARED BY CLKINT MODULE.
CWRD (SCF)			;;NON-ZERO AS A FLAG TO CLK ROUTINE TO FORCE
				;; RESCHEDULING, ON THIS CPU, EVEN THOUGH
				;; ITS CURRENT JOB IS IN EXEC MODE.  CAN HAPPEN
				;; ON MONITOR DETECTED ERRORS.

CWRD (CHT)			;;CLOCK HAS TICKED, START QUEUED I/O.

CWRD (RTF,,1,SCDRTF)		;;NON-ZERO ON REAL TIME RESCHEDULE REQUIRED
				;; REALLY A SYSTEM VARIABLE
CWRD (ISF)			;;NON-ZERO IF IN THE SCHEDULAR OR WHEN IN
				;; COMCON CONTAINS THE STACK POINTER JUST
				;; BEFORE COMMAND DISPATCH

CWRD (SUD)			;;SCAN USED FOR THIS SCHEDULING SCAN
IFN FTHPQ!FTNSCHED,<
CWRD (HQU)			;;NON-ZERO IF CURRENT JOB ON THIS CPU DID A
				;; HPQ UUO TO FORCE RESCHEDULING TO THE NEW HPQ
> ;;END IFN FTHPQ!FTNSCHED

CWRD (PLT)			;;POTENTIALLY LOST (WASTED) CLOCK TICK ON
				;; THIS CPU IF NON-ZERO.  NON-ZERO WHEN
				;; SCHEDULER SEES THAT THERE ARE JOBS WHICH ARE
				;; POTENTIALLY RUNABLE ON THIS CPU BUT HAS TO
				;; RUN NULL JOB.  ZERO WHEN IT FINDS A REAL
				;; JOB TO RUN OR NULL JOB IS ONLY JOB WHICH
				;; WANTS TO RUN ON THIS CPU.
IFN FTKL10,<
IFN FTMP,<
CWRD (CLF)			;;POTENTIAL CACHE LOST TIME FLAG (SEE .CPCLN)
CWRD (CL2)			;;LOW ORDER CACHE LOST TIME IN RTUPS UNITS
CWRD (SDA)			;;NUMBER OF TIMES CACHE WAS SWEPT BECAUSE OF
				;; CORE DEALLOCATION
> ;;END IFN FTMP
CWRD (CSR)			;;CACHE SWEEP REQUEST FLAG IF .GE. CURRENT
				;; SWEEP SERIAL NUMBER, MUST SWEEP AT CH7
				;; LEVEL FOR ANOTHER CPU
CWRD (CSW)			;;SWEEP SERIAL NUMBER TO WAIT FOR
> ;;END IFN FTKL10
CWRD (AEF)			;;APR ERROR FLAG ON THIS CPU.  CONTAINS APR
				;; CONI IF NULL JOB WAS CURRENT JOB ON THIS
				;; CPU WHEN APR ERROR OCCURRED SO COULD NOT
				;; STORE IN JOB DATA AREA.
				;; LEFT HALF USED FOR MEMORY PARITY CONTROL
				;; TO REQUEST PARITY SWEEPS AND PRINTING.
CWRD (SAC)			;;SAVED COPY OF .CPAEF
CWRD (APC,,2)			;;APR ERROR PC ON THIS CPU WHEN ERROR WHILE
				;; NULL JOB WAS CURRENT JOB ON THIS CPU.
CWRD (MDP,,2)			;;MEMORY PARITY ERROR DOUBLE WORD PC
CWRD (PPD,,2)			;;AR/ARX TRAP DOUBLE WORD PC
CWRD (NJE)			;;ERROR IN NULL JOB HAS OCCURRED IF NON-ZERO
CWRD (SFC)			;;SCHEDULER FAIRNESS COUNT. COUNT OF THE NUMBER
				;; OF SCANS OF THE PRIMARY SCAN TABLE WITHOUT
				;; GETTING TO THE LOWER QUEUES IN THE TABLE.
CWRD (SQF)			;;NON-ZERO IF CURRENT JOB WAS TAKEN FROM
				;; SUBQUEUES
CWRD (APR)			;;CONI APR INTO THIS LOCATION TO READ THE
				;; STATE OF MI PROG DIS SWITCH

IFN M.KL10,<
CWRD (IPI)			;;INTERVAL TIMER PI ASSIGNMENT
CWRD (DTT)			;;MINUTES TILL NEXT SEND DATE/TIME TO -20F
CWRD (EPW,,4)			;;SAVED DTE EXAMINE/PROTECTION WORD

;;EXEC MODE ADDRESS BREAK SCRATCH PATCH STORAGE
CWRD (ABF)			;;FLAGS (STOPCODE TYPE + CPU MASK)
CWRD (ABI)			;;INSTRUCTION TO XCT
CWRD (ABW)			;;ADDRESS BREAK WORD (CONDITIONS + ADDRESS)
CWRD (ABS,,S$MAXL)	 	;;STOPCODE
> ;;END IFN M.KL10
;PROCESSOR DEPENDENT VARIABLES FOR APR INTERRUPTS

CWRD (CN1)			;;CONTAINS CONSO MASK FOR APR INTERRUPTS,
CWRD (HRP)			;;LAST DATAO OUT TO SET HARDWARE RELOCATION
				;; AND PROTECTION FOR THIS CPU.
CWRD (SP,,2)			;;PLACE TO SAVE P ON APR INTERRUPT
CWRD (S17,,2)			;;PLACE TO SAVE AC 17 ON CLK INTERRUPT

;MEMORY PARITY ANALYSIS VARIABLES
CWRD (A00,,17)			;;FIRST WORD TO STORE AC0 ON PARITY SWEEP ON
				;; APR PI
CWRD (A17)			;;LAST WORD TO STORE AC17 ON PARITY SWEEP AT
				;; APR PI
CWRD (LPP)			;;LAST MEM PARITY PC USED TO DETECT PI DISMISS
				;; LOOPS
CWRD (LSB)			;;LAST SEG (HI OR LOW) WHICH IS (WAS) BLTED
				;; USED TO DETECT BAD PARITY DURING BLT
CWRD (LCI)			;;TIME OF LAST PAR/NXM INTERRUPT CAUSED BY A
				;; CHANNEL REFERENCE
CWRD (PIP)			;;POINTER TO REAL INTERRUPT PC
CWRD (PSP)			;;PARITY/NXM SWEEP IN PROGRESS
CWRD (CHE)			;;CHANNEL ERROR REPORTING IN PROGRESS
CWRD (TCX)			;;DATAI PAG, ON ERROR TRAP
CWRD (PFT)			;;PRE-EMPTIVE PAGE FAULT HANDLER (SEE SEILM)

IFN M.KL10,<
CWRD (TCT)			;;TRIAD COUNTER FOR 60HZ LEAP JIFFIES
CWRD (PJB)			;;JOB WHO OWNS PERFORMANCE METER (ZERO IF FREE)
CWRD (MJB)			;;MEASURED JOB (JOB ENABLE OF PERF. UUO)
				;; -2 = NULL JOB, 0 = DON'T CARE
CWRD (MJ1)			;;JOB ENABLE CONDITION SET ONLY WHEN METER
				;; IS RUNNING. (SEE APRSER)
CWRD (PMR)			;;NONZERO MEANS PERFORMANCE METER IS RUNNING
CWRD (PAE)			;;USED TO STORE PERFORMANCE ANALYSIS ENABLES
CWRD (PRQ)			;;SEMAPHORE USED TO TEST/GIVE METER AWAY
CWRD (APS)			;;NON ZERO MEANS ACCOUNTING AND PERFORMANCE
				;; METERS SHOULD BE KEPT IN SYNC
CWRD (MM0)			;;"VIRTUAL PERFORMANCE METER" HIGH ORDER
				;; MEMORY REFERENCE COUNT
CWRD (MM1)			;;"VIRTUAL PERFORMACE METER" LOW ORDER
				;; MEMORY REFERENCE COUNT
CWRD (BPC)			;;BACKGROUND PERF ANAL SAMPLE INTERVAL (TICKS)
CWRD (BPI)			;;B.P.A. SAVED PACTAB INDEX
CWRD (BPT,,2)			;;B.P.A. SAVED RDTIME AT START OF SAMPLE
CWRD (TIM)			;;CLOCK INTERRUPT FLAG
CWRD (KPB,,<<KPSLEN+3>/4>)	;;KLINIK PARAMETER BUFFER
CWRD (20F)			;;LH = FLAGS ABOUT RSX-20F FRONT END
				;;RH = COUNT OF CHARACTERS CURRENTLY BEING
				;;     OUTPUT
CWRD (20S,,2)			;;SPACE FOR INCOMING LINE SPEEDS
CWRD (20B,,<<TTDMOS+3>/4>)	;;BUFFER FOR 16BIT DATA TO 20F
CWRD (20D)			;;CHAIN OF DEVICE STATUS MESSAGES

;;LOCATIONS USED BY CPU HARDWARE ERROR RECOVERY
CWRD (PTH)			;;AR/ARX TRAP HAPPENED DURING PARITY SWEEP
CWRD (STE)			;;ERA CONTENTS ON SWEEP TRAP
CWRD (PTF)			;;COUNT OF PAGE TABLE PARITY TRAPS BETWEEN
				;; CLOCK TICKS USED TO CRASH SYSTEM IF TOO HIGH
CWRD (IOP)			;;API FUNCTION WORD ON I/O PAGE FAIL INTERRUPT
CWRD (IPG)			;;DATAI PAG, ON I/O PAGE FAIL INTERRUPT
CWRD (73)			;;CONTENTS OF AC BLOCK 7, AC 3 (IOP FNC WORD)
CWRD (CA1,,20)			;;POWER FAIL AC BLOCK SAVE AREA, ALSO AC BLOCK
				;; 1 ON A CRASH
CWRD (CA2,,20)			;;AC BLOCK 2
CWRD (CA3,,20)			;;AC BLOCK 3
CWRD (CA4,,20)			;;AC BLOCK 4
> ;;END IFN M.KL10
CWRD (RTM,,2)			;;RDTIME VALUE AT LAST TIMER INTERRUPT
IFN M.KS10,<
CWRD (TCT)			;;TRIAD COUNTER FOR 60HZ LEAP JIFFIES
CWRD (TIM)			;;CLOCK INTERRUPT FLAG FOR KS10S
CWRD (PTH)			;;HARD PARITY TRAP HAPPENED DURING PARITY SWEEP
CWRD (PTF)			;;COUNT OF PAGE TABLE PARITY TRAPS BETWEEN
				;; CLOCK TICKS USED TO CRASH SYSTEM IF TOO HIGH
CWRD (LMC)			;;LEAP MILLISECOND COUNT FOR 4.1 MHZ CLOCK RATE
CWRD (CA1,,20)			;;POWER FAIL AC BLOCK SAVE AREA, ALSO AC BLOCK
				; 1 ON A CRASH
CWRD (CA2,,20)			;;AC BLOCK 2
CWRD (CA3,,20)			;;AC BLOCK 3
CWRD (CA4,,20)			;;AC BLOCK 4
> ;;END IFN M.KS10

CWRD (CTQ,,2)			;;SCNSER OUTPUT QUEUE HEADER FOR CTY AND
				;; RSX-20F LINES
CWRD (SWP)			;;NON-0 IF SWAP REQUEST TO BE CHECKED FOR AT
				;; CLOCK LEVEL
IFN FTMP,<
CWRD (QUE)			;;QUEUE FOR IO REGS ON OTHER CPUS EMPTIED INTO
				;; CPUDSQ ONCE A TICK
CWRD (QND)			;;END OF QUEUE ABOVE
CWRD (SWD)			;;FLAG FOR FILIO CACHE SWEEPS
CWRD (DRQ)			;;DISKS ON CPU NEED RECUING
CWRD (TAP)			;;0 IF NO TAPE IO WAITING FOR SWEEP
				;;-1 IF TAPE IO WAITING, NEEDS SWEEP
				;;0,,-1 IF TAPE WAITING, DSKTIC DID SWEEP
> ;;END IFN FTMP

IFN M.KL10,<
CWRD (PIB)			;;SAVE PI STATE FOR NBFOFF
> ;;END IFN M.KL10

CWRD (PIS)			;;SAVE PI STATE FOR SYSPIN
CWRD (DPI)			;;SAVE PI STATE FOR DEVPIN
CWRD (BTI)			;;SAVE PI STATE FOR BTSOFF
CWRD (SCI)			;;SAVE PI STATE FOR SCNOFF
CWRD (NTI)			;;SAVE PI STATE FOR NETOFF
CWRD (DBI)			;;SAVE PI STATE FOR DDBSRL
CWRD (IUT)			;;UPTIME A SECOND AGO
IFN FTNET,<
CWRD (NTF)			;;DEFINE THE ONE SOFTWARE INTERRUPT FLAG
> ;;END IFN FTNET

IFN M.EQDQ,<
	QDBLEN==:23		;;LENGTH OF QUESER DATABASE
CWRD (QTS,,QDBLEN) 		;;QUESER VARIABLES
> ;;END IFN M.EQDQ

CWRD (CPG)			;;DATAI PAG, DONE BY SVSETS WITH BITS
				;;SET SO THAT DATAO WILL RESTORE CURRENT AC
CWRD (ACA)			;; SET ADDRESS OF 20 WORD BLOCK IN WHICH
				;; SVSETS SAVED THE CURRENT AC SET
CWRD (KPM)			;;CONTAINS PM.KPM IF CPU HAS AN MCA25 INSTALLED
CWRD (PMV)			;;NON-ZERO IF MICROCODE SUPPORTS PHYSICAL
				;; MOVE/MOVEM INSTRUCTIONS
CWRD (JCH)			;;JOB/CONTEXT HANDLE FOR JOB ON THIS CPU
CWRD (CXJ)			;;JOB OWNING CX ON THIS CPU

IFN M.KL10,<
CWRD (DSN,,<<^D<8*2>+4>/4>)	;;;CONSOLE FRONT-END DISK DRIVE SERIAL NUMBERS
> ;;END IFN M.KL10
CWRD (EMU,,2)			;;+0 = PDL FOR CALLING DIE
				;;+1 = SAVED P BEFORE CALLING DIE

IFN FTPATT,<
CWRD (PAT,,10)			;;PATCH SPACE
> ;;END IFN FTPATT

;;**********************************************************************
;;PUT NEW UNPUBLISHED VARIABLES ABOVE HERE
;;**********************************************************************
.C'N'END==:.

;;BEGINNING OF SPECIAL PER-CPU MAPPINGS. THESE VIRTUAL ADDRESSES APPEAR IN
;; SECTION 37 AND MUST BE LOCATED CORRESPONDING TO THEIR VIRTUAL ADDRESSES.
;; ADD NEW MAPPINGS ABOVE THIS ADJUSTING THE LOC STATEMENTS APPROPRIATELY.
IFN FTXMON,<
IFG <<.&PG.BDY> - MMAPS/PAGSIZ>,<LOC <.+PG.BDY>&777000>
	LOC	.&777000 + MMAPS/PAGSIZ
CWRD (MMA,,<MXSECN+1>)		;;MAP SLOTS FOR ALL MONITOR SECTION MAPS
> ;;END IFN FTXMON

IFG <<.&PG.BDY> - UMAPS/PAGSIZ>,<LOC <.+PG.BDY>&777000>
	LOC	.&777000 + UMAPS/PAGSIZ
CWRD (UMA,,<MXSECN+1>)		;;MAP SLOTS FOR ALL USER SECTION MAPS

> ;END OF CDB MACRO

IFN XPANDN,<LALL>
	ZZZ==0
	LOC	<.+PG.BDY>&777000
REPEAT M.CPU,<
	CDB(\ZZZ)
	LOC	<.+PG.BDY>&777000
IFE ZZZ,<.CPLEN==:.-.C0CDB>	;LENGTH OF CDB
	ZZZ==ZZZ+1
>; END REPEAT M.CPU

	.C0EVA==:.C0CDB+.CPLEN	;END OF CPU 0 VARIABLE AREA

	CDBPGS==:.CPLEN/PAGSIZ	;LENGTH OF CDB IN PAGES
	.EVCDB==:<FYSORG-<EVAPGS*PAGSIZ>>-.CPLEN ;EXEC VIRTUAL ADDRESS OF CDB
	HLCSAD==:.EVCDB		;HIGHEST LEGAL CODE SECTION ADDRESS +1

	$LIT			;ANY LITERALS IN CDB CAN GET CACHED IN HIGH SEG
	$ABS			;BACK TO ABS CODE
	LOC	<.+PG.BDY>&777000
;NOW GENERATE REFERENCES FOR GETTAB TABLES 55 THRU 70
;WILL GENERATE A ZERO WORD FOR INDIRECT REFERENCES TO NON EXISTANT CDB'S
DEFINE CPUGTB(A,B)<
IFG <M.CPU-A>,<ITMC'B'C==:.CPPCL
	ITMC'B'V==:.CPPVL>
IFLE <M.CPU-A>,<ITMC'B'C==:0	;MAKE LENGTH 0 SO ERROR RETURN
	ITMC'B'V==:0		;MAKE LENGTH 0 SO ERROR RETURN
	.C'B'CDB==:NULGTB##	;DEFINE ADR TO BE A WORD CONTAINING 0.
	.C'B'VBG==:NULGTB##
>>
ZZ==0
REPEAT 6,<
	CPUGTB(ZZ,\ZZ)
ZZ==ZZ+1
>
IFN FTNSCHED,<
;TABLES INDEXED BY CLASS NUMBER

CLSSTS::BLOCK	M.CLSN		;BITS IN LH, QUOTA (NUMBER FROM 0 TO 100) IN RH

CLSQTA::BLOCK	M.CLSN		;COMPUTED QUOTA IN JIFFIES, FIGURED OUT
				;FROM CLSSTS, RECOMPUTED AT THE
				;BEGINNING OF EVERY SCHEDULING INTERVAL.
				;DECREMENTED WHENEVER A CLASS USES A JIFFY
				;OF RUNTIME.


CLSRTM::BLOCK	M.CLSN		;RUNTIME FOR CLASSES SINCE ANY CHANGE IN CLSSTS
				;MINUS ANY TIME LEFT OVER AFTER ALL QUOTAS
				;WERE SATISFIED WITHIN AN INTERVAL

CLSMXL==:<M.CLSN-1>B26		;MAXIMUM LENGTH OF PER CLASS TABLES FOR GETTAB
>;END IFN FTNSCHED
SUBTTL MONITOR TABLES WITH ONE ENTRY PER JOB

	JOBMAX==:JOBN-1		;MAXIMUM LEGAL JOB NUMBER
	JOBMXL==:<JOBMAX>B26	;HIGHEST JOB NUMBERSHIFTED LEFT 9 (FOR GETTAB UUO)
	MJOBN==:-JOBN		;NEGATIVE NUMBERS OF JOBS (COUNTING NULL JOB)
	JBTMAX==:JOBN+SEGN-1	;HIGHEST INDEX IN JBT TABLES
	MJBTMX==:-JBTMAX		;MINUS JBTMAX FOR AOBJN POINTER
	JBTMXL==:<JBTMAX>B26	;HIGHEST JBT ENTRY SHIFTED LEFT 9 (FOR GETTAB UUO)
JBTSTS::BLOCK	JOBN+SEGN	;JOB AND HIGH SEG STATUS WORD
				;THIS IS DOCEMENTED AS GETTAB TABLE NUMBER 0
				;LH==STATUS BITS (SEE S.MAC FOR DESCRIPTION)
				;BITS 18-23=EXTENDED JOB STATUS BITS
	JBSSPR==^D9			;SIZE OF ACCES PRIV FOR HIGH SEG
	JBNSPR==^D17			;BYTE PTR. POS.
				;RH=IN CORE COUNT FOR HIGH SEGS

JBTVAD::			;VIRTUAL ADDRESS FOR HIGH SEG TABLE
JBTST2::BLOCK	JOBN+SEGN	;SECOND WORD OF JOB STATUS. USED BY SCHEDULER
				;  AND EVENT WAIT INFO

IFN M.KL10*<M.CPU-1>,<;IF KL10 SYSTEM WITH MORE THAN ONE CPU
JBTST3::BLOCK	JOBN		;18-35 = CPU DATA BLOCK ADDR OF LAST
				; CPU JOB RAN ON.  CLEARED WHEN
				; JOB GIVES UP ALL PHYSICAL CORE, OR
				; DOES RUN, GET, ETC.

JBTCSN::BLOCK	JOBN		;36 BIT SWEEP SERIAL NUMBER, TAKEN FROM
				; CPU WHOSE CDB ADDRESS IS IN JBTST3
>;END IFN M.KL10*<M.CPU-1>

IFN FTNSCHED,<
JBTSCD::BLOCK	JOBN		;SCHEDULER WORD CONTAINING EACH JOB'S
				;CLASS AND TYPE.
>;END IFN FTNSCHED

JBTSPS::IFG	<M.CPU-1>,<	;MULTI-PROCESSING SYSTEM?
	BLOCK	JOBN		;SECOND PROCESSOR STATUS BITS BOTH HALVES (PREFIX=.SP)
				;RH=GETTAB BITS FOR 6 CPU'S.
				;LH=UNPUBLISHED BITS
				;SEE S.MAC FOR DEFINITIONS.
	XP	ITMSPS,JOBMXL	;LH SYMBOL FOR GETTAB UUO
>
	IFLE	<M.CPU-1>,<	;SINGLE-PROCESSOR SYSTEM?
	0			;DUMMY ENTRY
	XP	ITMSPS,0	;DON'T ALLOW ANY REFERENCE IF NOT 2 CPU SYSTEM
>

JBTADR::BLOCK	JOBN+SEGN	;JOB AND HIGH SEG CORE ASSIGNMENT
				; LH==PROTECTION (LENGTH-1)
				; RH==RELOCATION (ABSOLUTE LOCATION IN CORE)
				; DURING BLT OF LOW OR HIGH SEG, THIS WORD
				; CONTAINS THE SOURCE RELOCATION
				;THIS IS DOCUMENTED AS GETTAB TABLE NUMBER 1
JBTCCC::BLOCK	JOBN		;NON-CONTROL-C COUNT (NEGATIVECOUNT OF USERS
				;WHO DON'T WANT USER TO GET OUT) (LH)
JBTSWI::
JBTSGN::IFG	SEGN, <
	BLOCK	JOBN+SEGN	;RH=SEGMENT NUMBER OF HIGH SEGMENT THIS JOB
				; IS USING IN CORE OR ON DISK
				; 0 MEANS JOB DOES NOT HAVE HIGH SEG
				;LH=USER DEPENDENT HIGH SEG STATUS BITS (SEE S.MAC)
				;THIS IS DOCUMENTED AS GETTAB TABLE NUMBER 14
				;INDEXED BY HIGH SEGMENT NUMBER THE TABLE (JBTSWI)
				; CONTAINS THE LOW SEGMENT NUMBER OF THE SEGMENT
				; WHICH THIS HIGH SEGMENT IS BEING SWAPPED IN FOR
>
	IFE	SEGN, <
	0			;SINGLE-ENTRY NULL JBTSGN TABLE....
	XP	ITMSGN,JOBMXL	;LH SYMBOL FOR GETTAB UUO SO THAT JBTSGN IS
				; UNDEFINED, I.E., MAKE INDEXING BY J BE 0, BUT
				; ALLOW REFERENCES UP TO JOBMXL.
>

JBTPPN::			;HIGH SEGMENT DIRECTORY NAME IF , 0 IF DTA,MTA
JBTPPN::BLOCK	JOBN+SEGN	;XWD PROJECT NUMBER, PROGRAMMER NUMBER
				;THIS IS DOCUMENTED AT GETTAB TABLE NUMBER 2

	IFG	SEGN, <		;REENTRANT MONITOR CAPABILITY?
JBTDEV==:.-JOBN		;JUST HIGH HALF (NO ENTRIES FOR LOW SEGS)
	BLOCK	SEGN		;HIGH SEGMENT PHYSICAL DEVICE NAME
			; OR FILE STRUCTURE NUMBER(DSKA,DSKB,DTAN,MTAN)
>
IFE	SEGN,<
JBTDEV==:JBTSGN-JOBN		;USE THE DUMMY ENTRY IN JBTSGN
	XP	ITMDEV,JBTMXL	;LH SYMBOL FOR GETTAB UUO SO THAT JBTDEV IS
				;UNDEFINED, IE. MAKE INDEXING BYITEM BE 0
>

IFN SEGN,<			;
JBTIDT==:.-JOBN			;MAKE FIRST HIGHSEG NUMBER POINT TO TABLE
	BLOCK	SEGN		;STORAGE FOR TIME SEGMENT LAST WENT DORMANT/IDLE
>				;
JBTVIR::BLOCK	JOBN		;JOB'S VIRTUAL SIZE (SEE LOVSIZ/HIVSIZ)
SWPLST::BLOCK	JOBN+SEGN
SW2LST::BLOCK	JOBN+SEGN	;PARALLEL SWPLST TABLE FOR USE BY FILSER
SW3LST::BLOCK	JOBN+SEGN	;PARALLEL SWPLST TABLE FOR ADDITIONAL INFO
				; LH=C(SWPOUT) FOR SCHED1, RH=JOB NUMBER
JBTSWP::BLOCK	JOBN+SEGN	; DISK ADDRESS WHILE SWAPPED OUT
				;BIT 0=1 IF SEGMENT IS FRAGMENTED
				;BITS 1-35 DISK ADDRESS IF NOT FRAGMENTED
				;FOR LEVEL D,
				;  BITS 2-4=INDEX OF UNIT IN SWPTAB (JBYSUN)
				;  BITS 5-17=1ST LOGICAL K ON UNIT (JBYLKN)
				;  BITS 18-35 CORE ADR OF FRAGMENT TABLE IF FRAGMENTED
JBTIMI::BLOCK	JOBN+SEGN	;IMAGE-IN SIZE (SEE IMGIN; SEE ALSO NZS?CN)
JBTIMO::BLOCK	JOBN+SEGN	;IMAGE-OUT SIZE (SEE IMGOUT)
JBTCHK::BLOCK	JOBN+SEGN	;CHECK SUM FOR SWAPPED OUT JOB DATA AREA OR
				; SAME AREA FOR HIGH SEG

JBTNAM::			;NAME OF HIGH SEGMENT (FILE IT WAS INITIALIZED FROM)
JBTPRG::BLOCK	JOBN+SEGN	;NAME OF FILE USED IN LAST R,RUN,GET, ETC
				; USED BY SYSTAT PROGRAM, AND AS DEFAULT FOR
				;  THESE COMMANDS

JBTWCH::BLOCK	JOBN		;BITS 1-5 = ENABLE BITS - SEE S.MAC
				;BITS 13-35 = TIME OF DAY IN JIFFIES USER
				;STARTED TO WAIT FOR RESPONSE FROM SYSTEM
				;REST UNUSED

IFN FTRSP,<			;USER TTY INPUT RESPONSE TIMES
JBTRSP::BLOCK	JOBN		;UP TIME AT WHICH USER BEGAN TO WAIT
				; FOR SYSTEM RESPONSE.
				; SET WHEN USER JOB COMES OUT OF TTY INPUT WAIT
				; OR TYPES A COMMAND WHICH RUNS A JOB.
				;HIGH ORDER BITS SET TO 0 WHEN USER STARTS TO WAIT
				; SET TO ONE AS EACH OF SEVERAL TYPES OF RESPONSE
				; TERMINATION CONDITIONS OCCUR.
				; SEE S.MAC FOR BITS OF FORM JR.R??
				; SEE CPU DATA BLOCK (ACR, ADR, AIR, ARR, AXR)
				; FOR DESCRIPTION OF TYPES OF RESPONSES GATHERED
JBTRQT::BLOCK	JOBN		;'RUN QUEUE TIME' ACCUM. TIME (JIFFIES) THAT JOB
				; HAS SPENT IN ONE OF THE RUN QUEUES (INCLUDING SWAPPED)
>
JBTSPL::BLOCK	JOBN		;LH=INPUT FILE NAME COUNTER
				;BITS 27-35 - WHAT DEVICES BEING SPOOLED
				; (SEE S.MAC FOR DEF'NS)
				;BITS 24-26 = DSK PRIORITY FOR JOB
				; (SEE JBXPRI IN COMMOD)

JBTLIM::BLOCK	JOBN		;TIME LIMIT, ETC. FOR JOB
				; (SEE S.MAC FOR LAYOUT)


JBTPDB::BLOCK	JOBN		;ADDRESS OF PDB

JBTPC::	BLOCK	JOBN		;USER MODE PC
JBTCLM::			;LH=CORE LIMIT (FORMERLY IN JBTLIM)
JBTDDB::BLOCK	JOBN		;RH=DDB JOB IS IN I/O WAIT FOR
JBTDAU::BLOCK	JOBN		;LH=UDB FOR WHICH JOB OWNS DA
				;RH=PPB FOR WHICH JOB OWNS AU

IFG SEGN,<			;REENTRANT MONITOR CAPABILITY?
JBTSHR==:.-JOBN			;JUST HIGH HALF (NO ENTRIES FOR LOW SEGS)
	BLOCK	SEGN		;HIGH SEGMENT TOTAL SHARER COUNT
>
IFE SEGN,<
JBTSHR==:JBTSGN-JOBN		;USE THE DUMMY ENTRY IN JBTSGN
	XP	ITMSHR,JBTMXL	;LH SYMBOL FOR GETTAB UUO SO THAT JBTSHR IS
				;UNDEFINED, IE. MAKE INDEXING BYITEM BE 0
>

JBTIPC::			;RH=JCH WHOM WE WANT IPCF INTERLOCK  FOR
JBTDTC::BLOCK	JOBN		;LH=MASTER DECTAPE DDB JOB WANTS
IFN M.CTX,<
JBTCX::BLOCK	JOBN		;LH=JOB # WHOSE CX RESOURCE OWNED BY INDEX
				;RH=JOB # WHO OWNS CX RESOURCE OF INDEX
> ;END IFN M.CTX
JBTLOC::BLOCK	JOBN		;JOB LOCATION TABLE
				;JBTLOC+0 IS CENTRAL SITE STATION NUMBER

IFN M.PSI,<
JBTPIA::BLOCK	JOBN		;LH HOLDS FLAGS (BITS 13-17 =0)
				;RH IS POINTER TO PROGRAM INTERRUPT
				;   TABLE.
>
IFE M.PSI,<
XP JBTPIA,777000		;CAUSE NXM IF REFERENCED
>
JBTJLT::BLOCK	JOBN		;JOB "LOGIN" TIME IN INTERNAL FORMAT

JBTHSA::			;FOR HIGH SEGS, PTR TO FIRST PAGE
JBTAD2::BLOCK	JOBN+SEGN	;BIT 0 FREE
				;BITS 1-21 DISK ADDR OF S0 MAP FOR JOB
				;BITS 22-35 PHYSICAL PAGE ZERO OF JOBS LOW SEG
JBTJRQ::BLOCK	JOBN		;LINKED LIST OF JOBS WAITING FOR REQUEUE
JBTPRV::BLOCK	JOBN		;PRIVILEGE BITS FOR JOB SET BY LOGIN

;THE FOLLOWING ARE USED TO CREATE MXQUE
;THE MAXIMUM QUEUE SIZE, USED BY SWAPPING SCHEDULER (SCHED)
	XP	MXQUE,0

	DEFINE	X	<MXQUE==MXQUE+1;>
	QUEUES
	RWAITS
DEFINE	X	(A)

		<A'Z==MXQUE
		MXQUE==MXQUE+1;>
	CODES
		MXQUE==MXQUE+3	;LEAVE SPACE FOR PQ1,PQ2, AND CMMQ


	IFG	M.HPQ,<MXQUE=MXQUE+M.HPQ>
			;LEAVE SPACE FOR HIGH PRIORITY QUEUES

XP MXQUE2,<2*MXQUE>
	BLOCK	MXQUE2		;NUMBER OF QUEUES FOR SWAPPING SCHEDULER
QQQMXL==:<MXQUE-1>B26		;NUMBER QUEUES FOR GETTAB
JBTCQ::	BLOCK	JOBN		;ONE ENTRY PER JOB,
				; LH=PREVIOUS JOB, RH=NEXT JOB IN QUEUE
				; NEGATIVE MEANS THIS IS FIRST (LH) OR LAST (RH)
				; JOB IN QUEUE
JBCQM1==:JBTCQ-1		;
JBCQP1==:JBTCQ+1
NCNULQ==:NULZ+MXQUE		;NUMBER OF NULQ IN NO-CORE HEADER
JBCQMN==:JBTCQ-NCNULQ		;NUL QUEUE HEADER
JBCQOH==:JBTCQ-MXQUE		;WHAT TO INDEX TO GET SWAPPED OUT QUEUE HEADER
IFN FTNSCHED,<
	BLOCK	2*M.CLSN	;HEADER FOR PQ2 SUBQUEUES
JBTCSQ::BLOCK	JOBN		;SAME AS JBTCQ FOR SUBQUEUES
	JBCSOH==:JBTCSQ-M.CLSN	;SWAPPED OUT SUB-QUE HEADER
>;END OF IFN FTNSCHED
JBTHSQ::BLOCK	1		;HEADER FOR JOBS WAITING FOR A HIGH SEG
JBTBBQ::BLOCK	1		;HEADER FOR BB JUST INPUT QUEUE
JBTJIQ::BLOCK	1		;HEADER FOR PQ2 JUST INPUT QUEUE
JBTJIL::BLOCK	JOBN		;LIST OF PQ2 JOBS JUST INPUT
	HSQ==:JBTJIL-JBTHSQ
	BBQ==:JBTJIL-JBTBBQ	;OFFSET FOR JBTBBQ
	MBBQ==:-BBQ		;NEGATIVE OFFSET
	JIQ==:JBTJIL-JBTJIQ	;OFFSET FOR JBTJIQ

JBTDIH::BLOCK	1		;HEADER FOR QUEUE OF DORMANT/IDLE HISEGS
JBTOBQ::BLOCK	1		;HEADER FOR BB OUTPUT SCAN LIST
JBTOLQ::BLOCK	1		;HEADER FOR PQ2 OUTPUT SCAN LIST
JBTOLS::BLOCK	JOBN		;LIST OF PQ2 IN ORDER TO BE SCANNED FOR OUTPUT
	BLOCK	SEGN		;ALSO, PUT QUEUE OF IDLE/DORMANT SEGMENTS HERE
JBTDIQ==:JBTOLS		;GIVE IT A DIFFERENT NAME
	DISQ==:JBTDIQ-JBTDIH	;DORMANT/IDLE QUEUE HEAD
	OBQ==:JBTOLS-JBTOBQ	;OFFSET FOR JBTOBQ
	MOBQ==:-OBQ
	OLQ==:JBTOLS-JBTOLQ	;OFFSET FOR JBTOLQ
;DATA STRUCTURE CLEARED ON SYSTEM STARTUP AND ON 143 RESTART


;TTYTAB IS A TABLE OF CONTROLLING (ATTACHED) TTY'S FOR EACH JOB,
;INDEXED BY JOB NUMBER. IF C(TTYTAB)=0 THEN THERE IS NO SUCH JOB.
;OTHERWISE, RH(TTYTAB(N)) IS CONTROLLING DDB FOR JOB N.

;THERE IS ALWAYS A TTY DDB FOR EVERY JOB, EVEN THOUGH NO TTY
; NEED BE ATTACHED.  THUS UUOS LOOK THROUGH TTYTAB(N) FOR A DDB,
; SINCE UUO'S COME FROM JOBS.  COMMANDS LOOK THROUGH LINTAB(LINENUMBER)
; TO THE LDB, SINCE COMMANDS COME FROM TTY'S (LINES).
; IF THE JOB IS DETACHED, THE LINKS FROM LDB TO DDB AND VICE VERSA
; ARE ZEROED (RH OF DDBLDB AND LDBDDB).
TTYTAB::BLOCK	JOBN
TTYDDL::BLOCK	1		;DIALLER INTERLOCK
TTYDDA::BLOCK	1		;TTY DIALLER DATA ADDRESS, 4 WORD BLOCK
DSDUNI::BLOCK	1		;TTY NUMBER USING DIALLER CODE


XPNMSZ==<JOBN/^D32>+1		;SIZE OF BIT MAP
XPNMAP::BLOCK	XPNMSZ		;BIT MAP OF EXPANDING JOBS
XP XPNMPT,-XPNMSZ		;FOR MAKING AOBJN POINTER
SPTTAB::			;SPECIAL PAGES TABLE

;SPT ENTRIES FOR CURRENT CONTEXT MUST IMMEDIATELY PRECEDE JBTUPM
;(FUNNY SPACE MAPPED IN THROUGH THESE SPT ENTRIES)

REPEAT M.CPU,<
	EXP	NUPMPP
>; END REPEAT M.CPU

JBTUPM::BLOCK	JOBN+SEGN	;ADDRESS OF THE UPMP

;SPT SLOTS FOR SPYING ON SECTION 0/1
;(INDIRECT POINTERS TO SECTION 0/1 LOW SEGMENT PAGES AND COMMON
;SUBROUTINE PAGES MAPPED IN THROUGH THESE SPT ENTRIES)

SPTLOW::

DEFINE	SPTENT(N),<
	EXP	.E'N'MAP/PAGSIZ
>; END DEFINE SPTENT
	ZZ==0
REPEAT M.CPU,<
	SPTENT	(\ZZ)		;GENERATE THEM
	ZZ==ZZ+1
>; END REPEAT M.CPU

;SPT SLOTS FOR SPYING ON SECTION 2

SPTHGH::

DEFINE	SPTENT(N),<
IFE FTXMON,<0>
IFN FTXMON,<
	EXP	.E'N'MP1/PAGSIZ
>; END IFN FTXMON
>; END DEFINE SPTENT
	ZZ==0
REPEAT M.CPU,<
	SPTENT	(\ZZ)		;GENERATE THEM
	ZZ==ZZ+1
>; END REPEAT M.CPU

;SPT SLOTS FOR SPYING ON COMMON DATA SECTIONS

IFN FTXMON,<

SPTCOM::

REPEAT <HLGSNO-<(MS.FMD)>>,<
	XWD	1,0		;GENERATE THEM (INVALID UNTIL SYSINI FILLS IN)
>; END REPEAT
>; END OF IFN FTXMON
SUBTTL	SYSTEM WIDE VARIABLES

;SYSTEM WIDE VARIABLES:
; CLEARED AT SYSTEM STARTUP

;GETTAB FOR SYSTEM WIDE VARIABLES (AS OPPOSED TO PER CPU DATA)
; GETTAB TABLE NO(RH) IS .GTSYS=51


SYSTBL::		;GETTAB TABLE NO. 51.  ( .GTSYS = 51
SYSERR::0		;(0) TOTAL NUMBER OF HARDWARE AND SOFTWARE ERRORS
			; DETECTED BY THE MONITOR AND ENTERED IN DAEMON
			; ERROR LOG FILE INCLUDING DAEMON ERRORS.
			; INCLUDES HARD AND SOFT ERRORS
			; HARD ERROR WITH 80 RETRIES ONLY COUNTS AS 1 ERROR IN SYSERR.
CMNOTF::0		;(1) NUMBER OF TIMES SCNSER WAS CALLED TO
			; FIND A COMMAND BECAUSE COMCNT WAS
			; NON-ZERO AND NO COMMAND WAS FOUND
DELCNT::0		; (2) DISABLED ERROR LOGGING COUNT
			; INCREMENT INSTEAD OF SYSERR IF USER HAS DISABLED
			; ERROR LOGGING IN OPEN UUO
%SYSPC::0		;(3) FULLWORD PC OF LAST STOPCODE
%SYNDS::0		;(4) NUMBER OF DEBUG STOPCD'S.
%SYNJS::0		;(5) NUMBER OF STOPCD'S WHICH CAUSED A JOB TO BE
			;    STOPED.
COMTOT::0		;(6) NUMBER OF COMMANDS PROCESSED
			; (DELAYED COMMANDS ARE COUNTED ONCE WHEN PROCESSED)

%SYSJN::0		;(7)JOB# OF JOB ON LAST STOPCD
%SYSTN::0		;(10)TTY NAME FOR LAST STOPCD
%SYSPN::0		;(11)PROGRAM NAME FOR LAST STOPCD
%SYSUU::0		;(12)UUO ON LAST STOPCD
%SYSUP::0		;(13)USER'S PC ON LAST STOPCD
%SYSPP::0		;(14)USER'S PPN ON LAST STOPCD
%SYSCD::0		;(15)NAME OF LAST STOPCODE
%SYNCS::0		;(16)TOTAL NUMBER OF CPU STOPCODES
%SYNIS::0		;(17)NUMBER OF NODUMP STOPCDS (BUGINFS)
%SYSTY::0		;(20)TYPE OF LAST STOPCODE
%SYSDT::0		;(21)UDT OF LAST STOPCODE
%SYSCP::-1		;(22)CPU NUMBER OF LAST STOPCD
XP SYSMXL,<<.-SYSTBL-1>B26>	;MAX. ENTRY
;UNPUBLISHED SYSTEM VARIABLES:

;OTHER SYSTEM DATA STORAGE


COMCNT::0			;NUMBER OF COMMANDS TYPED-IN BUT NOT DECODED
				;SET BY SCNSER, DECREMENTED BY COMCON
IFN FTMP,<
COMJOB::0			;JOB NUMBER OF JOB CURRENTLY EXECUTING
				; A COMMAND USED TO AVOID JOBSTS UUO RACE
>
NFCNT::	0			;COUNT OF TIMES COMCNT NON-ZERO,
				;BUT NO WAITING COMMANDS
HNGMIN::0			;DO ONCE PER MINUTE FUNCTIONS WHEN THIS
				;FLAG COUNTS NEGATIVE
				; SCHEDULER SCANS ALL JOBS EVERY
				; MINUTE TO SEE IF QJOB HAS BEEN COUNTED
				; DOWN TOO FAR.  MORE LIKELY IN DUAL CPU SYS.

CHKCNT::0			;NO. OF CALLS TO CHKTAL TO CHECK CORE
				; BEFORE ACTUALLY DOING THE OVERHEAD.
				; RESET TO M.CMCT WHEN COUNTS TO 0.


DATREM::0			;LAST REMAINDER IN UPDATING "DATE" (SMITHSONIAN DATE)

SCDTIM::0			;DECREMENTED EVERY JIFFY, END OF MEDIUM
				;TERM SCHED INTERVAL WHEN THIS REACHES ZERO.
;STORAGE FOR VARIOUS CORE ALLOCATION FUNCTIONS AND OTHER NON-SWAPPING DATA


	XP	CRSIZ,9
	XP	CRPOS,8
XP PP256K,^D512/<<PAGSIZ>_-^D9>



;MAXIMUM NUMBER OF PAGES OF PHYSICAL MEMORY POSSIBLE

IFN M.KL10,<
	XP CORBLK,<1_<^D22-^D9>> ;22 BIT PHYSICAL ADDRESSES (4 MEGAWORD)
>
IFN M.KS10,<
	XP CORBLK,<1_<^D20-^D9>> ;20 BIT PHYSICAL ADDRESSES (1 MEGAWORD)
>

IFN FTLOCK,<
LOCK::	0			;JOB#,,HIGH SEGMENT# OR
				;0,,JOB# IF NO HIGH SEGMENT
				;OF JOB CURRENTLY BEING LOCKED IN CORE

LOKREL::0			;DESIRED PROTECTION,,RELOCATION
				;FOR JOB CURRENTLY BEING LOCKED
	PAGLOK==:1B18		;FLAG THAT WE'RE LOCKING SPECIFIC PAGES
LASLOK::0			;JOB # OF LAST JOB LOCKED
>;END IFN FTLOCK

MOFLPG::0			;FLAG FOR SETTING MEMORY ON OR OFF LINE
LMPAG::0			;LAST PAGE IN MONITOR'S PAGTAB CHAIN

DOORBL::0			;SYSTEM DOORBELL
IFN FTKL10&FTMP,<
SAVCTL::0			;VALUE OF CORTAL WHEN MM RESOURCE WAS OBTAINED
>

;GFWN?? ALLOCATION CONTROL STUFF

NZSFCA:	BLOCK	1+MXSECN	;HEAD OF SECTION FREE CORE LISTS

	$HIGH
DEFINE	NZSMAC	(SECT),<400000,,NZSFCA+SECT>
	ZZ==0
NZSFCH::			;POINTERS TO SECTION FREE CORE HEADERS
REPEAT	1+MXSECN,<
	NZSMAC	(\ZZ)
	ZZ==ZZ+1
>
NZSFCL==:.-NZSFCH		;LENGTH OF TABLE
	$ABS
NZSFCE::			;TAIL POINTERS FOR NZS FREE CORE
	BLOCK	NZSFCL		;ACTUALLY FILLED IN BY SYSINI
;DATA LOCATIONS PRESENT ONLY IN SWAPPING SYSTEMS

SWPTBL::!			;FIRST LOCATION OF MONITOR DATA STORAGE
				; RETURNED BY GETTAB UUO (THESE LOCATIONS
				; PRESENT ONLY IN SWAP SYSTEMS)
				; OCTAL NUMBERS IN () CORRESPOND TO GETTAB ARG
				;THIS IS DOCUMENTED AS GETTAB TABLE NUMBER 13
BIGHOL::0			;(0) CURRENT BIGGEST HOLE IN CORE (1K BLOCKS)
FINISH::0			;(1) IF +, THEN JOB NUMBER OF JOB BEING SWAPPED IN,
				;IF -, THEN JOB NUMBER OF JOB BEING SWAPPED OUT
FORCE::	0			;(2) JOB NUMBER BEING FORCED TO SWAP OUT
FIT::	0			;(3) JOB NUMBER WAITING TO BE FITTED INTO CORE
VIRTAL::0			;(4) NUMBER OF FREE 1K BLOCKS OF SWAPPING SPACE LEFT
				; (COUNTING DORMANT SEGMENTS AS IF FREE).
				; PRINTED WITH CORE COMMAND (NO ARG) OR ERROR
				; USUALLY THE SAME AS THE AMOUNT OF VIRTUAL CORE
				; LEFT IN SYSTEM, EXCEPT WHILE R,RUN,KJOB,GET
				; COMMAND ARE WAITING TO BE SWAPPED IN, BECAUSE
				; THE OLD DISK SPACE HAS NOT BEEN RETURNED YET,
				; BUT VIRTUAL CORE IS ONLY 140 WORDS FOR SWAPIN
SWPERC::0			;(5) LH= NUMBER OF SWAPPER READ OR WRITE FAILURES
				; RH= ERROR BITS (BITS 18-23) + NUMBER OF K OF
				; IOCHNX=IO CHANNEL SWAP NON-EX MEM - BIT 23
				; IOCHMP=IO CHANNEL SWAP OUT MEMORY PARITY - BIT 22
				; BITS 18-22 = IOIMPM (SOFTWARE CHECKSUM),
				; IODERR, IODTER, IOBKTL
				; DISCARDED SWAPPING SPACE
SWAPIN::0			;(6) IF THE SYSTEM HAS FTPDBS TURNED ON,
				;     THIS WORD IS -1 WHEN A SWAPIN IS
				;     IN PROGRESS AND ZERO WHEN A SWAP OUT
				;     IS IN PROGRESS. IF FINISH IS ZERO
				;     THEN NO SWAP IS IN PROGRESS. IF FTPDBS
				;     IS OFF THIS WORD IS ALWAYS ZERO.



				;INSERT NEW LOCATIONS HERE WHICH ARE OF INTEREST
				; TO USER PROGS IN SWAPPING SYSTEMS
SWPEUJ::0			;(7)LH=J FOR JOB OR SEGMENT WHICH GOT A SWAP
				; READ/WRITE ERROR, RH=UNIT THAT THE
				; SWAPPING I/O WHICH RESULTED IN THE ERROR
				; WAS DONE TO
SWPMXL==:<.-SWPTBL-1>B26	;MAXIMUM ENTRY FOR GETTAB SHIFTED LEFT 9
;MORE SWAPPING SYSTEM LOCATIONS (NOT RETURNED BY GETTAB)

MAXJBN::0			;NUMBER OF JOB TO SWAP OUT
SUMCOR::0			;TEMPORARY STORAGE CELL USED BY SWAPPER FOR SUM OF
				; CORE NEEDED FOR SWAP IN
FITLOW::0			;NUMBER OF JOB BEING FIT (NEVER HI-SEG)
SWPIN::	0			;JOB NUMBER BEING SWAPPED IN IF IT HAS A HIGH SEG
SWPOUT::0			;JOB NUMBER BEING SWAPPED OUT IF IT HAS A HIGH SEG
				; (USED TO REMEMBER THE JOB NUMBER DURING HIGH SEG SWAP)



IFN FTRSP,<
SWPNU2::0			;JIFFY REMAINDER FOR SWAP NULL TIME
SWPLS2::0			;JIFFY REMAINDER FOR SWAP LOST TIME
SWPPLT::0			;POTENTIAL LOST TIME FLAG FOR SWAPPER
				;TO TELL CLOCK1 TO COUNT SOME LOST TIME
				;(HAVE JOB TO SWAP IN BUT SWAPPER IDLE)
SWPNUF::0			;NULL CYCLE FOR SWAPPER (AGAIN, SO CLOCK1
				;CAN COUNT NULL TIME FOR SWAPPER)
>;END IFN FTRSP

IFN FTNSCHED,<
SCDSTS::0			;TIME OF LAST SETTING OF PRIMARY PERCENTAGES
CNTSTS::0			;COUNT OF CPU CLASSES WITH NON-ZERO QUOTA
TOTSTS::0			;TOTAL OF ALL SUBCLASS PERCENTAGES
				; (MUST BE 100 OR ZERO)
MAXQTA::0			;NUMBER OF HIGHEST CLASS WITH SECONDARY QUOTA
CNTQTA::0			;COUNT OF CLASSES WITH NON-ZERO SECONDARY QUOTA
TOTQTA::0			;TOTAL OF ALL SECONDARY SUBCLASS PERCENTAGES
				; NORMALLY 100%, BUT CAN BE ANY NON-NEGATIVE

>;END OF IFN FTNSCHED
	$ABS

IFN M.FPS,<
	EXTERN	KASER		;CAUSE KA10 FP SIMULATION MODULE TO BE LOADED
>
IFE M.FPS,<
XP KALFPS,CPOPJ
XP SETFPS,CPOPJ
XP SETFPC,COMERA##
>
SUBTTL MACROS TO DEFINE PI CHANNELS


;MACROS TO DEFINE PI CHANNEL NUMBER AND GENERATE INTERRUPT CHAINING
; INFORMATION FOR AUTCON SO IT CAN LINK THE DEVICE INTERRUPT SERVICE
; ROUTINES AND THE DEVICE DATA BLOCKS

;TABLE INTTAB IS GENERATED WITH PAIRS OF ENTRIES FOR EACH DEVICE

;BYTE POINTERS TO INTTAB LOCATIONS USED BY AUTCON

PINTNO::POINT	11,INTTAB+0(P1),11	;NUMBER OF DDBS TO CREATE
PINTCP::POINT	 3,INTTAB+0(P1),14	;CPU NUMBER
PINTCH::POINT	 3,INTTAB+0(P1),17	;PI CHANNEL
PINTIN::POINT	18,INTTAB+0(P1),35	;INTERUPT ROUTINE ADDRESS
PINTSZ::POINT	 9,INTTAB+1(P1),17	;SIZE OF DDB TO CREATE
PINTDB::POINT	18,INTTAB+1(P1),35	;ADDRESS OF PROTOTYPE DDB
;MACRO TO GENERATE SYMBOLS FOR AUTOCONFIGURED DEVICES
;ARGUMENTS:
;	GEN	MONGEN SYMBOL (M.XXXX)
;	DEV	3 CHARACTER DEVICE PREFIX (I.E. 'TAP' FOR TAPE SERVICE)
;	PI	PI CHANNEL (USUALLY SPECIFIED AS "\.CH")
;	BITS	EXTRA PI CHANNEL BITS TO BE TURNED OFF OR ON (I.E. PI.SC7)

DEFINE	ASGDEV	(GEN,DEV,PI,BITS),<
IFN GEN,<			;;IF ANY OF THIS DEVICE

	USED'PI==:1		;;GENERATE CHANNEL SAVE ROUTINE
	.CHAS==1		;;CHANNEL HAS BEEN ASSIGNED
	DEV'CHN==:PI		;;PI CHANNEL
	DEV'CHL==:CH'PI		;;LOCATION WHERE INTERRUPT PC IS STORED
	DEV'SAV==:SAV'PI	;;CHANNEL AC SAVE ROUTINE LOCATION
	DEV'SAC==:SVAC'PI	;;STARTING CHANNEL SAVE LOCATION FOR ACS
	DEV'PDP==:C'PI'PDP	;;LOCATION WHERE P STORED
	DEV'PD1==:C'PI'PD1	;;PUSHDOWN LIST
	DEV'BIT==:PI.SC7_<7-'PI> ;;PI CHANNEL BIT
	DEV'PIF==:PI.TFP!<DEV'BIT>!'BITS ;;MASK TO TURN PI CHANNEL(S) OFF
	DEV'PIN==:PI.TNP!<DEV'BIT>!'BITS ;;MASK TO TURN PI CHANNEL(S) ON

> ;;END IFN GEN
> ;END DEFINE ASGDEV


;MACRO TO LINK A DDB WITHOUT A CORRESPONDING DEVICE DRIVER ONTO
;THE INTTAB CHAIN.
;ARGUMENTS:
;	GEN	MONGEN SYMBOL (M.XXXX)
;	DEV	3 CHARACTER DEVICE PREFIX (I.E. 'PTY' FOR PTY)

DEFINE	ASGDDB	(GEN,DEV),<
IFN GEN,<			;;IF ANY OF THIS DEVICE

IF2,<
	IFNDEF DEV'DDB,<EXTERN DEV'DDB>
	IFNDEF DEV'SER,<EXTERN DEV'SER>
>;; END IF2

.IFN	DEV'N,EXTERNAL,<	;;IF NOT EXTERNAL

IFNDEF	DEV'N,<DEV'N==1>	;;IF DEV'N NOT DEFINED, DEFAULT TO 1

IFE	<DEV'N-1>,<		;;IF ONLY A SINGLE DEVICE
	XWD	0,0		;;NO DUPLICATES NEEDED, NO PI CHANNEL STUFF
	XWD	0,DEV'DDB	;;ADDRESS OF PROTOTYPE DDB
>;; END IFE <DEV'N-1>

IFG	<DEV'N-1>,<
IF2,<IFNDEF DEV'DDS,<EXTERN DEV'DDS>>
	XWD	DEV'N*100,0	;;NUMBER OF DDBS TO CREATE
	XWD	DEV'DDS,DEV'DDB	;;SIZE,,ADDRESS  OF PROTOTYPE DDB
>;; END IFG DEV'N-1
>;; END .IFN

.IF	DEV'N,EXTERNAL,<	;;IF EXTERNAL
IF2,<IFNDEF DEV'DDS,<EXTERN DEV'DDS>>
	XWD	DEV'N*100,0	;;NUMBER OF DDBS TO CREATE
	XWD	DEV'DDS,DEV'DDB	;;SIZE,,ADDRESS  OF PROTOTYPE DDB
>;; END .IF

> ;;END IFN GEN
> ;END DEFINE ASGDDB
;;MACRO FOR DEVICES WHICH ARE ALWAYS PRESENT (AND WHICH DO NOT USE A
;; CHANNEL SAVE ROUTINE AND HAVE NO DDB)  EXAMPLES ARE APR, CTY, PEN, CLK...

DEFINE SPAXGINT (DEV,PI) <
	DEV'N==1
	ASGINT	DEV,PI
>


DEFINE ASGIN1 (DEV,PI) <
		DEV'CHL==:CH'PI
>

DEFINE SPASGINT (DEV,PI) <
	DEV'N==1
	ASGINT	DEV,PI
>

DEFINE ASGINT (DEV,PI) <
	IFG	DEV'N, <IFG PI, <
	IFE	<PI-.CH>, <.CHAS==1	;;CHANNEL PI IN USE.
>
		IF2,<IFNDEF DEV'INT,<EXTERN DEV'INT>>
		DEV'CHN==:PI&7
		DEV'CH1==PI		;DEFINE THIS FOR USE AFTER CHAN DEFINITIONS
		XWD PI,DEV'INT		;;GENERATE INTERRUPT ENTRY POINT FOR ONCE
		XWD 0,0
	ASGIN1	DEV,\PI
>>
>


;;MACRO FOR OPTIONAL DEVICES WHICH ALWAYS USE A CHANNEL SAVE ROUTINE
;; (EXAMPLES: CDR, DSK, PTR, ETC.  ALSO PTY WITH 0 PI)

DEFINE SPASGDDB (DEV,PI,NUM) <
	DEV'N==NUM
	NOSAV==1
	ASGSAV	DEV,PI
>
;MACRO TO GENERATE INTTAB ENTRY FOR SAVE ROUTINE BUT NO DDB
;  ASGSVE & ASGSVI
DEFINE ASGSVE (DEV,PI) <

	.CHAS==1
	DEV'CHN==:PI&7
	DEV'CH1==PI
	DEV'HAC==:13

	ASGSV2	DEV,\PI;
IFDIF	<DEV><SCN>,<
IF2 < IFNDEF DEV'INT,<EXTERNAL DEV'INT>> ;DEFINE AS EXTERN IF NOT IN COMMON
		XWD PI,DEV'INT
		XWD 0,0
>
>
DEFINE ASGSAV (DEV,PI) <
	IFG	DEV'N, <
	ASGSV1	DEV,\PI
	>>

;;MACRO FOR:	1. COMPLETION OF THE DEFINITION REQUIRED FOR THOSE
;;		   DEVICES INVOKING THE ASGSAV MACRO
;;		2. DEFINE SYMBOLS FOR DISK (DEV'N=0)

DEFINE ASGSV1 (DEV,PI) <
IF2, < IFNDEF DEV'DDB, <EXTERNAL DEV'DDB>>	;;DEVICE DATA BLOCK ADDRESS
	IFG	PI, <
	IFE	<PI-.CH>, <.CHAS==1	;;CHANNEL PI IN USE.
>
		DEV'CHN==:PI&7		;;DEFINE DEVICE CHANNEL NUMBER
		DEV'CH1==PI		;;USED AFTER CH'PI DEFINITIONS
IFE NOSAV,<
	ASGSV2	DEV,PI
>
>

IFG PI, <
IF2, < IFNDEF DEV'INT, <EXTERNAL DEV'INT>>	;;INTERRUPT SERVICE CONSO INSTRUCTION
>

	IFE	PI, <
		XWD DEV'N*100+0,0	;;NO PI CHANNEL FOR THIS DEVICE
	>
	IFG	PI, <
		XWD DEV'N*100+PI,DEV'INT	;;FIRST WORD OF INTTAB ENTRY
		IFE DEV'N,<EXTERNAL DEV'INT>	;;LEVEL D DISK IN COMMOD
	>

	IFG	DEV'N-1,<
		XWD DEV'DDS##,DEV'DDB	;;MULTIPLE DEVICE SECOND WORD OF INTTAB ENTRY
	>
	IFE	DEV'N-1, <
		XWD 0,DEV'DDB		;;SINGLE DEVICE SECOND WORD OF INTTAB ENTRY
	>
>		;;END ASGSV1 DEFINITION

DEFINE ASGSVN (DEV,X,PI) <
IFG	PI, <
	IFE	<PI-.CH>, <.CHAS==1>	;;CHANNEL PI IN USE.
	DEV'X'CHN==:PI&7	;;DEFINE DEVICE CHANNEL NUMBER
	DEV'X'CH1==PI		;;USED AFTER CH'PI DEFINITIONS
	ASGSV2	DEV'X,\PI
IF2, < IFNDEF DEV'X'INT, <EXTERNAL DEV'X'INT>> ;;INTERRUPT SERVICE CONSO INSTRUCTION
>;END IFG PI

	IFNDEF DEV'X'N,<DEV'X'N==1>
		EXP <DEV'X'N>B11!<PI>B17!DEV'X'INT
	IF2,<IFNDEF DEV'X'DDB,<EXTERN DEV'X'DDB>>
	IFE DEV'X'N-1,<
		EXP DEV'X'DDB
	>;;END IFE DEV'X'N-1
	IFN DEV'X'N-1,<
	IF2,<IFNDEF DEV'X'DDS,<EXTERN DEV'X'DDS>>
		EXP <DEV'X'DDS>B17!DEV'X'DDB
	>;;END IFN DEV'X'N-1
>;;END ASGSVN DEFINITION
;;MACRO'S TO ALLOW GENERATION OF MULTIPLE INTTAB ENTRIES FOR MULTIPLE
;; DEVICES SUCH AS LINE-PRINTERS

DEFINE MULASG (DEV,DE,PI,DSKFL) <
	IFG	DEV'N, <
		ZZ==0
		REPEAT DEV'N, <
			DEVASG DE,\ZZ,PI,DSKFL
			ZZ==ZZ+1
		>
	>
>

DEFINE DEVASG (DE,X,PI,DSKFL) <
	IFE	DSKFL,<DE'X'N==1>	;;DSKFL=1 IF NOT LEVEL D DISK
	IFN	DSKFL,<DE'X'N==0>	;;DSKFL=ZERO IF LEVEL D DISK
	ASGSV1	DE'X,\PI
>


;;MACROS TO CONTROL ASSIGNMENT OF PI CHANNELS TO DEVICES

DEFINE NEXTCH <	.CH==.CH+1	;;START ASSIGNING TO NEXT LOWER CHANNEL
.CHAS==0
NEXTCU \.CH
>
DEFINE NEXTCQ <	IFN .CHAS, <NEXTCH>>	;;START ASSIGNING TO NEXT LOWER CHANNEL IF
					;; CURRENT CHANNEL HAS BEEN USED.
DEFINE NEXTCU (N) < IFDEF UNIQ'N, < IFN UNIQ'N, <NEXTCH>>	;;TO SKIP OVER ANY
					;; SPECIALLY SPECIFIED CHANNELS (RECURSIVELY!)
		IFDEF RTCH'N,<IFN RTCH'N,<NEXTCH>>>	;IF RTCH'N IS DEFINED
					;DURING MONGEN, THAT CHANNEL WILL BE FREE FOR RT DEVICES

DEFINE UNIQDEF(N)
<	UNIQ'N==1
IFDEF	RTCH'N,<IFN RTCH'N,<
	PRINTX	?PI CHAN N CAN NOT BE RESERVED FOR REAL-TIME
	PRINTX	?IT IS NEEDED FOR BLKI/BLKO
>>>
DEFINE	MULFLG,	(DE,X,PI) <
	ASGSVE	DE'X,\PI
>

;;INITIALLY ASSUME NO PI CHANNEL SAVE ROUTINES NEEDED

DEFINE	USED(PI),<
	USED'PI==0
>
ZZ==0
REPEAT	M.CPU,<
ZZ==ZZ+1
REPEAT	7,<
	USED	\ZZ
ZZ==ZZ+1
>>
;MACRO TO ALLOW GENERATION OF CHANNEL SAVE ROUTINES ONLY

DEFINE SPASGSAV (DEV,PI,%ACNUM) <
	HIAC'PI==:%ACNUM
	DEV'HAC==:%ACNUM

	ASGSV2	DEV,PI
>

DEFINE ASGSV2 (DEV,PI) <
		USED'PI==:1		;SET FLAG SO THAT A CHANNEL SAVE
					; ROUTINE WILL BE GENERATED FOR
					; THIS PI CHANNEL
	IFDEF	SAV'PI, <		;WAIT TILL CHANNEL SAVE ROUTINES
					; ARE DEFINED BELOW (IN PASS 2)

		DEV'SAV==:SAV'PI	;CHANNEL AC SAVE ROUTINE LOCATION
		DEV'SV==:SAV'PI		;USED BY DISKS
		DEV'RET==:RET'PI	;CHANNEL AC RESTORE ROUTINE LOCATION
					; (USUALLY POPJ USED)
		DEV'CHL==:CH'PI		;LOCATION WHERE INTERRUPT PC IS STORED
		DEV'SAC==:SVAC'PI	;STARTING CHANNEL SAVE LOCATION FOR AC'S
		DEV'PDP==:C'PI'PDP	;LOCATION WHERE P STORED
		DEV'PD1==:C'PI'PD1	;PUSHDOWN LIST
		DEV'JEN==:C'PI'JEN	;LOCATION WHERE INT. IS DISMISSED
>>
;NOW GENERATE THE TABLE FOR ONCE AND DEFINE PI CHANNEL ASSIGNMENTS


		CTYN==:1	;ALWAYS ONE CTY
IFN M.ANF,<	NETN==1>	;ONLY ONE DDB

	DSKPIN==:PI.TNP	;SET PI ON BIT - WILL ALSO HAVE PI ON FOR DISK CONTOLLERS
	DSKPIF==:PI.TFP	;AND FOR PI OFF

	NOSAV==0	;DO NOT SUPPRESS GENERATION OF SAVE ROUTINES
INTTAB::		;TABLE OF DATA FOR DEFINING PI CHAN AND NUMBER OF DOB

	ASGDDB	(M.KDUP,KDP)	;KDP
	ASGDDB	(M.DMRN,DMR)	;DMR
IF2,<
	IFN M.KDUP,<ASGSV2 KDP,\SCNCHN>
	IFN M.DMRN,<ASGSV2 DMR,\SCNCHN>
>; END IF2

	ASGDDB	(M.KL10,DTE)	;DTE

;GROUP OTHER ASGDDB ENTRIES HERE BEFORE "REAL" ENTRIES
.CHAS==0
.CH==0
NEXTCH		;BEGIN AT CHANNEL 1

;THE FOLLOWING DEVICES MUST HAVE A UNIQUE, HIGH PRIORITY
; CHANNEL FOR BLOCK I/O TRANSFERS.

;PDP10 MAGTAPE BLKI/BLKO PI CHANNEL:

IFNDEF BLKMXC, <BLKMXC==.CH>	;REMEMBER THIS CHANNEL ON PASS 1
.CH==BLKMXC			;ON PASS 2, SKIP OVER BLKI CHANNELS
;THE FOLLOWING ARE GROUPED ON A HIGH PRIORITY CHANNEL, BUT DO NOT
; WRITE INTO THE INTERRUPT LOCATIONS

	ASGDEV	(M.CR10,CDR,\.CH,0) ;CARD READERS

DEFINE DTADF1(X),<
ASGSVE	D'X'D,PI1
>

DEFINE DTADEF(CPU),<
REPEAT M'CPU'TD10,<
	DTADF1(\"ZZZ)
	ZZZ==ZZZ+1
>
>

DEFINE GENDTA,<
ZZ==0
ZZZ=="A"
PI1==.CH
REPEAT M.CPU,<
	DTADEF(\ZZ)
ZZ==ZZ+1
PI1==PI1+10
>
>
	GENDTA

NEXTCQ

;THE FOLLOWING ARE GROUPED ON A CHANNEL FOR HIGH-PRIORITY DEVICES

	ASGDEV	(M.CDP,CDP,\.CH,0) ;CARD PUNCHES

ZZ==0
PI1==.CH
REPEAT M.CPU,<
	MULFLG	AP,\ZZ,\PI1
ZZ==ZZ+1
PI1==PI1+10
>
NEXTCQ

;THE FOLLOWING ARE MEDIUM-PRIORITY DEVICES, AS A GROUP
	ASGDEV	(1,SCN,\.CH,0) ;TERMINAL SCANNER

IFN	M.TTG0,<
	ASGSVE	DL0,.CH
>
IFN	M.TTG1,<
	ASGSVE	DL1,.CH
>
IFN	M.68L0,<
	ASGSVE	CC0,.CH
>
IFN	M.68L1,<
	ASGSVE	CC1,.CH
>

	ASGDEV	(M.PTR,PTR,\.CH,0) ;PAPER TAPE READERS
	ASGDEV	(M.CR10,CRF,\.CH,0) ;CR10 FLAGS

IFN M.KS10,<
	ASGDEV	(M.PTP,PTP,\.CH,0) ;PAPER TAPE PUNCHES
	ASGDEV	(M.CR20,CDR,\.CH,0) ;CARD READERS
DEFINE RX2DF1(x),<
	ASGSVN	RX,x,PI1
>;RX2DF1
DEFINE RX2DEF(CPU),<
    REPEAT M'CPU'RX20,<
	RX2DF1(\"ZZZ)
	ZZZ==ZZZ+1
    >;;REPEAT
>;RX2DEF
DEFINE GENRX2,<
    ZZ==0
    ZZZ=="A"
    PI1==.CH
    REPEAT M.CPU,<
	RX2DEF(\ZZ)
	ZZ==ZZ+1
	PI1==PI1+10
    >;;REPEAT
>;GENRX2
	GENRX2
>;M.KS10
	ASGDEV	(M.LP10!M.LP20,LPT,\.CH,0) ;I/O BUS LINE PRINTERS

DEFINE DTADF1(X),<
ASGSVN	DT,X,PI1
>
	GENDTA

IFE M.DSX&M.TS10,<
	ASGDEV	(M.TAPE,TAP,\.CH,0) ;MAGTAPES
IFN M.TS10,<
	ASGDEV	(M.SA10,SAX,\.CH,0) ;SA10 IBM CHANNEL ADAPTER
>; END IFN M.TS10
>; END IFE M.DSX&M.TS10

IFN M.KS10,<
DEFINE	CTYDEF(X),<
	SPAXGINT CT'X,PI1
>
	PI1==.CH
	ZZ==0
	REPEAT M.CPU,<
		CTYDEF	\ZZ
	ZZ==ZZ+1
	PI1==PI1+10
	>
>;END IFN M.KS10

IFN M.KL10,<
	ASGDEV	(M.ENET,KNI,\.CH,0) ;KLNI

; DEFINITIONS FOR THE DTE

	XP	SPCPI,.CH	;SECONDARY PROTOCOL PI ASSIGNMENT
	XP	PPCPI,.CH	;PRIMARY PROTOCOL PI ASSIGNMENT
DEFINE	DTEDEF(X,Y,PI)<
	ASGSV2	D'X'Y,PI
>
	ZZ==0
PI1==.CH
REPEAT	M.CPU,<
ZZZ==1
REPEAT	4,<
	DTEDEF(\ZZ,\ZZZ,\PI1)
ZZZ==ZZZ+1
>
PI1==PI1+10
ZZ==ZZ+1
>
>;END IFN M.KL10

IFN DL10XI,<
;ADD THE DL10 AT THE END OF THE SCANNER CHANNEL.  NOW YOU WOULD THINK THAT
;	SINCE THE DL10 IS RUN IN VECTORED INTERRUPT MODE, YOU WOULDN'T NEED
;	TO LOOK AT THE DL10 AT 40+2*N CONSO TIME BUT IT TURNS OUT THAT YOU
;	DO.  IT SEEMS THAT SOME (BUT NOT ALL) DL10'S LIKE TO IGNORE THE VECTOR
;	ADDRESS AND CAUSE OLD STYLE INTERRUPTS AND EVEN THEN, NOT ALL THE TIME.
;	THE DL10 ON OUR DEVELOPMENT SYSTEM ACTS LIKE THIS MOST OF THE TIME.
;	IF YOUR DL10 ALWAYS (OR ALMOST ALWAYS) TAKES THE VECTORED INTERRUPT
;	THIS CODE IS IN THE RIGHT PLACE (WILL HARDLY EVER GET THIS FAR ON THE
;	CONSO SKIP CHAIN).  IF IT LIKES TO ACT LIKE A KA-10 DEVICE, MOVE THIS
;	UP (BEFORE "PTR" ASSIGNMENTS) TO SERVICE THEM A LITTLE FASTER.

	ASGSVE	DLX,.CH

IFN M.DAS78,<			;IF WE HAVE DAS78 SUPPORT
	XXIN==	M.D78L		;NUMBER OF LINES
	ASGSAV	XXI,.CH

	XXON==	M.D78L		;NUMBER OF LINES
	ASGSAV	XXO,0		;JUST GENERATE DDB'S
> ;END IFN M.DAS78
> ;END IFN DL10XI

IFN M.ANF,<
;DEFINE THE SYMBOLS FOR THE "NETWORK FRONT END" CHANNEL
;  NOTE THAT BOTH THE DTE-20 AND THE DL-10 MUST BE ON THE
;  SAME CHANNEL

	XP	NTFCHN,.CH	;THE NETWORK FRONT END CHANNEL
	XP	NTFBIT,PI.SC7_<7-NTFCHN>
	XP	NTFIIP,PI.SC7_<7-NTFCHN+^D8> ;INTERRUPT IN PROGRESS
>

NEXTCQ
;THE FOLLOWING ARE LOWER-PRIORITY DEVICES, AS A GROUP
;FIRST ARE THE VARIOUS TYPES OF DISK CONTROLLERS....

	ASGDEV	(M.DISK,DSK,\.CH,0) ;DISKS
IFN M.DSX&M.TS10,<
	ASGDEV	(M.SA10,SAX,\.CH,0) ;SA10 IBM CHANNEL ADAPTER
	ASGDEV	(M.TAPE,TAP,\.CH,0) ;MAGTAPES
>; END IFN M.DSX&M.TS10
IFE M.TS10,<
	ASGDEV	(M.SA10,SAX,\.CH,0) ;SA10 IBM CHANNEL ADAPTER
>; END IFE M.TS10

IFN	M.XTC,<
	MULASG	XTC,XT,.CH,0
	XP	XTCBIT,PI.SC7_<7-XT0CHN>
>
	ASGSAV	PEN,.CH

IFN M.KL10,<
	ASGDEV	(M.PTP,PTP,\.CH,0) ;PAPER TAPE PUNCHES
> ;END IFN M.KL10

	ASGDEV	(M.CDP,CPF,\.CH,0) ;CARD PUNCHES (DATA CHANNEL)
	ASGDEV	(M.PLT,PLT,\.CH,0) ;PLOTTERS

	ASGSAV	VBC,.CH

NEXTCQ


;THE DISPLAY GETS ITS OWN LOW-PRIORITY CHANNEL
	ASGSAV	DIS,.CH

NEXTCQ
;THE NETWORK WANT'S TO RUN ON ANY CHANNEL BETWEEN CLOCK(7) AND DISK
IFN M.ANF,<

;DEFINE THE NETWORK SOFTWARE INTERRUPTS.  LINK CHAIN ON ALL CPU'S
DEFINE	NETDEF(CPU),<
	ASGSVE	NT'CPU,\<.CH+<CPU_3>>
>

ZZ==0
REPEAT	M.CPU,<
	NETDEF	\ZZ
	ZZ==ZZ+1
>
	XP	NETCHN,NT0CHN
	XP	NETBIT,PI.SC7_<7-NT0CHN>
	XP	NETIIP,PI.SC7_<7-NT0CHN+^D8>	;INTERRUPT IN PROCESS
	XP	REQNET,PI.IIO+NETBIT	;CONO PI,REQDXX REQUEST INTERRUPT
	XP	CLRNET,II.CPP+NETBIT	;CONO PI,CLRDXX CLEAR INTERRUPT

IFN M.ANF,<ASGSAV NET,0>	;TO GENERATE A DDB AT THE END OF THE LIST
				;NOTE!! THIS MUST BE THE LAST DDB.
>

NEXTCQ
;LAST IS THE SCHEDULER, ON CHANNEL 7 BY ITSELF

IFG <.CH-7>, <	PRINTX ?NOT ENOUGH PI'S TO SERVICE THIS CONFIGURATION.
		PRINTX ?SUGGEST EDITING COMMON TO PUT MORE DEVICES ON
		PRINTX ? A SINGLE CHANNEL
>

.CH==7

DEFINE CLKDEF(X)<
	CK'X'N==1
	ASGINT	CK'X,\PI1
>
ZZ==0
PI1==.CH
REPEAT M.CPU,<
	CLKDEF(\ZZ)
ZZ==ZZ+1
PI1==PI1+10
>


;NOW FOR SOME PI SYSTEM MASKS FOR DISK, SCANNER, AND NETWORK INTERLOCKS

IFE M.ANF,<			;IF NO NETWORKS
	NTFBIT==0		; DON'T FOOL WITH ANY
	NETBIT==0		; PI CHANNELS
	NTFCHN==0		; ..
	NETCHN==0		; ..
>

	XP	DSKPIN,DSKPIN!NTFBIT!NETBIT!SCNBIT ;INCLUDE SCANNER AND NETWORKS
	XP	DSKPIF,DSKPIF!NTFBIT!NETBIT!SCNBIT
	XP	SCNPIN,DSKPIN!PI.SC7		;INCLUDE DISKS, NETWORKS, CH7
	XP	SCNPIF,DSKPIF!PI.SC7
	XP	NETPIN,DSKPIN!PI.SC7		;INCLUDE DISKS, SCANNER, CH7
	XP	NETPIF,DSKPIF!PI.SC7
IFG M.TAPE,<
;IF THE PROCESSOR DOES A TAPOFF AT UUO LEVEL,
;THE TAPE CH IS TURNED OFF, BUT AN INTERRUPT
;ON THE DSK CH MIGHT STILL BE POSSIBLE (AND OTHERS).
;IF THE INTERRUPT DOES A DSKOFF/DSKON, THE
;TAPE CH MAY BE TURNED BACK ON.
;CURE:  MAKE TAPOFF DISABLE DISK INTERRUPTS ETC.

DEFINE XX(AA,BB),<
IFN  BB&TAPBIT,<XP AA,AA!BB>>
	XP	TPION,PI.TNP!TAPBIT
	XX	TPION,DSKPIN
	XX	TPION,SCNPIN
	XP	TPIOFF,PI.TFP!TAPBIT
	XX	TPIOFF,DSKPIF
	XX	TPIOFF,SCNPIF
IFN M.ANF,<
	XX	TPION,NETPIN
	XX	TPIOFF,NETPIF
>
> ;END IFG M.TAPE
	SPCINT
				;GENERATE ANY SPECIAL DEVICES CUSTOMER IS SUPPLYING
				; WHICH DO NOT USE A CHANNEL SAVE ROUTINE AND HAVE
				; NO DEVICE DATA BLOCK
	SPCDDB
				;GENERATE ANY SPECIAL DEVICES CUSTOMER IS SUPPLYING
				;WHICH HAVE MULTIPLE DEVICE DATA BLOCKS (0 MEANS NONE)
	SPCSAV
				;GENERATE ANY SPECIAL DEVICES CUSTOMER IS SUPPLYING
				; WHICH DO NEED A CHANNEL SAVE ROUTINE

;END OF THE ASSIGNMENT TABLE

	INTNUM==:INTTAB-.	;-LENGTH OF INTERRUPT CHANNEL ASSIGNMENT TABLE
SUBTTL NON-ZEROED DATA BASE

	$ABS

CLKNEW::0			;FLAG TO FORCE RECOMP OF CLKMIN
CLKMIN::BLOCK	M.CPU		;MIN TIME TO EXPIRE FOR THIS CPU
IFNDEF M.PWQC,<			;NUMBER OF EXTRA ENTRIES
IFE FTMP,<M.PWQC==1>
IFN FTMP,<M.PWQC==11>
>
	SLJOBN=JOBN+M.PWQC	;NUMBER OF CLOCK ENTRIES
CIPWT::	BLOCK	2*<SLJOBN>	;CLOCK REQUEST QUEUE
				;WORD 0 - RH=COUNT DOWN JIFFY TIMER
				;	- LH=ROUTINE TO CALL
				;
				;WORD 1 - RH=DATA MEM RETURNED
				;	- BIT 0=REQUEST IS CPU SPECIFIC
				;	- BITS 1-3=CPU#
				;	- BIT 4=SCANNED BY CLOCK1
CIPWTE::!			;FIRST WORD AFTER CIPWT. USED TO CHECK OVERFLOW
	CIPWTM==:CIPWT-1	;FIRST LOC-1 OF CLOCK QUEUE


DIECDB::0			;POINTER (IN PHYSICAL MEMORY) TO CDB IN USE AT
				;STOPCODE TIME. USED TO FACILITATE LOOKING AT
				;DUMPS.
;SPECIAL DEVICE SYMBOLS WHICH INVOLVE PI ASSIGNMENTS
; GOAL: MINIMIZE NO. OF SYMBOLS DEFINED HERE:

;    DECTAPE PI SYMBOLS
IFN M.DTXN,<
	XP	DTBOTH,DADCHN*10+DTACHN	;2ND DECTAPE PI
	XP	DTTURN,300200+DTBOTH
>


;    DISPLAY PI SYMBOLS
IFG M.DIS,<			;DISPLAY
	XP	DISBLK,.E0EPT+40+2*DISCHN	;BLKI/BLKO LOCATION
	XP	PENPIA,PENCHN*10	;PEN PI ASSIGNMENT FOR CONO
	XP	DISBTH,DISCHN+PENPIA	;BOTH DIS AND PEN PIS FOR CONO
XP DISBIT,1
REPEAT	7-DISCHN,<XP DISBIT,DISBIT*2>
>
IFN M.KS10,<
;UBA PI SYMBOLS
	XP UBA1PI,DSKCHN*10		;DISK PI
	XP UBA2PI,0			;UNUSED
	XP UBA3PI,<IFDEF TAPCHN,<TAPCHN*10>+SCNCHN> ;TAPE, COMM & UNIT RCD PI'S
	XP UBA4PI,0			;UNUSED
>; END IFN M.KS10
;BLOCKS FOR SAVE/RESTORE OF MAPPING FOR EDDT

IFE FTXMON,<
SYMSIZ==:270
SYMBK1:: BLOCK	SYMSIZ		;FILLED IN BY ONCE WITH NEW MAPPING INFO
SYMBK2:: BLOCK	SYMSIZ		;WHERE DDT SAVES OLD CONTENTS OF MAP
>; END IFE FTXMON
ASNTAB:	BLOCK	M.CPU		;CPU SERIAL NUMBERS FOR EDDT
				; FILLED IN BY SYSTR0

CNFTBL::!			;SYSTEM CONFIGURATION GETTAB TABLE
CONFIG::SYSNAM			;(000) ASCII
				;(001)  SYSTEM
				;(002)   NAME
				;(003)    (FIVE WORD QUANTITY)
				;(004)     ...
	LOC	CONFIG+5
SYSDAT::SYSDAT			;(005) ASCII SYSTEM BUILD DATE
				;(006) (TWO WORD QUANTITY)
	LOC	SYSDAT+2
SYSTAP::SIXBIT	/DSK/		;(007) SIXBIT NAME OF SYSTEM DEVICE
TIME::	EXP	0		;(010) TIME OF DAY IN JIFFIES
THSDAT::EXP	0		;(011) TODAYS DATE ((Y-1964)*12+(M-1))*31+(D-1)
SYSSIZ::EXP	PAT##		;(012) SIZE OF MONITOR
DEVOPR::			;(013) SIXBIT NAME OF OPERATORS CONSOLE AT THE
IFNDEF OPRLIN,<SIXBIT /CTY/>	;      CENTRAL (PDP10) SITE (IF THIS LOCATION
IFDEF  OPRLIN,<OPRLIN>		;      CONTAINS ZERO, NONE HAS BEEN DESIGNATED)
DEVLST::EXP	0		;(014) LH=ADDRESS OF FIRST DEVICE DATA BLOCK
				;      RH=0
SEGPTR::XWD	-SEGN,JOBN	;(015) AOBJN POINTER TO FIRST HIGH SEGMENT IN
				;      JBTXXX TABLES
	EXP	-1		;(016) FLAG TO INDICATE WHETHER BOTH HARDWARE
				;      AND SOFTWARE HAVE 2 RELOC REG CAPACITY
				;      NON-ZERO IF BOTH DO, 0 IF EITHER OR BOTH
				;      DO NOT SET BY ONCE ONLY CODE

;STATES WORD LH BITS:
	ZZ==0
	ZZ==ZZ!ST.DSK		;DISK SYSTEM
	ZZ==ZZ!ST.SWP		;SWAPPING SYSTEM
	ZZ==ZZ!ST.LOG		;LOGIN
	ZZ==ZZ!ST.FTT		;TTCALL, FULL DUPLEX
	ZZ==ZZ!ST.PRV		;PRIVILEGE CHECKING
	ZZ==ZZ!ST.TWR		;REENTRANT SOFTWARE
	ZZ==ZZ!2B9		;LEVEL D DISK SOFTWARE (ST.TDS)
IFN	INDPPN,<ZZ==ZZ!ST.IND>	;1 IF INDEPENDENT PROJ-PROG NUMBERS
	ZZ==ZZ!ST.IMG		;IMAGE, 8-BIT SCNSER
IFG	M.CPU-1,<ZZ==ZZ!ST.DUL>	;1 IF DUAL CPU SYSTEM
	ZZ==ZZ!ST.MRB		;MULTIPLE RIBS
	ZZ==ZZ!ST.HPT		;HIGH PREC.TIME ATTC.
IFG	M.RTCO,<ZZ==ZZ!ST.EMO>	;1 IF EXCLUDE MON.OVERHEAD FROM USER RUN TIME
	ZZ==ZZ!ST.MBF		;MONITOR BUILT TO HANDLE FOROTS

STATES::EXP	ZZ!SCHEDN	;(017) LH=BITS WHICH DEFINE TYPE OF SYSTEM
				;      RH=SET BY MONITOR "SCHED" COMMAND TO
				;         INDICATE OPERATIONAL STATE OF SYSTEM
				;         SEE ST.??? DEFINITIONS IN S.MAC
SERIAL::EXP	M.C0SN		;(020) SERIAL NUMBER OF CENTRAL PROCESSOR
MEMNSP::EXP	NSPMEM		;(021) NANOSECONDS PER MEMORY CYCLE
PTYPRM::EXP	0		;(022) PTY PARAMETERS FOR BATCH
FREPTR::EXP	0		;(023) AOBJN WORD POINTING TO USE BIT MAP OF
				;      MONITOR 4-WORD CORE BLOCKS
LOCORE::EXP	0		;(024) ABSOLUTE ADDRESS IN MONITOR OF FIRST
				;      WORD OF MONITOR TO BE ALLOCATED IN 4
				;      WORD CHUNKS
STBPTR::EXP	0		;(025) POINTER NOT USED WITH NETWORKS
OPRLDB::EXP	0		;(026) LDB OF OPR TELETYPE
TTFREE::EXP	0		;(027) FILLED IN AT ONCE TIME BY FREE LIST ADR
IFNDEF TTCHKN,<EXTERNAL TTCHKN>
TTCLST::XWD	TTCHKN,0	;(030) LH=NUMBER OF TTY CHUNKS
				;      RH=ADDRESS OF FIRST ONE
TTFREN::EXP	0		;(031) NUMBER OF FREE TTY CHUNKS AT THE MOMENT
LINSAV::EXP	0		;(032) POINTER TO CURRENT TTY SEEN BY COMCON
LINPTR::XWD -TTPLEN##,LINTAB##	;(033) POINTER TO EXAMINE TTY LINE TABLE
MONVER::EXP	A00VER		;(034) VERSION OF MONITOR (LH FOR CUSTOMER)
DSCPTR::XWD MDSLN##,DSCTAB##	;(035) POINTER TO DATASET CONTROL TABLE
DLSRWD::EXP	0		;(036) LAST RECEIVE INTERRUPT FROM DC10
CCIRWD::EXP	0		;(037) LAST RECEIVE INTERRUPT FROM 680
SEGPT1::EXP	JOBN		;(040) LAST DORMANT SEGMENT NUMBER THROWN AWAY
				;      TO FREE UP A SEGMENT NUMBER
LASPOK::EXP	0		;(041) CONTAINS ADDRESS OF LAST WORD CHANGED
				;      IN MONITOR BY A SUCCESSFUL POKE UUO
LASPUC::EXP	0		;(042) RH=COUNT OF SUCCESSFUL POKE UUOS SINCE
				;         SINCE SYSTEM WAS LOADED.
				;      LH=JOB NO. OF LAST JOB WHICH SUCCEEDED
				;         IN CHANGING MONITOR VIA POKE
WHYCOD::EXP	0		;(043) CONTAINS SIXBIT UNABBREVIATED OPERATOR
				;      ANSWER FOR WHY RELOAD ONCE ONLY QUESTION
TICSEC::EXP	0		;(044) CONTAINS NUMBER OF TICKS PER SECOND
				;      SET AT ONCE ONLY TIME BY MEASURING LINE
				;      FREQUENCY (50 OR 60 HERTZ)
PDBPTR:	XWD	0,JBTPDB	;(045) RH=POINTER TO TABLE OF PDB'S FOR JOBS
				;      LH=0 FOR FUTURE EXPANSION
RTCUPS::EXP	0		;(046) RESOLUTION (UNITS/SEC.) OF CLOCK
				;      USED FOR RUN TIME ACCOUNTING
				;      SET & CHANGED BY SETIME
SYSCHN::EXP	0		;(047) LH=ADR OF FIRST CHANNEL DATA BLOCK
				;      RH IS UNUSED
LOGMAX::M.JMAX			;(050) MAX JOBS ALLOWED TO BE LOGGED IN
BATMAX::M.BMAX			;(051) MAX BATCH JOBS ALLOWED
BATMIN::M.BMIN			;(052) MIN BATCH JOBS GARENTEED (RESERVED)
DATE::	EXP	0		;(053) DATE TIME IN NEW FORMAT
				;      LH = DAYS SINCE NOV. 17, 1858,
				;      RH = FRACTION OF A DAY (GMT)
LOGNUM::EXP	0		;(054) NUMBER JOBS CURRENTLY LOGGED IN
BATNUM::EXP	0		;(055) NUMBER BATCH JOBS CURRENTLY LOGGED IN.
LOCYER::EXP	0		;(056) LOCAL YEAR
LOCMON::EXP	0		;(057) LOCAL MONTH (1,2,...,12)
LOCDAY::EXP	0		;(060) LOCAL DAY OF MONTH (1,2,3,...)
LOCHOR::EXP	0		;(061) LOCAL HOUR (MIDNIGHT=0)
LOCMIN::EXP	0		;(062) LOCAL MINUTE (0,1,...,59)
LOCSEC::EXP	0		;(063) LOCAL SECOND (0,1,...,59)
GMTDIF::EXP	0		;(064) DIFFERENCE BETWEEN LOCAL AND GMT TIME.
				;      IN SAME UNITS AS DATE --
				;      E.G. DATE + GMTDIF = LOCAL DATE-TIME
				;      (LH = DAY, RH = FRACT. OF DAY)
DEBUGF::EXP	DEFDEB!DEFBPT	;(065) DEBUGGING STATES WORD
				;      SEE DF.??? DEFINITIONS IN S.MAC
FRUSED::EXP	0		;(066) AMOUNT OF FREE CORE IN USE
				;      (FTRSP CONDITIONAL)
RCCMAX::EXP	0		;(067) HIGHEST ADDRESS USED BY TTY CHUNKS
CNFCVN::EXP	A00CVN		;(070) CUSTOMER VERSION (=C(136))
CNFDVN::EXP	AXXDVN		;(071) DEC VERSION (=C(137))
CNFCHN::EXP	0		;(072) NUMBER OF DATA CHANNELS
CNFRTD::EXP	M.RTD		;(073) NUMBER OF REAL TIME DEVICES
CNFHPQ::EXP	M.HPQ		;(074) NUMBER OF HPQ'S
CNFLDB::EXP	DDBLDB##	;(075) WORD IN TTY DDB WHICH POINTS TO LDB
CNFMVO::EXP	PSIMVO		;(076) MAX. VECTOR OFFSET FOR PISYS. UUO
CNFMIP::EXP	PSIMPI		;(077) MAX. PRIORITY FOR PSISER
CNFMTA::EXP	0		;(100) POINTER TO FIRST MTA DDB AND INDEX
				;      OF START OF DAEMON INFORMATION
CNFET1:	EXP	JOBDAC##+T1	;(101) EXEC AC1 IN USER'S ADDRESS SPACE
CNFLSD:	EXP	DEVLSD		;(102) LENGTH OF SHORT DDB
CNFLLD:	EXP	DEVLLD		;(103) LENGTH OF LONG DDB
CNFLDD:	EXP	DDBLEN##	;(104) LENGTH OF DISK DDB
CNFEXM:	EXP	JOBEXM##	;(105) WORD IN JOBDAT WHICH HOLDS ADDRESS OF
				;      LAST EXAMINE OR DEPOSIT.

	ZZ==0
	ZZ==ZZ!1B35		;BIT 35=1 IF SWAP SPACE ALLOCATED IN PAGES
	ZZ==ZZ!1B34		;BIT 34=1 IF MTA ERROR REPORTING
	ZZ==ZZ!1B33		;BIT 33=1 IF VM MONITOR
IFN M.IPCF,<ZZ==ZZ!1B32>	;BIT 32=1 IF IPCSER IS LOADED
IFN M.PSI,<ZZ==ZZ!1B31>		;BIT 31=1 IF PSISER IS LOADED
IFN M.MPX,<ZZ==ZZ!1B30>		;BIT 30=1 IF MPXSER IS LOADED
	ZZ==ZZ!1B29		;BIT 29=1 IF NON-SUPER ENTER IS SUPPORTED
IFN FTNSCHED,<ZZ==ZZ!1B28>	;BIT 28=1 IF NEW SCHEDULER IS PRESENT
IFN M.EQDQ,<ZZ==ZZ!1B27>	;BIT 27=1 IF ENQ/DEQ IS LOADED
IF2, <ZZ==ZZ!<<ZGAL>B26>>	;BIT 26=1 IF GALAXY-10 FEATURES
	ZZ==ZZ!1B25		;BIT 25=1 MASSBUS ERROR REPORTING
	ZZ==ZZ!1B24		;BIT 24=1 IF NEW TAPSER
	ZZ==ZZ!1B23		;BIT 23=1 IF NEW ERROR REPORTING
	ZZ==ZZ!1B22		;BIT 22=1 IF MORE THAN 127 JOBS SUPPORTED
IFN M.EXE,<ZZ==ZZ!1B21>		;BIT 21=1 IF "SAVE" COMMAND PRODUCES EXE FILE
IFN M.EMRT,<ZZ==ZZ!ST%EMR>	;BIT 20=1 IF EBOX/MBOX RUNTIME IS IN EFFECT
IFN M.XPI,<ZZ==ZZ!ST%XPI>	;BIT 19=1 IF PI TIME EXCLUDED FROM USER RUNTIME
	ZZ==ZZ!1B18		;BIT 18=1 IF FULL 6 CHAR DEVICE NAMES
IFN M.ITA,<ZZ==ZZ!ST%ITA>	;BIT 17=1 IF INTERVAL TIMER IS AVAILABLE
IFE M.CLSS,<ZZ==ZZ!ST%NCS>	;BIT 16=1 IF NOT CLASS SYSTEM SCHEDULER
	ZZ==ZZ!ST%NER		;BIT 15=1 MONITOR SUPPORTS 6.03 ERROR REPORTING
IFN M.ACV,<ZZ==ZZ!ST%ACV>	;BIT 14=1 IF ACCOUNT VALIDATION SHOULD BE DONE
	ZZ==ZZ!ST%LSC		;BIT 13=1 IF LOW SEGMENT OF MONITOR IS CACHED
IFN FTMDA,<ZZ==ZZ!ST%MDA>	;BIT 12=1 IF MOUNTABLE DEVICE ALLOCATOR SUPPORT
	ZZ==ZZ!1B11		;BIT 11=1 IF KL PAGING
IFN M.DECN,<ZZ==ZZ!1B10>	;BIT 10=1 IF DECNET LOADED
IFN FTXMON,<ZZ==ZZ!1B9>		;BIT  9=1 IF EXTENDED ADDRESSING MONITOR
IFN M.RCMP,<ZZ==ZZ!1B8>		;BIT  8=1 IF RESTRICTED COMMAND SET FOR REMOTES
IFN M.NPPC,<ZZ==ZZ!ST%NPP>	;BIT  7=1 IF DISABLING PRIMARY PROTOCOL
IFN M.DECN,<ZZ==ZZ!0B6>		;BIT  6=1 IF RUNNING AS DECNET ENDNODE (SET
				;            BY DECNET INITIALIZATION CODE)
CNFST2::EXP	ZZ		;(106) FLAG BITS DEFINED ABOVE
	EXP	M.PSI*C$MIN	;(107) MINIMUM CONDITION FOR PISYS.UUO
	EXP	PITSIZ		;(110) LENGTH OF PI TABLE
CNFPIA::EXP	JBTPIA		;(111) ADDRESS OF JBTPIA
%CNMNT:	BYTE	(1)0(17)0(6)1(6)0(6)0	;(112) TYPE OF MONITOR
					;    (1)=STRANGE
					;    (17)=RESERVED TO DEC
					;    (6)=TYPE:	1=TOPS-10
					;		2=I.T.S.
					;		3=TENEX
					;		REST RESERVED TO DEC
					;    (6)=SUBTYPE (RESERVED TO DEC)
					;    (6)=RESERVED TO CUSTOMERS

CDROCR::EXP	0		;(113) OFFSET TO CARD COUNT FOR CDR
CDPOCC::EXP	0		;(114) OFFSET TO CARD COUNT FOR CDP
	EXP	PAGSIZ		;(115) BASIC UNIT OF CORE ALLOCATION
	EXP	MINMAX		;(116) MINIMUM VALUE FOR CORMAX
	EXP	M.CLSN		;(117) NUMBER OF SCHEDULER CLASSES
	EXP	0		;(120) EXPONENTIAL FACTOR FOR COMPUTING
				;      USER TIME
SYSORG::EXP	0		;(121)
SYSLEN::EXP	0		;(122)
NWCORE::EXP	2000*M.NKC	;(123) NUMBER OF WORDS OF CORE
NXMPTR::EXP	0		;(124) AOBJN POINTER TO NXMTAB USED TO
				;      SCAN FOR ZEROES
	EXP	NETNDB##	;(125) POINTER TO THE FIRST NODE BLOCK
	EXP	0		;(126) OBSOLETE
	EXP	0		;(127) OBSOLETE
HNGLST::XWD	0,0		;(130) LH = COPY OF DEVLST
				;      RH = UNUSED
	EXP	BOOTXT		;(131) ADDRESS OF RELOAD CCL TEXT
TAPDDP::EXP	0		;(132) OFFSET OF DDB ADDRESS IN TUB
	EXP	0		;(133) OBSOLETE
NOCPUS::EXP	M.CPU		;(134) NO OF CPUS MONITOR WAS BUILT FOR
	XWD	PJBNLH,DEVJOB	;(135) GETTABLE PJOBN (SANS INDEX FIELD)
SYSUPT::EXP	0		;(136) SYSTEM UPTIME IN TICKS
BOOTCP::EXP	-1		;(137) BOOT CPU NUMBER
BOOTCT::EXP	CTYLIN##	;(140) BOOT CPU CTY LINE NUMBER
NCPRUN::EXP	M.CPU		;(141) NUMBER OF CPUS ALLOWED TO RUN
STRMON::SIXBIT	/SYS/		;(142) FILE STRUCTURE MONITOR WAS BOOTED FROM
FILMON::SIXBIT	/SYSTEM/	;(143) FILE NAME
EXTMON::SIXBIT	/EXE/		;(144) EXTENSION
PPNMON::XWD	1,4		;(145) PPN
SYSNBP::EXP	MAXNBP		;(146) MAXIMUM NUMBER OF BREAK POINTS SETTABLE
				;      BY THE SNOOP. UUO
MONVFF::EXP	MONORG		;(147) FIRST FREE VIRTUAL ADDRESS ABOVE MONITOR
LDBVRG::EXP	0		;(150) VIRTUAL ADDRESS OF THE ORGIN OF LDBS
FOPHXC::EXP	HIGHXC-20	;(151) NUMBER OF EXTENDED CHANNELS AVAILABLE
				;      VIA THE FILOP. UUO
MONHSO:	EXP	MONORG		;(152) VIRTUAL ADDRESS OF START OF MONITOR
				;      HIGH SEGMENT
RSDTTM::EXP	0		;(153) UNIVERSAL DATE/TIME OF LAST ROLE SWITCH
				;      ON MULTIPLE CPU SYSTEMS
CNFDCH:	EXP	LDBDCH##	;(154) OFFSET OF LDBDCH IN LDB'S
SFDMON::EXP	0		;(155) 1ST SFD MONITOR WAS BOOTED FROM
	EXP	0		;(156) 2ND SFD MONITOR WAS BOOTED FROM
	EXP	0		;(157) 3RD SFD MONITOR WAS BOOTED FROM
	EXP	0		;(160) 4TH SFD MONITOR WAS BOOTED FROM
	EXP	0		;(161) 5TH SFD MONITOR WAS BOOTED FROM
	EXP	FRCLIN##	;(162) TTY LINE NUMBER OF FRCLIN
PTYPTR::EXP	0		;(163) POINTER TO PTY TABLE
	-LATLEN##,,NETLAT##	;(164) -LENGTH,,LOCATION LINK ADDRESS TABLE
CNFLPD:	EXP	.PDLEN		;(165) LENGTH OF A PDB
	XWD	0,PAGSIZ	;(166) LH=FLAG
				;      RH=SIZE OF LARGEST JOBPEK TRANSFER
				;      WHERE FLAG=0 IF SWAP SPACE JOBPEKS MAY
				;      NOT CROSS A PAGE BOUNDARY AND FLAG=1
				;      IF THEY MAY
CNFDAE::EXP	DAEVER		;(167) LH=OLD DAEMON NAME
				;      RH=CURRENT MONITOR VERSION
				;      OLD DAEMON NAME IS THE SIXBIT NAME
				;      OF THE PREVIOUS MONITOR, E.G. 701
CNFHSH::XWD	-HSHLEN,HSHTAB	;(170) AOBJN POINTER TO HSHTAB
	EXP	.PDACS		;(171) OFFSET IN PDB FOR ACCOUNT STRING
	TOPLN1##,,TOPTB1##	;(172) POINTER TO TOPTB1, TRMOP DISPATCH
	EXP	JBTSFD##	;(173) POINTER TO JBTSFD
	EXP	CIPWT		;(174) POINTER TO CLOCK QUEUE
ND	PRVPRV,<-1,,0>		;DEFINE DEFAULT PRIVS
CNFPRV::EXP	PRVPRV		;(175) DEFINE PRIVED JOB PRIVS
IFN M.DECN,<
CTHREV::CTHR			;(176) CTERM HOST REVISION STRING
				;(177) (TWO WORD QUANTITY)
>
IFE M.DECN,<
CTHREV::EXP	0,0		;(176) NO CTERM SUPPORT
				;(177) (TWO WORD QUANTITY)
>
LAHNDB::EXP	0		;(200) LAT HOST NODE DATA BASE ADDRESS
	EXP	OUTMSK		;(201) 'AND' MASK FOR JBTIMI/JBTIMO/JBTVIR
				;      TO REDUCE TO ACTUAL PAGE COUNT
	.LNKEND	.LKACB,SYSACB
SYSACB::EXP	0		;(202) FIRST ALLOCATION CONTROL BLOCK ADDRESS
	.LNKEND	.LKAHB,SYSAHB
SYSAHB::EXP	0		;(203) FIRST ALLOCATION HEADER BLOCK ADDRESS
	EXP	IPKDDB		;(204) OFFSET OF DRAM DUMP BUFFER IN IPA20 KDB
DEFTTT::EXP	M.DTTT		;(205) DEFAULT TTY TYPE FOR SYSTEM
SYSUTM::EXP	0		;(206) SYSTEM UPTIME IN MILLISECONDS
CNFREM:	EXP	LDBREM##	;(207) OFFSET OF LDBREM IN LDB'S
CNUK4S:	EXP	UNIK4S		;(210) OFFSET OF UNIK4S IN UDB'S
STOPTN::EXP	0		;(211) STARTUP OPTION
DAEJOB::EXP	-1		;(212) JOB NUMBER OF DAEMON
CNFMXL==:<.-CNFTBL-1>B26	;MAXIMUM ENTRY IN CNFTBL FOR GETTAB UUO
ERRLAP::EXP	0		;COUNT OF ERRORS NOT LOGGED (LOST)
LOWLIM::EXP	0		;HIGHEST POSSIBLE ADDRESS IN LOW SEGMENT
USRCOR::EXP	0		;TOTAL AMOUNT OF USER CORE AVAILABLE
				; NOT CURRENTLY UPDATED BY SET MEMORY OFF

;----------------------------------
;INSERT HERE ANY NEW LOCATIONS OF INTEREST WHICH ARE SET UP BY ONCE ONLY CODE.
; OR ARE CONSTANTS WHICH ARE NOT CLEARED AT STARTUP
;-------------------------------------
DEBCPU::EXP	-1		;CPU NUMBER OF BOOT CPU FOR DEBUGGING SMP
WHYTXT::BLOCK	<WHYSIZ==:20>	;WHY RELOAD TEXT
	WHYMXL==:<WHYSIZ-1>B26	;LENGTH FOR GETTAB
TICMIN::EXP	0		;NUMBER OF TICKS PER MINUTE
				;(CALCULATED BY ONCE)
TIMLST::0			;VALUE OF "TIME" LAST TIME AT CLOCK LEVEL
				; USED FOR ALL TIMING FUNCTIONS, E.G.,
				; MAINTAINING CLOCK QUEUE AND SMITHSONIAN DATE
IFN M.KL10,<
NULJPC::EXP	XC.USR+IC.LIP+1	;PC FOR THE NULL JOB
NULDOP::EXP	LG.LUB+LG.IAM+NLUPMP/PAGSIZ
>
IFN M.KS10,<
NULJPC::EXP	XC.USR+IC.LIP+1
NULDOP::EXP	SG.LUB+NLUPMP/PAGSIZ
>
SYSBPJ::0			;SNOOP.ING JOB
SYSBPP::0			;ADDRESS OF BREAK POINT TABLE,, NUMBER OF BREAK POINTS
MSTCKS::0			;MONITOR SYMBOL TABLE CHECKSUM
LOWLOC::0
ONCCOM::0
IFN M.KL10,<
LOWLEN==<IOWNUM+^D143>/^D144
LOWPTR::XWD	-LOWLEN,LOWTAB
LOWTAB:	BLOCK	LOWLEN
>
NXMTBL==:<CORBLK+^D35>/^D36
NXMTAB::BLOCK	NXMTBL		;TABLE WHICH RECORDS PAGES OF MEMORY EXIST
NXMMXL==:<NXMTBL-1>B26		;MAXIMUM ITEM FOR GETTAB
OLDNXM::BLOCK	NXMTBL		;OLD COPY OF NXMTAB
CORLIM::EXP	COREN
OMSMIN::EXP	M.OMSM		;# MINUTES REMAINING BEFORE NEXT CALL
				; TO BIGBEN
OMSINI::EXP	M.OMSM		;TIME BETWEEN CALLS
SEGPT2::EXP	JOBN		;ROUND ROBIN OVER IN-CORE DORMANT SEGMENTS
IFNDEF		MFRHPQ,<MFRHPQ==2>;DEFAULT IS 2
FRSHPQ::EXP	MFRHPQ		;MINIMUM HPQ FORCING SCHED
IFNDEF		STHLOG,<STHLOG==0>
STHFLG::EXP	STHLOG		;IF NON-ZERO,NRT CAN RUN W/O LOGIN
CLPTOP::0			;POINTER TO BEGINNING OF CLP LIST
CLPBOT::CLPTOP			;POINTER TO END OF CLP LIST
IFN FTKL10&<FTSCA!FTENET>,<
IPAMSK::0			;BIT MASK TO SKIP STARTING IPA DEVICE
				; LH = CI (CPU0=1B17, CPU1=1B16, ETC.)
				; RH = CI (CPU0=1B35, CPU1=1B34, ETC.)
>; END IFN FTKL10&<FTSCA!FTENET>
CSBLEN::0			;LENGTH OF COMMON SUBROUTINES SEGMENT
;BITMAP MEMORY DEFINITIONS

IFN FTSCA,<
SCALOC::EXP	0		;STARTING ADDRESS OF SCA FREE CORE
	SCABTL==<SCASIZ+^D143>/^D144 ;SIZE OF THE BIT MAP FOR SCA FREE CORE
SCAPTR::XWD -SCABTL, .+1	;AOBJN POINTER TO SCA FREE CORE BIT MAP
	BLOCK	SCABTL		;THE MAP ITSELF
>; END IFN FTSCA
;INTERLOCK WORDS AND OWNER WORDS MUST BE IN THE SAME ORDER
; "INTRLK" MUST BE FIRST

IFN FTMP,<
	INTERN	INTL0,INTO0
INTRLK::-1			;CPU PI SYSTEM INTERLOCK
SCDLOK::-1			;SCHEDULER INTERLOCK
SCNLOK::-1			;SCNSER INTERLOCK
INTRDD::-1			;DDB-SCAN INTERLOCK
INTRST:	-1			;CPU START-UP INTERLOCK
INTRUU::-1			;GENERAL UUO-LEVEL LOCK
INTRDC::-1			;DISK CACHE INTERLOCK
INTRDS::-1			;DSKOFF INTERLOCK
INTRTP::-1			;TAPOFF INTERLOCK
NETLOK::-1			;USED IN NETOFF,NETOM MACROS
NTLOCK::-1			;THE NETSER INTERLOCK
INTLBT::-1			;BIT DIDDLER INTERLOCK (SETOS,CLRBTS)
IFN FTKL10,<
INTLNB::-1			;BUFFER (CACHE) MANAGEMENT INTERLOCK
>
IFN FTDECNET,<
SCTLOK::-1			;DECNET'S SESSION CONTROL INTERLOCK
NSPLOK::-1			;DECNET'S NSP INTERLOCK
>
IFN FTSCA,<
INTLSC::-1			;SCA BUFFER MANAGEMENT INTERLOCK
>; END IFN FTSCA
IFN FTENET,<
ETHLOK::-1			;ETHERNET INTERLOCK
>; END IFN FTENET
IFN FTPATT,<			;FOR PATCHING
INTRP1::-1
INTRP2::-1
>
INTRCL::-1			;CLOCK QUEUE PROCESSING
DEFINE	INTLK(A,B)<
IFE A,<INTL'B: -1>		;PI LEVEL B ON CPU A PI INTERLOCK
IFN A,<INTL'A'B: -1>>

ZZ==0
REPEAT M.CPU,<
ZZZ==0
REPEAT 10,<
INTLK(\ZZ,\ZZZ)
ZZZ==ZZZ+1>
ZZ==ZZ+1>
;OWNING CPU OF INTERLOCKS (CONI PAG OR APRID)
INTOLK::-1			;CPU PI-SYSTEM
INOSCD::-1			;SCHEDULER
INOSCN::-1			;SCNSER
INTODD::-1			;DDB-SCAN
INTOST::-1			;CPU START-UP
INTOUU::-1			;GENERAL  UUO-LEVEL
INTODC::-1			;DISK CACHE
INTODS::-1			;DSKOFF
INTOTP::-1			;TAPOFF
INONET::-1			;NETOFF
INONT::	-1			;NETSER
INTOBT::-1			;BIT DIDDLERS
IFN FTKL10,<
INTONB::-1			;BUFFER (CACHE) MANAGEMENT
>
IFN FTDECNET,<
SCTLKO::-1			;DECNET'S SESSION CONTROL
NSPLKO::-1			;DECNET'S NSP INTERLOCK
>
IFN FTSCA,<
INTOSC::-1			;SCA BUFFER MANAGEMENT OWNER
>; END IFN FTSCA
IFN FTENET,<
INOETH::-1			;ETHERNET
>; END IFN FTENET
IFN FTPATT,<			;FOR PATCHING
INTOP1::-1
INTOP2::-1
>
INTOCL::-1			;CLOCK QUEUE PROCESSING
DEFINE INTLKO(A,B)<
IFE A,<INTO'B:-1>
IFN A,<INTO'A'B:-1>>
ZZ==0
REPEAT M.CPU,<
ZZZ==0
REPEAT 10,<
INTLKO(\ZZ,\ZZZ)
ZZZ==ZZZ+1>
ZZ==ZZ+1>
;NOT CORRESPONDING TO ABOVE INTERLOCKS
SCNOWN::-1			;OWNER OF SCNCNT (.CPCPU)
INTLMO::-1			;OWNER OF THE MEMORY MANAGEMENT RESOURCE (APRID)
INTDIE::-1			;DIE INTERLOCK
INODIE::-1			;DIE OWNER
DIEFLG::0			;DIE TYPE (-1=STOPCD, +1=EVENT, 0=UNKNOWN)
>;END FTMP
IFE FTMP,<
NTLOCK::-1			;NTLOCK EXISTS ON SINGLE CPU'S TOO
SCTLOK::-1			;DECNET INTERLOCKS EXIST ON SINGLE CPU's TOO
NSPLOK::-1
RTRLOK::-1
SCTLKO::-1
NSPLKO::-1
INTRDC::-1
RTRLKO::-1
>
;GETTAB TABLE OF QUEUE CODES FOR JOBS - TABLE(RH)=25
;MUST BE A SEPARATE TABLE SINCE THE NUMBER OF ENTRIES VARIES ACCORDING
;TO THE CONFIGURATION

;ENTRIES ARE 2 SIXBIT CHARACTERS, THREE PER WORD
;STATE CODE 0 IS LEFT THIRD, 1 IS MIDDLE THIRD, 2 IS RIGHT THIRD OF FIRST WORD
;STATE CODE 3 IS LEFT THIRD OF SECOND WORD, ETC.


STSTBL::

DEFINE X(A,B,C)
<	IFE ZZ-ZZ/3*3-0,
	<	  XX==   <SIXBIT /A/&7777B11>B35>
	IFE	ZZ-ZZ/3*3-1,
	<	  XX==XX!<SIXBIT /A/&7777B11>B47>
	IFE	ZZ-ZZ/3*3-2,
	<	  XX==XX!<SIXBIT /A/&7777B11>B59
	  EXP XX>
ZZ==ZZ+1
>

ZZ==0
	QUEUES
	RWAITS
	CODES
	IFN	ZZ-ZZ/3*3-0,<
	  EXP XX>

STSMXL==:<.-STSTBL-1>B26		;MAX ENTRY IN STSTBL FOR GETTAB UUO
ODPTBL::!			;FIRST LOCATION IN MONITOR DATA AREA FOR DISK-
				; RELATED LOCATIONS WHICH ARE NOT SET TO 0 WHEN
				; THE SYSTEM IS STARTED UP.
				; ODPTBL IS GETTAB UUO TABLE NUMBER 15.

SWPHGH::0			;(0) HIGHEST LOGICAL BLOCK # ASSIGNED FOR SWAPPING.
				; SPACE IS ASSIGNED FROM HIGHEST BLOCK # DOWNWARDS.
K4SWAP::0			;(1) # OF K OF DISK WORDS SET ASIDE FOR SWAPPING.
				; ASSIGNED AT ONCE ONLY REFRESH TIME.

KXFTIM==0			;SET PROTECT TIMES TO 0
SEEKTM==0			;ONCE ONLY CODE MUST SET PROT,PROT0
				;DEPENDING ON FASTEST UNIT USED FOR SWAPPING
PROT::	EXP	0		;(2) IN-CORE PROTECT TIME PARAMETER TO BE
				; MULTIPLIED BY <K-1> OF CORE IN JOB.
PROT0::	EXP	0		;(3) IN-CORE PROTECT TIME PARAMETER TO
				; BE ADDED TO ABOVE RESULT.
PROT1::	EXP	0		;(4) SWAPPABLE CYCLING TIME
PROTM::	EXP	0		;(5) MAXIMUM IN-CORE PROTECT TIME

	;INSERT HERE ANY NEW LOCATIONS OF INTEREST WHICH ARE SET UP BY
	; ONCE ONLY CODE AND WHICH PERTAIN ONLY TO DISK SYSTEMS.

ODPMXL==:<.-ODPTBL-1>B26		;MAXIMUM ENTRY IN ODPTBL FOR GETTAB UUO

;DISK LOCATIONS NOT IN GETTAB


REFLAG::Z			;FLAG LOCATION TO INDICATE WHETHER ANY REFRESHING
				; OCCURRED AND TO CONTAIN THE [PROJ,PROG]
				; NUMBERS FOR AUTOMATIC LOG-IN FOLLOWING REFRESH.
;MORE DATA LOCATIONS SETUP AT ASSEMBLY TIME OR ONCE ONLY TIME
; BUT NOT OF INTEREST TO USER PROGRAMS



	$HIGH
XJBPFI::XWD	JOBPFI##,0	; JOBPFI==HIGHEST LOC, IN USER JOB DATA AREA
				; PROTECTED FROM I/O
;MONTH TABLE FOR DAYTIME COMMAND PRINTING

PMONTB::POINT	6,MONTAB(T1),5	;POINTER TO NUMBER OF DAYS IN MONTH
MONTAB::EXP	^D30B5+"Jan"
	EXP	^D27B5+"Feb"
	EXP	^D30B5+"Mar"
	EXP	^D29B5+"Apr"
	EXP	^D30B5+"May"
	EXP	^D29B5+"Jun"
	EXP	^D30B5+"Jul"
	EXP	^D30B5+"Aug"
	EXP	^D29B5+"Sep"
	EXP	^D30B5+"Oct"
	EXP	^D29B5+"Nov"
	EXP	^D30B5+"Dec"

;DAY TABLE FOR DAYTIME COMMAND AND ONCE
DAYTAB::[ASCIZ/Wednesday/]	;INDEXED BY UDT REMAINDER
	[ASCIZ/Thursday/]	;
	[ASCIZ/Friday/]		;
	[ASCIZ/Saturday/]	;
	[ASCIZ/Sunday/]		;
	[ASCIZ/Monday/]		;
	[ASCIZ/Tuesday/]	;

MIDNIT::EXP	0		;JIFFIES TILL MIDNIGHT (CALCULATED BY ONCE)

IFN FTMP,<
COKTAB::BLOCK	M.CPU		;TABLE TO SET THE POLICY CPU'S OK WORD
				;(INDEX BY THE NUMBER OF RUNNING CPUS-1)
> ;END IFN FTMP
	$ABS
;TABLE OF SCHEDULER STATISTICS (CAN BE USED TO HELP TUNE SYSTEM)

.GTSST::!			;SCHEDULER STATISTICS TABLE - #115


FORCFC::0			;(0)COUNT OF TIMES SCHEDULER RAN A JOB
				;OUT OF ORDER SO THAT IT WOULD RELEASE
				;A SHARABLE RESOURCE IN ORDER THAT IT
				;COULD BE SWAPPED OUT.

UNWNDC::0			;(1)COUNT OF TIMES SCHEDULER RAN A JOB
				;OUT OF ORDER BECAUSE ANOTHER JOB HAS BEEN
				;SELECTED THAT NEEDS A SHARABLE DISK
				;RESOURCE THE FIRST JOB OWNED

SWPNUL::0			;(2)SWAPPER NULL TIME (TIME WHEN SWAPPING
				;LOGIC COULD NOT FIND ANYTHING TO DO.)

SWPLOS::0			;(3)SWAPPER LOST TIME (TIME THAT SWAPPER
				;WANTED TO SWAP A JOB IN BUT COULDN'T

RQCNT::0			;(4)NUMBER OF PHYSICAL REQUEUES SINCE
				;SYSTEM STARTUP

MCUINT::0			;(5)INTERVAL AT WHICH MINIMUM CORE
				;USAGE FUNCTION IS CALCULATED.
				;ZERO MEANS DO NOT CALCULATE

SCDINT::0			;(6)MICRO SCHEDULING INTERVAL. ZERO
				;MEANS RUN ROUND ROBIN IGNORING CLASSES.

AVJSIZ::0			;(7)AVERAGE JOB SIZE COMPUTED ONCE A MINUTE

TOTRTC::0			;(10)TOTAL RUNTIME GIVEN TO ALL SUBCLASSES
				;DOES NOT INCLUDE ANY PQ1 OR HPQ TIME

SCDEXF::0			;(11)EXPONENTIAL FACTOR USED FOR COMPUTING
				;EXPONENTIALLY AVERAGED RUNTIME FOR
				;CPU CLASSES

UTMEAR::0			;(12)EXPONENTIALLY AVERAGED USER TIME USED
				;FOR THE ENFORCEMENT OF QUOTAS

RTCTOT::0			;(13)TOTAL USER RUNTIME SINCE LAST
				;SCHED UUO SET CLASS PARAMETERS

DEFCLS::M.DCLS			;(14)DEFAULT CLASS FOR NEW JOBS

SCDJIL::0			;(15)PERCENT OF TIME SCHEDULER SCANS
				;JUST SWAPPED IN QUEUE BEFORE SUBQUEUES

SCDSWP::0			;(16)MINIMUM NUMBER OF TICKS
				;SWAPPER SCANS THE SAME PRIMARY SUBQUEUE

BBSUBQ::0			;(17)BACKGROUND BATCH SUBQUEUE

SCDBBS::0			;(20)NUMBER OF TICKS BETWEEN
				;BACKGROUND BATCH SWAPS

SCDIOF::0			;(21)PERCENT OF TIME THAT SWAPPER SCANS PQ2
				;INCORE CHAIN BEFORE OUTCORE CHAIN
SCDSET::0			;(22)FLAG = 0 IF RUNNING ROUND ROBIN
				;= DATE/TIME WHEN CLASS RUNTIME TABLE
				;INITIALIZED IF RUNNING IN CLASS MODE
RRFLAG::0			;(23)FLAG = 0 IF RUNNING ROUND ROBIN SCHEDULER
				;= CNTSTS IF CLASS SCHEDULING
SCDCOR::0			;(24) TIME TO WAIT AFTER SWAPPING OUT
				;A RUNNABLE JOB BEFORE SETTING CORSCD
				;FLAG
SSDMXL==:<.-.GTSST-1>B26	;MAXIMUM LENGTH OF TABLE FOR GETTABS
;IPCF COMMON DATA

IFN M.IPCF,<

IFNDEF	M.PKTL,<M.PKTL==12>
%IPMPL==:M.PKTL			;MAXIMUM PACKET LENGTH

IFNDEF M.PIDN,<XP M.PIDN,JOBN*2>
XP MIDMXL,<<M.PIDN>B26>		;FOR GETTAB

ND M.IPCR,5			;DEFAULT RECEIVE QUOTA
ND M.IPCS,2			;DEFAULT SEND QUOTA
ND M.IPCP,2			;DEFAULT PID QUOTA

PIDMSK==JOBN
IFG <M.PIDN-JOBN>,<PIDMSK==M.PIDN>  ;MAX (JOBN,M.PIDN)
PIDMSK==<1B<^L<PIDMSK>-1>>-1	;MAKE INTO MASK

; MACRO TO DEFINE EXEC PROCESS PIDS
DEFINE	PIDS,<

	ZZ==0			;;INIT COUNTER

X	(IPC)			;;[SYSTEM]IPCC
X	(GFR)			;;[SYSTEM]GOPHER

> ;END PID MACRO

DEFINE	X	(NAM),<XWD	<NAM'PID==<ZZ==ZZ+1>>,0>
PIDTAB::PIDS			;GENERATE EXEC PROCESS PID ENTRIES
%IPCNS==:.-PIDTAB		;NUMBER OF SYSTEM PROCESSES
	XLIST
	REPEAT	<M.PIDN-%IPCNS>,<Z>	;REMAINDER OF TABLE ZERO
	LIST

DEFINE	X	(NAM),<EXP	NAM'ADR>
EXPROC::PIDS			;GENERATE POINTERS TO EXEC PROCESS IPCF DATA

; EXEC PROCESS CONTROL BLOCK FOR [SYSTEM]IPCC
IPCADR:	Z			;.EPIPC
	Z			;.EPIPA
	XWD	200000,-1	;.EPIPQ
	Z			;.EPIPL
	Z			;.EPPID
	Z			;.EPIPI
	Z			;.EPIPN
	Z			;.EPQSN
	Z			;.EPEPA
	IFIW	IPCFPR##	;.EPADR

; EXEC PROCESS CONTROL BLOCK FOR [SYSTEM]GOPHER
GFRADR:	Z			;.EPIPC
	Z			;.EPIPA
	XWD	200000,-1	;.EPIPQ
	Z			;.EPIPL
	Z			;.EPPID
	Z			;.EPIPI
	Z			;.EPIPN
	Z			;.EPQSN
	Z			;.EPEPA
	IFIW	IPCSPR##	;.EPADR

	EXTERN	IPCSER


IPCTAB::			;MISCELLANEOUS IPCF DATA
%CNIPL::	%IPMPL		;(0) MAX PACKET LENGTH
%CNIPI::	Z		;(1) PID OF SYS:INFO (0=NONE)
%CNIPQ::BYTE (2)1(16)(9)M.IPCS,M.IPCR	;(2) DEFAULT QUOTAS + IP.HBS BIT
%CNIPS::	Z		;(3) TOTAL PACKETS SENT
%CNIIP::	Z		;(4) NUMBER OF PACKETS OUTSTANDING
%IPCFP::	IPCPID,,0	;(5) PID OF [SYSTEM]IPCC
%IPCPM::	PIDMSK		;(6) MASK FOR PID
%IPCMP::	M.PIDN		;(7) LENGTH OF PID TABLE
%IPCNP::	%IPCNS		;(10) CURRENT NUMBER OF PID'S
%IPCTP::	%IPCNS		;(11) TOTAL PID'S SINCE RELOAD
%CNPIC::	Z		;(12) NUMBER OF IPCF PAGES CURRENTLY IN CORE
%IPCSP::	GFRPID,,1	;(13) PID OF [SYSTEM]GOPHER
%IPTWT::	Z		;(14) TOTAL WORDS PASSED (NON-PAGE MODE)
%IPTPT::	Z		;(15) TOTAL PAGES PASSED
%IPOPP::	.IPCFD##	;(16) OVERHEAD PER PACKET
%CNIPD::	M.IPCP		;(17) DEFAULT PID QUOTA
IPCMXL==:<.-IPCTAB-1>B26	;FOR GETTAB

	$HIGH
.GTQFC::			;CUSTOMER SPECIAL QUEUE. FUNCTIONS GO HERE
IFN FTPATT,<
	EXP	0
	EXP	0
>

;INSERT REAL CUSTOMER FUNCTIONS HERE

.GTQFT::0			;QUEUE. UUO FUNCTION TABLE (ZERO IS ILLEGAL)
%QPRNT::%SIQSR			;(1) PRINT A FILE
%QPCRD::%SIQSR			;(2) PUNCH A FILE ON CARDS
%QPTAP::%SIQSR			;(3) PUNCH A FILE ON PAPER TAPE
%QPLOT::%SIQSR			;(4) PLOT A FILE
%QSUBM::%SIQSR			;(5) SUBMIT A FILE
%QALLC::%SIQSR			;(6) ALLOCATE A VOLUME SET
%QDEAL::%SIQSR			;(7) DEALLOCATE A VOLUME SET
%QMOUN::%SIQSR			;(10) MOUNT A VOLUME
%QDMNT::%SIQSR			;(11) DISMOUNT A VOLUME
%QWTO::	%SIOPR			;(12) WRITE TO OPERATOR
%QWTOR::%SIOPR			;(13) WRITE TO OPERATOR WITH RESPONSE
%QVALA::%SIACT			;(14) VALIDATE AN ACCOUNT
%QMAUE::%SIACT			;(15) MAKE A USAGE ENTRY
%QCATV::%SICAT			;(16) CATALOG VALIDATION REQUEST
%QMAIL::%SIMAI			;(17) MAIL REQUEST
%QEVNT::%SIQSR			;(20) EVENT QUEUE REQUEST

;ADD NEW DEC FUNCTIONS HERE

IFN FTPATT,<
	EXP	0
	EXP	0
>
QUTBLN==:.-.GTQFT-1
	$ABS

.GTCSD::			;CUSTOMER SPECIAL PID'S GO HERE
IFN FTPATT,<
	Z			;(-2) ALLOW ONE CUSTOMER PID
	Z			;(-1) AND ANOTHER
>
.GTSID::			;SPECIAL PID TABLE
%SIIPC::XWD	IPCPID,0	;(0) IPCC
%SIINF::Z			;(1) [SYSTEM] INFO
%SIQSR::Z			;(2) [SYSTEM] QUASAR
%SIMDA::Z			;(3) MOUNT DEV ALLOCOTOR
%SITLP::Z			;(4) MAGTAPE LABELING PROCESS
%SIFDA::Z			;(5) FILE DAEMON
%SITOL::Z			;(6) TAPE AVR PROCESS
%SIACT::Z			;(7) [SYSTEM] ACCOUNTING
%SIOPR::Z			;(10) OPERATOR INTERFACE PROCESS
%SISEL::Z			;(11) SYSTEM ERROR LOGGER
%SIDOL::Z			;(12) DISK AVR PROCESS
%SITGH::Z			;(13) [SYSTEM] TGHA
%SINML::Z			;(14) DECNET NETWORK MANAGEMENT LAYER
%SIGFR::XWD	GFRPID,1	;(15) PID OF [SYSTEM]GOPHER
%SICAT::Z			;(16) PID FOR [SYSTEM]CATALOG
%SIMAI::Z			;(17) PID FOR [SYSTEM]MAILER
SDTBLN==:.-.GTSID-1
SIDJOB==:.+<.GTSID-.GTCSD>	;ZERO 'TH SYSTEM JOB #
	BLOCK	<.-.GTCSD>	;SPACE FOR PARALLEL JOB
MDAJOB==:SIDJOB+<%SIMDA-.GTSID>
FDAJOB==:SIDJOB+<%SIFDA-.GTSID>
TLPJOB==:SIDJOB+<%SITLP-.GTSID>
ACTJOB==:SIDJOB+<%SIACT-.GTSID>
TGHJOB==:SIDJOB+<%SITGH-.GTSID>
NMLJOB==:SIDJOB+<%SINML-.GTSID>
CATJOB==:SIDJOB+<%SICAT-.GTSID>
MAIJOB==:SIDJOB+<%SIMAI-.GTSID>
>

IFE M.IPCF,<

XP UIPCFR,CPOPJ			;MAKE IPCF UUOS LOOK UNIMPLEMENTED
XP UIPCFS,CPOPJ
XP UIPCFQ,CPOPJ
XP IPCFRC,CPOPJ			;DO NOTHING ON RESET UUO
XP LOKIPC,CPOPJ
XP FNDIPC,CPOPJ
XP GLXINF,CPOPJ			;NO QUEUE. UUO
XP IPMCHK,CPOPJ			;NO IPCF QUEUE TO INTERLOCK
XP IPCULK,CPOPJ			;NO IPCF QUEUE TO UNLOCK
XP SNDFFC,CPOPJ			;SEND MESSAGE TO SPECIAL PID


XP IPCLGO,CPOPJ			;DO NOTHING ON LOGOUT UUO
XP SNDMDR,CPOPJ			;LOCKED STRUCTURE MESSAGE TO MDA
XP SNDMDN,CPOPJ			;SEARCH LIST CHANGE MESSAGE TO MDA
XP SNDFIN,CPOPJ			;DEVICE DEASSIGN MESSAGE TO MDA
XP SNDMDX,CPOPJ			;SEND MESSAGE TO SPECIAL SYSTEM PID
XP ATTMPA,CPOPJ			;DISK UNIT ATTACH MESSAGE TO MDA
XP DETMPA,CPOPJ			;DISK UNIT DETACH MESSAGE TO MDA
XP XCHMPA,CPOPJ			;DISK UNIT EXCHANGE MESSAGE TO MDA
XP REMMPA,CPOPJ			;STRUCTURE REMOVAL MESSAGE TO MDA
XP MTAMPA,CPOPJ			;MAGTAPE ACCESSIBLE MESSAGE TO MDA

XP MIDMXL,0			;MAKE GETTABS FAIL
XP IPCMXL,0
XP PIDTAB,0
XP IPCTAB,0
XP .GTCSD,0			;NO CUSTOMER PID TABLE
XP .GTSID,0			;NO SPECIAL PID TABLE
XP .GTQFT,0			;NO QUEUE. TABLE
XP %QWTO,0			;NO QUEUE. TABLE OFFSET FOR WTO

XP SDTBLN,0
XP .IPCTL,0			;NO MESSAGE CODE FOR TAPE LABELING
XP .IPCSC,0			;NO CSHIFT MESSAGE TO ACCOUNTING DAEMON
XP .IPCGM,0			;NO QUEUE. UUO MESSAGE TO GALAXY COMPONENTS
XP .IPCME,0			;NO MOS MEMORY ERROR MESSAGE TO TGHA
XP FILMSG,0
XP .IPCFP,0
XP .IPCFD,0
XP SPBMAX,0
XP SPBCOR,0

%CNIPS::			;NUMBER OF PACKETS SENT
%CNPIC::			;NUMBER OF PIDS IN CORE

MDAJOB::			;MDA
FDAJOB::			;FILE DAEMON
TLPJOB::			;TAPE LABELER
ACTJOB::			;ACCCOUNTING DAEMON
NMLJOB::			;DECNET NETWORK MANAGEMENT LAYER

%SIIPC::			;(0) IPCC
%SIINF::			;(1) [SYSTEM] INFO
%SIQSR::			;(2) [SYSTEM] QUASAR
%SIMDA::			;(3) MOUNT DEV ALLOCOTOR
%SITLP::			;(4) MAGTAPE LABELING PROCESS
%SIFDA::			;(5) FILE DAEMON
%SITOL::			;(6) TAPE AVR PROCESS
%SIACT::			;(7) [SYSTEM] ACCOUNTING
%SIOPR::			;(10) OPERATOR INTERFACE PROCESS
%SISEL::			;(11) SYSTEM ERROR LOGGER
%SIDOL::			;(12) DISK AVR PROCESS
%SITGH::			;(13) [SYSTEM] TGHA
%SINML::			;(14) DECNET NETWORK MANAGEMENT LAYER
%SIGFR::			;(15) PID OF [SYSTEM]GOPHER
%SICAT::			;(16) PID OF [SYSTEM]CATALOG
%SIMAI::			;(17) PID OF [SYSTEM]MAILER
	EXP	0		;ALL THOSE WHO DO SKIPE %SIXXX

XP STRSIG,CPOPJ			;MAKE IPCF CALL FOR PSISER
XP QSRSPL,CPOPJ			;MAKE IPCF CALL FOR FILUUO
XP SENDSP,CPOPJ
XP SNDMDC,CPOPJ
XP QSRLGI,CPOPJ
>
;36 BITS 1 PER WORD
	$CSUB
BITTBL::
SALL
	ZZ==1B0
REPEAT ^D36,<
	EXP	ZZ
	ZZ==ZZ_<-1>
>
	$ABS
;ENQUEUE/DEQUEUE COMMON DATA

IFN M.EQDQ,<
IFNDEF	M.ENQD,<M.ENQD==:EQDFEQ##>;DEFAULT ENQ QUOTA
IFNDEF	M.ENQM,<M.ENQM==:EQMXAQ##>;MAXIMUM NUMBER OF ACTIVE QUEUES
HSHLEN==:2*JOBMAX		;SIZE OF HASH TABLE
HSHTAB::BLOCK HSHLEN

	EXTERN	QUESER
>;END OF IFN M.EQDQ CONDITIONAL

IFE M.EQDQ,<
EQUATE	(GLOBAL,CPOPJ,<UENQ,UDEQ,UENQC>)
EQUATE	(GLOBAL,CPOPJ1,<ENQRST,ENQLGO,ENQPOP,ENQMIN,ENQSDT,ENQINI,ENQJBI>)
EQUATE	(GLOBAL,CPOPJ1,<ENQCLS,ENQNDR>)
EQUATE	(GLOBAL,0,<ENQMXL,ENQTAB,.EQTAB,HSHTAB,HSHLEN>)
>;END OF IFE M.EQDQ CONDITIONAL
;PSISER SYMBOLS

	$CSUB

IFN M.PSI,<
	EXTERN PSIAPR,PSISER,PSIMVO,PSIMPI,PITSIZ
IFE M.CTX,<		;ONLY IF SINGLE-CONTEXT MONITOR
NOPISK::SKIPE	JBTPIA(J)	;SKIP IF USER IS NOT ENABLED FOR TRAPS
OKSGNL::SKIPN	JBTPIA(J)	;SKIP IF USER IS ENABLED FOR TRAPS
>
IFN M.CTX,<		;ELSE NO WAY TO AVOID OVERHEAD
NOPISK::TRN		;ALWAYS TRY
OKSGNL::TRNA		;DITTO
>
PINOJN::SKIPGE	JBTPIA(J)	;SKIP IF CANNOT GRANT AN INTERRUPT
> ;END M.PSI
IFE M.PSI,<
	XP	PSIMVO,0
	XP	PSIMPI,0
	XP	PITSIZ,0	;DUMMY CODE
PSIIVR::
PSIIVA::SETZ	T1,		;NOTHING TO TELL PFH
	POPJ	P,
PINOJN::			;CAN NEVER GRANT AN INTERRUPT
NOPISK::CAIA			;NOBODY EVER ENABLED
OKSGNL::CAI			;...
PSITST==:CPOPJ			;...
PSIERR==:CPOPJ2			;ALWAYS STOP THE JOB
USREIJ==:CPOPJ1			;...
PSIJBI==:CPOPJ1			;...
PSIIOD==:CPOPJ			;NO DEVICE INTERRUPTS
PSIIDN==:CPOPJ			;...
PSIONL==:CPOPJ			;...
PSIODN==:CPOPJ			;...
PSIDWN==:CPOPJ			;...
PSIEDN==:CPOPJ			;...
PSIDVB==:CPOPJ			;...
PISYS==:CPOPJ			;UUOS FAIL
PIINI==:CPOPJ			;...
PIRST==:CPOPJ			;...
PISAVE==:CPOPJ			;...
DEBRK==:CPOPJ			;...
PIJOB==:CPOPJ			;...
PITMR==:CPOPJ			;...
PIBLK==:CPOPJ			;...
PSINTC==:CPOPJ			;NO NETWORK INTERRUPTS
PSIDVT==:CPOPJ			;NO DECNET EVENTS
APPSI==:CPOPJ			;NO APR TRAPS
PSIAPR==:ILLTIN##		;...
ANYUUO==:CPOPJ			;NO UUO TRAPS
CLRPSI==:CPOPJ			;NOTHING TO CLEAR
PSIRMV==:CPOPJ			;NOTHING TO REMOVE
PSIGEN==:CPOPJ			;NOTHING TO GRANT
PSICND==:CPOPJ			;NOTHING TO SIGNAL
PSIKSY==:CPOPJ			;NO KSYS INTERRUPTS
PSISDT==:CPOPJ			;NO DATE/TIME INTERRUPTS
> ;END M.PSI

	$ABS
;TABLE OF MAPPINGS FROM 2-CHARACTER DEVICE NAMES
; TO 3-CHARACTER NAMES. EACH 2-CHAR NAME IS IN
; RIGHT OF WORD AND 3-CHAR EQUIVALENT IS
; IN LEFT HALF.
;

	$HIGH
SPCTAB::XWD	'LPT','LP '	;LINE PRINTER
	XWD	'CDP','CP '	;CARD PUNCH
	XWD	'CDR','CR '	;CARD READER
	XWD	'PTP','PP '	;PAPER-TAPE PUNCH
	XWD	'PTR','PR '	;PAPER-TAPE READER
	XWD	'SYS','SY '	;SYSTEM DEVICE
	XWD	'TTY','TT '	;TELETYPE

STEND==:.
STLEN==:STEND-SPCTAB
;TABLE OF GENERIC DEVICE NAMES USED TO SPEED UP GENERIC DEVICE SEARCH
;
;THE TABLE CONSISTS OF TWO-WORD PAIRS.  THE FIRST WORD CONTAINS A
;RIGHT JUSTIFIED THREE-CHARACTER SIXBIT GENERIC DEVICE NAME.  THE
;SECOND WORD CONTAINS A 30-BIT ADDRESS OF THE FIRST DDB OF THAT
;TYPE.  THE TABLE IS BUILT AND MAINTAINED IN SORTED ORDER BY AUTCON.

DEFINE GNRIC(DEV,SYM),<
	IFNDEF	M.R'DEV,<M.R'DEV==0>	;DEFINE REMOTE DEVICES
IFN	M.'DEV+M.R'DEV+SYM,<
	XWD	0,''DEV''
	EXP	0
	>>

DEFINE	DGNRIC(X),<
	GNRIC	DT'X
>

	$ABS

GENPTR::EXP	0		;AOBJN POINTER TO GENTAB
GENTAB::
REPEAT	M.GENL,<EXP <0,,-1>,0>	;RESERVE EMPTY SPACE FOR AUTCON
ZZ=="A"
REPEAT M.TD10,<
	DGNRIC(\"ZZ)
ZZ==ZZ+1
>
DEFINE RGNRIC(Y),<
	GNRIC	RX'Y
>
ZZ=="A"
REPEAT M.RX20,<
	RGNRIC(\"ZZ)
	ZZ==ZZ+1
>
	GNRIC(PTY)	;PSEUDO-TTY
IFN M.DAS78,<		;IF DAS78 SUPPORT
	GNRIC(XXI)	;XXI DEVICE
	GNRIC(XXO)	;XXO DEVICE
> ;END IFN M.DAS78
GENLEN==:.-GENTAB
;DATA BASE TO LIMIT THE NUMBER OF STOPCD'S PER UNIT TIME SO THAT
;WE DON'T KEEP GETTING "CONTINUABLE" STOPCD'S THAT REALLY AREN'T.
;THE DATA BASE CONSISTS OF TWO TABLES, SCCTAB AND SCLTAB.  SCCTAB
;IS THE COUNT OF THE NUMBER OF STOPCD'S PROCESSED DURING THE PERIOD
;INDICATED BY THE OFFSET IT THE TABLE.  SCLTAB CONTAINS, IN THE
;LEFT HALF, THE PERIOD FOR THIS ENTRY AND, IN THE RIGHT HALF, THE
;LIMIT FOR THE NUMBER OF STOPCD'S DURING THE PERIOD.  BOTH TABLES
;MUST BE ORDERED SUCH THAT THE PERIOD OF EACH ENTRY IS MONOTONICALLY
;INCREASING.  THE LIMITS FOR EACH PERIOD ARE CHANGABLE VIA THE MONGEN
;DIALOG AND MAY BE CHANGED BY THE CUSTOMER.  WHEN A STOPCD IS PROCESSED
;BY DIE, STCLIM INCREMENTS THE COUNTS OF STOPCD'S FOR EACH ENTRY
;AND COMPARES EACH WITH THE LIMIT FOR THE ENTRY.  IF A LIMIT HAS BEEN
;EXCEEDED, DIE TURNS THE CONTINUABLE STOPCD INTO A STOP STOPCD.  IF
;NO LIMIT HAS BEEN EXCEEDED, STCLIM PUTS IN A CLOCK REQUEST TO CALL
;DECSCC AFTER THE PERIOD OF THE LOWEST ENTRY IN THE TABLE.  DECSCC
;DECREMENTS THE COUNT OF STOPCDS FOR THIS ENTRY AND PUTS IN A CLOCK
;REQUEST TO DECREMENT THE NEXT HIGHER COUNT.  THIS CONTINUES UNTIL ALL
;HAVE BEEN DECREMENTED. NOTE, THAT SINCE THE CLOCK QUEUE IS USED TO
;DECREMENT THE STOPCD COUNTS, THE PERIOD OF THE LARGEST ENTRY CANNOT
;BE LARGER THAN 2**18-1 TICKS.


SCCTAB::EXP	0		;1 MINUTE COUNT OF STOPCD'S
	EXP	0		;8 MINUTE COUNT OF STOPCD'S
	EXP	0		;1 HOUR COUNT OF STOPCD'S
SCCTBL==:.-SCCTAB		;LENGTH OF TABLE


SCLTAB::XWD	^D60,  LIM1MS	;PERIOD:=1 MINUTE, LIMIT:=LIM1MS
	XWD	^D480, LIM8MS	;PERIOD:=8 MINUTES, LIMIT:=LIM8MS
	XWD	^D3600,LIM1HS	;PERIOD:=1 HOUR, LIMIT:=LIM1HS
;GALAXY-10 PARAMETERS

DEFINE GPARM(Z1),<
IFE Z1,<
ZGAL==0
>>

ZGAL==1
GPARM(M.IPCF)
GPARM(M.PSI)
GPARM(M.PTY)
IFN	M.IPCF,<
IFG ^D10-%IPMPL,<ZGAL==0>
>

;DEFINE IPCF SYMBOLS IF NOT AROUND
	$HIGH
;TABLE FOR SPOOLING DEVICES
SPLNAM==:0			;NAME OF SPOOLING DEVICE
SPLBIT==:2			;SPOOLING BIT
SPLLEN==:DEVMOD+1		;LENGTH OF EACH ENTRY
;NOTE THAT WORD 1 (DEVCHR) MUST BE 0
SPLTAB::SIXBIT	.LPT.
	0
	XWD	.TYLPT,.SPLPT
	0			;NO REAL DEVSER
LPTMOD==1_A+1_AL+1_I
	XWD	DVOUT+DVLPT,ASSCON!ASSPRG!LPTMOD
	SIXBIT	.PLT.
	0
	XWD	.TYPLT,.SPPLT
	0
	XWD	DVOUT,ASSCON!ASSPRG!14403
	SIXBIT	.CDP.
	0
	XWD	.TYCDP,.SPCDP
	0
	XWD	DVOUT+DVCDR,ASSCON!ASSPRG!14403
	SIXBIT	.PTP.
	0
	XWD	.TYPTP,.SPPTP
	0
	XWD	DVOUT+DVPTP,ASSCON!ASSPRG!14403
	SIXBIT	.CDR.
	0
	XWD	.TYCDR,.SPCDR
	0
SPLTOP::XWD	DVIN+DVCDR,ASSCON!ASSPRG!14403

	$ABS
SUBTTL	CPU START-UP CODE

;NOTE: CODE AT ENTDDT SHOULD MATCH CODE FROM SYSTRT THROUGH CALL TO SYSTR0

SYSTRT::JSP	T1,.+1		;GET THE FLAGS
	TLNE	T1,(XC.USR)	;ARE WE IN USER MODE?
	JRST	USRONC##	;YES, THEN THIS MUST BE TWICE
	EXECAC			;GET AC SET RIGHT
	CONO	APR,AP.IOR	;BLAST
	CONO	PI,CLRPIS	;BLAST
IFN M.KL10,<
	CONO	PAG,0		;INSURE THAT THE CACHE IS OFF
	DATAO	APR,[EXP 0]	;CLEAR OLD ADDRESS BREAK
>
	JSP	T4,SYSTR0	;SEE WHICH CPU THIS IS AND SETUP THE EBR
	  JRST	SYSINI##	;BOOT CPU
IFG <M.CPU-1>,<
	JRST	SPRINI		;NON-BOOT CPU
>
IFLE <M.CPU-1>,<
	HALT	.		;ATTEMPT TO START NON-BOOT CPU WITH A SINGLE CPU MONITOR
>
;SUBROUTINE TO SEE WHICH CPU THIS IS (CALLED ON SYSTEM
; STARTUP AND POWER FAIL AUTO-RESTART)
;CALLING SEQUENCE:
;	JSP	T4,SYSTR0
;	RETURN HERE IF BOOT CPU
;	RETURN HERE IF NON-BOOT CPU
SYSTR0::TLO	T4,(IC.UOU)	;TURN ON USRIOT FOR RETURN
IFN M.KL10,<
	CONO	APR,LP.CSF!LP.CSD
	DATAI	CCA,		;INVALIDATE CACHE, NOT VALIDATING CORE
	CONSO	APR,LP.CSD
	JRST	.-1
	CONO	APR,LP.CSF!LP.CSD
>
IFN M.KS10,<
	RDUBR	T2		;INVALIDATE CACHE
	WRUBR	T2
>
SYSTR1::APRID	T1		;READ CPU SERIAL #
	MOVE	T3,T1		;COPY
	ANDI	T1,ID.PSN	;JUST SERIAL # BITS
IFN FTMP,<
	SKIPGE	INTRST
	AOSE	INTRST
	JRST	.-2
>
	MOVEI	T2,.C0CDB	;START WITH FIRST CDB
SYSTR2:	CAME	T1,.CPASN-.EVCDB(T2) ;THIS CPU THE OWNER OF THE CDB?
	JRST	SYSTR6		;NO
SYSTR3:	MOVEM	T3,.CPAPD-.EVCDB(T2) ;YES, STORE APRID
	SETOM	.CPOCB-.EVCDB(T2) ;MARK THIS CDB AS OWNED
	SETZM	.CPPFT-.EVCDB(T2) ;CLEAR PRE-EMPTIVE PAGE FAULT HANDLER
IFN M.KL10,<
	MOVE	T1,.CPAPD-.EVCDB(T2) ;GET OPTION BITS
	TLNE	T1,(ID.PMV)	;UCODE SUPPORT PHYSICAL MOVE/MOVEM?
	SETOM	.CPPMV-.EVCDB(T2) ;YES, FLAG FOR PHMOV/PHMOVM
	TRNN	T1,ID.MCA	;MCA25 INSTALLED?
	TDZA	T1,T1		;NO
	MOVSI	T1,(PM.KPM)	;YES
	MOVEM	T1,.CPKPM-.EVCDB(T2)
>; END IFN M.KL10

;MAP THE CDB VIA EXEC VIRTUAL ADDRESS .EVCDB ('CDBPGS' PAGES)

	MOVE	T3,.CPMAP-.EVCDB(T2) ;GET ADDRESS OF EXEC MAP
	MOVE	T1,T2		;GET CDB ADDRESS
	LSH	T1,W2PLSH	;CONVERT TO A PAGE NUMBER
	TLO	T1,(<PM.DCD>B2+PM.WRT+PM.PUB) ;MAKE IT ACCESSIBLE AND WRITABLE
IFN M.KL10,<
	IOR	T1,.CPKPM-.EVCDB(T2) ;INCLUDE "KEEP ME" IF MCA25
>; END IFN M.KL10
	HRLI	T3,-CDBPGS	;NUMBER OF ENTRIES TO COPY
	MOVEM	T1,.EVCDB/PAGSIZ(T3) ;SET UP MAPPING FOR CDB VIA .CPXXX
	AOBJP	T3,.+2		;COPY ALL ENTRIES
	AOJA	T1,.-2		;LOOP FOR ANOTHER
IFN M.KL10,<
	MOVE	T1,.CPKPM-.EVCDB(T2) ;GET "KEEP ME" BIT OR ZERO
	MOVE	T3,.CPEPT-.EVCDB(T2) ;GET ADDRESS OF EPT
	IORM	T1,SECTAB+0(T3)	;TURN ON "KEEP ME" IN SECTION 0 AND 1 MAP POINTERS
	IORM	T1,SECTAB+1(T3)
	XJRSTF	[EXP XC.UOU,.+1]	;SET PRVIOUS CONTEXT USER, PCS =0
	DATAI	PAG,P3			;SET PREVIOUS CONTEXT AC SET TO 6
	AND	P3,[LG.CAC]
	TLO	P3,(LG.LAB+6B11)
	DATAO	PAG,P3
	MOVSI	T1,[EXP -1,0,0]		;NO CST UPDATE(AND MASK,OR MASK,BASE ADDR 0=NONE)
	EXCTXU	<BLT T1,2>		;SET LOCATIONS IN AC SET 6, FOR CSTS
	MOVEI	T1,SPTTAB		;MAKE A POINTER TO THE SPT FOR THIS CPU
	EXCTXU	<MOVEM T1,3>		;SET IT UP IN AC SET 6 LOCATION 3
	TLC	P3,(7B11)		;PREVIOUS AC SET TO 1
	DATAO	PAG,P3
>
IFN FTKS10,<
	CONO	PAG,0			;OTHERWISE THE UCODE GETS HUNG
	WRCSTM	[-1]			;KEEP ALL CST BITS (AND MASK)
	WRPUR	[0]			;SET NOTHING FOR REF'D PAGES (OR MASK)
	WRCSB	[0]			;NO CST PRESENT REQUIRES UCODE 124
					;WITH INHCST OR NOCST TURNED ON
	APRID	0			;READ OUR ID
	TLNE	0,(ID.KLP)		;BETTER SAY KLP IS AVAIL
	TLNN	0,(ID.NCU)		;AND SOME WAY TO TURN OFF CST
	STOPCD	.+1,HALT,WNGUCV		;++WRONG UCODE VERSION
	MOVEI	0,@.CPSPT-.EVCDB(T2)	;POINT TO OUR SMALL SPT
	WRSPB	0			;TELL THE MICROCODE
>
	MOVE	P3,@.CPSPT-.EVCDB(T2)	;SAVE ORIGINAL CONTENTS
	MOVEI	T1,NLUPMP/PAGSIZ	;ESTABLISH AN SPT
	MOVEM	T1,@.CPSPT-.EVCDB(T2)

IFN M.KL10,<
IFN FTXMON,<
;NOW SETUP THE MAPPING TO MAKE ALL OF THE USER SECTION MAPS ADDRESSABLE IN EXEC MODE
; THE MAPS START AT VIRTUAL ADDRESS UMAPS IN SECTION 37.
	MOVEI	T1,<SECTAB+(<PM.ICD>B2+PM.WRT+IFE FTMP,<PM.CSH>)>
	HRL	T1,.CPCPN-.EVCDB(T2) ;@THRU CURRENT CPU'S ASSIGNED SPT SLOT
	MOVEI	T3,.CPUMA-.EVCDB(T2)
SYSTR4:	MOVSM	T1,(T3)		;POINTER FOR NEXT USER SECTION MAP
	ADDI	T1,1		;NEXT SECTION
	CAIE	T3,.CPUMA-.EVCDB+MXSECN(T2) ;MAPPED ALL SECTIONS?
	AOJA	T3,SYSTR4	;NO, LOOP OVER ALL SECTIONS
> ;END IFN FTXMON
	CONO	PAG,@.CPEBR-.EVCDB(T2)
	DATAO	PAG,NULDOP	;SETUP UBR TO
				; NULL JOB'S UPT SO THAT MUUO'S, ACCOUNTING
				; METERS, EXEC PAGE FAILS DURING ONCE ONLY
				; WORK CORRECTLY. INHIBIT ACCOUNTING STORE
>
IFN M.KS10,<
	WREBR	0		;DO THIS IN CASE POWER UP. KS10 MICRO-CODE V111
				; HAS BUG THAT WILL CAUSE BOGUS PAR ERR
				; IF THIS ISN'T DONE
	WREBR	@.CPEBR-.EVCDB(T2) ;SET UP EXEC BASE REGISTER
	WRUBR	NULDOP		;SET UP USER BASE REGISTER TO NULL JOB
				; SO THAT MUUO'S & PAGE FAILS WORK DURING ONCE
	MOVE	T3,.CPEPT	;GET EPT ADDRESS
	MOVEI	T1,.EPHSB(T3)	;GET HALT STATUS BLOCK ADDRESS
	WRHSB	T1		; DUMP ADDRESS
>
IFG <M.CPU-1>,<
	MOVE	T2,BOOTWD
IFN M.KL10,<
	ANDI	T2,ID.PSN
>
	SKIPGE	BOOTCP		;IS THERE ALREADY SOMEBODY AS THE BOOT CPU
	CAME	T2,.CPASN	;SAME AS THE CURRENT CPU?
	AOJA	T4,SYSTR5	;NO, THIS MUST BE CPU1
>
IFE <M.CPU-1>,<
	MOVE	T2,.CPASN
>
	MOVEM	T2,SERIAL	;STORE FOR SECOND GETTAB
	MOVE	T1,.CPCPN	;OUR CPU NUMBER
	MOVEM	T1,BOOTCP	;NOBODY ELSE DURING SYSTEM STARTUP
	MOVE	T1,[<PM.DCD>B2+PM.WRT+NUPMPP]
	MOVEM	T1,NLUPMP+.UMUPT

SYSTR5:	MOVE	T1,.CPCPN	;GET OUR CPU NUMBER
	MOVE	T2,.CPASN	;AND OUR SERIAL NUMBER
	MOVEM	T2,ASNTAB(T1)	;SAVE FOR EDDT
IFN FTMP,<
	SETOM	INTRST
>
IFN FTKS10,<RDTIME .CPRTM>	;READ INITIAL TIME BASE
	JRSTF	@T4		;DO CPU1 INITIALIZATION
SYSTR6:	HLRZ	T2,.EVCDB-.EVCDB(T2)
	JUMPN	T2,SYSTR2
	MOVEI	T2,.C0CDB
SYSTR7:	SKIPE	.CPOCB-.EVCDB(T2)
	JRST	SYSTR8
	MOVEM	T1,.CPASN-.EVCDB(T2)
	JRST	SYSTR3
SYSTR8:	HLRZ	T2,.EVCDB-.EVCDB(T2)
	JUMPN	T2,SYSTR7
IFN FTMP,<
	SETOM	INTRST
>
	HALT	.



APRRES::EXECAC			;SWITCH TO EXEC AC BLOCK ON PWR FAIL RESTART
	JSP	T4,SYSTR0	;THIS DOES THAT (AND TURNS PAGING ON)
IFE M.CPU-1,<JRSTF @[IC.UOU+APRPFR##]> ;RESTART PROCESSOR
IFN M.CPU-1,<
	  JFCL			;NON-BOOT CPU RETURN
	XCT	.CPRES		;RESTART PROCESSOR
> ;END IFN M.CPU-1
;HERE ON A RESTART AFTER SYSTEM SLEEP, REBOOT

SYSRST::EXECAC			;GET AC SET RIGHT
	CONO	APR,AP.IOR	;BLAST
	CONO	PI,CLRPIS	;BLAST
IFN M.KL10,<CONO PAG,0>		;INSURE THAT THE CACHE IS OFF
	JSP	T4,SYSTR0	;SEE WHICH CPU THIS IS AND SETUP THE EBR
	  JFCL			;ALWAYS RESTART VIA SPRINI
	SETZM	MBTCOM		;MAKE SURE THAT DUMPED CRASHES DON'T LOOK REBOOTABLE
	SETZM	CLKDDT		;ZERO CLKDDT SO WE DON'T JUMP TO EDDT
IFN FTKL10,<
	JSP	T4,ZAPICH	;MAKE SURE INT CHANS ARE IN A REASONABLE STATE
>;END IFN FTKL10
IFG <M.CPU-1>,<
	HRRZ	T1,.CPCPN	;WHERE WE ARE
	CAMN	T1,BOOTCP	;SAME CPU AS WE SUSPENDED ON?
	JRST	SPRINI		;YES - REINITIALIZE
	MOVE	P,.CPNPD	;ANY OLD PUSH DOWN LIST WILL DO
	MOVEI	T1,[ASCIZ/?Must REBOOT on the Policy CPU
/]
	PUSHJ	P,CTYTYP##	;EXPLAIN THE ERROR
	PUSHJ	P,RMVCPU##	;AND GO AWAY
>
;FALL INTO SPRINI ON SINGLE CPU SYSTEMS
SUBTTL INITIALIZATION ON STARTUP/RESTART AFTER SYSTEM SLEEP
;NON-BOOT PROCESSOR INITIALIZATION. REINITIALZATION FOR ALL CPUS
; AFTER SYSTEM SLEEP

SPRINI::CONO	PI,CLRPIS	;CLEAR PI AND PARITY ERROR FLAG
	CONO	APR,APRRST	;RESET EVERYTHING AND ENABLE CLOCK
	EXECAC			;MAKE SURE AC BLOCKS ARE OK
	MOVSI	P,(CR.RMV!CR.DET) ;"CPU IS DOWN" OR "DETACHED" BITS
	TDNE	P,.CPRUN	;CAN THIS CPU RUN YET
	JRST	.-1		;NO, WAIT UNTIL IT CAN
	MOVE	P,.CPNPD	;SET UP PUSH DOWN POINTER
IFN FTKL10,<
	DATAO	APR,[EXP 0]	;CLEAR OLD ADDRESS BREAK
	MOVSI	T1,(1B0)	;CLEAR ADDRESS BREAK SETUP BIT IN CASE RESTART
	ANDCAM	T1,.CPABF	; AFTER REBOOT SO ADDR BREAK GETS SET UP AGAIN
	MOVE	T1,.CPCPN
	PUSHJ	P,DTEINI##
	PUSHJ	P,ENTSPC##	;ENTER SECONDARY PROTOCOL
>;END IFN FTKL10
	MOVSI	T1,(CR.TSS)	;SUCCESSFUL DUMP BIT
	TDNN	T1,.CPRUN	;SET AFTER A SUSPEND?
	JRST	SPRIN0		;NO - CONTINUE
	PUSHJ	P,SUSDTM	;YES - ASK FOR DATE & TIME
	MOVSI	T1,(CR.TSS)	;SUCCESSFUL DUMP BIT
	ANDCAB	T1,.CPRUN	;CLEAR IT
IFG <M.CPU-1>,<
	JRST	SPRIN1		;CONTINUE WITHOUT WITING ON THIS CPU
>
SPRIN0:
IFG <M.CPU-1>,<
	PUSHJ	P,PRTCPU##	;TELL OPR WHO WE ARE
	MOVE	12,[ACLOOP##,,2];LOAD AC'S WITH WAIT LOOP
	BLT	12,12		;CPU1 WILL WAIT UNTIL CPU0 IS GOING
	MOVE	12,[JRST SPRIN1];TO EXIT LOOP
	SJSP	0,3		;ENTER LOOP

;INITIALIZE PD LIST
SPRIN1:	MOVE	P,.CPNPD	;SET UP PUSH DOWN POINTER
	PUSHJ	P,MAPINI##	;COPY THE BOOT CPU'S MAP INTO THE CURRENT CPU'S MAP
	JRSTF	@[EXP IC.UOU+.+1] ;TURN ON USER IOT SO EXECUTE PAGED WORKS
				; CORRECTLY AND PROCEED WITH INITIALIZATION
	CLRPGT
	CONO	PI,PI.CPI	;AND CLEAR PI SYSTEM
	MOVSI	T1,(CR.SPD)	;SUSPENDED BIT
	TDNE	T1,.CPRUN	;RESTART AFTER REBOOT?
	JRST	SPRIN5		;YES, DISKS ARE INITIALIZED
SPRIN2:	MOVE	17,[ONCLOP##,,1] ;WAIT IN ACS FOR CPU0 TO REQUEST IO
	BLT	17,16		; DO IT (AT SPRIN3) WHEN REQUESTED
	SJSP	0,3
;HERE FROM LOOP IN THE ACS TO DO DISK I/O DURING ONCE-ONLY ON NON-BOOT CPUS
SPROIO::
SPRIN3:	MOVE	P,.CPNPD	;SET UP A PDL
	SKIPN	T1,ONCCOM	;WHAT CPU0 WANTS US TO DO
	JRST	SPRIN2		;NOTHING TO DO
	AOJE	T1,SPRIN2	;RESTARTED IF -1
	SOS	F,T1		;COMM WORD INTO F
	SOJE	T1,SPRIN5	;DONE IF +1
	PUSHJ	P,MAPINI##	;SOME OTHER NON BOOT CPU MAY
				; HAVE CHANGED MAPS
	PUSHJ	P,CPUDSP##	;GO DO SOME WORK
	JRST	SPRIN2		;AND WAIT SOME MORE

;HERE TO SET UP TO RUN NULL JOB, & SETUP PI
SPRIN5:	PUSHJ	P,MAPINI##
> ;END IFG <M.CPU-1>
	CONO	PI,PI.ON+DSKPIN	;TURN ON THE PI SYSTEM AND THE DISK PI'S
	MOVSI	T1,(CR.SPD)	;SUSPENDED BIT
	TDNN	T1,.CPRUN	;RESTART AFTER REBOOT?
	JRST	SPRI5A		;NO
IFN M.SCA,<PUSHJ P,PPDINX##>	;INITIALIZE THE PHYSICAL PORT DRIVER
IFN M.ENET,<PUSHJ P,KNIINI##>	;INITIALIZE THE KLNI PORT DRIVER
SPRI5A:
IFN FTKL10,<PUSHJ P,CSDMP##>	;ONCE ONLY/FILSER MAY HAVE POLLUTED CACHE
	MOVEI	T1,CCTYO##	;GET ADDRESS OF TYPEOUT ROUTINE
	MOVEM	T1,.CPTOA	; AND TELL SCNSER
	MOVEI	T1,COMTIV##	;GET ADDRESS OF COMMAND INPUT ROUTINES
	MOVEM	T1,.CPTIV	; AND TELL SCNSER TO USE LDB'S NOW.
	SETZM	.CPTNT		;JUST STARTING
	MOVE	J,.CPCPN	; FOR THIS CPU
	SETZM	CLKMIN(J)	;CLEAR MIN REQUEST
IFN FTMP,<
	SETOM	.CPDIE		;CLEAR DIE NESTING
	SETOM	.CPSCD		;CLEAR SCHED NESTING
	SETZM	.CPNBI		;CLEAR NUMBER OF BROKEN INTERLOCKS
	SETOM	.CPDLK		;CLEAR DSKOFF NESTING
IFN FTSCA,<
	SETOM	.CPSCA		;CLEAR SCA BUFFER MANAGEMENT NESTING
>; END IFN FTSCA
IFN FTENET,<
	SETOM	.CPETH		;CLEAR ETHERNET NESTING
>; END IFN FTENET
>;END IFN FTMP
	SETOM	.CPDWD		;GIVE UP DIE RECURSION INTERLOCK
	SETOM	.CPSIN		;CLEAR SCNSER NESTING
IFN M.TAPE,<SETOM .CPTPN>	;CLEAR TAPSER NESTING
	SETZM	.CPAEF		;CLEAR CPU ERROR/SWEEP FLAGS
	HRRZS	.CPMPC		;CLEAR SERIOUS MEMORY PARITY HALT FLAG
				; HALT AFTER PRINTING ON CPU0 CTY
	MOVE	T1,TIME		;GET CURRENT TIME
	MOVEM	T1,.CPTML	;STORE FOR TICKS GONE BY
	MOVE	T2,TICSEC	;TICK PER SECOND
	LSH	T2,-1		;DIVIDE BY 2
	ADD	T1,T2		;AND ROUND
	IDIV	T1,TICMIN	;T2 = PARTIAL MINUTE (IN TICKS)
	IDIV	T2,TICSEC	;T2 = SECONDS, T3 = REMAINDER IN TICKS
	SUBI	T2,^D60		;COMPUTE TIME TO NEXT MINUTE
	MOVNM	T2,.CPSEC	;STORE FOR ONCE-A-MINUTE UPDATE
	SUB	T3,TICSEC	;TIME TO NEXT SECOND
	MOVNM	T3,.CPHTM	;STORE FOR ONCE-A-SECOND UPDATE
	MOVEI	T1,SR.STS!SR.DIE!SR.ACL ;CLEAR THESE BITS WHEN WE
	ANDCAM	T1,.CPSBR	; RESTART THE PROCESSOR
IFN FTKL10,<
	APRID	T3		;PROCESSOR HARDWARE OPTIONS
	DMOVE	T1,[M.EBPS	;ASSUME A MODEL A PROCESSOR
		M.MBPS]
	TRNE	T3,ID.XKL	;IS IT A MODEL B PROCESSOR?
	DMOVE	T1,[^D30*M.EBPS/^D25 ;YES, USE DIFFERENT EBOX/MBOX CALABRATION CONSTANTS
		^D30*M.MBPS/^D25]
	MOVEM	T1,.CPEBS	;STORE AS EBOX TICS/SEC
	MOVEM	T2,.CPMBS	;STORE AS MBOX TICS/SEC
	IDIV	T1,TICSEC	;AND NOW GET EBOX COUNTS/JIFFY
	IMULI	T1,.EBCPT	;MULTIPLY BY EBOX COUNTS/TICK
	MOVEM	T1,.CPEBJ	;STORE IN CDB VARIABLE
	MOVE	T1,.CPMBS	;GET MBOX TICKS/SECOND
	IDIV	T1,TICSEC	;GET MBOX COUNTS/JIFFY
	IMULI	T1,.MBCPT	;MULTIPLY BY MBOX COUNTS/TICK
	MOVEM	T1,.CPMBJ	;SAVE
	PUSHJ	P,SETCLK	;SETUP CLOCKS, PI, APR
>
	SETZM	.CPTIM		;NO TICKS YET SINCE LAST INTERRUPT
IFN FTKS10,<PUSHJ P,UBAPIS>	;MAKE SURE UBA'S HAVE A PIA
	SETZB	S,P1		;ALWAYS CALL INI ROUTINE ONCE
	HLRZ	P3,HNGLST	;LOOK ONLY AT REAL HARDWARE
SPRIN9:	MOVE	F,P3		;SETUP F FOR INI CODE
	MOVE	P3,DEVSER(P3)	;ADDRESS OF DEVICE DISPATCH VECTOR
IFN FTMP,<
	LDB	T1,DEYCPF	;CPU OWNING THE DEVICE
	CAMN	T1,.CPCPN	;CURRENT CPU?
>;END IFN FTMP
	CAIN	P1,(P3)		;YES, ALREADY CALLED INI ROUTINE?
	JRST	SPRI10		;YES, SKIP ON
	PUSHJ	P,DINI(P3)	;NO, CALL INI ROUTINE
	  HRRZ	P1,P3		;NEEDN'T CALL IT AGAIN
SPRI10:	HLRZS	P3		;NEXT DDB
	JUMPN	P3,SPRIN9	;LOOP IF THERE IS ONE
IFN FTKL10,<
	PUSHJ	P,SETCSH##	;SET CACHE STRATEGY AS ESTABLISHED BY KLI
	PUSHJ	P,STAPPC##	;START PRIMARY PROTOCOL
>; END IFN FTKL10
IFN FTKS10,<PUSHJ P,ENAKAL##>	;ENABLE KEEP ALIVE
	MOVSI	T1,(CR.SPD)	;BIT TO TEST
	TDNN	T1,.CPRUN	;RESTARTING SUSPENDED MONITOR?
	JRST	SPRI11		;NO
	PUSHJ	P,DSKRCL	;YES, GENERATE A FREE INTERRUPT FROM ALL DSKS
				; SO FILIO WILL REREAD THE HOME BLOCK AND
				; VERIFY THAT PACKS WEREN'T MOVED WHILE ASLEEP
IFN FTXMON,<XJRST [MCSEC1+.+1]> ;RUN IN SECTION ONE
	PUSHJ	P,SETBFL##	;RELOAD MONITOR FILESPEC INTO BOOT VECTOR
	PUSHJ	P,SSLBLD##	;AND SSL
	  JFCL
	PUSHJ	P,ASLBLD##	;AND ASL
	  JFCL
	PUSHJ	P,SDLBLD##	;AND FINALLY THE SDL
	  JFCL
IFN FTNET,< PUSHJ P,FEKCPW##>	;TEL THE FRONT ENDS WE ARE BACK
IFN FTENET,<PUSHJ P,KNIMON##>	;TELL KLNI WE ARE BACK
IFN FTSCA,< PUSHJ P,PPDMON##>	;TELL KLIPA WE ARE BACK
	MOVSI	T1,(CR.SPD)	;SUSPEND BIT
	ANDCAM	T1,.CPRUN	;CLEAR IT SINCE RESUMING
IFN FTXMON,<XJRST [MCSEC0+.+1]> ;BACK TO SECTION ZERO
SPRI11:
IFG <M.CPU-1>,<
	SKIPE	J,.CPJOB	;IF A RESTART AND A JOB WAS RUNNING,
	PUSHJ	P,CPUZAP##	; ZAP IT AND INFORM THE USER
	MOVEI	J,JOBMAX	;MAX JOB NO.
	MOVSI	T1,(SP.CJ0)	;JOB RUNNING ON CPU1 BIT
	LSH	T1,@.CPCPN
	ANDCAM	T1,JBTSPS(J)	;CLEAR FOR ALL JOB IN SYSTEM
	SOJGE	J,.-1		;MORE?
	SETZM	.CPJOB		;NO PREVIOUS JOB
	SETZM	.CPDRQ		;NO MORE DISKS TO RESCUE
>
	CLRPGT
IFN FTKL10,<PUSHJ P,ABKCHK##>	;CHECK & POSSIBLY SET EXEC MODE ADDRESS BREAK
	SJSP	U,NULJB1	;GO START NULL JOB
;ROUTINE TO GET THE DATE: & TIME: FROM THE OPERATOR AFTER A /REBOOT
;OF A SUSPENDED SYSTEM.

SUSDTM:	SE1ENT			;NEED LDB'S
	HRRZ	T1,.CPCTN	;GET CTY LINE NUMBER FOR THIS CPU
	MOVE	U,LINTAB##(T1)	;SETUP U FOR CTY
	MOVEI	T1,CTYWAT##	;ADDRESS OF TYPEOUT ROUTINE TO USE
	MOVEM	T1,.CPTOA	; AND TELL SCNSER
	MOVEI	T1,COMTIV##	;GET ADDRESS OF COMMAND INPUT ROUTINES
	MOVEM	T1,.CPTIV	; AND TELL SCNSER TO USE LDB'S
	PUSHJ	P,TSETBI##	;CLRBFI INPUT FROM THE CHUNKS
	PUSHJ	P,TSETBO##	;DON'T WANT ANY OUTPUT FROM BEFORE
	PUSH	P,LDBDCH##(U)	;SAVE STATE OF LINE
	MOVSI	T1,LDLCOM##	;COMMAND MODE BIT
	TDNN	T1,LDBDCH##(U)	;IF NOT ON THEN
	PUSHJ	P,TTYSTC##	; GET LINE INTO COMMAND MODE
	PUSHJ	P,INLMES##	;GET FROMT-END IN THE MOOD
	BYTE(7)177
	CAIA			;ASK FOR DATE
SUSDT0:	PUSHJ	P,TTYCMR##	;SAY PREVIOUS COMMAND IS COMPLETED
	PUSHJ	P,INLMES##	;ASK FOR THE DATE
	ASCIZ	/Date: /
	PUSHJ	P,PCOMM		;TAKE A COMMAND LINE FROM CTY
	MOVEI	T1,LOCYER
	PUSHJ	P,GTDATE##	;GET THE DATE IN LOCYER,LOCMON,LOCDAY
	 JRST	[PUSHJ	P,INLMES##	;BAD FORMAT
		 ASCIZ	/Please type today's date as MON-DD(-YY)
/
		 JRST	SUSDT0]		;AND ASK AGAIN
SUSTM:	PUSHJ	P,TTYCMR##	;SAY PREVIOUS COMMAND IS COMPLETED
	PUSHJ	P,INLMES##	;ASK FOR TIME
	ASCIZ	/Time: /
	PUSHJ	P,PCOMM		;TAKE A COMMAND LINE FROM CTY
	PUSHJ	P,RDTIM##	;GET TIME OF DAY IN T1
	 SETO	T1,			;BAD FORMAT
	JUMPLE	T1,[PUSHJ P,INLMES##	; OR NEGATIVE OR JUST RETURN
		    ASCIZ /Please type time as HHMMSS or HH:MM:SS
/
		    JRST SUSTM]		;ASK AGAIN
	PUSH	P,U		;SAVE LDB ADDRESS
	PUSHJ	P,SETDA3##	;DO THE SETUUO STUFF
	 JFCL			;SKIP RETURNS
	POP	P,U		;RESTORE ADDR OF LDB
	PUSHJ	P,TTYCMR##	;SAY PREVIOUS COMMAND IS COMPLETED
	PUSHJ	P,TYIEAT##	;AND EAT PREVIOUS COMMAND LINE
	POP	P,T1		;GET BACK STATE OF LINE
	HRRZ	F,LDBDDB##(U)	;GET THE DDT
	JUMPE	F,CPOPJ		;NONE - JUST RETURN
	LDB	J,PJOBN		;SETUP JOB INCASE WE CALL TTYUSW
	TLNN	T1,LDLCOM##	;IF IT WAS IN USER MODE THEN
	PUSHJ	P,TTYUSW##	; SET THE LINE BACK THE WAY IT WAS
	POPJ	P,		;RETURN

;ROUTINE TO TAKE A COMMAND LINE FROM THE CTY WITH INTERRUPTS OFF

PCOMM:	PUSHJ	P,TYIEAT##	;EAT ANY PREVIOUS COMMAND LINE
	PUSHJ	P,PLINE		;TAKE AN INPUT LINE INTO THE CHUNKS
	MOVE	T1,LDBTIT##(U)	;BYTE POINTER TO LINE JUST READ IN
	PUSHJ	P,CTISBP##	;TELL COMCON
	MOVEI	T3," "		;PRIME THE COMMAND SCANNER
	PUSHJ	P,CTISLC##	;BY MAKING THE LAST CHR A BLANK
	POPJ	P,		;RETURN


;ROUTINE TO TAKE A LINE OF INPUT FROM THIS CPU'S CTY WITHOUT INTERRUPTS
;TURNED ON.  INPUTTED CHARACTERS ARE STORED IN THE CHUNKS AND ECHO IS
;HANDLED THROUGH CTYWAT.

PLINE:	PUSHJ	P,PTYI		;GET A POLLED CHARACTER
	HRRZ	U,.CPCTN	;GET CTY LINE NUMBER FOR THIS CPU
	PUSHJ	P,RECINT##	;GIVE CHR TO SCNSER - RETURNS LDB IN U AGAIN
PLINEC:	PUSHJ	P,XMTCHR##	;GET ANY ECHO
	 JRST	PLINBK		;NOTHING LEFT TO ECHO
	PUSHJ	P,CTYWAT##	;ECHO IT
	JRST	PLINEC		;CHECK FOR MORE TO ECHO
PLINBK:	PUSHJ	P,TTLCHK##	;CHECK FOR END OF LINE
	 JRST	PLINE		;NOT A LINE YET - GET ANOTHER CHARACTER
	POPJ	P,		;RETURN WITH A LINE IN THE CHUNKS

;ROUTINE TO INPUT ONE POLLED CHARACTER FROM THE CTY

PTYI:
IFN FTKL10,<
	PUSHJ	P,SPCGTI##	;SKIP IF CHAR PRESENT, WITH IT IN T3
>; END IFN FTKL10
IFN FTKS10,<
	SKIPN	T3,CTYIWD	;SKIP IF CHAR PRESENT, WITH IT IN T3
>; END IFN FTKS10
	  JRST	PTYI		;NONE THERE - LOOP
IFN FTKS10,<
	SETZM	CTYIWD		;CLEAR FOR NEXT TIME
>; END IFN FTKS10
	ANDI	T3,CK.CHR	;JUST CHARACTER BITS
	POPJ	P,		;RETURN WITH CHR IN T3
SETCLK:
IFN FTEMRT,<
	PUSHJ	P,ACCMON##	;START UP ACCOUNTING METERS
	PUSHJ	P,CLREMB##	;CLEAR OUT E AND MBOX ACCOUNTING METERS
>;END IFN FTEMRT
	PUSHJ	P,SETIME	;TO INITILIZE 'GGTIME' CLOCK (IN SYSINI)
IFN FTKL10,<
IFG <M.CPU-1>,<
	MOVE	T1,BOOTCP	;BOOT CPU
	MOVSI	T2,(CR.SPD)	;SUSPENDED BIT
	TDNN	T2,.CPRUN	;THERE MIGHT NOT BE A BOOT CPU AFTER A REBOOT
	CAMN	T1,.CPCPN	;ALSO COULD BE THE BOOT - WARM RESTART
	JRST	SETCL1		; SO DON'T WAIT ON IT
	IMULI	T1,.CPLEN	;OFFSET TO ITS CDB
	SKIPE	T2,.C0TMF(T1)	;WAIT UNTIL CLOCK FLAG CLEARS, ZERO T2
	JRST	.-1
	SKIPN	.C0TMF(T1)	;TIME FROM SET UNTIL SET
	JRST	.-1
	SKIPE	.C0TMF(T1)
	AOJA	T2,.-1
	SKIPN	.C0TMF(T1)
	AOJA	T2,.-1
	MOVE	T3,.CPCPN	;OUR CPU NUMBER
	SUB	T3,BOOTCP	; MINUS THE BOOT CPU NUMBER
	SKIPG	T3		;IF NEGATIVE, (NEVER EQUALS ZERO)
	ADDI	T3,M.CPU	; MODULO THE NUMBER OF CPU'S
	IMULI	T2,(T3)
	IDIVI	T2,M.CPU	;FRACTION OF A TIC TO WAIT
	SOJG	T2,.		; BEFORE STARTING THE CLOCK
>
SETCL1:	MOVEI	T1,^D1666	;ASSUME 60HZ
	MOVE	T2,STATES
	TLNE	T2,(ST.CYC)	;IS OUR ASSUMPTION CORRECT?
	MOVEI	T1,^D2000	;NO, 2000 IS INTERVAL
	CONO	TIM,TO.CTD!TO.CIT!TO.SIT(T1)	;START TIMER GOING
>
	CONO	APR,APRNUL
	CONO	PI,PI.CPI!PI.TNP!PI.ON!II.ACO!IFE FTKS10,<PI.EPE>
				;TURN ON ALL PI, ENABLE MEMORY PARITY
	POPJ	P,
;SUBROUTINE TO DO A RECAL ON EVERY DISK THAT THE SYSTEM KNOWS ABOUT
; THIS WILL CAUSE A FREE INTERRUPT TO BE GENERATED BY EACH DISK WHICH
; WILL CAUSE FILIO TO REREAD AND VERIFY HOME BLOCKS ON EVERY PACK
; CURRENTLY SPINNING. THUS IF SOME PACKS WERE REMOVED OR MOVED DURING
; THE SYSTEM SLEEP OR POWER FAIL, THE OPERATOR WILL BE COMPLAINED AT
; AND THERE WILL BE NO CHANCE OF COMPROMISING DATA INTEGRITY.

DSKRCL::MOVEI	U,SYSUNI##-UNISYS ;START AT FIRST UNIT ON SYSTEM
DSKRC1:	HLRZ	U,UNISYS(U)	;NEXT UNIT
	JUMPE	U,CPOPJ		;DONE IF LAST UNIT
	MOVE	J,UDBKDB(U)	;KONTROLLER THIS UNIT IS CONNECTED TO
	MOVSI	T1,U2PNRM##	;FIXED MEDIA BIT
IFG <M.CPU-1>,<
	MOVE	T2,UDBCAM(U)	;CPU THAT THIS UNIT IS ON
	TDNE	T2,.CPBIT	;THIS CPU?
>
	TDNE	T1,UNIDS2(U)	;AND NOT FIXED MEDIA (THAT BETTER NOT MOVE)
	JRST	DSKRC1		;NEXT UNIT IF NOT THE RIGHT CPU OR FIXED MEDIA
	SKIPN	UNISTS(U)	;DON'T RECAL IF NOT IDLE (POWER FAIL)
	PUSHJ	P,@KONRCL##(J)	;RECALIBRATE SO WE WILL GET A FREE INTERRUPT AND
				; REREAD THE HOME BLOCKS IN CASE A PACK WAS MOVED
	  JFCL			;DON'T CARE IF OFF-LINE
	JRST	DSKRC1		;LOOK AT NEXT UNIT
SUBTTL	EXEC DATA VECTOR SETUP


; HERE TO SET UP SOME EXEC DATA VECTOR QUANTITIES.  THESE VARIABLES
; ARE REQUIRED TO SET UP PAGING SO THAT GETTAB AND JOBPEK UUOS MAY
; BE SIMULATED ON A MONITOR CRASH FILE.  THESE WORDS CONTAIN CPU
; DEPENDANT INFORMATION.  THE EXEC DATA VECTOR FOR THE BOOT CPU, NOT
; THE CRASHING CPU, WILL BE POINTED TO BY .JBEDV IN JOBDAT.  ON ALL
; SYSTEMS, .JBEDV IS SET UP AT SYSTEM STARTUP.  ON MULTI-CPU SYSTEMS,
; .JBEDV IS RESET ON EVERY ROLE SWITCH.  .JBEDV (AND THE CPU DEPENDANT
; EDVS) WILL REQUIRE ADDRESS FIXUPS IF A "SET MEMORY OFFLINE" COMMAND
; IS EXECUTED.  THIS BE BECAUSE THE EDVS CONTAIN PHYSICAL ADDRESSES.
;
SETEDV::PUSH	P,T1		;SAVE T1
	PUSH	P,T2		;SAVE T2
	MOVEI	T1,EDVSET	;POINT TO SUBROUTINE
	PUSHJ	P,CPUAPP	;EXECUTE IT OVER ALL CPUS
IFN FTMP,<
	SKPCPU	(0)		;ARE WE THE BOOT CPU?
	JRST	TTPOPJ		;NO--JUST RETURN
>
	MOVEI	T1,.CPEDV	;POINT TO OUR EDV BLOCK
	PUSHJ	P,EDVMAP	;MAP THE ADDRESS
	MOVEM	T2,.JBEDV##	;STASH IT AWAY FOR CURIOUS PROGRAMS
	JRST	TTPOPJ		;RESTORE ACS AND RETURN

EDVSET:	HRRZ	T2,.CPTYP-.EVCDB(P1) ;GET DEC CPU TYPE CODE
	APRID	T1		;READ SERIAL NUMBER
	TLO	T2,(ED.KLP)	;ONLY KL-PAGING IS SUPPORTED
IFN FTKL10,<
	TRNE	T1,ID.XKL	;EXTENDED KL10?
	TLO	T2,(ED.XKL)	;YES
>
	MOVEM	T2,.CPEDV-.CPCDB+.EDDAT(P1) ;SAVE IT
	MOVE	T1,.CPEPT-.CPCDB(P1) ;GET VIRTUAL ADDRESS OF OUR EPT
	PUSHJ	P,EDVMAP	;MAP PHYSICAL
	MOVEM	T2,.CPEDV-.CPCDB+.EDEPT(P1) ;SAVE IT

	MOVEI	T1,SPTTAB	;GET VIRTUAL ADDRESS OF THE SPT
	PUSHJ	P,EDVMAP	;MAP PHYSICAL

	MOVEM	T2,.CPEDV-.CPCDB+.EDSPT(P1) ;SAVE IT
	SETZM	.CPEDV-.CPCDB+.EDCST(P1) ;NO CST NONSENSE ON TOPS-10

	MOVEI	T1,.CPACA-.CPCDB(P1) ;GET VIRTUAL ADDRESS OF CRASH ACS POINTER
	PUSHJ	P,EDVMAP	;MAP PHYSICAL
	MOVEM	T2,.CPEDV-.CPCDB+.EDCAC(P1) ;SAVE IT
	POPJ	P,		;RETURN

EDVMAP:	MAP	T2,(T1)		;CONVERT VIRTUAL ADDRESS TO PHYSICAL
	TLZ	T2,777000	;STRIP OFF PAGE MAP FLAGS
	POPJ	P,		;RETURN
;DTE20 DEVICE CODES FROM DTEPRM.MAC

	DTE0==200
	DTE1==204
	DTE2==210
	DTE3==214

;RH20 DEVICE CODES

	RH2==540
	RH21==544
	RH22==550
	RH23==554
	RH24==560
	RH25==564
	RH26==570
	RH27==574

;OTHER DEVICES

	FHD2==174	;DEVICE CODE FOR SECOND FIXED HEAD CONTROLLER
	DPC==250	;DISK PACK CONTROL - NOT IN MACRO.SVE FOR SPMON
	DPC2==254	;DEVICE CODE FOR SECOND DISK PACK CONTROLLER
	DPC3==260
	DPC4==264
	DAS==324
	FSD==270
	FSD2==274
	FSD3==360
	DAC==320
	DBS==334
	DBC==330
	DLC==64
	DLC2==164
	DLB==60
	DLB2==160
	CDR2==154
	LPT2==234
	LPT3==230
	LPT3==230
	PLT2==144
	DX10==220
;SUBROUTINE TO STORE INFORMATION IN THE CPU STATUS BLOCK

CPUSTS::APRID	.CPAPD		;(0) APRID
	CONI	APR,.CPACN	;(1) CONI APR,
	CONI	PI,.CPPIC	;(2) CONI PI,
	DATAI	PAG,.CPPGD	;(3) DATAI PAG,
	CONI	PAG,.CPPGC	;(4) CONI PAG,
	MOVE	T1,[.USMUO,,.CPUP0] ;(5) UPT LOCS 424-427
	BLT	T1,.CPUP0+3
IFN M.KL10,<
	RDERA	.CPERA		;(11) RDERA
	CONI	RH2,.CPRHC	;(12) CONI RH20, FOR ALL 8 RH'S
	CONI	RH21,.CPRHC+1
	CONI	RH22,.CPRHC+2
	CONI	RH23,.CPRHC+3
	CONI	RH24,.CPRHC+4
	CONI	RH25,.CPRHC+5
	CONI	RH26,.CPRHC+6
	CONI	RH27,.CPRHC+7
	CONI	DTE0,.CPDTC	;(22) CONI DTEn
	CONI	DTE1,.CPDTC+1
	CONI	DTE2,.CPDTC+2
	CONI	DTE3,.CPDTC+3
	HRLZ	T1,.CPEPT	;(26) EPT LOCS 0-37
	HRRI	T1,.CPEP0
	BLT	T1,.CPEP0+37
	MOVE	T1,.CPEPT	;(66) EPT LOCS 140-147
	HRLI	T1,140(T1)
	HRRI	T1,.CPEP1
	BLT	T1,.CPEP1+37
>
	MOVE	T1,[.UPMP+500,,.CPUP1] ;(126) UPT LOCS 500-503
	BLT	T1,.CPUP1+3
IFN M.KL10,<
	EXECAC	(6)		;(132) AC BLOCK 6, REGS 0-3 AND 12
	MOVEM	0,.CP6
	MOVEM	1,.CP6+1
	MOVEM	2,.CP6+2
	MOVEM	3,.CP6+3
	MOVEM	12,.CP6+4
>
IFN M.KS10,<
	RDCSTM	.CP6
	RDPUR	.CP6+1
	RDCSB	.CP6+2
	RDSPB	.CP6+3
>
	EXECAC	(7)		;(136) AC BLOCK 7, REGS 0-2
	MOVEM	0,.CP7
	MOVEM	1,.CP7+1
	MOVEM	2,.CP7+2
IFN M.KL10,<MOVEM 3,.CP73>	;*** NOT IN CSB, BUT USEFUL
	DATAO	PAG,.CPPGD	;RESTORE ORIGIONAL AC BLOCK
IFN M.KL10,<
	PUSHJ	P,REDSBD	;READ SBDIAG INFO
>
REPEAT 0,<
	MOVE	T1,.CPCPN	;CURRENT CPU NUMBER
	LSH	T1,1		;MULTIPLY BY 2
	MOVE	T2,.CPSLF	;ADDRESS OF THIS CPU'S CDB
	ADDI	T2,.CPAPD-.CPCDB ;OFFSET OF CPU STATUS BLOCK IN CDB
	MOVEM	T2,110(T1)	;STORE ADDRESS OF CPU STATUS BLOCK FOR F/S
	MAP	T2,(T2)		;ABSOLUTE ADDRESS OF CPU STATUS BLOCK
	MOVEM	T2,111(T1)	;STORE IT FOR FIELD SERVICE
>;END REPEAT 0
	MOVEI	T1,SR.CSB	;SET FLAG TO INDICATE CPU
	IORM	T1,.CPSBR	;STATUS BLOCK READ ON THIS CPU
	POPJ	P,
IFN M.KL10,<
;ROUTINE TO CLEAR SBUS ERRORS IN EACH MEMORY CONTROLLER.  RETURNS
;CPOPJ ALWAYS AND PRESERVES ALL AC'S.

CLRSBD::PUSHJ	P,SAVE3		;SAVE P1-P3
	MOVSI	P1,-.SBNMC	;MAKE AOBJN POINTER TO ALL MEM CONTROLLERS
	MOVSI	P2,SB.CLR	;BIT TO CLEAR ALL ERRORS
CLRSB1:	DPB	P1,[POINT 5,P2,4] ;STORE MEMORY CONTROLLER NUMBER
	SBDIAG	P2		;CLEAR THE ERROR BITS
	AOBJN	P1,CLRSB1	;LOOP FOR ALL CONTROLLERS
	POPJ	P,		;RETURN


;ROUTINES TO PERFORM SBDIAG FUNCTIONS 0 AND 1 FOR EACH MEMORY CONTROLLER.
;CALL REDSBD TO JUST READ THE DATA.  CALL REDSBC TO READ THE DATA AND
;CLEAR THE ERRORS.  THE FORMAT OF THE SBDIAG STATUS BLOCK IS AS FOLLOWS:
;	WORD 0: -NUMBER OF DATA BLOCKS,,OFFSET TO FIRST BLOCK
;EACH DATA BLOCK HAS THE FOLLOWING FORMAT:
;	WORD 0: -NUMBER OF WORDS FOLLOWING,,CONTROLLER NUMBER
;	WORD 1: SBDIAG FUNCTION 0 FROM-MEMORY WORD
;	WORD 2: SBDIAG FUNCTION 1 FROM-MEMORY WORD
;DESTROYS T1, PRESERVES ALL OTHERS

REDSBD::TDZA	T1,T1		;CLEAR T1 AND SKIP
REDSBC::MOVSI	T1,SB.CLR	;BIT TO CLEAR ERRORS
	PUSHJ	P,SAVE4		;SAVE P1-P4
	SETZM	.CPSBD		;CLEAR FIRST WORD OF BLOCK FOR COUNT
	MOVSI	P1,-.SBNMC	;AOBJN POINTER TO MEMORY CONTROLLERS
	MOVEI	P2,.CPSBD+1	;START FIRST BLOCK HERE
	HRLI	P2,-.SBFNC	;-FUNCTIONS TO LH
REDSB1:	MOVEI	P3,0		;SET TO BUILD TO-MEMORY WORD
	DPB	P1,[POINT 5,P3,4] ;STORE MEMORY CONTROLLER
	SBDIAG	P3		;DO FUNCTION 0
	PUSH	P,P4		;SAVE FUNCTION 0 FROM-MEMORY WORD
	JUMPE	T1,REDSB2	;AVOID 2ND SBDIAG IF NOT CLEARING CONTROLLER
	IOR	P3,T1		;SET SB.CLR
	SBDIAG	P3		;DO FUNCTION 0 TO CLEAR CONTROLLER
REDSB2:	TRO	P3,1		;MAKE IT FUNCTION 1
	SBDIAG	P3		;DO FUNCTION 1
	POP	P,P3		;RESTORE FUNCTION 0 FROM-MEMORY WORD
	SKIPN	P3		;ANYTHING THERE?
	JUMPE	P4,REDSB3	;NO, NO MEMORY CONTROLLER IF BOTH ZERO
	MOVEM	P3,1(P2)	;SAVE FUNCTION 0 WORD IN THE BLOCK
	MOVEM	P4,2(P2)	;  ALONG WITH FUNCTION 1 WORD
	HRRZM	P1,0(P2)	;SAVE CONTROLLER NUMBER AS WORD 0
	HLLM	P2,0(P2)	;MAKE IT -WORDS,,CONTROLLER
	AOS	.CPSBD		;COUNT THIS CONTROLLER
	ADDI	P2,.SBFNC+1	;INCREMENT TO NEXT BLOCK
REDSB3:	AOBJN	P1,REDSB1	;LOOP FOR NEXT CONTROLLER
	MOVN	P1,.CPSBD	;GET NUMBER OF BLOCKS WE STORED
	JUMPE	P1,CPOPJ	;LEAVE IT ZERO IF NONE
	HRLI	P1,1		;MAKE SWAPPED HEADER WORD
	MOVSM	P1,.CPSBD	;SAVE IN WORD 0
	POPJ	P,		;RETURN
>;END IFN M.KL10
;SUBROUTINE TO READ AND STORE DEVICE STATUS

DVCSTS::MOVSI	T1,-DVSLEN	;LENGTH OF DEVICE STATUS TABLE
	XCT	DVSXCT(T1)	;DO THE I/O INSTRUCTION
	AOBJN	T1,.-1		;LOOP FOR ALL OF THEM
IFN M.KL10,<
	HRLI	T1,-10		;NOW DO THE EIGHT RH20'S
DVCST1:	LDB	T2,[POINT 7,DVSXCT(T1),9] ;GET THE DEVICE CODE
	MOVE	T3,[CONI RH2,T3] ;LOAD CONI INSTRUCTION
	DPB	T2,[POINT 7,T3,9] ;MAKE IT SPECIFIC TO THIS RH20
	XCT	T3		;DO THE CONI
	JUMPL	T3,DVCST2	;JUMP IF NOT AN RH20 (CI/NI)
	MOVE	T3,[DATAO RH2,RH2IVI] ;LOAD DATAO INSTRUCTION
	DPB	T2,[POINT 7,T3,9] ;MAKE IT SPECIFIC TO THIS RH20
	XCT	T3		;DO THE DATAO TO SELECT IVI REGISTER
	XCT	DVSXCT(T1)	;NOW DO THE DATAI TO READ THE IVI
DVCST2:	AOBJN	T1,DVCST1	;LOOP FOR ALL EIGHT RH20'S
>; END IFN M.KL10
IFN M.KS10,<
	PUSH	P,.USPFP	;SAVE PREVIOUS PC
	PUSH	P,.USPFP+1
	PUSH	P,.USPFW	;SAVE PREVIOUS PAGE FAIL WORD
	MOVSI	T1,-KSRTBL	;POINTER TO DEVICE ADDRESS TABLE
	MOVEI	T2,DVCST2	;TRAP ADDRESS FOR NX DEVICES
	EXCH	T2,.USPFN	;SET IT AND SAVE CURRENT ONE
DVCST1:	RDIO	T4,@KSRTAB(T1)	;READ SOME REGISTER
	MOVEM	T4,.CPUB1(T1)	;SAVE IT IN RIGHT SLOT
				;*** HERE ON NX DEVICE TRAP
DVCST2:	AOBJN	T1,DVCST1	;DO NEXT
	EXCH	T2,.USPFN	;RESTORE TRAP ADDRESS
	POP	P,.USPFW	;RESTORE PREVIOUS PAGE FAIL WORD
	POP	P,.USPFP+1	;RESTORE PREVIOUS PC
	POP	P,.USPFP
>;END IFN M.KS10
IFN M.SA10,<PUSHJ P,SAXDMP##>	;PRESERVE SA10 STUFF
	MOVEI	T1,SR.DSB	;SET FLAG TO INDICATE
	IORM	T1,.CPSBR	;DEVICE STATUS BLOCK READ
	POPJ	P,

IFN M.KL10,<
RH2IVI:	.DOIVI			;DATAO TO SELECT IVI
>
;TABLE OF INSTRUCTIONS TO EXECUTE TO FILL IN CDB ENTRIES BEGINNING
;AT CDB VARIABLE .CPDVS.  THE ORDER OF THIS TABLE MUST MATCH THE
;ORDERING OF ENTRIES IN THE CDB AT CDB VARIABLE .CPDVS.

;FOR THE KS10 THIS TABLE IS USED A LITTLE DIFFERENTLY.  THE FIRST
;PART OF THE TABLE CONTAINS I/O INSTRUCTIONS JUST LIKE FOR THE
;KL10.  THE SECOND PART OF THE TABLE CONTAINS THE DEVICE REGISTER
;ADDRESS FOR UNIBUS DEVICES.

DVSXCT::
IFN M.KL10,<
	CONI	TIM,.CPTMR		;INTERVAL TIMER STATUS
	CONI	MTR,.CPMTR		;METER STATUS
	CONI	TTY,.CPTTY
	CONI	PTR,.CPPRA
	CONI	PTP,.CPPPA
	CONI	DLS,.CPDLS
	CONI	DAC,.CPDAC
	CONI	DAS,.CPDAS
	CONI	CR,.CPCRA
	CONI	LPT,.CPLPT
	CONI	PLT,.CPPLA
	CONI	TMS,.CPTMS
	CONI	TMC,.CPTMC
	CONI	DX10,.CPDX1
	CONI	DSK,.CPDSK
	CONI	FHD2,.CPFH2
	CONI	FSD,.CPFSD
	CONI	FSD2,.CPFS2
	CONI	FSD3,.CPFS3
	CONI	DPC,.CPDPC
	CONI	DPC2,.CPDP2
	CONI	DPC3,.CPDP3
	CONI	DPC4,.CPDP4
	CONI	DBS,.CP2DS		;2ND TD10
	CONI	DBC,.CP2DC
	CONI	DLC,.CPDLC
	CONI	DLB,.CPDLB
	CONI	DLC2,.CPDC2
	CONI	DLB2,.CPDB2
	CONI	CDP,.CPCDP
	CONI	CDR2,.CPCRB		;CDR1
	CONI	LPT2,.CPLPB		;LPT1
	CONI	LPT3,.CPLPC		;LPT2
	CONI	PLT2,.CPPLB		;PLT1
	DATAI	APR,.CPDAK		;ADDRESS BREAK CONDITIONS
	DATAI	DSK,.CPDDK
	DATAI	FHD2,.CPDH2
	DATAI	FSD,.CPDFS
	DATAI	FSD2,.CPDS2
	DATAI	FSD3,.CPDS3
	DATAI	DPC,.CPDDP
	DATAI	DPC2,.CPDD2
	DATAI	DPC3,.CPDD3
	DATAI	DPC4,.CPDD4
	DATAI	DLC,.CPDDC
	DATAI	DLB,.CPDDB
	DATAI	DLC2,.CPD2C
	DATAI	DLB2,.CPD2B
DVSLEN==.-DVSXCT		;LENGTH OF (NON-RH20) I/O INSTRUCTION TABLE
	DATAI	RH2,.CPIVI
	DATAI	RH21,.CPIVI+1
	DATAI	RH22,.CPIVI+2
	DATAI	RH23,.CPIVI+3
	DATAI	RH24,.CPIVI+4
	DATAI	RH25,.CPIVI+5
	DATAI	RH26,.CPIVI+6
	DATAI	RH27,.CPIVI+7
>;END IFN M.KL10
IFN M.KS10,<
	RDINT	.CPTMR
	RDTIME	.CPTMB
DVSLEN==.-DVSXCT		;LENGTH OF I/O INSTRUCTION TABLE
	RDTIME	.CPTMB+1	;THIS IS A DUMMY AS RDTIME RETURNS 2 WORDS
KSRTAB:	XWD	1,UNBSTW	;UBA1 STATUS REGISTER
	XWD	3,UNBSTW	;UBA3 STATUS REGISTER
	RH11CA			;RPCS1
	RH11CA+10		;RPCS2
	RH21CA			;MTCS1
	RH21CA+10		;MTCS2
	LP11CA			;LPT CSRA
	LP11CA+2		;LPT CSRB
	CD11BA			;CDR CDST
	PR11CA			;PTR CSR
	PP11CA			;PTP CSR
	RX21BA			;RXA CSR
KSRTBL==.-KSRTAB		;LENGTH OF REGISTER TABLE
>; END IFN M.KS10
IF1,<IFN <.-DVSXCT>-.CPDVL,<PRINTX ?DVSXCT TABLE IS INCORRECT>>
LENDVS==:<.-DVSXCT-1>B26	;LENGTH OF TABLE OF INSTRUCTIONS FOR GETTAB
;HERE FROM THE DIAG. UUO (FUNCTION 10) TO READ THE CPU STATUS
;BLOCK.
DIACSB::PUSHJ	P,CPUSTS	;READ CPU STATUS BLOCK
	PUSHJ	P,CSBELG	;LOG CPU STATUS BLOCK
	JRST	CPOPJ1		;GIVE SUCCESS RETURN FROM UUO


;HERE FROM THE DIAG. UUO (FUNCTION 11) TO READ THE DEVICE
;STATUS BLOCK.
DIADSB::PUSHJ	P,DVCSTS	;READ DEVICE STATUS BLOCK
	PUSHJ	P,DVLELG	;LOG DEVICE STATUS BLOCK
	JRST	CPOPJ1		;GIVE SUCCESS RETURN FROM UUO
;ROUTINE TO TYPE RELEVANT PARTS OF THE CPU STATUS BLOCK ON THE CTY
;WHEN A CRASH OCCURS.

TYPCSB::PUSHJ	P,INLMES##
	ASCIZ/

CPU Status Block
/
	PUSHJ	P,INLMES##
	ASCIZ/
APRID = /
	MOVE	T1,.CPAPD	;GET APRID
	PUSHJ	P,HWDPNT##	;TYPE IT
IFN M.KL10,<
	PUSHJ	P,INLMES##
	ASCIZ/
ERA = /
	SKIPN	T1,.CPAER
	MOVE	T1,.CPERA	;GET ERA
	PUSHJ	P,HWDPNT##	;TYPE IT
>;END IFN M.KL10
	PUSHJ	P,INLMES##
	ASCIZ/
CONI APR, = /
	MOVE	T1,.CPACN	;GET CONI APR
	PUSHJ	P,HWDPNT##	;TYPE IT
	PUSHJ	P,INLMES##
	ASCIZ/
CONI PI, = /
	SKIPN	T1,.CPCPI
	MOVE	T1,.CPPIC	;GET CONI PI
	PUSHJ	P,HWDPNT##	;TYPE IT
	PUSHJ	P,INLMES##
	ASCIZ/
CONI PAG, = /
	MOVE 	T1,.CPPGC	;GET CONI PAG
	PUSHJ	P,HWDPNT##	;TYPE IT
	PUSHJ	P,INLMES##
	ASCIZ/
DATAI PAG, = /
	MOVE	T1,.CPPGD	;GET DATAI PAG
	PUSHJ	P,HWDPNT##	;TYPE IT
IFN M.KL10,<
	PUSHJ	P,INLMES##
	ASCIZ/
AR ARX Data Word = /
	MOVE	T1,.CP7		;GET AC BLOCK 7 LOC 0
	PUSHJ	P,HWDPNT##	;TYPE IT
	PUSHJ	P,INLMES##
	ASCIZ/
IO Page Fail Word = /
	MOVE 	T1,.CP7+2	;GET AC BLOCK 7 LOC 2
	PUSHJ	P,HWDPNT##	;TYPE IT
	PUSHJ	P,INLMES##
	ASCIZ/

SBUS Diags:

CNTRLR FNC 0          FNC 1
/
	PUSHJ	P,TYPSBD	;TYPE SBDIAG INFORMATION
>;END IFN M.KL10
	PJRST	CRLF##		;END WITH CRLF AND RETURN
;ROUTINE TO TYPE THE SBDIAG FUNCTIONS AND VALUES ON THE CTY WHEN
;A CRASH OCCURS.

IFN M.KL10,<
TYPSBD::PUSH	P,P1		;SAVE P1
	PUSH	P,P2		;  AND P2
	MOVE	P1,.CPSBD	;GET -# BLOCKS,, OFFSET TO FIRST
	HRRZI	P2,.CPSBD(P1)	;POINT AT FIRST BLOCK
TYPSB1:	HLL	P2,0(P2)	;MAKE P2 BE AOBJN POINTER TO THIS BLOCK
	HRRZ	T1,0(P2)	;GET CONTROLLER LOGICAL ADDRESS
	PUSHJ	P,OCTPNT##	;PRINT IT
	HRRI	P2,1(P2)	;ADVANCE TO FIRST OF FUNCTION WORDS
TYPSB2:	PUSHJ	P,PRSPC##	;SEPARATE FIELDS WITH A SPACE
	MOVE	T1,0(P2)	;GET NEXT FUNCTION WORD
	PUSHJ	P,HWDPNT##	;TYPE IT
	AOBJN	P2,TYPSB2	;LOOP FOR ALL WORDS IN THIS BLOCK
	PUSHJ	P,CRLF##	;TYPE CRLF AT END OF LINE
	AOBJN	P1,TYPSB1	;LOOP FOR ALL BLOCKS
	POP	P,P2		;RESTORE P2
	POP	P,P1		;  AND P1
	POPJ	P,		;RETURN
>;END IFN M.KL10



;ROUTINE TO READ THE CPU AND DEVICE STATUS BLOCKS.
;CALL:	PUSHJ	P,RCDSTB
;	RETURN

RCDSTB::PUSHJ	P,CPUSTS	;READ CPU STATUS BLOCK
	PUSHJ	P,DVCSTS	;READ DEVICE STATUS BLOCK
RCDSTD::PUSHJ	P,CSBELG	;DO CPU STATUS BLOCK ERROR LOGGING
	PUSHJ	P,DVLELG	;DO DEVICE STATUS BLOCK ERROR LOGGING
	POPJ	P,		;RETURN
;CPU STATUS BLOCK ERROR LOGGING
CSBELG:	MOVEI	T1,.CPCSL	;GET LENGTH OF CPU SUBTABLE
	PUSHJ	P,ALCSEB##	;ALLOCATE A SYSTEM ERROR BLOCK
	  POPJ	P,		;NO CORE
	XMOVEI	T2,STBTBL	;POINT TO TRANSFER TABLE
	PUSHJ	P,XFRSEB##	;SET UP ERROR RECORD
	  JFCL			;??
	MOVSI	T2,.CPAPD	;WHERE THE DATA STARTS
	HRRI	T2,.EBHDR(T1)	;AND WHERE TO PUT IT
	BLT	T2,.EBHDR+.CPCSL-1(T1) ;FILL THE RECORD
IFN M.KL10,<
	MOVEI	T2,142		;RELATIVE OFFSET OF POINTER
	ADDM	T2,.EBHDR+142(T1) ;ADJUST
> ;END IFN M.KL10
	PJRST	QUESEB##	;QUEUE UP BLOCK FOR DAEMON

;TRANSFER TABLE FOR CPU STATUS BLOCK ERROR LOGGING
STBTBL:	SEBTBL	(.ERCSB,STBEND,EX.SYE)
STBEND:				;END OF TABLE



;DEVICE STATUS BLOCK ERROR LOGGING
DVLELG:	MOVEI	T1,<.CPDVL*2>+2	;GET LENGTH OF DEVICE SUBTABLE
	PUSHJ	P,ALCSEB##	;ALLOCATE A SYSTEM ERROR BLOCK
	  POPJ	P,		;NO CORE
	XMOVEI	T2,DTBTBL	;POINT TO TRANSFER TABLE
	PUSHJ	P,XFRSEB##	;SET UP ERROR RECORD
	  JFCL			;??
	MOVSI	T2,DVSXCT	;START OF I/O INSTRUCTIONS
	HRRI	T2,.EBHDR+2(T1)	;WHERE TO PUT THEM
	MOVEI	T3,.EBHDR+2+.CPDVL(T1) ;COMPUTE END OF STORAGE
	BLT	T2,-1(T3)	;COPY THEM
	MOVSI	T2,.CPDVS	;WHERE THE RESULTING VALUES LIVE
	HRRI	T2,.EBHDR+2+.CPDVL(T1) ;WHERE TO PUT THEM
	ADDI	T3,.CPDVL	;COMPUTE END OF STORAGE
	BLT	T2,-1(T3)	;COPY
	PJRST	QUESEB##	;QUEUE UP BLOCK FOR DAEMON

;TRANSFER TABLE FOR DEVICE STATUS BLOCK ERROR LOGGING
DTBTBL:	SEBTBL	(.ERDSB,DTBEND,EX.SYE)
	MOVE	[-.CPDVL,,2]	;(R00) OFFSET TO I/O INSTRUCTIONS
	MOVE	[-.CPDVL,,2+.CPDVL] ;(R01) OFFSET TO RESULTING VALUES
DTBEND:				;END OF TABLE
SUBTTL STOP PROCEDURE WHEN SHUTTING DOWN SYSTEM
;TRANSFER HERE ON 404, 405, 406, OR 407 START OR LOCATION 30 BEING
;SET NON-ZERO.
;PROCEDURE TO SAVE CRASHED MONITOR ON DISK FOR LATER DEBUGGING UNDER
;TIMESHARING.  OPERATOR SHOULD:
;	1. TRY TO FORCE THE SYSTEM TO TAKE A DUMP BY CAUSING LOCATION
;	   30 TO BE SET NON-ZERO.  THIS CAN BE DONE FROM THE KEYS ON
;	   A KI10 OR THROUGH COMMANDS TO THE FRONT-END ON KL10 OR KS10
;	   SYSTEMS.
;	2. IF THIS DOESN'T WORK, TRY STARTING THE MACHINE AT 406 OR
;	   407 (FOR SINGLE CPU SYSTEMS).  THIS SHOULD GET US HERE.
;	3. IF ALL ELSE FAILS, LOAD BOOT WITH READ-IN OR VIA THE
;	   FRONT-END.  THIS HAS THE DISADVANTAGE THAT SOME MACHINE
;	   STATE, THE AC SETS, ETC. ARE LOST.

;HERE ON A 405 START TO SAVE THE MACHINE STATE AND JUMP INTO THE AC'S
STPCPU:	DMOVEM	P1,RBTSVA	;SAVE P1,P2 IN A VERY TEMPORARY PLACE
	JSP	P1,PAGENB	;MAKE SURE PAGING IS ON
	MOVEI	P1,SR.DIE	;SET BIT TO FORCE CPNSER TO LOOP
	IORB	P1,.CPSBR	; IN THE AC'S UNTIL EXPLICITLY RESTARTED
	JRST	SYSTO1		;JOIN COMMON CODE

;HERE ON A 404 START TO SET 30 TO -1 TO FORCE ALL OTHER CPU'S INTO
;THEIR AC'S
STPALL:	SETOM	CRSHWD		;FORCE ALL OTHER CPU'S INTO THE AC'S

;HERE ON A 406 START TO GET TO MONBTS ON THIS CPU REGARDLESS OF WHO
;THE BOOT CPU IS.
STPLDB:	DMOVEM	P1,RBTSVA	;SAVE P1,P2 IN A VERY TEMPORARY PLACE
	JSP	P1,PAGENB	;MAKE SURE PAGING IS ON
	MOVEI	P1,SR.LBH	;SET BIT TO GET TO MONBTS ON THIS CPU
	IORB	P1,.CPSBR	; REGARDLESS OF WHO THE BOOT CPU IS
	JRST	SYSTO1		;JOIN COMMON CODE

;HERE ON A 407 START OR 30 NON-ZERO AT APR INTERRUPT LEVEL
SYSTOP::DMOVEM	P1,RBTSVA	;SAVE P1, P2 IN A VERY TEMPORARY AREA
	JSP	P1,PAGENB	;MAKE SURE PAGING IS TURNED ON
	MOVE	P1,.CPSBR	;GET STATUS BITS
SYSTO1:	TRNE	P1,SR.ACL	;THIS CPU LOOPING IN THE AC'S?
	JRST	[DMOVE	P1,RBTSVA ;YES, AC'S SAVED BY AC LOOP SETUP
		 JRST SYSTO2]	;SO DON'T SAVE THEM AGAIN
	DMOVE	P1,RBTSVA	;RESTORE P1 AND P2
	JSR	.CPSVA		;SAVE ALL AC SETS

SYSTO2:	MOVE	P,.CPEPD	;SETUP P TO ERRPDL
	MOVEI	P1,SR.STS	;BIT SET IF MACHINE STATE ALREADY SAVED
	TDNN	P1,.CPSBR	;ALREADY SAVE MACHINE STATE?
	SKIPGE	BOOTCP		;NO, MAP SETUP YET?
	CAIA			;NO, CAN'T READ DATA BLOCKS
	PUSHJ	P,RCDSTB	;READ CPU AND DEVICE STATUS BLOCKS
	IORM	P1,.CPSBR	;SET THE BIT FOR THE NEXT TIME


				;FALL INTO REBOOT
;HERE ON ANY CPU FROM DIE OR FALL INTO FROM ABOVE TO RELOAD THE MONITOR.
;IN MULTIPROCESSOR SYSTEMS, ALL BUT THE BOOT CPU ARE DISPATCHED TO
;CP1CRS IN CPNSER.  IT IS THE CALLERS RESPONSIBILITY TO SAVE ALL AC
;SETS (WITH .CPSVA) BEFORE GETTING HERE.

REBOOT::EXECAC
	MOVE	P1,BOOTCP	;SAVE CURRENT VALUE OF BOOTCP
	SETZM	BOOTCP		;CAUSE SYSTR1 TO NOT CHANGE SERIAL, BOOTCP
	JSP	T4,SYSTR1	;TURN ON PAGING FOR THIS CPU
	  JFCL			;IGNORE RETURN
	MOVEM	P1,BOOTCP	;RESTORE BOOTCP
	MOVEM	P3,@.CPSPT	;RESTORE FROM VALUE SYSTR1 SAVE FOR US
IFN M.KL10,<
	DATAO	DLB,[0]
	DATAO	DLB2,[0]
>
IFN M.KL10,<
	CONO	PI,PI.OFF	;TURN OFF PI
	SWPUA			;SWEEP CACHE
	CONSZ	APR,LP.CSB	;WAIT UNTIL DONE
	JRST	.-1		; ..
	CONI	PAG,T1		;GET PAGING STATE
	TRZ	T1,LG.CSL!LG.CSW ;TURN OFF, LOOK AND LOAD
	CONO	PAG,(T1)	;MAINTAIN PAGING BUT WITHOUT CACHE
	JSP	T4,ZAPICH	;FIX UP INTERNAL CHANNELS
>
IFN M.KS10,<
	CONO	PI,PI.OFF	;TURN OFF PI
	WRUBR	NULDOP		;SWEEP CACHE
>
	CONO	APR,APRRST	;RESET SYSTEM
	CONO	PI,CLRPIS	;WIPEOUT PI-SYSTEM

IFN FTMP,<
IFG <M.CPU-1>,<
	MOVEI	T1,SR.LBH	;DO WE WANT TO GET TO MONBTS ON THIS
	TDNE	T1,.CPSBR	;  CPU REGARDLESS OF WHO THE BOOT CPU IS?
	JRST	REBOO1		;YES, SKIP THE REST OF THE CHECKS
	SKIPL	BOOTCP		;MAP SETUP YET?
	SKPCPU(1)		;YES, ON ANY BUT THE BOOT CPU?
	CAIA			;NO, LOAD BOOTS AND RELOAD
	PJRST	CP1CRS##	;GO TO CPNSER AND LOOP IN THE AC'S
REBOO1:>>

;CALL TO METINI REMOVED SO METER POINTS WILL BE PRESERVED IN
;THE CRASH DUMP--THIS REQUIRES THAT NONE OF THE ROUTINES
;CALLED BELOW (E.G. GETZ) SHOULD CONTAIN METER POINTS.
	MOVE	P,.CPEPD	;SETUP P TO SPARE AREA
	MOVE	T1,[<PM.DCD>B2+PM.WRT+NUPMPP]
;*********
	MOVEM	T1,NLUPMP+.UMUPT
	MOVE	T1,LOCYER	;GET YEAR
	SUBI	T1,^D1970	;SUBTRACT BASE
	JUMPL	T1,RLDMON##	;DON'T STORE IF BAD
	LSH	T1,5		;SHIFT OVER
	IOR	T1,LOCDAY	;ADD IN DAY
	LSH	T1,4		;AND
	IOR	T1,LOCMON	;MONTH
	HRLZM	T1,CRSDTM	;SAVE FOR ONCE AFTER RELOAD
	MOVE	T2,TIME		;GET TIME IN JIFFIES
	IDIV	T2,TICSEC	;CONVERT TO SECONDS TO FIT
	ADDI	T2,RLDTIM
	HRRM	T2,CRSDTM	;SAVE FOR ONCE AFTER RELOAD
	ADD	T1,T2		;ADD DATE AND TIME TOGETHER
	HLRZ	T2,CRSWHY	;GET LEFT THREE CHARACTERS OF STOPCODE NAME
	ADD	T1,T2		;PLUS STOPCD NAME
	HRRZ	T2,STATES	;GET SCHED SETTING
	HRRM	T2,CRSSTS	;SAVE FOR RELOAD
	ADD	T1,T2		;AND ADD INTO CHECKSUM
	ADDI	T1,507601	;ADD IN THE MAGIC CONSTANT
	HRRZM	T1,CRSCHK	;SAVE CHECKSUM FOR ONCE AFTER
				; RELOAD SO IT CAN DEFEND AGAINST
				; JUNK OR NON-MONITOR PREDECESSORS.
	PJRST	RLDMON##	;GO RELOAD MONITOR
	SUBTTL	FATAL SYSTEM HALT

;THE STOPCODE MACRO DISPATCHES HERE FOR "HALT" TYPE STOPCODES.  ONLY
;ESSENTIAL HALT ACTIONS SHOULD BE TAKEN BEFORE EXECUTING THE HALT
;INSTRUCTION AT THE END OF THIS ROUTINE.

DOHALT::EXP	0,0		;XPCW HERE
	EXP	IC.UOU,.+1
	MOVEM	17,.CPCAC+17	;SAVE AC 17
	MOVEI	17,.CPCAC	;SET UP BLT
	BLT	17,.CPCAC+16	;SAVE ACS 0-16
IFN FTKL10,<JSP	T4,ZAPICH>	;ZAP INTERNAL CHANNELS


;HERE TO FORCE A RELOAD BY THE FRONT END
DOLOAD::
IFN FTKL10,<PUSHJ  P,LOAD10##>	;TELL MASTER-11 TO RELOAD US
IFN FTKS10,<
	MOVSI	T1,(KSRLD)	;RELOAD REQUEST BIT
	IORM	T1,RLWORD	;SET IT FOR THE 8080
	WRAPR	SP.SSF+SP.IFE	;BANG ON THE 8080'S BELL (POINTLESS TRADITION)
> ;END IFN FTKS10
	HALT	.		;TERMINATE THIS NONSENSE
IFN FTKL10,<
;SUBROUTINE TO GET THE INTERNAL CHANNELS BACK INTO A KNOWN STATE
;FOR RH20'S DOES A MASSBUS INIT, THEN STOPS RH20 AND CLEARS DONE
;FOR IPA'S (NIA-20 OR CI-20) DOES A PORT CLEAR

ZAPICH::MOVEI	T1,FSTICD/4	;GET FIRST INTERNAL CHANNEL NUMBER
ZPICH1:	MOVE	T2,[CONI FSTICD,T3] ;GET CONI INSTRUCTION
	DPB	T1,[POINT 7,T2,9] ;MAKE IT SPECIFIC TO THIS CHANNEL
	XCT	T2		;READ CONI
	JUMPE	T3,ZPICH3	;JUMP IF NOTHING OUT THERE
	MOVE	T2,[CONO FSTICD,(T3)] ;GET CONO INSTRUCTION
	DPB	T1,[POINT 7,T2,9] ;MAKE IT SPECIFIC TO THIS CHANNEL
	.CREF	CI.PPT		;BIT WE'RE TESTING
	JUMPL	T3,ZPICH2	;IF SIGN BIT SET THIS IS A KLNI OR KLIPA
	MOVEI	T3,CO.MBI	;MASSBUS INIT
	XCT	T2
	MOVEI	T3,CO.STP	;STOP
	XCT	T2
	MOVEI	T3,CO.CCD	;CLEAR DONE
	XCT	T2
	JRST	ZPICH3		;SKIP IPA STUFF

ZPICH2:	MOVEI	T3,CO.CPT	;CLEAR PORT
	XCT	T2
ZPICH3:	CAIGE	T1,LSTICD/4
	AOJA	T1,ZPICH1	;LOOP FOR ALL INTERNAL CHANNELS
	JRSTF	@T4		;RETURN
>
;SUBROUTINE TO INSURE THAT PAGING IS ON WHEN WE COME THROUGH
;SYSTOP.
;CALL:	JSP	P1,PAGENB
;	RETURN HERE ALWAYS

PAGENB:	DMOVEM	T1,RBTSVA+2	;SAVE AC'S WHICH WILL BE
	DMOVEM	T3,RBTSVA+4	; DESTROYED BY SYSTR1
IFN FTKL10,<
	CONI	PAG,T1		;GET CURRENT MAPPING
	TRNE	T1,LG.TEN	;PAGING ALREADY ON?
>
IFN FTKS10,<
	RDEBR	T1		;GET CURRENT MAPPING
	TRNE	T1,SG.TEN	;PAGING ALREADY ON?
>
	JRST	PAGEN1		;YES, DON'T ALTER CURRENT STATE
	MOVE	P2,BOOTCP	;GET CURRENT VALUE OF BOOTCP
	SETZM	BOOTCP		;MAKE SURE SYSTR1 WILL NOT CHANGE SERIAL, BOOTCP
	JSP	T4,SYSTR1	;TURN ON PAGING FOR THIS CPU
	  JFCL			;IGNORE RETURN
	MOVEM	P2,BOOTCP	;RESTORE BOOTCP
PAGEN1:	DMOVE	T1,RBTSVA+2	;RESTORE T1,T2
	DMOVE	T3,RBTSVA+4	; AND T3,T4
	JRSTF	@P1		;RETURN

RBTSVA:	BLOCK	6		;STORE P1-P2 AND T1-T4 HERE
ARFLAG::-5			;TESTED TO SEE IF AUTO RELOAD NEEDED
				; COUNTED UP ONE EVERY 60 SEC.

BTXLEN==:^D16			;MAX LENGTH OF BOOTXT
BTXMXL==:<BTXLEN-1>B26		;MAXIMUM FOR GETTAB
;THIS BLOCK MAY BE OVERWRITTEN BY ONCE
ZZ1==.
	ASCIZ	"/D SYSTEM.EXE[1,4] "

	BLOCK	ZZ1+BTXLEN-.
ZZZ==.-1
IFN	<ZZ1&-PAGSIZ-ZZZ&-PAGSIZ>,<
	LOC	ZZZ&-PAGSIZ
BOOTXT::
	ASCIZ	"/D SYSTEM.EXE[1,4] "

	BLOCK	BOOTXT+BTXLEN-.
>
IFE	<ZZ1&-PAGSIZ-ZZZ&-PAGSIZ>,<BOOTXT==:ZZ1>

	$ABS
	LIT		;FORCE INITIALIZATION AND READ BOOTS LITERALS
			; INTO THE LOW SEGMENT
SUBTTL	COMMON SUBROUTINES


; SET UP AN INSTUCTION TO ENTER DDT VIA THE UNSOLICITED BREAKPOINT.
; THE CDBS ARE INITIALLY BUILT WITH .CPDDT CONTAINING A NOOP.  THE
; NOOP MUST BE A TRN.  THIS ALLOWS ANY ROUTINE TO DETERMINE IF IT'S
; CPU MAY ENTER EDDT BY DOING A SKIPL .CPDDT (TRN HAS THE SIGN BIT ON).
;
; DEBUGF CONTAINS A MASK OF THE CPUS WHICH MAY ENTER EDDT VIA THE
; UNSOLICITED BREAKPOINT.  INITIALLY, THIS MASK IS SET TO ALLOW
; BREAKPOINTS ON ALL CPUS, BUT MAY BE CHANGED AT ANY TIME.
;
	$HIGH

CPUDDT::MOVE	T1,DEBUGF	;GET DEBUGGING FLAGS
	ANDI	T1,DF.BPT	;KEEP JUST THE CPU BREAKPOINT MASK
	MOVE	T2,T1		;COPY MASK
	XOR	T1,BPTMSK	;COMPARE
	JUMPE	T1,CPOPJ	;RETURN IF NO CHANGE
	MOVEM	T2,BPTMSK	;SAVE NEW MASK
	MOVEI	T1,.C0CDB	;POINT TO START OF CDB CHAIN

CPUDD1:	MOVEI	T3,DF.BP0	;GET BIT FOR CPU0
	MOVN	T4,.CPCPN-.CPCDB(T1) ;GET A CPU NUMBER
	LSH	T3,(T4)		;SHIFT TO FIND THIS CPU'S BIT IN MASK
	TDNE	T3,DEBUGF	;WANT TO ALLOW BREAKPOINTS ON THIS CPU?
	SKIPA	T2,BPTXCT	;YES--GET INSTRUCTION TO ENTER DDT
	MOVE	T2,[BPTNOP]	;NO--GET SPECIAL NOOP
	MOVEM	T2,.CPDDT-.CPCDB(T1) ;SAVE INSTRUCTION
	HLRZ	T1,.CPCDB-.CPCDB(T1) ;GET ADDRESS OF NEXT CDB
	JUMPN	T1,CPUDD1	;LOOP FOR ALL CPUS
	POPJ	P,		;RETURN

BPTXCT::JSR	$0BPT##		;INSTRUCTION TO ENTER DDT
BPTNOP==<TRN	0,0>		;NOOP

	$ABS
BPTMSK::EXP	-1		;MASK OF OLD CPU BREAKPOINT BITS
	$HIGH
SUBTTL	COMMON SUBROUTINES - EXTENDED ADDRESSING

IFN FTXMON,<

	$CSUB			;MUST BE ADDRESSABLE BY ALL CODE SEGMENTS

;COROUTINE TO SAVE AND RESTORE THE CALLER'S PC SECTION NUMBER AND
; CALL THE CALLER AS A COROUTINE IN SECTION 1.
;CALLING SEQUENCE:
;	PUSHJ	P,SSEC1
;	ALWAYS RETURNS HERE IN SECTION 1
;RESTORES PC SECTION ON RETURN

SSEC1::	PUSH	P,T1		;SAVE A TEMP
	XMOVEI	T1,.		;CURRENT SECTION
	TLNE	T1,MXSECN	;ARE WE ALREADY EXTENDED?
	JRST	TPOPJ		;YES, GO HOME
	HRRZS	-2(P)		;MAKE CALLER RETURN TO SECTION 0
	MOVSI	T1,(MCSEC1)	;A SECTION 1 PC
	HLLM	T1,-1(P)	; FOR OUR POPJ
	XJRST	[MCSEC1+TPOPJ]	;ENTER SECTION 1 AND RETURN

;COROUTINE TO SAVE AND RESTORE THE CALLER'S PC SECTION NUMBER AND
; CALL THE SUBROUTINE SPECIFIED IN THE ARGUMENT LIST IN THE SECTION
; SPECIFIED IN THE ARGUMENT LIST
;CALLING SEQUENCE:
;	XCT	[PUSHJ P,SENCAL
;		 SN,,ADDR]	;CALL SUBROUTINE AT ADDR IN SECTION SN
;	RETURNS AS SUBROUTINE RETURNS
;RESTORES CALLER'S PC SECTION ON RETURN

SENCAL::PUSH	P,T1		;SAVE A TEMP
	MOVE	T1,-1(P)	;CALLER'S PC
	TLNN	T1,MXSECN	;ADDRESS OF THE XCT, SKIP IF NOT IN SECTION 0
	HRRZS	T1,-1(P)	;ADDRESS OF THE XCT, ZERO SECTION NUMBER FOR RETURN
	HRRZ	T1,-1(T1)	;TARGET OF THE XCT
	MOVE	T1,1(T1)	;SN,,ADDR
	MOVEM	T1,1(P)		;SAVE FOR CALL
	TLNN	T1,MXSECN	;CALL TO SECTION 0?
	JRST	SSEC0C		;YES, DO REST OF SSEC0
	POP	P,T1		;NO, RESTORE T1
	XJRST	2(P)		;AND CALL THE SUBROUTINE IN SN SECTION
;COROUTINE TO SAVE AND RESTORE THE CALLER'S PC SECTION NUMBER AND
; CALL THE CALLER AS A COROUTINE IN SECTION 0
;CALLING SEQUENCE:
;	PUSHJ	P,SSEC0
;	ALWAYS RETURN HERE IN SECTION 0.
;RESTORES PC SECTION ON RETURN.

SSEC0::	EXCH	T1,(P)		;GET PC WE WERE CALLED AT
	TLZN	T1,MXSECN	;MAKE SURE IT IS AN EXTENDED PC
	JRST	[EXCH	T1,(P)	;RESTORE T1
		POPJ	P,]	;AND RETURN IN SECTION 0 (ROUTINE IS A NOOP).
SSEC0C:	PUSH	P,T1		;SAVE AS A SECTION 0 PC.
	HRRZI	T1,SSEC0E	;NOTE SECTION 0 PC.
	EXCH	T1,-1(P)	;RESTORE T1, LEAVE A RETURN PATH TO US.
	POPJ	P,		;"RETURN" TO CALLER.

;RETURN HERE IN SECTION 0 ON RETURN FROM ROUTINE WHICH CALLED SSEC0.
SSEC0E:	SKIPA			;RETURNED NON-SKIP, LEAVE EVERYTHING ALONE
	AOS	(P)		;SKIP RETURN, BUMP CALLERS PC
	EXCH	T1,(P)		;GET RETURN PC TO HIGHER LEVEL ROUTINE.
	TLZ	T1,-1-MXSECN	;WIPE FLAGS IN CASE SECTION 0 PC
	MOVEM	T1,1(P)		;SAVE AS PC PART OF XJRSTF DUO-WORD
	POP	P,T1		;RESTORE T1
	XJRST	2(P)		;RETURN IN PROPER SECTION
>; END IFN FTXMON
IFE FTXMON,<
SSEC0==:CPOPJ			;THESE ARE NO-OPS
SSEC1==:CPOPJ			; ON THE KS
>; END IFE FTXMON
SUBTTL COMMON SUBROUTINES - ERROR RECOVERY

	$HIGH

;ERROR RECOVERY - TRY TO START NULL JOB

NULJB1::SETZB	J,.CPJOB	;ZERO J AND JOB NUMBER FOR NULJOB
	JRST	NULJOB##	;GO RESTORE NULL JOB
SUBTTL	COMMON SUBROUTINE RETURNS


	$CSUB			;MUST BE ADDRESSABLE BY ALL CODE SEGMENTS

CPOPJ2::AOS	(P)		;DOUBLE SKIP SUBROUTINE RETURN
RSKP::!				;FOR MACSYM USERS
CPOPJ1::AOSA	(P)		;SKIP SUBROUTINE RETURN
DPOPJ::	MOVEM	S,DEVIOS(F)	;DEPOSIT I/O STATUS WORD IN DDB
RTN::!
CPOPJ::	POPJ	P,

TTPOJ1::AOSA	-2(P)		;RESTORE T2, T1 SKIP RETURN
TPOPJ1::AOSA	-1(P)		;RESTORE T1 THEN SKIP RETURN
TTPOPJ::POP	P,T2
TPOPJ::	POP	P,T1		;RESTORE T1
	POPJ	P,		;AND RETURN

IPOPJ1::!			;DUPLICATE NAME
JPOPJ1::AOS	-1(P)		;SET FOR SKIP RETURN
IPOPJ::!			;DUPLICATE NAME
JPOPJ::	POP	P,J		;RESTORE J (USUALLY JOB OR HIGH SEG NUMBER)
	POPJ	P,

T2POJ1::AOS	-1(P)
T2POPJ::POP	P,T2		;RESTORE T2
	POPJ	P,

MPOPJ1::AOS	-1(P)
MPOPJ::	POP	P,M
	POPJ	P,

WPOPJX::CAIA			;NETSER PUSHES THIS ADDR ON THE STACK THEN
WPOPJ1::AOS	-1(P)		; EVENTUALLY DOES A CPOPJ1 RETURN
WPOPJ::	POP	P,W
	POPJ	P,

T3POJ1::AOS	-1(P)
T3POPJ::POP	P,T3
	POPJ	P,

P3POPJ::POP	P,P3
	POPJ	P,
FUPOJ1::POP	P,F
LPOPJ1::!
UPOPJ1::AOSA	-1(P)		;SKIP AND RESTORE LINE
FUPOPJ::POP	P,F
LPOPJ::!
UPOPJ::	POP	P,U		;RESTORE LINE AND RETURN
	POPJ	P,		;RETURN

FPOPJ1::AOS	-1(P)
FPOPJ::	POP	P,F		;RESTORE F
	POPJ	P,		;RETURN

ZPOPJ::	TDZA	T1,T1
M1POPJ::SETOM	T1
	POPJ	P,
;GENERATE AND/OR STORE UUO ERROR CODES
	ERCALC(ECDMAX)
	ERCALX(ECDMAX)
	$ABS
SUBTTL	COMMON SUBROUTINES - SAVE AC SETS


;ROUTINE TO SAVE ALL AC SETS IN .CPCAC AND .CPCAn.  RETURNS WITH
;NO AC'S IN ANY SET CHANGED AND THE FOLLOWING LOCATIONS SETUP:
;
;	.CPCPG - ARGUMENT TO DATAO PAG, TO RESTORE CURRENT AC SET
;	.CPACA - ADDRESS OF SAVED VALUES FOR CURRENT AC SET.
;
;CALL:
;		JSR	.CPSVA
;		RETURN HERE ALWAYS

SVSETS:	DATAI	PAG,.CPCPG	;SAVE CURRENT STATE OF AC BLOCKS
	SAVE	(1,.CPCA1)	;SAVE ALL AC SETS
	SAVE	(2,.CPCA2)	;...
	SAVE	(3,.CPCA3)	;...
	SAVE	(4,.CPCA4)	;...
	SAVE	(0,.CPCAC)	;AND LEAVE AC SET 0 AC THE CURRENT ONE
	LDB	17,[POINT 3,.CPCPG,8] ;GET NUMBER OF CURRENT AC SET
	JUMPN	17,SVSET1	;GO IF NOT AC SET 0
	MOVEI	17,.CPCAC	;AC SET 0 IS SAVED AT .CPCAC
	JRST	SVSET2		;CONTINUE
SVSET1:	IMULI	17,20		;COMPUTE OFFSET INTO .CPCA1 OF THIS SET
	ADDI	17,.CPCA1-20	;COMPUTE ADDRESS OF THIS SET
SVSET2:	MOVEM	17,.CPACA	;SAVE ADDRESS OF WHERE AC SET WAS SAVED
	MOVE	17,.CPCAC+17	;RESTORE AC 17 OF SET 0
	DATAO	PAG,.CPCPG	;RESTORE CURRENT AC SET
	JRSTF	@.CPSVA		;RETURN TO CALLER
	$ABS
	LIT
SUBTTL	COMMON SUBROUTINES - SAVE AND RESTORE PRESERVED ACS



;SUBROUTINES TO SAVE AND RESTORE PRESERVED ACS
;SAVEN IS CALLED AT THE BEGINNING OF A SUBROUTINE
;FOR CONVENIENCE NO MATCHING SUB IS NEEDED TO BE CALLED
;TO RESTORE THIS ACS.
;INSTEAD AN EXTRA RETURN IS PUT ON STACK
;5 CHAR NAME INDICATES IT VIOLATES
;SUBROUTINE CALLING CONVENTIONS
;CALL:	PUSHJ	P,SAVEN
;	RETURN	HERE IMMEDIATELY WITH EXTRA RETURN ON STACK
;	RESPECTS ALL ACS

;NOTE:	THIS CODE USES 1 LOC BEYOND END OF STACK BUT THEN PUSHES ON TOP OF IT
;SO GET OVERFLOW INTERUPT IF TOO FULL.  OK TO DO 1(P) SINCE THIS WORD WRITTEN ON OVERFLOW

	$CSUB			;MUST BE ADDRESSABLE BY ALL CODE SEGMENTS

SAVE1::	EXCH	P1,(P)		;SAVE P1, GET CALLER PC
	MOVEM	P1,1(P)		;SAVE CALLER PC ONE BEYOND END
	MOVE	P1,(P)		;RESTORE P1
	PUSHJ	P,@1(P)		;GO BACK TO CALLER, OVERWRITE CALLER PC WITH .+1
	  JRST	RES1
	AOS	-1(P)
	JRST	RES1

SAVE2::	EXCH	P1,(P)		;SAVE P1, GET CALLER PC
	PUSH	P,P2
	MOVEM	P1,1(P)		;SAVE CALLER PC ONE BEYOND END
	MOVE	P1,-1(P)	;RESTORE P1
	PUSHJ	P,@1(P)		;GO BACK TO CALLER, OVERWRITE CALLER PC WITH .+1
	  JRST	RES2
	AOS	-2(P)
	JRST	RES2

SAVE3::	EXCH	P1,(P)		;SAVE P1, GET CALLER PC
	PUSH	P,P2
	PUSH	P,P3
	MOVEM	P1,1(P)		;SAVE CALLER PC ONE BEYOND END
	MOVE	P1,-2(P)	;RESTORE P1
	PUSHJ	P,@1(P)		;GO BACK TO CALLER, OVERWRITE CALLER PC WITH .+1
	  JRST	RES3
	AOS	-3(P)
	JRST	RES3
SAVE4::	EXCH	P1,(P)		;SAVE P1, GET CALLER PC
	PUSH	P,P2
	PUSH	P,P3
	PUSH	P,P4
	MOVEM	P1,1(P)		;SAVE CALLER PC ONE BEYOND END
	MOVE	P1,-3(P)	;RESTORE P1
	PUSHJ	P,@1(P)		;GO BACK TO CALLER, OVERWRITE CALLER PC WITH .+1
	  JRST	RES4
	AOS	-4(P)
RES4:	POP	P,P4
RES3:	POP	P,P3
RES2:	POP	P,P2
P1POPJ::
RES1:	POP	P,P1
	POPJ	P,

;COROUTINE TO SAVE AND RESTORE P2

SAVP2::	EXCH	P2,(P)		;SAVE P2, GET CALLER PC
	MOVEM	P2,1(P)		;SAVE CALLER PC ONE BEYOND END
	MOVE	P2,(P)		;RESTORE P2
	PUSHJ	P,@1(P)		;CALL OUR CALLER, OVERWRITE CALLER PC WITH .+1
	  SKIPA			;PROPOGATE SKIP/NON-SKIP RETURN
	AOS	-1(P)		;...
P2POPJ::POP	P,P2		;RESTORE P2
	POPJ	P,		;AND RETURN

;COROUTINE TO SAVE AND RESTORE P3

SAVP3::	EXCH	P3,(P)		;SAVE P3, GET CALLER PC
	MOVEM	P3,1(P)		;SAVE CALLER PC ONE BEYOND END
	MOVE	P3,(P)		;RESTORE P3
	PUSHJ	P,@1(P)		;CALL OUR CALLER, OVERWRITE CALLER PC WITH .+1
	  SKIPA			;PROPOGATE SKIP/NON-SKIP RETURN
	AOS	-1(P)		;...
	POP	P,P3		;RESTORE P3
	POPJ	P,		;AND RETURN

;COROUTINE TO SAVE AND RESTORE P4

SAVP4::	EXCH	P4,(P)		;SAVE P4, GET CALLER PC
	MOVEM	P4,1(P)		;SAVE CALLER PC ONE BEYOND END
	MOVE	P4,(P)		;GET BACK P4
	PUSHJ	P,@1(P)		;GO BACK TO CALLER, OVERWRITE CALLER PC WITH .+1
	 JRST	P4POPJ		;NON-SKIP RETURN
P4PPJ1:	AOS	-1(P)		;INCREMENT RETURN PC
P4POPJ::POP	P,P4		;RESTORE OLD VALUE OF P4
	POPJ	P,
;SUBROUTINE TO SAVE AND RESTORE TEMP ACS
;CALLED BY PUSHJ P,SAVT   RETURN EITHER CPOPJ OR CPOPJ1 WHEN THROUGH

SAVT::	EXCH	T4,(P)		;SAVE T4, GET RETURN ADR.
	PUSH	P,T3		;SAVE T3
	PUSH	P,T2		;AND T2
	PUSH	P,T1		;AND T1
	MOVEM	T4,1(P)		;STORE PC
	MOVE	T4,-3(P)	;RESTORE T4
	PUSHJ	P,@1(P)		;RETURN TO CALLER
	  SKIPA			;POPJ RETURN
	AOS	-4(P)		;CPOPJ1 - SET SKIP RETURN
	POP	P,T1		;RESTORE T1
	POP	P,T2		;RESTORE T3 ACS
	POP	P,T3
T4POPJ::POP	P,T4
	POPJ	P,		;AND RETURN

;SUBROUTINE TO SAVE AND RESTORE AC'S J AND W
SAVJW::	EXCH	J,(P)		;SAVE J AND GET THE RETURN
	PUSH	P,W		;SAVE W
	MOVEM	J,1(P)		;SAVE THE RETURN
	MOVE	J,-1(P)		;RESTORE J
	PUSHJ	P,@1(P)		;RETURN
	  SKIPA			;SKIP RETURN NO
	AOS	-2(P)		;SKIP RETURN YES
	POP	P,W		;RESTORE W
	PJRST	JPOPJ		;RESTORE J AND EXIT

;SUBROUTINE TO SAVE U.
SAVU::	EXCH	U,(P)		;SAVE U AND GET THE RETURN
	MOVEM	U,1(P)		;SAVE THE RETURN TO CALLER
	MOVE	U,(P)		;RESET CALLER'S VALUE OF U
	PUSHJ	P,@1(P)		;CO-RETURN
	  JRST	UPOPJ		;NON-SKIP, RESTORE U
	JRST	UPOPJ1		;SKIP & RESTORE U

;SUBROUTINE TO SAVE U,M, and W. USED MAINLY BY DECNET.
SAVUM::	EXCH	U,(P)		;SAVE U AND GET THE RETURN
	PUSH	P,M		;SAVE M
	PUSH	P,W		;SAVE W
	MOVEM	U,1(P)		;SAVE THE RETURN TO USER
	MOVE	U,-2(P)		;GET ORIGINAL VALUE OF U
	PUSHJ	P,@1(P)		;RETURN TO CALLING ROUTINE.
	 SKIPA			;NON-SKIP RETURN
	AOS	-3(P)		;SKIP RETURN, BUMP RETURN PC
	POP	P,W		;GET BACK VALUE OF W
	POP	P,M		;GET BACK VALUE OF M
	JRST	UPOPJ		;GET BACK VALUE OF U AND RETURN
;COROUTINE TO SAVE AND RESTORE R
SAVR::	EXCH	R,(P)		;SAVE R, GET CALLER PC
	MOVEM	R,1(P)		;SAVE CALLER PC ONE BEYOND END
	MOVE	R,(P)		;RESTORE R
	PUSHJ	P,@1(P)		;GO BACK TO CALLER, OVERWRITE CALLER PC WITH .+1
	  JRST	RPOPJ
RPOPJ1::AOS	-1(P)
RPOPJ::	POP	P,R
	POPJ	P,


;COROUTINE TO SAVE AND RESTORE W
SAVW::	EXCH	W,(P)		;SAVE W, GET CALLER PC
	MOVEM	W,1(P)		;SAVE CALLER PC ONE BEYOND END
	MOVE	W,(P)		;RESTORE W
	PUSHJ	P,@1(P)		;GO BACK TO CALLER, OVERWRITE CALLER PC WITH .+1
	  JRST	WPOPJ
	JRST	WPOPJ1
;TOPS-20 AC SAVE ROUTINES

	T20SYM			;SWITCH TO TOPS-20 AC NAMES

IFN FTSCA!FTENET,<

;SAVE Q1 - Q3
SAVQ::	ADJSP	P,3		;ADJUST STACK
	DMOVEM	Q1,-2(P)	;SAVE Q1 AND Q2
	MOVEM	Q3,0(P)		;SAVE Q3
	PUSHJ	P,@-3(P)	;CALL THE CALLER
	  SKIPA			;NON-SKIP RETURN
	AOS	-4(P)		;ADJUST RETURN PC
	DMOVE	Q1,-2(P)	;RESTORE Q1 AND Q2
	MOVE	Q3,0(P)		;RESTORE Q3
	ADJSP	P,-4		;ADJUST STACK
	POPJ	P,		;RETURN

;SAVE Q1
SAVQ1::	PUSH	P,Q1		;SAVE Q1
	PUSHJ	P,@-1(P)	;CALL THE CALLER
	  SKIPA			;NON-SKIP RETURN
	AOS	-2(P)		;ADJUST RETURN PC
	POP	P,Q1		;RESTORE Q1
	ADJSP	P,-1		;ADJUST STACK
	POPJ	P,		;RETURN

> ;END IFN FTSCA!FTENET
IFN FTSCA,<

;SAVE P1 - P6

SAVP::	ADJSP	P,6		;ADJUST STACK
	DMOVEM	P1,-5(P)	;SAVE P1 AND P2
	DMOVEM	P3,-3(P)	;SAVE P3 AND P4
	DMOVEM	P5,-1(P)	;SAVE P5 AND P6
	PUSHJ	P,@-6(P)	;CALL THE CALLER
	  SKIPA			;NON-SKIP RETURN
	AOS	-7(P)		;ADJUST RETURN PC
	DMOVE	P1,-5(P)	;RESTORE P1 AND P2
	DMOVE	P3,-3(P)	;RESTORE P3 AND P4
	DMOVE	P5,-1(P)	;RESTORE P5 AND P6
	ADJSP	P,-7		;ADJUST STACK
	POPJ	P,		;RETURN

;SAVE P1 - P6 AND Q1 - Q3

SAVPQ::	ADJSP	P,^D9		;ADJUST STACK
	DMOVEM	P1,-^D8(P)	;SAVE P1 AND P2
	DMOVEM	P3,-6(P)	;SAVE P3 AND P4
	DMOVEM	P5,-4(P)	;SAVE P5 AND P6
	DMOVEM	Q1,-2(P)	;SAVE Q1 AND Q2
	MOVEM	Q3,0(P)		;SAVE Q3
	PUSHJ	P,@-^D9(P)	;CALL THE CALLER
	  SKIPA			;NON-SKIP RETURN
	AOS	-^D10(P)	;ADJUST RETURN PC
	DMOVE	P1,-^D8(P)	;RESTORE P1 AND P2
	DMOVE	P3,-6(P)	;RESTORE P3 AND P4
	DMOVE	P5,-4(P)	;RESTORE P5 AND P6
	DMOVE	Q1,-2(P)	;RESTORE Q1 AND Q2
	MOVE	Q3,0(P)		;RESTORE Q3
	ADJSP	P,-^D10		;ADJUST STACK
	POPJ	P,		;RETURN

> ;END FTSCA
SUBTTL	COMMON SUBROUTINES - BLSUB SUPPORT

IFN FTSCA,<
;SUBROUTINE TO SUPPORT BLSUB.  USES .A16 AS A TRASH AC,
; AND .FP AS A FRAME POINTER.

.ENTER::PUSH	P,.FP		;SAVE THE OLD FRAME POINTER
	MOVE	.FP,P		;MAKE A NEW FRAME POINTER
	ADD	P,0(.A16)	;ALLOCATE LOCAL STORAGE
	JUMPGE	P,ENTOV		;JUMP IF OVERFLOW
ENTOV1:	PUSHJ	P,1(.A16)	;AND RETURN TO USER
	  SKIPA			;NON-SKIP RETURN
	AOS	-1(.FP)		;SKIP RETURN, BUMP RETURN PC
	MOVE	P,.FP		;RESTORE OLD STACK POINTER
	POP	P,.FP		;RESTORE SAVED FRAME POINTER
	MOVN	.A16,-1(P)	;GET -<N,,N>
	HRRZM	.A16,-1(P)	;STORE 0,,-N
	POP	P,.A16		;RECOVER RETURN ADDRESS
	ADJSP	P,@0(P)		;CLEAN UP THE STACK
	JRST	0(.A16)		;RETURN

ENTOV:	MOVE	P,.FP		;STACK OVERFLOW, UNDO ADD
	PUSH	P,.A16		;SAVE LOCAL RETURN IN 1(.FP)
	HRRZ	.A16,0(.A16)	;GET COUNT
	ADJSP	P,-1(.A16)	;ALLOCATE SPACE, GET TRAP HERE OR ON PUSH
	MOVE	.A16,1(.FP)	;RESTORE LOCAL RETURN
	JRST	ENTOV1		;CHARGE AHEAD
> ;END IFN FTSCA
SUBTTL	COMMON SUBROUTINES - TRVAR/STKVAR

;SUBROUTINE TO HANDLE "TRVAR". USES .A16 AS A TRASH AC,
; AND .FP AS A FRAME POINTER.

	T20SYM

.XTRST::
.TRSET::PUSH	P,.FP		;SAVE THE OLD FRAME POINTER
	MOVE	.FP,P		;MAKE A NEW FRAME POINTER
	ADJSP	P,@(CX)		;ALLOCATE SIZE OFF OF STACK
	PUSHJ	P,1(CX)		;AND RETURN TO USER
.TRRET:	 TRNA			;NON SKIP RETURN.
	 AOS	-1(.FP)		;SKIP RETURN, BUMP RETURN PC
	MOVE	P,.FP		;RESTORE STACK POINTER TO OLD POINTER
	POP	P,.FP		;RESTORE OLD FRAME POINTER
	POPJ	P,		;AND RETURN

;SUBROUTINE TO HANDLE "STKVAR". USES R AS A TRASH AC

.XSTKS::
.STKST::ADJSP	P,@(CX)		;ADD SOME WORDS ONTO THE STACK
	PUSH	P,(CX)		;SAVE NUMBER OF WORDS ON STACK
	PUSHJ	P,1(CX)		;AND RETURN TO CALLER
.STKRT:	JRST	.STKVT		;NON SKIP RETURN
	MOVN	CX,(P)		;GET NEGATIVE WORDS SAVED
	ADJSP	P,-1(CX)	;RETURN THEM, INCLUDING COUNT WORD
	AOS	(P)		;SKIP RETURN
	POPJ	P,		;RETURN

.STKVT:	MOVN	CX,(P)		;GET NEGATIVE WORDS SAVED
	ADJSP	P,-1(CX)	;RETURN THEM
	POPJ	P,		;RETURN

	PURGEACS
	T10SYM
SUBTTL	COMMON SUBROUTINES - EXTENDED BLT

;Extended BLT routine. Used mostly by DECnet.
XBLTAT::
XBLTA::
IFN FTXMON,<
	EXTEND T1,[XBLT]	;COPY FROM LAST MSD TO NEW USER DATA
>;END IFN FTXMON
IFE FTXMON,<
	HRLZS T2		;SOURCE IN LEFT HALF
	HRRI T2,(T3)		;DESTINATION IN RIGHT HALF
	ADDI T3,(T1)		;LAST WORD BEYOND DESTINATION
	BLT T2,-1(T3)		;COPY THE WORDS
	SETZ T1,		;CLEAR NUMBER OF WORDS COPIED
	HLRZS	T2		;AND LEAVE LAST SOURCE WORD COPIED HERE
>;END IFE FTXMON
	POPJ P,			;RETURN (IMPORTANT!)

;PXCT'ED XBLT SIMULATORS.  FOR USE BY UUOS WHICH ALLOW GLOBAL ADDRESSES.
;USED ONLY WHEN FTXMON IS OFF.

IFE FTXMON,<
PBLTXU::HRLZS	T2		;SOURCE IN LEFT HALF
	HRRI	T2,(T3)		;DESTINATION IN RIGHT HALF
	ADDI	T3,(T1)		;LAST WORD BEYOND DESTINATION
	EXCTXU	<BLT T2,-1(T3)>	;DO THE APPROPRIATE FLAVOR OF PXCT
	SETZ	T1,		;CLEAR NUMBER OF WORDS COPIED
	HLRZS	T2		;AND LEAVE LAST SOURCE WORD COPIED HERE
	POPJ	P,		;RETURN TO CALLER

PBLTUX::HRLZS	T2		;SOURCE IN LEFT HALF
	HRRI	T2,(T3)		;DESTINATION IN RIGHT HALF
	ADDI	T3,(T1)		;LAST WORD BEYOND DESTINATION
	EXCTUX	<BLT T2,-1(T3)>	;DO THE APPROPRIATE FLAVOR OF PXCT
	SETZ	T1,		;CLEAR NUMBER OF WORDS COPIED
	HLRZS	T2		;AND LEAVE LAST SOURCE WORD COPIED HERE
	POPJ	P,		;RETURN TO CALLER
>;END IF IFE FTXMON
	SUBTTL	INTERLOCKING ROUTINES

	$CSUB

;THIS ROUTINE IMPLEMENTS A SYSTEM WIDE INTERLOCK. IT IS EXACTLY
; SYNONUMOUS TO TURNING THE PI SYSTEM OFF ON A SINGLE PROCESSOR SYSTEM
; EXCEPT IT DOES NOT ALLOW NESTING, I.E., A CALL TO UNLSPI MUST BE
; EXECUTED BEFORE LOKSPI CAN BE CALLED AGAIN.

LOKSPI::CONO	PI,PI.OFF	;NO PIS
	CONI	PI,.CPPIS	;READ CURRENT STATE OF CHANNEL ENABLES
	CONO	PI,PI.ON+SYSOFF	;TURN THE PI SYSTEM ON,
				; LEAVING OFF CHANNELS WHICH OBTAIN THE INTERLOCK
IFG <M.CPU-1>,<
LOKSP1:	SKIPGE	INTRLK		;DON'T TRY UNLESS ITS POSSIBLE TO GET IT (TIES UP MEMORY)
	AOSE	INTRLK		;INTERLOCK AVAILABLE?
	JRST	LOKSP1		;NO, WAIT UNTIL IT IS
	APRID	INTOLK		;SERIAL NUMBER OF OWNING CPU
>; END IFG <M.CPU-1>
	POPJ	P,		;RETURN WITH THE INTERLOCK

;THIS ROUTINE RETURNS THE SYSTEM WIDE INTERLOCK AND EXITS WITH THE PI
; SYSTEM TURNED OFF

UNLSPT::EXCH	T1,.CPPIS	;SAVE T1, GET STATE OF THE PI WHEN INTERLOCK WAS OBTAINED
	ANDI	T1,177		;ISOLATE CHANNEL ENABLES
	TRO	T1,PI.OFF	;EXIT WITH PI OFF
	JRST	UNLSP1		;JOIN COMMON CODE

;COMMON EXIT ROUTINE TO RETURN SYSTEM WIDE INTERLOCK AND POPJ

ONPOPJ::			;FALL INTO UNLSPI
;	SYSPIN
;	POPJ	P,

;ROUTINE TO GIVE UP THE SYSTEM WIDE INTERLOCK, RESTORE THE CHANNELS WHICH
; WERE ENABLED WHEN THE INTERLOCK WAS OBTAINED, AND EXIT WITH THE PI IN
; THE STATE IT WAS IN WHEN THE INTERLOCK WAS OBTAINED - ON IF ON/OFF IF OFF

UNLSPI::EXCH	T1,.CPPIS	;SAVE T1, GET STATE OF THE PI WHEN INTERLOCK WAS OBTAINED
	ANDI	T1,177		;ISOLATE CHANNEL ENABLES
UNLSP1:	TRO	T1,PI.TNP	;TURN ON SELECTED CHANNELS
	EXCH	T1,.CPPIS	;RESTORE T1, SET TO RESTORE PI SYSTEM
IFG <M.CPU-1>,<
	SETOM	INTOLK		;NO LONGER THE OWNER OF THE INTERLOCK
	SETOM	INTRLK		;RELINQUISH INTERLOCK
>; END IFG <M.CPU-1>
	CONO	PI,@.CPPIS	;RESTORE THE PI SYSTEM
	POPJ	P,		;AND RETURN
;ROUTINE TO INTERLOCK ON A DEVICE TO ENSURE THAT THE USER PROGRAM USING
; THE DEVICE IS NOT RUNNING AT UUO LEVEL ON ONE PROCESSOR "PIOFF" WHILE AN
; INTERRUPT FROM THE DEVICE IS BEING SERVICED ON ANOTHER PROCESSOR.
; THIS CAN NOT HAPPEN ON A SINGLE CPU BECAUSE OF CONO PI,PI.OFF.
; THE INTERLOCK IS ONLY BETWEEN UUO LEVEL AND THE INTERRUPT LEVEL WHICH
; THE DEVICE INTERRUPTS TO. THE INTERLOCK IS ONLY ON THE CHANNEL THAT THE DEVICE
; INTERRUPTS ON, I.E., IF A PROCESSOR IS WAITING AT AN INTERUPT LEVEL
; FOR AN INTERLOCK OWNED BY SOME OTHER PROCESSOR AT UUO LEVEL, INTERRUPTS
; AT HIGHER PI LEVELS ON THE WAITING PROCESSOR CAN STILL BE SERVICED.

LOKDPI::CONO	PI,PI.OFF	;TURN THE PI SYSTEM OFF
	CONI	PI,.CPDPI	;READ PI CHANNEL ENABLES
	CONO	PI,PI.ON+SYSOFF	;TURN PI ON WITH DEVICE CHANNELS OFF
IFG <M.CPU-1>,<
	PUSH	P,T1		;SAVE A TEMPORARY
	HRRZ	T1,DEVCPU(F)	;ADDRESS OF THIS DDB'S INTERLOCK WORD
LOKDP1:	SKIPGE	(T1)		;ONLY TRY IF ITS POSSIBLE TO GET IT
	AOSE	(T1)		;DDB INTERLOCK AVAILABLE?
	JRST	LOKDP1		;NO, WAIT FOR IT
	SUBI	T1,INTL0	;OFFSET INTO INTERLOCKS
	APRID	INTO0(T1)	;REMEMBER WHICH CPU OWNS THE INTERLOCK
	POP	P,T1		;RESTORE T1
>; END IFG <M.CPU-1>
	POPJ	P,		;RETURN

;COMMON EXIT ROUTINE TO RETURN DEVICE PI INTERLOCK
; AND RETURN WITH PI RESTORED

ONPOPD::			;FALL INTO UNLDPI
;	PION
;	POPJ	P,

;ROUTINE TO RETURN THE DEVICE INTERLOCK, MARK IT AS UNOWNED, AND
; RESTORE THE PI SYSTEM TO THE STATE IT WAS IN WHEN THE DEVICE WAS
; LOCKED

UNLDPI::PUSH	P,T1		;SAVE A WORKING AC
	MOVE	T1,.CPDPI	;CHANNEL ENABLES WHEN INTERLOCK WAS OBTAINED
	ANDI	T1,177		;ONLY CHANNEL ENABLES
	TRO	T1,PI.TNP	;TURN ON SELECTED CHANNELS
	MOVEM	T1,.CPDPI	;FOR CONO
IFG <M.CPU-1>,<
	HRRZ	T1,DEVCPU(F)	;ADDRESS OF THIS DDB'S INTERLOCK WORD
	SUBI	T1,INTL0	;OFFSET INTO INTERLOCK TABLES
	SETOM	INTO0(T1)	;AND INDICATE NO LONGER OWNED BY THIS CPU
	SETOM	INTL0(T1)	;RETURN THE DDB INTERLOCK
>; END IFG <M.CPU-1>
	CONO	PI,@.CPDPI	;RESTORE SELECTED PI CHANNELS
	JRST	TPOPJ		;RESTORE TEMPORARY AND RETURN
;THIS ROUTINE IMPLEMENTS AN INTERLOCK FOR BIT DIDDLERS (SETOS,CLRBTS).
; IT IS SIMILAR TO LOKSPI AND LOKDPI.

LOKBTI::CONO	PI,PI.OFF	;NO PIS
	CONI	PI,.CPBTI	;READ CURRENT STATE OF CHANNEL ENABLES
	CONO	PI,PI.ON+SYSOFF	;TURN THE PI SYSTEM ON
IFG <M.CPU-1>,<
LOKBT1:	SKIPGE	INTLBT		;DON'T TRY IF CAN'T POSSIBLY GET IT (TIES UP MEMORY)
	AOSE	INTLBT		;INTERLOCK AVAILABLE?
	JRST	LOKBT1		;NO, WAIT UNTIL IT IS
	APRID	INTOBT		;SERIAL NUMBER OF OWNING CPU
>; END IFG <M.CPU-1>
	POPJ	P,		;RETURN WITH THE INTERLOCK

;COMMON EXIT ROUTINE TO RETURN BIT DIDDLER INTERLOCK AND POPJ

ONPOPB::			;FALL INTO UNLBTI
;	BTSON
;	POPJ	P,

;ROUTINE TO GIVE UP THE BIT DIDDLER INTERLOCK AND RESTORE THE PI CHANNELS

UNLBTI::EXCH	T1,.CPBTI	;SAVE T1, GET STATE OF THE PI WHEN INTERLOCK WAS OBTAINED
	ANDI	T1,177		;ISOLATE CHANNEL ENABLES
	TRO	T1,PI.TNP	;TURN ON SELECTED CHANNELS
	EXCH	T1,.CPBTI	;RESTORE T1, SET TO RESTORE PI SYSTEM
IFG <M.CPU-1>,<
	SETOM	INTOBT		;NO LONGER THE OWNER OF THE INTERLOCK
	SETOM	INTLBT		;RELINQUISH INTERLOCK
>; END IFG <M.CPU-1>
	CONO	PI,@.CPBTI	;RESTORE THE PI SYSTEM
	POPJ	P,		;AND RETURN
;THIS ROUTINE IMPLEMENTS AN INTERLOCK FOR BUFFER MANAGEMENT.
; IT IS SIMILAR TO LOKSPI AND LOKDPI.

IFN M.KL10,<
LOKNBI::CONO	PI,PI.OFF	;NO PIS
	CONI	PI,.CPPIB	;READ CURRENT STATE OF CHANNEL ENABLES
	CONO	PI,PI.ON+SYSOFF	;TURN THE PI SYSTEM ON
IFG <M.CPU-1>,<
LOKNB1:	SKIPGE	INTLNB		;DON'T TRY IF NOT POSSIBLE TO GET IT
	AOSE	INTLNB		;INTERLOCK AVAILABLE?
	JRST	LOKNB1		;NO, WAIT UNTIL IT IS
	APRID	INTONB		;SERIAL NUMBER OF OWNING CPU
>; END IFG <M.CPU-1>
	POPJ	P,		;RETURN WITH THE INTERLOCK

;COMMON EXIT ROUTINE TO RETURN BUFFER MANAGEMENT INTERLOCK AND POPJ

ONPOPN::			;FALL INTO UNLNBI
;	NBFON
;	POPJ	P,

;ROUTINE TO GIVE UP THE BUFFER MANAGEMENT INTERLOCK AND RESTORE THE PI CHANNELS

UNLNBI::EXCH	T1,.CPPIB	;SAVE T1, GET STATE OF THE PI WHEN INTERLOCK WAS OBTAINED
	ANDI	T1,177		;ISOLATE CHANNEL ENABLES
	TRO	T1,PI.TNP	;TURN ON SELECTED CHANNELS
	EXCH	T1,.CPPIB	;RESTORE T1, SET TO RESTORE PI SYSTEM
IFG <M.CPU-1>,<
	SETOM	INTONB		;NO LONGER THE OWNER OF THE INTERLOCK
	SETOM	INTLNB		;RELINQUISH INTERLOCK
>; END IFG <M.CPU-1>
	CONO	PI,@.CPPIB	;RESTORE THE PI SYSTEM
	POPJ	P,		;AND RETURN
>; END IFN M.KL10
;ROUTINES TO INTERLOCK/RELEASE SCNSER'S DATA

LOKSCI::CONO	PI,PI.OFF	;NO PIS
	AOSE	.CPSIN		;BUMP LEVEL OF NESTING
	JRST	[SKIPGE	.CPDWD	;IN MIDDLE OF A STOPCODE?
		 STOPCD .,STOP,SCNRIA, ;++RECURSIVE INTERLOCK ATTEMPT
		 CONO PI,PI.ON	;JUST NESTING, RETURN, ALREADY HAVE INTERLOCK
		 POPJ P,]	;...
	CONI	PI,.CPSCI	;READ CURRENT STATE OF CHANNEL ENABLES
	CONO	PI,PI.ON+SCNPIF	;TURN THE PI SYSTEM ON
IFG <M.CPU-1>,<
LOCSC1:	SKIPGE	SCNLOK
	AOSE	SCNLOK
	JRST	LOCSC1
	APRID	INOSCN
>; END IFG <M.CPU-1>
	POPJ	P,

UNLSCI::PUSH	P,T1		;SAVE A REGISTER
	SOSL	T1,.CPSIN	;DECREMENT LEVEL OF NESTING, SEE IF DONE
	PJRST	TPOPJ		;STILL NESTING, JUST RETURN
	EXCH	T1,.CPSCI	;GET CHANNEL ENABLE STATES
	ANDI	T1,177		;KEEP JUST THE CHANNELS WHICH WERE ON
	TRO	T1,PI.TNP	;TURN THEM BACK ON
	EXCH	T1,.CPSCI	;RESTORE T1, SET TO RESTORE PI SYSTEM
IFG <M.CPU-1>,<
	SETOM	INOSCN
	EXCH	T1,SCNLOK	;RESET THE INTERLOCK
	SKIPGE	T1		;MAKE SURE IT WAS OWNED
	STOPCD	.,CPU,SCNIU,	;++ SCNSER INTERLOCK UNOWNED
>; END IFG <M.CPU-1>
	CONO	PI,@.CPSCI	;PUT THE PI SYSTEM BACK THE WAY IT WAS
	PJRST	TPOPJ		;RESTORE T1 AND RETURN


;ROUTINES TO INTERLOCK/RELEASE NETSER'S DATA

LOKNPI::CONO	PI,PI.OFF	;TURN PI SYSTEM OFF
	CONI	PI,.CPNTI	;SAVE CHANNEL ENABLE STATE
	CONO	PI,PI.ON+NETPIF	;TURN PI SYSTEM BACK ON, LEAVE NET CHANS OFF
IFG <M.CPU-1>,<
LOKNP1:	SKIPGE	NETLOK
	AOSE	NETLOK
	JRST	LOKNP1
	APRID	INONET
>; END IFG <M.CPU-1>
	POPJ	P,

UNLNPI::EXCH	T1,.CPNTI	;SAVE T1, GET CHANNEL ENABLE STATE
	ANDI	T1,177		;KEEP JUST CHANNELS
	TRO	T1,PI.TNP	;TURN THEM BACK ON
	EXCH	T1,.CPNTI	;RESTORE T1, SAVE CHANNEL ENABLE STATE
IFG <M.CPU-1>,<
	SETOM	INONET
	SETOM	NETLOK
>; END IFG <M.CPU-1>
	CONO	PI,@.CPNTI	;TURN THE CHANNELS BACK ON
	POPJ	P,

;ROUTINES TO INTERLOCK/RELEASE ETHSER'S DATA

IFN FTENET,<
LOKETH::AOSE	.CPETH		;BUMP NESTING INTERLOCK
	POPJ	P,		;STILL NESTING, RETURN
	CONO	PI,PI.OFF	;DISABLE INTERRUPTS
IFG <M.CPU-1>,<
LOKET1:	SKIPGE	ETHLOK		;INTERLOCK POSSIBLY AVAILABLE
	AOSE	ETHLOK		;YES, TRY FOR INTERLOCK
	JRST	LOKET1		;DIDN'T SUCCEED, LOOP
	APRID	INOETH		;RECORD INTERLOCK OWNER
>; END IFG <M.CPU-1>
	POPJ	P,		;AND RETURN

UNLETH::SOSL	.CPETH		;DECREMENT NESTING COUNT
	POPJ	P,		;STILL NESTED, RETURN
IFG <M.CPU-1>,<
	SETOM	INOETH		;...
	SETOM	ETHLOK		;RELEASE INTERLOCK
>; END IFG <M.CPU-1>
	CONO	PI,PI.ON	;RE-ENABLE INTERRUPTS
	POPJ	P,		;AND RETURN
>; END IFN FTENET
	SUBTTL	COMPUTE NUMBER OF WORDS DESCRIBED IN AN IOLIST

IFN M.KL10,<
;ROUTINE TO COMPUTE THE NUMBER OF WORDS DESCRIBED IN AN IOLIST
;ENTER WITH T1=ADDR OF THE INITIAL CONTROL WORD
; AND WITH P1=LOC OF CHANNEL DATA BLOCK
;EXIT WITH T1=NUMBER OF GOOD WORDS TRNSFERRED
; T2=CORRECTIVE DATA FOR IOWD
; T3= N,,LOC OF FAILING IOWD   WHERE N=0 IF RH10, N=-1 FOR RH20
WRDCNT::TDZA	T2,T2
WRDCNX::MOVSI	T2,200000
	PUSHJ	P,SAVE4		;SAVE P1,P2
	MOVEI	P3,-1		;SET UP MASK
	HLLZ	P2,T2		;ASSUME 22 BIT CHAN
	MOVE	T2,CHNTYP(P1)	;GET CHANNEL TYPE BITS
	TLNE	T2,CP.RH2	;RH20?
	HRROI	P2,2		;YES, SPECIAL STUFF
	ASH	P3,@ASH22B(P2)	;SHIFT MASK
	SETZ	P1,		;P1 WILL ACCUMULATE WRDCNT
	LDB	T3,CNTPT1(P2)	;L(IOWD)+1
	CAILE	T3,20		;IS IOWD LOC LEGAL?
	CAMLE	T3,SYSSIZ
	JRST	WRDCN5		;NO, WORD-COUNT=0
	LDB	T2,CNTPT2(P2)
	JUMPN	T2,WRDCN0
	MOVE	T3,T1		;YES, GET START OF LIST
WRDCNA:	LDB	T2,CNTPT3(P2)
	JUMPN	T2,WRDCNB
	SKIPN	(T3)
	JRST	WRDCNC
	MOVE	T3,(T3)		;YES, GET ITS ADDRESS
	JRST	WRDCNA		;  AND TEST IT
WRDCNB:	MOVE	T4,T3		;YES, SAVE LOC OF REAL IOWD IN T4
	AOJA	T3,WRDCNA	; AND TEST NEXT
WRDCNC:	AOS	T3,T4		;END - T3=L(LAST IOWD)+1
WRDCN0:	LDB	T4,ADRPT2(P2)
	LDB	T2,ADRPT1(P2)	;LOC+1 OF GOOD DATA WRD
	JUMPL	P2,[CAMLE T4,T2	;RH20 ADR IS 1 HIGHER
		    JRST WRDCN5	; SO EQUALS IS OK
		    MOVE P4,2(T1)  ;SAVE ENDING CHAN DATA FOR TEST
		    LDB T3,CNTPT2(P2)  ;WORDCOUNT
		    ADD T4,T3	;TOP ADDR +1 OF IOWD
		    JRST WRDCND]  ;CARRY ON
	CAML	T4,T2		;IS LAST DATA WRD IN BOUNDS?
	JRST	WRDCN5		;NO, ASSUME THAT IOWD IS NG
	HLRO	T3,-1(T3)	;MAYBE
	ASH	T3,@ASH22B(P2)	;WORD COUNT
	SUB	T4,T3		;LAST GOOD ADR IN IOWD+1
WRDCND:	CAMGE	T4,T2		;IS WORD IN BOUNDS?
	JRST	WRDCN5		;NO
	LDB	T1,ADRPT3(P2)

WRDCN1:	SKIPN	(T1)		;IS THERE AN IOWD?
	JRST	WRDCN5		;NO, THE DF10 LIED!
	JUMPL	P2,[CAMN P4,(T1) ;THIS IOWD WHAT THE RH20 STORED?
		    JRST WRDCNF	;YES. THE LAST IOWD IS LAST IT DID
		    LDB T4,[POINT 11,(T1),13]
		    MOVNS T4	;11 BITS OF NEGATIVE WDCNT
		    JRST WRDCNE]
	HLRO	T4,(T1)		;WDCNT OF IOWD
	ASH	T4,@ASH22B(P2)	;WORD COUNT
WRDCNE:	LDB	T3,ADRPT3(P2)	;1ST ADDR OF IOWD -1
	TRNN	T4,(P3)		;IF RH 14 BITS=0
	JRST	WRDCN3		; ITS A CHAN JUMP
	CAMG	T2,T3		;GOOD DATA WD IN THIS IOWD?
	JUMPN	T3,WRDCN2	;YES, COUNT THE DATA AND STEP TO NEXT
	SUB	T3,T4		;MAYBE. ADR OF TOP WD IN IOWD
	CAMG	T2,T3		;LAST GOOD DATA IN IOWD?
	JRST	WRDCN4		;YES
WRDCN2:	SUB	P1,T4		;THIS IOWD IS GOOD. COUNT # OF WDS
	HRLS	T1		;SAVE LOC OF GOOD IOWD
	AOJA	T1,WRDCN1	;AND GO TEST NEXT IOWD
WRDCN3:	JUMPE	T3,WRDCN5	;DF10 BLEW IT IF THIS THE END OF THE LIST
	MOVE	T1,T3		;CHAN JUMP - SET T1 TO ADR
	JRST	WRDCN1		;OF IOWD AND TEST IT


;HERE WITH T1=LOC OF FAILING IOWD,  P1=NO OF WDS IN PREVIOUS IOWDS
;T2=TERMINATION WORD, T3=ADDR+COUNT
;I.E. ON RH10 T3=<LAST WORD>, ON RH20 T3=<LAST WORD>+1
;IF THE ERROR IS IN THE MIDDLE OF AN IOWD,
;THE RH10 STORES <LAST WORD XFERED>+1 IN THE
;TERMINATION WORD. BUT IF THE ERROR IS IN THE LAST
;SECTOR OF THE LAST IOWD, THEN THE RH10 MERELY
;STORES <LAST WORD XFERED>
WRDCN4:	CAMN	T2,T3		;LAST SECTOR OF IOWD?
	TLNE	P2,600000	;AND RH10?
	CAIA			;NO, RH20 OR NOT LAST
	ADDI	T2,1		;YES, ADD FUDGE FACTOR
	LDB	T3,ADRPT3(P2)
	TLNN	P2,600000
	ADDI	T3,1
	SUB	T2,T3		;NO OF GOOD DATA WDS IN IOWD
	ADD	P1,T2		;P1=TOTAL GOOD WORDCOUNT
	JUMPE	P1,WRDCN6	;NO CORRECTION IF NO DATA
	CAIG	T2,1		;IF ONLY 1 WORD
	TRNE	P1,BLKSIZ##-1	;OR NOT AN EVEN MULTIPLE OF 200 WORDS
	JRST	WRDCN6		;NO CORRECTION DATA (CHANNEL BLEW IT)
	SUB	P1,T2		;NUMBER OF REMAINING WORDS
WRDCNF:	HLRZS	T3,T1		;ADDRESS OF IOWD
	LDB	T2,CNTPT3(P2)	;GET ORIGINAL COUNT OF THIS IOWD
	JUMPL	P2,WRDCN6	;GO IF RH20
	HLRO	T2,(T3)		;RH10, MUST GET +COUNT
	ASH	T2,@ASH22B(P2)
	MOVNS	T2
WRDCN6:	MOVEI	T3,T2		;T2 WILL GET THE ANSWER
	SKIPL	P2		;RH10?
	SKIPA	T4,T2		;YES, GET - COUNT
	MOVN	T4,T2		;NO, ALREADY HAVE -COUNT
	DPB	T4,CNTPT3(P2)	;SAVE LH CORRECTION DATA
	SKIPGE	T3,P2		;RH20?
	TLO	T2,700000	;YES, ALLOW FOR CARRY INTO BIT 2
	HRR	T3,T1		;RH OF CORRECTION DATA
	SKIPA	T1,P1		;TOTAL NO OF GOOD WORDS
WRDCN5:	SETZB	T1,T3		;WE LOSE, ZERO MEANINGFUL ACS
	POPJ	P,		;RETURN WITH ANSWER
;BYTE POINTERS INDEXED BY CHANNEL TYPE 0 = DF10C, 1 = DX10, 2 = RH20

ADRPT1::POINT	22,1(T1),35
	EXP	-1
	POINT	22,2(T1),35
ADRPT2::POINT	22,-1(T3),35
	EXP	-1
	POINT	22,-1(T3),35
ADRPT3:	POINT	22,(T1),35
	EXP	-1
	POINT	22,(T1),35
ADRPT4::POINT	14,T1,13
	EXP	-1
	POINT	14,T1,13
CNTPT1::POINT	14,1(T1),13
	EXP	-1
	POINT	22,1(T1),35
CNTPT2::POINT	14,-1(T3),13
	EXP	-1
	POINT	11,-1(T3),13
CNTPT3::POINT	14,(T3),13
	EXP	-1
	POINT	11,(T3),13

ASH22B::0,,-4
	0,,-4
	0,,-7

CNTFIL::XWD	-1,740000

MSK22B::XWD	17,-1

WDCPNT::POINT	14,0(P1),13
	POINT	14,0(P1),13
	POINT	14,0(P1),13
>;END IFN M.KL10
SUBTTL	COMMON SUBROUTINES - CPUAPP


;SUBROUTINE TO EXECUTE A SUBROUTINE OVER ALL CPU'S
;CALLING SEQUENCE:
;	MOVEI	T1,SUBROUTINE TO BE EXECUTED, OR
;	HRROI	T1,IF SUBROUTINE SHOULDN'T BE EXECUTED ON THIS CPU
;	PUSHJ	P,CPUAPP
;SUBROUTINE IS CALLED WITH P1 POINTING AT A CPU CDB
; FOR WHICH THE DESIRED ACTION IS TO BE APPLIED

	$CSUB			;MUST BE ADDRESSABLE BY ALL CODE SEGMENTS

CPUAPP::PUSHJ	P,SAVE1		;SAVE P1
IFE M.CPU-1,<
	JUMPL	T1,CPOPJ	;RETURN IF NOT TO BE APPLIED TO .CPSLF
	MOVEI	P1,.C0CDB	;ONLY CPU0
	TLO	T1,(IFIW)	;STAY IN CALLER'S SECTION
	JRST	(T1)		;DO IT
>
IFN M.CPU-1,<
	PUSH	P,T1		;SAVE ADDRESS OF SUB
	SKIPL	T1		;CALL SUB ON SELF CPU?
	TDZA	T1,T1		;YES, CLEAR T1 AND SKIP
	MOVE	T1,.CPSLF	;NO, GET ADDRESS OF SELF CDB
	PUSH	P,T1		;SAVE ON STACK
	HLLZ	T1,-2(P)	;GET RETURN PC OF SAVE1 CALL
	TLZ	T1,-1-MXSECN	;STAY IN CALLER'S SECTION
	HRR	T1,-1(P)	;CALLER'S SECTION NUMBER + PC
	EXCH	T1,-1(P)	;RESTORE T1, SAVE CALLER'S PC
	MOVEI	P1,.C0CDB	;START WITH CPU0
CPUAP1:	CAME	P1,(P)		;POSSIBLY SKIP CALL ON SELF CPU
	PUSHJ	P,@-1(P)	;CALL THE SUBROUTINE
	  JFCL			;ALLOW FOR A SKIP RETURN
	HLRZ	P1,.CPCDB-.CPCDB(P1) ;NEXT CDB
	JUMPN	P1,CPUAP1	;NEXT CPU
	ADJSP	P,-2		;SO CALLED ROUTINE CAN RETURN AN ANSWER IN T1
	POPJ	P,		;RETURN
>
	$ABS			;MUST BE IN LOW SEG FOR ONCE REFERENCES

;SUBROUTINE TO REFERENCE A MEMORY LOCATION IN PHYSICAL MEMORY
;CALLING SEQUENCE:
;	MOVE	U,ABSOLUTE ADDRESS TO REFERENCE
;	PUSHJ	P,REFMEM
;	...	RETURN HERE
;T1 CONTAINS THE CONTENTS OF THE LOCATION SPECIFIED BY U

REFMEM::PUSH	P,P1		;CAN'T USE SAVE1
	MOVE	P1,U		;COPY ADDRESS
	LSH	P1,W2PLSH	;ISOLATE PAGE NUMBER
	HRLI	P1,(<PM.DCD>B2+PM.WRT) ;MAKE IT ACCESSIBLE AND WRITABLE
	PUSH	P,P3		;SAVE AN AC
	MOVE	P3,.CPMAP	;GET ADDRESS OF S0 MAP
	MOVEM	P1,.EUPMP/PAGSIZ(P3) ;MAKE ADDRESSABLE VIA .EUPMP
	CLRPT	.EUPMP		;FLUSH MAPPING FOR THAT PAGE
	MOVE	P1,U		;COPY ADDRESS
	ANDI	P1,PG.BDY	;KEEP JUST LINE NUMBER WITHIN PAGE
	IORI	P1,.EUPMP	;PLUG IN REST OF VIRTUAL ADDRESS
	MOVEI	P3,REFME2	;SET UP PAGE FAULT ADDRESS SINCE NXM MAY CAUSE
				; AR/ARX PARITY TRAP
	PUSH	P,.USPFN	;SAVE NEW PC
	MOVEM	P3,.USPFN	;STORE NEW TRAP ADDRESS
	SETZ	T1,		;RETURN A ZERO IF NXM
	MOVES	T1,(P1)		;REFERENCE THE ADDRESS AND UPDATE CONTENTS
REFME2:	POP	P,.USPFN	;RESTORE NEW PC
	POP	P,P3		;RESTORE ACS
	POP	P,P1
	POPJ	P,		;RETURN

	$HIGH
IFN M.KS10,<
;ROUTINE TO COMPUTE THE NUMBER OF WORDS TRANSFERRED IN THE LAST I/O OPERATION
;THROUGH THE UNIBUS ADAPTER LINKED TO THE CHANNEL DATA BLOCK POINTER TO BY
;P1. FINAL ADDRESS IS IN T1.
;RETURNS CPOPJ ALWAYS WITH THE NUMBER OF GOOD WORDS TRANSFERRED IN T1.

WRDCNT::HRRZ	T2,CHNIEA(P1)	;GET INITIAL ELEVEN STYLE ADDRESS
	SUB	T1,T2		;SUBTRACT FROM FINAL ADDRESS
	LSH	T1,-2		;GET INTO TEN STYLE WORDS
	POPJ	P,		;AND RETURN

>;END IFN M.KS10
SUBTTL SYSTEM BYTE POINTERS

	$CSUB

PUUOAC::POINT	4,M,12		;UUO AC FIELD
PIOMOD::POINT	4,S,35		;MODE BITS

XP PJBNLH,001100		;LEFT HALF OF "POINT 9,XXX,35"

PUNIT::	POINT	 9,DEVJOB(F),17	;DEVICE UNIT NUMBER
PCTXN::	POINT	 9,DEVJOB(F),26	;DEVICE CONTEXT ASSIGNMENT
PJOBN::	POINT	 9,DEVJOB(F),35	;DEVICE JOB ASSIGNMENT
PJCHN::	POINT	18,DEVJOB(F),35	;DEVICE JOB/CONTEXT HANDLE ASSIGNMENT

PJBSTS::POINT	JWSIZ,JBTSTS(J),JWPOS	;JOB WAIT STATE (QUEUE) CODE
				;IN JOB STATUS WORD
PJBST2::POINT	JS.SIZ,JBTST2(J),JS.POS	; JOB QUEUE NUMBER (NOT STATE CODE)
PJ2ST1::POINT	JS.SIZ,JBTST2(T1),JS.POS ;SAME AS PJBST2 FOR IDX T1
JBYEWT::POINT	ESLPSZ,JBTST2(J),ESLPBP	;EVENT WAIT REASON
JBYICC::POINT ICCSIZ,JBTSTS(J),ICCPOS  ;POINTER TO HIGH
				; SEGMENT IN CORE COUNT
PDVSTA::POINT	6,DEVSTA(F),35	;STATION NUMBER OF DEVICE
PBUFSZ::POINT	17,DEVCHR(F),35	;BUFFER SIZE
PDVTIM::POINT	3,DEVCHR(F),9	;CODE FOR TIME DEVICE MAY
					;BE ACTIVE BEFORE BEING DECLARED
					;HUNG. N MEANS 2^N-1 SECONDS
PDVCNT::POINT	7,DEVCHR(F),16	;COUNTED DOWN EACH SECOND,
				;1 TO 0 TRANSITION MEANS HUNG DEVICE
IADPTR::POINT	2,DEVIAD(F),2	;COUNT OF NUMBER OF USER CHANNELS INITED
				; ON THIS DEVICE (DECTAPE ONLY)
DEYSPL::POINT	8,DEVSPL(F),17	;SPOOL BIT ASSOCIATED WITH DEVICE

DEYISN::POINT	5,DEVISN(F),17	;POINTER TO SECTION OFFSET FOR MULTI-SECTION I/O
DEYTYP::POINT	8,DEVTYP(F),9	;POINTER TO DEVICE-TYPE BIT (+.TYVAR & .TYRAS)

PDVTYP::POINT	6,DEVTYP(F),9	;JUST DEVICE TYPE
PCORSZ::POINT	CRSIZ,JBTADR(J),CRPOS	;BYTE POINTER TO LOW OR HIGH SEG CORE SIZE-1
PCORSR::POINT	CRSIZ,R,CRPOS	;SAME FROM R

PDYQT2::POINT	PDSQNT,.PDQNT(T2),PDNQNT
PDYQNT::POINT	PDSQNT,.PDQNT(W),PDNQNT ;POINTER TO QUANTUM RUN TIME FOR JOB
PDYIPT::POINT	PDSIPT,.PDIPT(W),PDNIPT ;POINTER TO INCORE PROTECT TIME
PDYIP2::POINT	PDSIPT,.PDIPT(T1),PDNIPT ;POINTER TO INCORE PROTECT TIME
PDYDPT::POINT	9,.PDDFL(W),8	;DEFAULT PROTECTION
PDYBFN::POINT	9,.PDDFL(W),35	;DEFAULT NUMBER OF DISK BUFFERS
IFN FTFDAE,<
PDYFSP::POINT	9,.PDDFL(W),26	;FILE DAEMON SUPPLIED PROTECTION
>
PDYBSN::JBPBSN+.PDOBI(W)	;POINTER TO BATCH STREAM NUMBER
PDYOPP::JBPOPP+.PDOBI(W)	;POINTER TO OPERATOR PRIVILEGES BYTE
PDYWTO::JBPWTO+.PDOBI(W)	;POINTER TO WRITE-TO-OPR TYPE
PIEVM::	POINT	9,DEVEVM(F),8	;VIRTUAL PAGE NUMBER OF STARTING PAGE IN THE
				; EXEC MAP ALLOCATED TO THIS DEVICE FOR BUFFERED INPUT
PIEVMS::POINT	9,DEVEVM(F),17	;NUMBER OF PAGES IN THE EXEC MAP ALLOCATED TO
				; THIS DEVICE FOR BUFFERED INPUT
POEVM::	POINT	9,DEVEVM(F),26	;VIRTUAL PAGE NUMBER OF STARTING PAGE IN THE
				; EXEC MAP ALLOCATED TO THIS DEVICE FOR BUFFERED OUTPUT
POEVMS::POINT	9,DEVEVM(F),35	;NUMBER OF PAGES IN THE EXEC MAP ALLOCATED TO
				; THIS DEVICE FOR BUFFERED OUTPUT
	XP	PDEVM,POEVM	;VIRTUAL PAGE NUMBER OF STARTING PAGE IN THE EXEC
				; MAP ALLOCATED TO THIS DEVICE FOR DUMP I/O
	XP	PDEVMS,POEVMS	;NUMBER OF PAGES IN THE EXEC MAP ALLOCATED TO
				; THIS DEVICE FOR DUMP I/O
PDVESE::POINT	9,DEVESE(F),35	;EXTENDED ERROR STATUS
IFN FTMP,<
DEYCPF::POINT	3,DEVCPU(F),2	;1ST CPU OWNING DEVICE
	CPFBOO==:7		;CODE NUMBER FOR BOOT CPU
	CPFBIT==:6		;CODE NUMBER FOR CI DEVICE
				;MUST USE BIT MASK FOR ALL CI DEVICES
DEYCPS::POINT	3,DEVCPU(F),5	;2ND CPU OWNING DEVICE
				;THIS FIELD IS NO LONGER USED
				;FOR HISTORICAL PURPOSES THE CODE HAS
				;BEEN REPEAT ZEROED. SEE CHKCPI AND CPUDDB
DEYPCL::POINT	3,DEVCPU(F),8	;0 FOR NON-Q PROTOCOL, CPU DOING IO FOR QUEUED
	PCLCP0==:7		;CODE NUMBER FOR CPU0
	PCLDKY==:6		;CODE NUMBER FOR "I DON'T KNOW YET"
DEYCPU::POINT	3,DEVCPU(F),11	;CPU WHICH LAST DID INPUT OR OUTPUT UUO
MPYNRN::POINT	6,JBTSPS(J),5	;NOT RUNNABLE ON CPUN FIELD
>
NFYPGS::POINT	MCPSIZ,JBTPDB(J),MCPBPP ;POINTER TO NUMBER OF FUNNY PAGES
IFYPGS::POINT	MCPSIZ,JBTPDB(J),IMCPBP ;NUMBER OF FUNNY PAGES TO SWAP IN

IMGIN::POINT 21,JBTIMI(J),35	;SIZE OF USER JOB IN P IN CORE
IMGOUT::POINT 21,JBTIMO(J),35	;SIZE OF USER JOB IN P ON DISK
	OUTMSK==:7,,777777	;MASK OF IMAGE SIZE IN JBTIMI/JBTIMO/JBTVIR

NZSICN::POINT	6,JBTIMI(J),8	;NUMBER OF NZS MAPS FOR SWAPIN
NZSSCN::POINT	6,JBTIMI(J),14	;NUMBER OF NZS MAPS
NZSXCN::POINT 12,JBTIMI(J),14	;ALL NZS MAP COUNT

LOVSIZ::POINT 21,JBTVIR(J),35	;VIRTUAL LOW SEG SIZE
HIVSIZ::POINT 9,JBTVIR(J),14	;VIRTUAL HI SEG SIZE
JBYSPR::POINT	JBSSPR,JBTSTS(J),JBNSPR	;HIGH SEG ACCESS PRIVILEGES

JBYSUN::POINT	3,JBTSWP(J),17
JBYLKN::POINT	18,JBTSWP(J),35

SSUNT1::POINT	3,T1,17		;SWAPPING UNIT FROM ADDRESS IN T1
SSUNT4::POINT	3,T4,17		;ALSO FROM T4
SLKNT1::POINT 18,T1,35	;SWAPPING ADDRESS ON UNIT FROM T1

JBYWCH::POINT	23,JBTWCH(J),35	;BYTE POINTER TO TIME OF DAY STARTED WAITING
				;END FT WATCH

	JBYLCR::POINT	18,JBTCLM(J),17 ;CORE LIMIT POINTER
JBYLTM::POINT	36-^L<JB.LTM>,JBTLIM(J),35 ;TIME LIMIT POINTER

IFN FTNSCHED,<
JBYCLS::POINT 5,JBTSCD(J),17	;POINTER TO CLASS FOR JOB.
JBYCL1::POINT 5,JBTSCD(T1),17	;DITTO FOR IDX T1
JBYCL4::POINT 5,JBTSCD(T4),17	;DITTO FOR IDX T4
>;END IFN FTNSCHED

PDVIAD::POINT 22,DEVIAD(F),35	;POINTER FOR STORING EVA OF CURRENT INPUT BUFFER
PDVOAD::POINT 22,DEVOAD(F),35	;POINTER FOR STORING EVA OF CURRENT
				; OUTPUT BUFFER

JBYSSA::
JBYHSA::
JBYLSA::POINT 14,JBTAD2(J),35	;POINTER TO PHYSICAL PAGE NO. OF FIRST PAGE
				; OF THIS LOW SEGMENT
JBYMAP::POINT 21,JBTAD2(J),21	;SWAPPED OUT LOCATION OF .UPMAP
JBYMT4::POINT 21,JBTAD2(T4),21	;FOR VMSER

JBYVAD::POINT	21,JBTVAD(J),35	;VIRTUAL ADDRESS OF HIGH SEG MAP
JBYOFF::POINT 9,JBTVAD(J),35	;OFFSET IN PAGE ADDR OF START OF 2NDARY MAP
	POFFLH==:<POINT 9,,35>	;BYTE POINTER FOR ABOVE
JBYHSO::POINT 9,JBTUPM(J),8	;VIRTUAL PAGE NUMBER OF HIGH SEGMENT ORIGIN
				; LAST TIME THE MAP WAS SET UP

LSTBAS::POINT 7,.PDACS+ACTSTL-1(W),34 ;LAST BYTE IN ACCOUNT STRING

JBYDEB::POINT 2,JBTST2(J),2	;DEFERRED ECHO BITS


FRGAP3::POINT 21,(P3),35	;DISK ADDR IN FRAGMENT TABLE (P3)
FRGUP3::POINT 3,(P3),17		;DISK UNIT IN FRAGMENT TABLE (P3)
FRGCP3::POINT 9,(P3),14		;FRAGMENT SIZE IN FRAGMENT TABLE (P3)
FRGAP1::POINT 21,(P1),35	;SAMAE AS ABOVE CORRESPONDING FOR (P1)
FRGUP1::POINT 3,(P1),17
FRGCP1::POINT 9,(P1),14

FRGUT1::POINT 3,T1,17		;BYTE POINTER FOR UNIT IN FRAG PTR IN T1
FRGUT2::POINT 3,T2,17
FRGCT4::POINT 9,T4,14		;BYTE POINTER FOR COUNT IN FRAG PTR IN T4
	$ABS
SUBTTL PI CHANNEL SAVE/RESTORE
;DEFINE PI CHANNEL SAVE AND RESTORE ROUTINES IF A DEVICE IS ON THE CHANNEL

	PDL==201		;LENGTH OF INTERRUPT PI PUSH DOWN LIST

DEFINE CHAN (PI)<
;	XLIST
	HIGHAC==17
	HIACBL==17
CH'PI::	0		;PC STORED HERE BY JSR ON INTERRUPT TO CHANNEL PI
	0
	EXP	IC.UOU
	EXP	.+1
	XJEN	CH'PI


DEFINE FSTCHN,<
ZZS==0
IFE <PI&7-SCNCHN>,<ZZS==2>	;USE EXEC AC BLOCK 2 ON SCANNER CHANNEL
IFE <PI&7-DSKCHN>,<ZZS==3>	;USE EXEC AC BLOCK 3 ON DSK CHANNEL
IFE <PI&7-NETCHN>,<ZZS==4>	;USE EXEC AC BLOCK 4 ON NETWORK
>

DEFINE INTL.(X)<INTL'X>
DEFINE INTL<INTL'PI>

DEFINE INTO.(X)<INTO'X>
DEFINE INTO<INTO'PI>

;CHAN DEFINITION CON'T ON NEXT PAGE
;CONTINUE CHAN DEFINITION

;HERE FROM AN INTERRUPT ROUTINE WHICH HAS FOUND ITS DEVICE NEEDS SERVICE
;SAVE ACS 0 THRU HIGHAC, CALLED BY JSR, SETS UP P TO PUSH DOWN LIST FOR THIS PI
	FSTCHN		;ZZS NON-ZERO IF SCANNER OR DSK PI SAVE ROUTINE

SAV'PI::0		;CALLED BY JSR
IFN M.KL10,<
	DATAI	PAG,SVPG'PI	;REMEMBER OLD AC BLOCK #
	EXECAC	(ZZS)		;SET EXEC AC BLOCK
;	XLIST
>
IFN M.KS10,<
	RDUBR	SVPG'PI		;REMEMBER OLD AC BLOCK #
	EXECAC	(ZZS)
	XLIST
>
IFE ZZS,<
	MOVEM	HIGHAC,SVAC'PI+HIGHAC	;SAVE AC HIGHAC
IFG M.RTD,<
	SKIPN	HIGHAC,.CPRTT	;ALWAYS SAVE ACS IF RTTRP IS IN PROGRESS
>
	MOVE	HIGHAC,CH'PI	;GET INTERRUPT PC
	TLNE	HIGHAC,(XC.USR)	;WAS THE INTERRUPT OUT OF EXEC MODE
	JRST	SAV'PI'A	;NO, DON'T NEED TO SAVE AC'S
	MOVEI	HIGHAC,SVAC'PI	;SETUP TO SAVE 0 THRU HIGHAC-1
	BLT	HIGHAC,SVAC'PI+HIGHAC-1	;SAVE ACS
>
SAV'PI'A:MOVE	P,C'PI'PDP	;SETUP PUSH DOWN POINTER
	MOVSI	(IC.UOU)	;TURN ON USER IOT SO XCT PAGED WILL
	HLLM	SAV'PI		; REFERENCE USER RATHER THAN EXEC VIRTUAL MEMORY
IFN M.KL10,<
	MOVE	[LG.LPC!LG.LUB!LG.IAM]
	XORM	SVPG'PI
>
IFN FTMP,<
	SKIPGE	INTL		;DON'T TRY UNLESS ITS POSSIBLE TO GET IT
	AOSE	INTL		;WAIT FOR INTERLOCK
	JRST	.-2
	APRID	INTO

>
	JRSTF	@SAV'PI		;RETURN TO CALLER AND PROCESS INTERRUPT
;HERE FROM INTERRUPT ROUTINE WHEN IT HAS FINISHED SERVICING INTERRUPT
;RESTORE ACS AND DISMISS INTERRUPT
;USUALLY TRANSFERRED TO BY POPJ P,

	$HIGH
RET'PI::
IFN FTMP,<
	SETOM	INTO		;NO LONGER OWN
	SETOM	INTL		;GIVE UP INTERLOCK
RET'PI'B:
> ;END IFN FTMP
IFE ZZS,<
IFN M.KL10,<
IFG M.RTD,<
	SKIPN	HIGHAC,.CPRTT	;RESTORE SAVED ACS IF RTTRP IS IN PROGRESS
> ;END IFG M.RTD
	MOVE	HIGHAC,CH'PI	;GET INTERRUPT PC
	TLNE	HIGHAC,(XC.USR)	;WAS THE INTERRUPT OUT OF USER MODE?
	JRST	CH'PI'XIT	;YES--AC'S WERE NOT SAVED
> ;END IFN M.KL10
> ;END IFE ZZS

IFE ZZS,<
	MOVSI	HIGHAC,SVAC'PI	;RESTORE ACS 0 THRU HIGHAC
	BLT	HIGHAC,HIGHAC
> ;END IFE ZZS
IFN M.KL10,<
CH'PI'XIT:
	DATAO	PAG,SVPG'PI	;RESTORE OLD AC BLOCK #
> ;END IFN M.KL10
IFN M.KS10,<
IFE ZZS,<
	WRUBR	SVPG'PI		;RESTORE OLD AC BLOCK #
> ;END IFE ZZS
IFN ZZS,<
	MOVE	17,SVPG'PI	;CONTENTS OF THE UBR AT THE INTERRUPT
	TLZ	17,(SG.LUB)	;ONLY RESTORE AC SETS
	WRUBR	17		;RESTORE ACS AT INTERRUPT TIME
> ;END IFN ZZS
> ;END IFN M.KS10
C'PI'JEN::
	XJEN	CH'PI

	$ABS

;;CHANNEL SAVE ROUTINES FOR MULTI-CPU DEVICES

IFN PI&70,<
SAVB'PI::0		;;CALLED BY JSR
IFN M.KL10,<
	DATAI	PAG,SVPG'PI	;;REMEMBER OLD AC BLOCK #
	EXECAC	(ZZS)		;;SET EXEC AC BLOCK
;;	XLIST
>
IFN M.KS10,<
	RDUBR	SVPG'PI		;;REMEMBER OLD AC BLOCK #
	EXECAC	(ZZS)
	XLIST
>
IFE ZZS,<
	MOVEM	HIGHAC,SVAC'PI+HIGHAC	;;SAVE AC HIGHAC
IFG M.RTD,<
	SKIPN	HIGHAC,.CPRTT	;;ALWAYS SAVE ACS IF RTTRP IS IN PROGRESS
>
	MOVE	HIGHAC,CH'PI	;;GET INTERRUPT PC
	TLNE	HIGHAC,(XC.USR)	;;WAS THE INTERRUPT OUT OF EXEC MODE
	JRST	SVB'PI'A	;;NO, DON'T NEED TO SAVE AC'S
	MOVEI	HIGHAC,SVAC'PI	;;SETUP TO SAVE 0 THRU HIGHAC-1
	BLT	HIGHAC,SVAC'PI+HIGHAC-1	;;SAVE ACS
>
SVB'PI'A:MOVE	P,C'PI'PDP	;;SETUP PUSH DOWN POINTER
	MOVSI	(IC.UOU)	;;TURN ON USER IOT SO XCT PAGED WILL REFERENCE
	HLLM	SAVB'PI		;; USER RATHER THAN EXEC VIRTUAL MEMORY
IFN M.KL10,<
	MOVE	[LG.LPC!LG.LUB!LG.IAM]
	XORM	SVPG'PI
>
	SKIPGE	INTL.(\<PI&7>)	;;DON'T TRY UNLESS ITS POSSIBLE TO GET IT
	AOSE	INTL.(\<PI&7>)	;;WAIT FOR INTERLOCK
	JRST	.-2
	APRID	INTO.(\<PI&7>)	;;ADMIT TO OWNERSHIP

	PUSH	P,[EXP RETB'PI]	;;SAVE OUR (ALTERNATE) RESTORATION ROUTINE
	JRSTF	@SAVB'PI	;;RETURN TO CALLER AND PROCESS INTERRUPT

;;HERE FROM INTERRUPT ROUTINE WHEN IT HAS FINISHED SERVICING INTERRUPT
;;RESTORE ACS AND DISMISS INTERRUPT
;;TRANSFERRED TO BY POPJ P,

	$HIGH
RETB'PI::
	SETOM	INTO.(\<PI&7>)	;;NO LONGER OWN
	SETOM	INTL.(\<PI&7>)	;;GIVE UP INTERLOCK
	JRST	RET'PI'B	;;JOIN COMMON RESTORATION CODE

	$ABS

> ;;END OF IFN PI&70


IFG M.RTD,<
IFN M.KL10,<
	RTPOPN==30
>	;END IFN M.KL10
IFN M.KS10,<
	RTPOPN==0
>
		RTOFST==:CHD'PI-CHND'PI

CHND'PI::	MOVE P,C'PI'RTP
		IFLE PI-APRCHN,<JSP J,DSMAPR>
		IFG  PI-APRCHN,<JSP J,DISMIS>
RTRT'PI::	MOVSI 17,SVAC'PI	;RESTORE ALL OF THE AC'S
		BLT 17,17
IFN M.KL10,<
		DATAO PAG,SVPG'PI	;RESTORE AC BLOCK
>	;END IFN M.KL10
IFN M.KS10,<
		WRUBR	SVPG'PI		;RESTORE AC BLOCK
>
		XJEN	CH'PI

C'PI'RTP:	XWD	-<PDL-RTPOPN>+1,C'PI'PD1+RTPOPN


RTSV'PI::	0			;COME HERE TO SAVE ALL AC'S
IFN M.KL10,<
		DATAI PAG,SVPG'PI	;SAVE AC BLOCK
		EXECAC			;SET EXEC AC BLOCK
>	;END IFN M.KL10
IFN M.KS10,<
		RDUBR	SVPG'PI		;SAVE AC BLOCK
		EXECAC			;SET EXEC AC BLOCK
>
		MOVEM 17,SVAC'PI+17	;SAVE 17
		MOVEI 17,SVAC'PI	;SET UP BLT POINTER
		BLT 17,SVAC'PI+16	;SAVE THE AC'S
		MOVE P,C'PI'PDP		;SET UP P POINTER
		MOVSI (IC.UOU)		;TURN ON USER IOT SO PAGED XCT
		HLLM RTSV'PI		; WILL REFERENCE USER VIRTUAL
		JRST 2,@RTSV'PI		;RETURN TO CALLER

CHD'PI::		EXP ENBSTD
		Z	;STORAGE LOCATION FOR PROTECTION-RELOCATION VALUE.
		Z	;STORAGE LOCATION FOR APR ENABLE BITS.
>	;IFG M.RTD
SVPG'PI::	BLOCK	1
SVAC'PI::	BLOCK HIACBL+1	;PLACE TO SAVE ACS 0 THRU HIGHAC
C'PI'PDP::	XWD -PDL+1,.+1	;INITIAL PUSH DOWN POINTER
C'PI'PD1::	EXP RET'PI	;FIRST WORD ON LIST,
				; POPJ WILL RETURN TO DISMISS INTERRUPT
	BLOCK	PDL-1		;PUSHDOWN LIST SPACE
	LIST
>	;END OF CHAN DEFINITION
;SET USED'N TO BE NON-ZERO FOR ALL CHANNELS
;THAT NEED CHANNEL SAVE ROUTINES
;THIS INCLUDES ALL CHANNELS WHICH RTTRP MAY USE
IFN FTRTTRP,<
	DEFINE	SETUSED(PI)
	<CUSD'PI==:USED'PI
	IFE	USED'PI,<IFDEF UNIQ'PI,<IFE UNIQ'PI,<USED'PI=:-1>>
IFN M.TD10,<
IFE PI-DADCHN,<CUSD'PI==:1	;DON'T ALLOW FAST BLOCK MODE ON DTA DATA CHN
>>
					IFNDEF UNIQ'PI,<USED'PI=:-1>>
>	;DEFINE SETUSED

	ZZ==-1
	REPEAT M.CPU,<
	ZZ==ZZ+2
	REPEAT 6,<
	SETUSED(\ZZ)
	ZZ==ZZ+1
>>
>	;IFN FTRTTRP
IFG M.CPU-1,<LOC	<.+PG.BDY>&777000>
CSHFIR==:.
;NULL JOB DUMP AC AREA:

DEFINE NULDAC(N)<
NU'N'DAC::BLOCK	20
	XP NU'N'DAT,NU'N'DAC-20
>
ZZ==0
REPEAT M.CPU,<
	NULDAC(\ZZ)
ZZ==ZZ+1
>
ERPDLL==143
ERRPLL==:-ERPDLL+1
DEFINE PDLDEF(N)<
ER'N'PDL::
	BLOCK	ERPDLL
>
ZZ==0
REPEAT M.CPU,<
PDLDEF (\ZZ)
ZZ==ZZ+1
>

MNULPD=:-205+1			;LENGTH OF NULL PDL

DEFINE PDLDEF(N)<
NU'N'PDL::
MNU'N'PD==MNULPD
	BLOCK	-MNULPD+2
>
ZZ==0
REPEAT M.CPU,<
PDLDEF (\ZZ)
ZZ==ZZ+1
>
IFLE <M.CPU-1>,<NU1PDL==:NU0PDL>
;GENERATE THE CHANNEL SAVE ROUTINE ONLY FOR PI WHICH NEED THEM (ASGSAV MACRO USED)

;GENERATE NULL CHANNEL SAVE ROUTINES FOR THOSE CHANNELS NOT USED

DEFINE NULL (PI)<
	SAV'PI==PIERR##
IFN PI&70,<SAVB'PI==PIERR##>
CH'PI::	0
	0
	EXP	0
	EXP	.+1
	XJEN	CH'PI
>

	DEFINE	USED(PI)<
		IFN USED'PI, <CHAN PI>
		IFE USED'PI, <NULL PI>
	>;END DEFINE USED
	ZZ==0
	REPEAT M.CPU,<
	ZZ==ZZ+1
	REPEAT 7,<
		USED \ZZ
	ZZ==ZZ+1
	>
	>
;NOW DEFINE DURING PASS 1 A FEW NECESSARY SYMBOLS

	DEFINE	DEFCHL(A,B),<
	A'CHL==:CH'B
	IFDEF C'B'PD1,<A'PD1==:C'B'PD1>
>

	DEFINE CALCHL(A,B)<
		DEFCHL (<A'B>,\A'B'CH1)
	>;END DEFINE CALCHL
	ZZ==0
	REPEAT M.CPU,<
		CALCHL(AP,\ZZ)
		CALCHL(CK,\ZZ)
	ZZ==ZZ+1
	>;END REPEAT M.CPU
SUBTTL	GENERATE COMMON INTERRUPT ROUTINES FOR ALL PROCESSORS

;MACRO TO MAKE THE INTERRUPT SKIP CHAIN ENTRY'S FOR THE NETSER
; SOFTWARE INTERRUPT. (ONE ENTRY PER CPU)

DEFINE	GCNET(CPU,CHN),<
IFN M.ANF,<
NT'CPU'INT::SKIPN	.CPNTF
	JRST	.-1
	JSR	SAV'CHN
	PJRST	NETINT##
>> ;END M.ANF AND DEFINE GCNET

;MACRO TO GENERATE CLOCK (CH7) INTERRUPT CHAIN

DEFINE	GCCLK(CPU),<
CK'CPU'INT:SKIPN	.CPCKF
	JRST	.-1
	JRST	CLKINT##
> ;END GCCLK MACRO



;NOW EXPAND ALL THE ABOVE MACROS FOR EACH CPU IN THE CONFIG.
	$HIGH

ZZ==0
REPEAT M.CPU,<
	GCNET(\ZZ,\<ZZ*10+NETCHN>)
	GCCLK(\ZZ)
ZZ==ZZ+1
> ;END REPEAT M.CPU
	$ABS


	SUBTTL	COMMAND TABLE

;THE NEW FORMAT OF THE COMMAND TABLES IS AS FOLLOWS:
;COMTAB - CONTAINS SIXBIT COMMAND NAME
;DISP	- CONTAINS THE DISPATCH ADDRESS
;UNQTAB	- CONTAINS THE DISPATCH BITS AS WELL AS THE UNIQUENESS BITS IN
;		THE RIGHTMOST BITS. THE LEFT HALF OF THIS WORD ARE POST
;		DISPATCH BITS, THE RIGHT HALF PREDISPATCH.

;CUSTOMER-DEFINED COMMAND NAME MACRO

;COMMAND NAME, PROGRAM TO RUN IF DISPATCH ADDRESS NOT SPECIFIED, DISPATCH
;	ADDRESS, DISPATCH FLAGS, UNIQUENESS BITS, PRVTAB NAME
DEFINE UCMDNM(NM,PR,AD,FL,UN,PV),<
  IFNB <NM>,<
    IFNB <AD>,<C  <NM>,AD,FL,UN>
    IFB  <AD>,<
      IFB  <PR>,<C  <NM>,RUNAME,FL,UN>
      IFNB <PR>,<
        IFIDN <NM>,<PR>,<C  <NM>,RUNAME,FL,UN>
        IFDIF <NM>,<PR>,<C  <NM>,%'PR,FL,UN>
      >
    >
  >
>
;MONITOR COMMANDS

DEFINE NAMES,<
C	<>,CBLANK,<<NOFLM!NOINCK!NOCRLF>_^D18>!NOCORE!NOJOBN!NOLOGIN!NORCMP
C	START,START,<<NOPER!TTYRNU>_^D18>!INCORE!NOACT!NORUN!NOLOGIN!NOJOBN,UNIQ.2
C	.HALT,STOPF,<<NOINCK!CMWRQ>_^D18>!NOCORE!NOJOBN!NOLOGIN!NORCMP
C	HALT,STOP,<<NOINCK!CMWRQ>_^D18>!NOCORE!NOJOBN!NOLOGIN!NORCMP,,HALTXT
C	KJOB,KJOB,<<NOINCK!NOCRLP!NOMESS>_^D18>!NOCORE!NOJOBN!NOLOGIN!NOACT!INCORE!NORUN!NORCMP
C	R,RCOM,<<NOPER!TTYRNU>_^D18>!NOCORE!NOACT!NORUN!INCORE
C	RUN,RUNCOM,<<NOPER!TTYRNU>_^D18>!NOCORE!NOACT!NORUN!INCORE,UNIQ.2
C	CORE,CORE,<<CMWRQ>_^D18>!NOCORE!INCORE!NOACT
C	GET,GET,RUNFLG,UNIQ.1!UNIQ.2
C	SAVE,CSAVE,<<NOCRLP!TTYRNU>_^D18>!INCORE!NOACT!NORUN!NXONLY
C	SSAVE,SSAVE,<<NOCRLP!TTYRNU>_^D18>!INCORE!NOACT!NORUN!NXONLY
C	MERGE,CMERGE,<<NOCRLP!TTYRNU>_^D18>!INCORE!NOACT!NORUN!NXONLY
C	CONTINUE,CONT,<<NOINCK!NOPER!TTYRNW>_^D18>!INCORE!NORUN!NOJOBN!NOLOGIN,UNIQ.1!UNIQ.3!UNIQ.4,CONTXT
C	JCONTINUE,JCONT,<<NOINCK>_^D18>!NOCORE!NOJOBN!NOLOGIN
C	.FCONT,FCONT,<<NOINCK!NOCRLP!CMWRQ!NOMESS>_^D18>!NORUN!INCORE!NOJOBN!NOLOGIN!NORCMP,,FCOTXT
C	DEPOSIT,DCOM,<<CMWRQ>_^D18>!INCORE!NXONLY,UNIQ.1
C	EXAMINE,ECOM,<<NOFLM!CMWRQ>_^D18>!INCORE!NXONLY,UNIQ.1
C	PJOB,PJOBX,<<NOINCK>_^D18>!NOCORE!NOJOBN!NOLOGIN
C	.HELLO,HELLO,RUNFLG!NOLOGIN!NORCMP
C	.BYE,BYECOM,<<NOINCK>_^D18>!NOCORE!NOLOGIN!NOJOBN!NORCMP
C	DEASSI,DEASSIG,<<NOINCK!CMWRQ>_^D18>!NOCORE!INCORE,UNIQ.3
C	ASSIGN,ASSIGN,<<CMWRQ>_^D18>!NOCORE!INCORE
C	DDT,DDTGO,<<NOPER!TTYRNU>_^D18>!INCORE!NORUN!NOLOGIN!NOJOBN
C	.BPT,CDBPT,<<NOINCK!CMWRQ!NOMESS!NOCRLP>_^D18>!INCORE!NOCORE!NOJOBN!NOLOGI!NORCMP
C	FINISH,CFINI,<<NOCRLP!TTYRNU>_^D18>!NOACT!INCORE!NORUN
C	CLOSE,CLSCOM,<<NOCRLP!TTYRNU>_^D18>!NOACT!INCORE!NORUN
C	REENTER,REENTER,<<NOPER!TTYRNU>_^D18>!INCORE!NORUN!NOLOGIN!NOJOBN
C	CSTART,STARTC,<<TTYRNC>_^D18>!INCORE!NOACT!NORUN!NBATCH
C	CCONTINUE,CONTC,<<TTYRNC>_^D18>!INCORE!NORUN!NBATCH
C	DETACH,DETACH,<<NOINCK>_^D18>!NOCORE!NBATCH!NOLOGIN
C	ATTACH,ATTACH,<<NOINCK>_^D18>!NOCORE!INCORE!NOLOGIN!NBATCH!NORCMP
C	XCHNGE,XCHDSK,<<NOINCK>_^D18>!NOCORE!NOJOBN!NOLOGIN!NBATCH
C	ENABLE,ENABLE,NOCORE
C	DISABL,DISABL,NOCORE
C	DAYTIME,DAYTIM,<<NOINCK>_^D18>!NOCORE!NOJOBN!NOLOGIN!NORCMP
C	.RESTA,RESTRT,<<NOINCK>_^D18>!NOCORE!NOJOBN!NOLOGIN!NORCMP
C	TIME,RUNTIM,<<NOINCK>_^D18>!NOCORE!NOLOGIN!NOJOBN
C	RESOURCES,FREDEV,<<NOINCK>_^D18>!NOCORE!NOJOBN!NOLOGIN
C	USESTAT,USECOM,<<NOINCK!NOPER!NOMESS>_^D18>!NOCORE!NOJOBN!NOLOGIN!NORCMP
C	VERSION,VERCOM,<<CMWRQ>_^D18>!INCORE,,VERTXT
C	DSK,DSKCOM,<<NOINCK>_^D18>!NOCORE
C	MOUNT,MNTCOM,RUNFLG,UNIQ.2
C	DISMOUNT,MNTCOM,RUNFLG,UNIQ.3!UNIQ.4
IFN FTMDA,<
C	ALLOCA,RUNMDA,RUNFLG
C	DEALLO,RUNMDA,RUNFLG
C	SHOW,RUNMDA,RUNFLG
C	CANCEL,RUNMDA,RUNFLG
>
C	QUEUE,RUNQUE,RUNFLG!NOLOGIN,,QUEUE
C	CPUNCH,RUNQUE,RUNFLG!NOLOGIN
C	PLOT,RUNQUE,RUNFLG!NOLOGIN
C	PRINT,RUNQUE,RUNFLG!NOLOGIN
C	PUNCH,RUNQUE,RUNFLG!NOLOGIN
C	SUBMIT,RUNQUE,RUNFLG!NOLOGIN
C	TPUNCH,RUNQUE,RUNFLG!NOLOGIN

C	SEND,SEND,<<NOINCK>_^D18>!NOCORE!NOLOGIN!NBATCH
C	.TYPE,RETYPE,<<NOINCK!NOCRLP!NOMESS>_^D18>!NOCORE!NOJOBN!NOLOGIN!NORCMP
IFN	FTMIC,<
C	COJOB,RUNMIC,RUNFLG
C	WHENEVER,RUNMIC,RUNFLG
C	ON,RUNMIC,RUNFLG
C	LET,RUNMIC,RUNFLG
C	IF,RUNMIC,RUNFLG
C	GOTO,RUNMIC,RUNFLG
C	BACKTO,RUNMIC,RUNFLG
C	OPERATOR,RUNMIC,RUNFLG
C	NOOPERATOR,RUNMIC,RUNFLG
C	ERROR,RUNMIC,RUNFLG
C	NOERROR,RUNMIC,RUNFLG
C	SILENCE,RUNMIC,RUNFLG
C	PLEASE,RUNPLS,RUNFLG
C	REVIVE,RUNMIC,RUNFLG
C	MIC,RUNMIC,RUNFLG
C	DO,RUNMIC,RUNFLG
C	<@>,RUNMIC,RUNFLG
>;END OF FTMIC STUFF
C	SCHEDULE,SKEDUL,<<NOINCK>_^D18>!NOCORE!NOJOBN!NOLOGIN!NORCMP
C	LOGIN,CLOGIN,RUNFLG!NOLOGIN!NORCMP,,LOGTXT
C	PASSWORD,RUNLGN,RUNFLG
C	TRANSL,RUNLGN,<<SACFLG>_^D18>!RUNFLG
C	REATTA,RUNLGN,<<SACFLG>_^D18>!RUNFLG
C	REASSI,REASS,<<CMWRQ>_^D18>!NOCORE!NOACT!INCORE!NORUN
C	SET,SET,<<NOINCK>_^D18>!NOCORE!NOJOBN!NOLOGIN!NORCMP
C	TTY,TTYCMD,<<NOINCK>_^D18>!NOCORE!NOLOGIN!NOJOBN!NORCMP
C	TERMINAL,TTYCMD,<<NOINCK>_^D18>!NOCORE!NOLOGIN!NOJOBN!NORCMP
IFN FTNET,<
C	.NETLD,RUNNET,RUNFLG!NOLOGIN!NORCMP
C	NETWORK,RUNAME,RUNFLG!NOLOGIN!NORCMP
C	NODE,CNODE,<<NOCRLP!CMWRQ>_^D18>!INCORE!NOCORE!NOLOGIN!NORCMP,UNIQ.2
> ;END FTNET
C	LOCATE,CLOCATE,NOCORE!INCORE
C	WHERE,CWHERE,<<CMWRQ>_^D18>!INCORE!NOCORE!NOLOGIN
C	INITIA,RUNAME,RUNFLG!NOLOGIN!NORCMP,UNIQ.1!UNIQ.2!UNIQ.3!UNIQ.4,INITIA
C	DIRECT,RUNAME,RUNFLG,UNIQ.2!UNIQ.3!UNIQ.4
C	HELP,RUNAME,<<NOCRLP!TTYRNU!SACFLG>_^D18>!NOCORE!NOLOGIN!NOACT!NORUN!INCORE!NORCMP
C	SYSTAT,RUNAME,RUNFLG!NOLOGIN
C	FILE,RECALL,RUNFLG
IFE FTMIC,<
C	PLEASE,RUNAME,<<NOCRLP!TTYRNU>_^D18>!NOCORE!INCORE!NOACT!NORUN!NBATCH
>
C	FUDGE,RUNPIC,RUNFLG
C	CREF,RUNAMC,RUNFLG
C	SOS,RUNAME,RUNFLG
C	ACCOUNT,CACCT,NOCORE
C	SESSION,RUNLGN,RUNFLG
C	DECLARE,RUNAME,RUNFLG
C	MAIL,RUNMAI,RUNFLG
C	.EXEC,EXECCM,RUNFLG!NOLOGIN!NORCMP
C	.RUN,RUNAME,RUNFLG!NOLOGIN,,.RNTXT
C	CONTEXT,CTXCMD,<<NOCRLP!NOINCK>_^D18>!NOCORE!INCORE,UNIQ.2
C	PUSH,PSHCMD,<<NOCRLP!NOMESS>_^D18>!NOCORE!NORUN!INCORE
C	POP,POPCMD,<<NOCRLP!NOMESS>_^D18>!NORUN!INCORE

IFN FTPATT,<
C	.PATCH,CPOPJ,<<NOINCK>_^D18>!NOCORE!NOJOBN!NOLOGIN!NORCMP
>
C	.PLRUN,PLNCOM,RUNFLG,,PLNTXT

;COMPIL-CLASS COMMANDS

C	COMPILE,CCLRUN,RUNFLG,,COMPIL
C	DEBUG,CCLRUN,RUNFLG
C	EXECUTE,CCLRUN,RUNFLG,UNIQ.2
C	LOAD,CCLRUN,RUNFLG
C	CREATE,CCLRUN,RUNFLG
C	DELETE,CCLRUN,RUNFLG
C	EDIT,CCLRUN,RUNFLG
C	LIST,CCLRUN,RUNFLG
C	MAKE,CCLRUN,RUNFLG,UNIQ.2
C	RENAME,CCLRUN,RUNFLG
C	TECO,CCLRUN,RUNFLG,UNIQ.2!UNIQ.3
C	TYPE,CCLRUN,RUNFLG,UNIQ.2
C	COPY,CCLRUN,RUNFLG
C	PRESERVE,CCLRUN,RUNFLG
C	REWIND,CCLRUN,RUNFLG
C	UNLOAD,CCLRUN,RUNFLG
C	ZERO,CCLRUN,RUNFLG
C	SKIP,CCLRUN,RUNFLG
C	BACKSPACE,CCLRUN,RUNFLG,UNIQ.2!UNIQ.3!UNIQ.4
C	EOF,CCLRUN,RUNFLG
C	PROTECT,CCLRUN,RUNFLG
C	LABEL,CCLRUN,RUNFLG
C	CTEST,CCLRUN,RUNFLG	;ALWAYS LAST CCLRUN
>; END NAMES MACRO
;SET COMMANDS

DEFINE SNAMES,<
C	WATCH,SETWAT,NOCORE
C	TIME,SETRTM,NOCORE
C	SPOOL,SETSPL,NOCORE
C	CDR,SETCDR,NOCORE
C	SCHEDULE,SETSCD,<<NOINCK>_^D18>!NOCORE!NOJOBN!NOLOGIN
C	CORMAX,SETMAX,<<NOINCK>_^D18>!NOCORE!NOJOBN!NOLOGIN
IFN FTLOCK,<
C	CORMIN,SETMIN,<<NOINCK>_^D18>!NOCORE!NOJOBN!NOLOGIN
>
C	DAYTIM,SETDAY,<<NOINCK>_^D18>!NOCORE!NOJOBN!NOLOGIN
C	DATE,SETDAT,<<NOINCK>_^D18>!NOCORE!NOJOBN!NOLOGIN
C	OPR,SETOPR,<<NOINCK>_^D18>!NOCORE!NOJOBN!NOLOGIN
C	TTY,TTYCMD,<<NOINCK>_^D18>!NOCORE!NOJOBN!NOLOGIN!NORCMP
C	TERMINAL,TTYCMD,<<NOINCK>_^D18>!NOCORE!NOJOBN!NOLOGIN!NORCMP
IFN FTHPQ,<
C	HPQ,HPQCMD,NOCORE
>
C	DENSITY,MTADEN,<<CMWRQ>_^D18>!NOCORE!INCORE!NOACT
C	BLOCKSIZE,MTABLK,<<CMWRQ>_^D18>!NOCORE!INCORE!NOACT
C	FORMAT,MTAMOD,<<CMWRQ>_^D18>!NOCORE!INCORE!NOACT
C	RETRY,MTARTY,<<CMWRQ>_^D18>!NOCORE!INCORE!NOACT
IFN FTMP,<
C	CPU,CPUCMD,NOCORE
>
C	NOMESS,DSKSIL,<<NOINCK>_^D18>!NOCORE!NOJOBN!NOLOGIN
C	DSKPRI,DSKPRI,NOCORE
C	DSKFUL,FULSTP,NOCORE
C	BREAK,SETBRK,NOCORE
C	VMMAX,SETVMX,<<NOINCK>_^D18>!NOCORE!NOJOBN!NOLOGIN
C	VIRTUAL,SETUVC,NOCORE
C	PHYSICAL,SETUPC,NOCORE
IFN FTNET!FTDECNET,<
C	HOSTESS,DAASTH,RUNFLG!NOLOGIN!NORCMP
>
C	MEMORY,SETMEM,<<CMWRQ>_^D18>!NOCORE!NOLOGIN!INCORE
C	DEFER,SETDFC,NOCORE
C	NODEFER,SETNDC,NOCORE
C	DEFAULT,SETDFL,NOCORE!NOLOGIN
C	FLOATING,SETFPC,NOCORE
C	DDT,SETBPT,NOCORE
C	EDDT,SETEBP,NOCORE!NOLOGIN!NOJOBN!NBATCH
IFN FTPATT,<
C	CTEST,CPOPJ,<<NOINCK>_^D18>!NOCORE!NOJOBN!NOLOGIN	;ALWAYS LAST
>
>; END SNAMES MACRO
;CUSTOMER DEFINED COMMANDS

DEFINE CNAMES,<
	SPCCMD			;;EXPAND CUSTOMER DEFINED COMMANDS
>; END CNAMES MACRO
;GENERATE TABLE OF SIXBIT COMMAND NAMES
DEFINE C(A,B,D,E,F)<
IFNB<F>,<F::>
IFDIF <A><>,<IFDIF <A><>,<
	<SIXBIT A>
>>
IFIDN <A><>,<BYTE(6)34,0>
IFIDN <A><>,<BYTE(6)36,0>
>
XALL

COMTB2::SNAMES
DISPL2==:.-COMTB2	;LENGTH
COMMX2==:<DISPL2-1>B26
CSTTAB::CNAMES		;CUSTOMER DEFINED NAMES
DISPLC==:.-CSTTAB	;LENGTH OF TABLE
COMMXC==:<DISPLC-1>B26
COMTAB::NAMES
LASCCL==:.
DISPL==:.-COMTAB	;LENGTH OF TABLE
COMMXL==:<DISPL-1>B26
	$HIGH
;GENERATE THE DISPATCH TABLE PLUS SPECIAL BITS

DEFINE C(A,B,D,E,F) <
 IF2,<IFNDEF B,<EXTERN B>>
	EXP	B		;A
>


DISP2::	SNAMES
DISPC::	CNAMES		;CUSTOMER TABLE
DEFINE C(A,B,D,E,F) <
 IF2,<IFNDEF B,<EXTERN B>>
  IFG .-DISP-COMPIL+COMTAB,<
    IFDIF <B><CCLRUN>,<PRINTX ? B DOES NOT PRECEDE CCLRUN IN COMTAB>>
  IFLE .-DISP-COMPIL+COMTAB,<
	EXP	B		;A
>>


DISP::	NAMES


;AND ONE MORE FOR AN UNKNOWN COMMAND DISPATCH

COMERD::EXP	NOCOM##
;GENERATE TABLE OF UNIQUENESS BITS FOR SIXBIT COMMAND NAMES
DEFINE C(A,B,D,E,F)<
	EXP	D!E		;A
>

UNQTAB::NAMES
	EXP	NOCORE+NOJOBN+NOLOGIN+NOINCK ;UNKNOWN COMMAND DISPATCH

UNQTB2::SNAMES

UNQTBC::CNAMES
;GENERATE COMMAND DISPATCHES FOR USER DEFINED COMMANDS

DEFINE UCMDNM(NM,PR,AD,FL,UN,PV),<
  IFNB <NM>,<
    IFB  <AD>,<
      IFNB <PR>,<
        IFDIF <NM>,<PR>,<
          IFNDEF %'PR,< %'PR: >
          IFE	%'PR-.,<
%'PR:	MOVE	P2,[SIXBIT/PR/]
	JRST	RUNAME##
          >
        >
      >
    >
  >
>


	SPCCMD


	SALL
;TABLE OF PRIVILEGED CUSPS
;USED TO TURN ON JACCT WHEN R OR RUN COMMAND OR RUN UUO

PRVTAB::
LGONAM::SIXBIT	/LOGOUT/	;NAME FOR "LOGOUT" (TURN OFF JLOG TOO)
LGINAM::SIXBIT	/LOGIN/		;NAME FOR "LOGIN" (ALSO LOGS OUT JOBS)
	SIXBIT	/UMOUNT/
	SIXBIT	/SYSTAT/	;FOR PEEK UUO PRIVILEGE
IFN FTNET,<
	SIXBIT	/NETLDR/
IFN FTKS10,<
	SIXBIT	/KDPLDR/	;KMC-11 MICRO-CODE LOADER TO RUN ON FRCLIN
>
>; END IFN FTNET
IFN M.DN60,<			;IF WE HAVE A DN60...
	SIXBIT	/D60RTV/	; RETRIEVAL PGM MUST HAVE FULL FILE ACCESS
>
CCPNAM::EXP	M.CRSH		;AUTO CRASH COPY PROGRAM. (MAY BE CHANGED
				;WITH MONGEN BY DEFINING THE SYMBOL M.CRSH IN
				;THE SIXBIT DEFINITION SECTION TO BE THE NAME
				;OF THE PROGRAM TO RUN)
IFN M.ENET&M.KL10,<
	SIXBIT/KNILDR/		;KLNI MICROCODE LOADER
>

DEFINE UCMDNM(NM,PR,AD,FL,UN,PV),<
  IFNB <PV>,<EXP SIXBIT/PV/>
>

	SPCCMD			;GENERATE PRVTAB ENTRIES FOR CUSTOMER
				;  DEFINED COMMANDS
IFN FTPATT,<0>			;SAVE A WORD FOR PATCHING OVER
PRVTBL==:.-PRVTAB		;NO.  OF PRIVILEGED CUSPS
DAASTH::
IFE M.RMCR!M.DECN,<		;IF NO NETWORK SUPPORT
	JSP	T1,ERRMES##	;CAN'T DO THESE IF NO NETWORK
	ASCIZ	|No network software|
> ;END IFN M.RMCR!M.DECN
IFN M.RMCR!M.DECN,<		;IF NETWORKS
	PUSHJ	P,SAVE4		;SAVE P1-P4
	PUSHJ	P,CTEXT1##	;GET NEXT ARGUMENT
	JUMPE	T2,NOTENF##	;IF NO ARGUMENT
	MOVE	T1,T2		;T1=NAME
	PUSHJ	P,CVTOCT##	;CONVERT IF NUMBER
	  JFCL			;MUST BE A NUMBER
IFN M.RMCR,<IFN M.DECN,<
	NETOFF			;INTERLOCK
IFE M.RVTM,<			;IF NO LOCAL ANF SET HOST
	SKIPL	LDBTTW##(U)	;IF THIS ISN'T AN ANF LINE,
	JRST	HOST.D		;DON'T BOTHER ANF WITH IT
>
	PUSHJ	P,SRCND0##	;SEARCH ANF TABLE
	  PJRST	HOST.D		;IF NOT FOUND
	NETON			;FREE INTERLOCK
>;END IFN M.DECN
	PJRST	HOST.A##	;ANF HOST
>;END IFN M.RMCR

IFN M.DECN,<
HOST.D:IFN M.RMCR,<NETON>
HOSTD0:
IFN FTXMON,<
	SNCALL	(SCTN2A##,MS.HGH) ;CONVERT NODE NAME TO NODE ADDRESS
>
IFE FTXMON,<
	DNCALL	SCTN2A##	;CONVERT NODE NAME TO NODE ADDRESS
>
	  JRST	[MOVEI	T1,[ASCIZ  /Undefined Network Node/]
		PJRST ERRMES##]	;GIVE USER AN ERROR
	MOVSI	T1,LTLNRT##	;LETS SEE IF WE ARE ALREADY NRTED IN
	SE1XCT	<TDNE T1,LDBTTW##(U)> ;AND DON'T ALLOW IT IF SO
	 JRST	[MOVEI T1,[	;NRTED IN, DON'T LET HIM NRT OUT
		ASCIZ \Cannot SET HOST to a DECnet node from a NRT line\]
		PJRST ERRMES##]	;&&ADD CODE HERE TO DISCONNECT LINE&&
	PUSHJ	P,FNDPDS##	;RESTORE W
	MOVE	P2,[SIXBIT /CTHNRT/] ;PROGRAM NAME
	MOVE	T1,JBTSTS(J)	;JOB STATUS WORD
	TLNN	T1,JLOG		;LOGGED IN
	SKIPE	STHFLG		; OR NOT REQUIRED
	PJRST	RUNAME##	;RUN NRT PROGRAM
	MOVEI	T1,LOGPLM##	;ELSE TYPE
	PJRST	ERRMES##	; "LOGIN PLEASE"
>
>

	$ABS
IFN FTKL10,<IFG M.CPU-1,<
	LOC <.+PG.BDY>&777000
>
CSHLAS==:.-1			;CACHE FROM CSHFIR TO HERE
>
SUBTTL	COMMON -- CODE IN COMMON TO BUILD FEK'S

	FEKFST==:0		;START CHAIN OF FEKS BY ASSUMING
				;  THAT NO FEK'S WILL BE DEFINED

DEFINE FEKGEN(NAM,NM,TYPE,CPU,UNIT),< ;;MACRO TO LAY OUT FEK BLOCKS

;;ARGUMENTS ARE:
;;	NAM	3 CHARACTER GENERIC FEK TYPE (IE D8S)
;;	NM	3 CHARACTER "PARTICULAR" NAME FOR THIS FEK (IE "S01")
;;	TYPE	LEGAL NAME OF FEK (IE. NULL, KMCDUP DTE20 ...)
;;	CPU	NUMBER OF THE CPU THAT THIS FEK IS ON
;;	UNIT	UNIT NUMBER OF THIS FEK

;;FIRST VERIFY THAT THE FEK IS ONE OF A VALID TYPE
IFDIF <TYPE>,<NULL>,<
  IFDIF <TYPE>,<DL10>,<
    IFDIF <TYPE>,<DTE20>,<
      IFDIF <TYPE>,<KMCDUP>,<
	IFDIF <TYPE>,<DMR11>,<
	  IFDIF <TYPE>,<ENET>,<
	    PRINTX ? Illegal third argument TYPE to FEKGEN macro.?
	  >;DMR11
	>;DMR11
      >;KMCDUP
    >;DTE20
  >;DL10
>;NULL

DEFINE X(OFFSET,EXPR)<		;;MACRO TO SET SELECTED LOCATIONS IN THE BLOCK
	LOC NM'FEK+OFFSET	;;GO TO THE RIGHT WORD
	EXPR			;;ASSEMBLE IN THE EXPRESSION
>

  IFNDEF NAM'DSP,<EXTERNAL NAM'DSP> ;;RESOLVE DISPATCH VECTOR ADDRESS
  ND NM'CST,NAM'CST		;;COST MAY BE MONGEN'ED

  Q==0				;;DEFINE DEFAULT FEKBLK BITS
IFIDN <TYPE>,<NULL>,<
  Q==<FK.NUL!FK.ONL!FK.NID>	;;STATUS BITS FOR NULL FEK
>;NULL

NM'FEK::BLOCK	0		;;RESERVE STORAGE FOR THIS FEK

	X	FEKBLK,<XWD Q,FEKFST>	;;STATUS BITS AND LINK TO LAST FEK
	X	FEKDSP,<PUSHJ P,NAM'DSP>;;ONCE-ONLY CODE
	X	FEKUNI,<XWD CPU,UNIT>	;;XWD CPU,UNIT
	X	FEKCST,<XWD NM'CST,0>	;;SET COST FOR THIS FEK
	X	FEKHTM,<EXP 0>		;;INITIALIZE WITH HUNG TIME OF ZERO
	X	FEKIAD,<EXP 0>		;;NO INPUT BUFFERS (ADDRESS)
	X	FEKIDN,<EXP 0>		;;NO INPUT BUFFERS FILLED
	X	FEKBSI,<EXP -1>		;;INPUT IS IDLE
	X	FEKOAD,<EXP 0>		;;NO OUTPUT BUFFERS (ADDRESS)
	X	FEKOCT,<EXP 0>		;;NO OUTPUT BUFFERS (COUNT)
	X	FEKODN,<EXP 0>		;;NO EMPTY OUTPUT BUFFERS EITHER
	X	FEKBSO,<EXP -1>		;;OUTPUT IS IDLE

IFIDN <TYPE>,<DL10>,<			;;IF THIS IS A DL10
	X	FEKDLX,<CONC(DL'CPU,\<UNIT>,BS)> ;;BACK POINTER
> ;END IFIDN <TYPE><DL10>

IFIDN <TYPE>,<DTE20>,<			;;IF THIS IS A DTE 20
	X	FEKIBP,<EXP 0>		;;WE HAVE NO INPUT BYTE POINTER
	X	FEKAKC,<EXP 0>		;;THE "ACK" INTERLOCK IS FREE
	X	FEKDLX,<EXP D'NM'BS>	;;RUDE HACK TO GET BACK POINTER
	X	FEKETD,<CONC(ETD'CPU,\<UNIT+1>,B##)> ;;ETD ADDRESS
> ;END IFIDN <TYPE><DL10>

IFIDN <TYPE>,<ENET>,<
	X	FEKNIA,<EXP 0,0>	;;REMOTE ETHERNET ADDRESS
	X	FEKNIC,<EXP 0>		;;ETHERNET "CHANNEL" ID
	X	FEKNID,<EXP 0>		;;ETHERNET "PORTAL" ID
	X	FEKNIF,<EXP 0>		;;ETHERNET MASTER FEK ADDRESS
	X	FEKNIQ,<EXP 0>		;;ETHERNET INPUT PCBS QUEUED COUNT
	X	FEKNIS,<EXP 0>		;;ETHERNET NODEID SERIAL NUMBER
	X	FEKNIT,<EXP 0>		;;ETHERNET TIMERS
> ;END IFIDN <TYPE><ENET>

	LOC	NM'FEK+FEKLEN	;;GO TO THE END OF THE BLOCK
	FEKFST==:NM'FEK		;;REDEFINE THE "FIRST" FEK TO KEEP CHAIN ALIVE
	PURGE	X		;;UNDEFINE THE "X" MACRO
>;FEKGEN
SUBTTL	DN87 (ANF-10) AND DN60 (IBM) FEKS
	$ABS

;NOW DEFINE 4 HELPER MACROS.  ONE EACH FOR DN87(85), DC76, DN60 AND DN6S
;NOTE -- THESE FEKS MAY ONLY GO ON CPU #0.

DEFINE	FEK85(P),<		;;MACRO TO BUILD DN85 FEKS
  IRP P,<			;;FOR EACH ARGUMENT,
    IFE <TP.DL'P-TP.D85>,<	;;  IF THE -11 IS A DN85 (DN87),
      ND D85CST,^D5		;;  DEFAULT COST
      FEKGEN (D85,D8'P,DL10,0,0);;  THEN BUILD THE FEK, AND
      EXTERN D85INT>>>		;;  MAKE SURE THE SERVICE ROUTINE IS LOADED

DEFINE	FEK76(P),<		;;MACRO TO BUILD DC76 FEKS
  IRP P,<			;;FOR EACH ARGUMENT,
    IFE <TP.DL'P-TP.D76>,<	;;  IF THIS -11 IS SUPPOSED TO BE A DC76
      ND D76CST,^D5		;;  DEFAULT COST
      FEKGEN (D76,D8'P,DL10,0,0);;  THEN BUILD THE FEK, AND
      EXTERN D76INT>>>		;;  MAKE SURE THE SERVICE ROUTINE IS LOADED


DEFINE FEK60(P),<		;;MACRO FOR DN60 FEKS (DL-10 BASED IBM COMM)
  IRP P,<			;;FOR EACH POSSIBLE -11,
    IFE <TP.DL'P-TP.D60>,<	;;IF THIS -11 IS TO BE A DN60,
      ND D60CST,^D5		;;  DEFAULT COST
      FEKGEN (D60,D8'P,DL10,0,0);;  THEN BUILD IT'S FEK, AND
      EXTERN D60SER,D6DINT>>>	;;  MAKE SURE THE SERVICE ROUTINES ARE IN

;NOW ACTUALLY BUILD THE FEKS.

	FEK85 <0,1,2,3,4,5,6,7>	;;LEGAL FRONT ENDS FOR DN87(85) FEKS
	FEK76 <0,1,2,3,4,5,6,7>	;;LEGAL FRONT ENDS FOR DC76 FEKS
	FEK60 <0,1,2,3,4,5,6,7>	;;LEGAL FRONT ENDS FOR DN60 FEKS
IFN FTKL10,<
;NOW BUILD THE DN87S AND DN60S FEKS (DTE-20 BASED ANF AND IBM FRONT ENDS)
;NOTE -- THESE FEKS MAY BE ON ANY CPU.

IFN M.DN8S,<EXTERN D8SINT,D8SDSP>	;LOAD D8SINT
IFN M.DN6S,<EXTERN D6SINT,D6SDSP,D60SER> ;LOAD IBMCOMM
;;IFN M.DDCN,<EXTERN MCBINT,MCBDSP>	;;THERE SHOULD HAVE BEEN ONE OF THESE

DEFINE	FEKDTE(CPX,DTX),<		;;MACRO TO BUILD DTE-BASED FEKS
    ND DFKCST,^D7			;;DEFAULT COST
    FEKGEN(DFK,S'CPX'DTX,DTE20,CPX,DTX)	;;BUILD THE FEK
>

;NOW FOR ALL CPUS, FOR ALL DTES, BUILD THEIR FEKS

ZZ==0
REPEAT M.CPU,<Z=0			;;FOR ALL CPUS,
    REPEAT 4,<				;;  FOR EACH DTE ON THIS CPU
	FEKDTE(\ZZ,\Z)			;;  BUILD A FEK FOR THE -11
	Z==Z+1>				;;STEP TO THE NEXT DTE
    ZZ=ZZ+1>				;;  AND STEP TO THE NEXT CPU
> ;IFN FTKL10
;Define the DMR11 FEKs
;Put them so they will be after the KDPs for FEK2LN
IFN M.DMRN,<
	EXTERN	D8RINT,DMRINT,DMRSER	;;  LOAD THE SERVICE ROUTINES
 IFN M.DN6R,<
	EXTERN	D6RINT>			;; LOAD SERVICE ROUTINE FOR IBM

DEFINE FEK8R(N),<
      ND D8RCST,^D8			;;DEFAULT COST
      FEKGEN(D8R,DR'N,DMR11,0,DMR'N)>
ZZ==0

REPEAT M.DMRN,<
	FEK8R(\ZZ)
	ZZ==ZZ+1>
>;IFN M.DMRN

;DEFINE THE KMC/DUP-11 FEK'S
;FOR NOW, THE NAMES ARE JUST DK<NNM>FEK

IFN M.KDUP,<				;;IF THERE ARE KMC/DUP-11 FEK'S

DEFINE FEK8K(N),<			;;DEFINE A HELPER MACRO TO DEFINE FEK'S
    ND D8KCST,^D10			;;  DEFAULT COST
    FEKGEN(D8K,DK'N,KMCDUP,0,KDL'N'PG)	;;  BUILD THE D8K FEK
    EXTERNAL D8KINT,KDPINT,KDPSER>	;;  AND FORCE LOADING

ZZ==0					;;COUNTER FOR FEK NUMBER
REPEAT M.KDUP,<				;;FOR ALL KMCDUP FEK'S
	FEK8K(\ZZ)			;;  BUILD THE FEK
	ZZ==ZZ+1>			;;  AND STEP TO THE NEXT

>;M.KDUP
;NOW THE ETHERNET PROTOTYPE (AND ETH-0 MASTER) FEK

IFG M.ENET,<				;AND IT IS LOADED
  ND ANFNIP,NCLNIP			;DEFAULT TO BE EXCLUDED
  ND ANFNIM,<<ANFNIP>B15>		;DEFAULT LOW ORDER MULTICAST ADDRESS
  IFN ANFNIP!ANFNIM,<			;AND USER HAS DEFINED ANF NI SERVICE
    IFN M.ANF,<
	ND D8ECST,^D2			;DEFAULT COST
	FEKGEN(D8E,ET0,ENET,-1,0)	;THEN BUILD A PROTOTYPE ETHERNET FEK
	EXTERN D8EINT			;AND LOAD ANF'S ETHERNET FEK SERVICE
    > ;IFN M.ANF
  > ;IFDEF ANFNIP
> ;IFG M.ENET




;BUILD THE "NULL" FEK.

IFN M.ANF,<
	ND NLFCST,^D1			;;DEFAULT COST
	FEKGEN(NLF,NL0,NULL,-1,0)	;;GENERATE THE NULL FEK'S FEK
	EXTERN NULFEK			;;  AND LOAD THE SERVICE ROUTINE
>;M.ANF
	$HIGH

IFN FTKL10,<
;GENERATE TABLE TO MAP FROM DTE AND CPU # TO FEK ADDRESS

DEFINE	FEKPNT(DTX,CPX),<EXP S'CPX'DTX'FEK>

DTEFEK::
Z==-4
REPEAT	M.CPU,<
	CONC(<IFIW DTEFEX+>,\<Z==Z+4>,<(P1)>)
>

DTEFEX:
ZZ==0				;CPU INDEX
REPEAT	M.CPU,<			;FOR ALL CPUS
    ZZZ==0			;DTE INDEX
    REPEAT 4,<			;FOR ALL DTE'S
	FEKPNT(\ZZZ,\ZZ)	;BUILD THE NEXT POINTER
	ZZZ==ZZZ+1>		;STEP TO THE NEXT DTE
    ZZ==ZZ+1>			;STEP TO THE NEXT CPU
>;END IFN FTKL10
	SUBTTL	KDP BLOCKS FOR THE KMC-11/DUP-11
	$ABS

IFN M.KDUP,<			;ONLY ASSEMBLE IF WE HAVE KMC-DUPS

;SINCE THE KS10 MAY HAVE AT MOST ONE KMC-11, THIS CODE DOES NOT
;  EASILY PROVIDE FOR MORE THAN ONE "KDP" BLOCK.

KDPTBL::EXP	KDP0		;WE ONLY HAVE ONE KDP(KMC)
KDPMAX==:0			;THE HIGHEST ONE IS "0"

DEFINE	X(OFFSET,VALUE),<	;;HELPER MACRO FOR FILLING IN KDP BLOCK
	LOC	KDP0+OFFSET	;;GO TO THE APPROIATE LOCATION IN THE BLOCK
	VALUE			;;AND ASSEMBLE IN THIS "VALUE"
>
DEFINE	XX(DUPN),<		;;HELPER MACRO FOR FILLING IN KDPKDL SUB-TABLE
	X(KDPKDL+DUPN,<XWD DK'DUPN'FEK,KDL'DUPN'PG>) ;; FILL IN FEK AND PAGE
>
;NOW LAY OUT THE KDP BLOCK
KDP0::	X(KDPCSR,<EXP KMC1BA>)	;CSR ADDRESS OF THE KMC-11
	X(KDPVEC,<EXP KMC1IV>)	;INTERRUPT VECTOR ADDRESS
	X(KDPDPN,<EXP M.KDUP>)	;NUMBER OF DUP-11'S ON THIS KMC
	X(KDP1DP,<EXP DUP1BA>)	;BASE ADDRESS OF THE FIRST DUP-11
	X(KDPNUM,<EXP 0>)	;NUMBER OF THIS KDP

Q==0				;NOW LOOP OVER ALL KDL(DUPS) START WITH ZERO
REPEAT M.KDUP,<
	XX(\Q)			;BUILD THE NEXT KDL ENTRY (XWD FEK,KDL)
	Q==Q+1			;STEP TO THE NEXT KDL
>				;LOOP UNTIL DONE
;NOW LAY OUT THE INTERRUPT ROUTINES (THEY LIVE IN THE KDP BLOCK)
	X(KDPIVA,<EXP 0>)	;VECTOR A.  JSR COMES HERE
	EXP	0		;SECOND WORD OF OLD PC
	EXP IC.UOU,EXP .+1	;NEW PC

	EXCH	T1,KDP0+KDPIVA	;SAVE T1, GET ADDR WE INTERRUPED OUT OF
	MOVEM	T1,KDPCHL	;PUT IT BACK WHER A POPJ WILL RETURN
	MOVE	T1,KDP0+KDPIVA+1;TWO WORD PC
	MOVEM	T1,KDPCHL+1	;SAVE FOR XJEN

	MOVE	T1,KDP0+KDPIVA	;GET T1 BACK
	JSR	KDPSV		;GO SAVE THE AC'S
	MOVEI	W,KDP0		;LOAD W FOR D8KINT
	JRST	KDPAIV##	;GO TO THE INTERRUPT VECTOR "A" ROUTINE

	X(KDPIVB,<EXP 0>)	;VECTOR B.  JSR COMES HERE
	EXP	0		;SECOND WORD OF OLD PC
	EXP IC.UOU,EXP .+1	;NEW PC

	EXCH	T1,KDP0+KDPIVB	;SAVE T1, GET ADDR WE CAME FROM
	MOVEM	T1,KDPCHL	;SAVE ADDR FOR WHEN WE EXIT INTERRUPT
	MOVE	T1,KDP0+KDPIVB+1;TWO WORD PC
	MOVEM	T1,KDPCHL+1	;SAVE FOR XJEN

	MOVE	T1,KDP0+KDPIVB	;GET T1 BACK
	JSR	KDPSV		;SAVE THE AC'S
	MOVEI	W,KDP0		;LOAD W FOR D8KINT
	JRST	KDPBIV##	;GO TO INTERRUPT VECTOR "B" CODE

	LOC	KDP0+KDPLEN	;SKIP OVER THE BLOCK
	PURGE	X,XX		;UNDEFINE THE "HELPER" MACROS
>;M.KDUP
IFE M.KDUP,<			;IF NO KDP'S
	TSTKDP==:CPOPJ		;DEFAULT KDP CHECK ROUTINE
	KDPSEC==:CPOPJ		;KDP ONCE/SECOND ROUTINE
	ZAPKDP==:CPOPJ		; KDP KILL ROUTINE
>
	SUBTTL	DMR Blocks for the DMR11 lines

IFE M.DMRN,<			;IF NO DMR'S
	TSTDMR==:CPOPJ		;DEFAULT DMR CHECK ROUTINE
	DMRSEC==:CPOPJ		;DMR ONCE/SECOND ROUTINE
	ZAPDMR==:CPOPJ		;DMR KILL ROUTINE
>
IFN M.DMRN,<
	DEFINE	X(N),<EXP	DMR'N>
ZZ==0
DMRTBL::REPEAT	M.DMRN,<
	X(\ZZ)
	ZZ==ZZ+1>

	DEFINE	X(N,OFFSET,VALUE),<;;Standard macro
	LOC	DMR'N+OFFSET
	VALUE>

	DEFINE	XX(N,FT,DEF),<
IFNDEF DMR'N'FT,<DMR'N'FT==<DEF>>
IFN DMR'N'FT,<ZZZ==ZZZ+DMRS'FT>>

	DEFINE $DMR(N),<
DMR'N::	X(N,DMRUSR,<EXP	M.'N'DMR>)	;;Initial use of this line
	X(N,DMRCSR,<EXP	DMR1BA+<N*10>>)	;;CSR address of this DMR
	X(N,DMRVEC,<EXP	DMR1IV+<N*10>>)	;;Vector
	X(N,DMRTAD,<EXP	DMR'N'PG>)	;;10 address of this DMR's com region
	X(N,DMRLIN,<XWD	M.KDUP+N,N>)	;;Line # on node,,DMR #
	X(N,DMRIVA,<EXP 0>)		;;Vector "A" Interrupt header
		EXP	0,IC.UOU,.+1	;;This is an XPCW block
		EXCH	T1,DMR'N+DMRIVA	;;GET INTERRUPT PC
		MOVEM	T1,DMRCHL	;;SAVE FOR DMRSV
		MOVE	T1,DMR'N+DMRIVA+1;;GET SECOND WORD OF PC
		MOVEM	T1,DMRCHL+1	;;SAVE IT TOO

		MOVE	T1,DMR'N+DMRIVA	;;Restore T1
		JSR	DMRSV		;;Get our AC block
		MOVEI	W,DMR'N		;;Point to this DMR block
		MOVE	F,DMRTAD(W)	;; and communications page
		JRST	DMRAIV##	;;Process interrupt
	X(N,DMRIVB,<EXP 0>)		;;Vector "B" Interrupt header
		EXP	0,IC.UOU,.+1	;;This is an XPCW block
		EXCH	T1,DMR'N+DMRIVB	;;GET INTERRUPT PC
		MOVEM	T1,DMRCHL	;;SAVE FOR DMRSV
		MOVE	T1,DMR'N+DMRIVB+1;;GET SECOND WORD OF PC
		MOVEM	T1,DMRCHL+1	;;SAVE IT TOO

		MOVE	T1,DMR'N+DMRIVB	;;Restore T1
		JSR	DMRSV		;;Get our AC block
		MOVEI	W,DMR'N		;;Point to this DMR block
		MOVE	F,DMRTAD(W)	;; and communications page
		JRST	DMRBIV##	;;Process interrupt
	ZZZ==0
	XX(N,HD,0);;Default HDX setting
	XX(N,SW,0);;Default switched line setting
	XX(N,LS,1);;Default Long start select
	XX(N,MT,0);;Default maintenance mode
	X(N,DMRSTS,<EXP	ZZZ>)		;;Initial status
	X(N,DMRFEK,<EXP	DR'N'FEK>)	;;Address of our FEK
	X(N,DMRLEN,<BLOCK 0>)
	>;Define $DMR

ZZ==0
REPEAT M.DMRN,<
	$DMR(\ZZ)
	ZZ==ZZ+1>
	PURGE	X,$DMR,XX,ZZZ
>;IFN M.DMRN
SUBTTL	MUUO PROCESSING

	$HIGH
MUUO:	EXECAC			;EXEC ACS
	JRSTF	@[XWD XC.UOU,.+1];HAVE TO DO THIS BY HAND
	MOVE	T1,.USMUO	;GET THE MUUO PC FLAGS
	MOVE	R,.CPADR
	TLNN	T1,(XC.USR)	;WAS THE MUUO DONE IN USER MODE?
	JRST	UUOSY1##	;NO, DISPATCH TO EXEC MODE MUUO HANDLER
	JUMPE	R,MUUO1		;IS THERE A JOB DATA AREA FOR THE JOB DOING THE UUO?
				;NO, MUST BE THE DOORBELL OR ERROR IN THE
				; NULL JOB
	AOS	.CPTUC		;ACCUMULATE THE NUMBER OF UUOS ON THIS CPU
	SKIPN	P,.USEPL	;USE EXTENDED PDL IF THERE IS ONE
	MOVE	P,[XWD MJOBPD##,.JDAT+JOBPDL##]
	MOVEI	F,0		;FLAG NO DDB IN CASE ILLEGAL UUO
	MOVE	J,.CPJOB	;JOB NUMBER OF CURRENT JOB
	JRST	UUOSY1##	;DISPATCH TO MUUO HANDLER
MUUO1:	HRLZ	T1,.USMUO
	IOR	T1,.USMUE
	CAME	T1,WAKINS##	;DOORBELL CALLI
	STOPCD	.+1,STOP,UNJ,	;NO, ILLEGAL NULL JOB UUO
MUUO1A:
IFN FTMP,<
	AOS	.CPNDB		;COUNT NUMBER OF DOORBELLS
	MOVE	P,.CPNPD
	JRSTF	@[IC.UOU+.+1]
	MOVE	T1,.CPQPC
	TDNN	T1,DOORBL
	JRST	MUUO1B
	ANDCAM	T1,DOORBL
	PUSHJ	P,DSKTIC##
	PUSHJ	P,TAPTIC##

IFN M.ENET,<PUSHJ P,KNITIC##>	;KLNI QUEUED I/O
IFN M.SCA,<PUSHJ P,PPDTIC##>	;KLIPA QUEUED I/O

MUUO1B:	MOVE	T1,.CPSCC
	TDNN	T1,DOORBL
	JRST	[USERAC
	 	XJEN	.USMUO]
	ANDCAM	T1,DOORBL
>
	DMOVE	T1,.USMUO
	DMOVEM	T1,.CPPC
	JRST	CLKSPD##	;DISPATCH TO THE SCHEDULAR SINCE SOME
				; JOB IS POSSIBLY NOW RUNNABLE ON THIS CPU
UMPRET::			;HERE ON RETURN FROM MUUO PROCESSING
	POP	P,.USMUP	;RESTORE THE MUUO PC
	POP	P,.USMUO	;RESTORE FLAGS

IFN	FTHPQ,<
	SKIPGE	SCDRTF		;HPQ JOB WAKE UP AND IN CORE?
	  PUSHJ	P,USCHD1##	;YES
>
	USERAC			;RESET USER AC BLOCK
	XJEN	.USMUO

	$LIT			;FORCE LITERALS INTO THE HIGH SEGMENT
SUBTTL	APR INTERRUPTS
;DEFINE MACRO TO CALL KL OR KI OR KS CODE FOR EACH CPU
DEFINE KILS(N)<
IFN	M.KL10,<KL(N)>
IFN	M.KS10,<KS(N)>
>				;END KILS MACRO DEF

	$ABS
;HERE TO TRY TO CONTINUE THE SYSTEM AFTER A CLOCK ERROR STOP
IFN M.KL10,<
APRWRS::EXECAC			;GET CORRECT AC SET
	CONO	APR,AP.IOR	;CLEAR THE WORLD (ACTUALLY, RSX20F ALREADY DID)
	CONO	PI,CLRPIS
	CONO	PAG,0
	JSP	T4,SYSTR0	;SETUP PAGING, FIND OUT WHAT CPU WE ARE
	  JFCL			;DON'T CARE WHETHER BOOT OR NOT
	MOVE	T1,.CPCPN	;CURRENT CPU NUMBER
	MOVEI	P,WRSPTB-1(T1)	;SETUP A VERY SHORT STACK
	LSH	T1,1		;DOUBLE WORD PC
	LDB	T2,[POINT 18,WRSLOC(T1),35] ;CODE FOR RESTART
	DMOVE	T3,WRSLOC(T1)	;GET DOUBLE WORD PC
	DMOVEM	T3,@.CPKAF	;STORE IN KAF LOC

	CAIN	T2,.WRKAC	;IF KAF, REPORT AS SUCH
	XCT	KAF##		;BUTCHERY
	CAIE	T2,.WRPTO	;IF PROTOCOL TIMED OUT, CAN'T RECOVER
	TLNN	T3,(XC.USR)	;PC IN USER MODE?
	STOPCD	.,CPU,WRF,WRSF	;++WARM RESTART FAILED
	SKIPN	J,.CPJOB	;NULL JOB RUNNING?
	JRST	SPRINI		;YES, JUST RESTART IT
	HRRZ	T1,JBTUPM(J)	;USER PROCESS TABLE
	HRRM	T1,@.CPSPT	;SETUP SPT

	TLO	T1,(LG.LUB)	;LOAD USER BASE REGISTER
	DATAO	PAG,T1		;ZAP, ADDRESSABLE
	MOVE	P,[MJOBPD##,,.JDAT+JOBPDL##] ;ESTABLISH A USER CONTEXT STACK
	PUSH	P,T3		;SAVE FLAGS

	PUSH	P,T4		;AND PC
IFN FTMP,<
	SETZM	.CPNBI		;SINCE ESSENTIALLY STARTING OVER, NO BROKEN INTERLOCKS
>;END IFN FTMP
	PUSHJ	P,SETCLK	;SETUP CLOCKS, APR, AND PI
	PUSHJ	P,ENTSPC##	;ENTER SECONDARY PROTOCOL, MAKE SURE 20F IN SAME STATE
	PUSHJ	P,STAPPC##	;NOW, START PRIMARY PROTOCAL
	STOPCD	.,JOB,WRJ,WRSF	;++WARM RESTART GOT JOB

;HERE TO PRINT WARM RESTART CODE

WRSF:	PUSHJ	P,INLMES##	;TELL WHAT'S BEING REPORTED
	ASCIZ	/code = /
	MOVE	T1,.CPCPN	;CURRENT CPU NUMBER
	LSH	T1,1		;TIMES 2
	LDB	T1,[POINT 18,WRSLOC(T1),35] ;WARM RESTART CODE
	PJRST	PRTDI8##	;REPORT IT

WRSPTB:	REPEAT	M.CPU,<
	BLOCK	1		;VERY SHORT PDL TO USE DURING WARM RESTART
>
	LIT
>	;END IFN M.KL10
	$HIGH

IFN M.KS10,<

;ROUTINE TO SET UP PI ASSIGNMENTS ON UNIBUS ADAPTERS

UBAPIS::PUSHJ	P,SAVE1		;FREE UP P1
	MOVEI	P1,1		;START WITH FIRST UNIBUS ADAPTER
UBAPI1:	MOVS	T1,P1		;GET ADAPTER NUMBER,,0
	HRRI	T1,UNBSTW	;ADDRESS OF STATUS REGISTER
	PUSHJ	P,UBGOOD##	;IS UNIBUS ADAPTER THERE?
	  JRST	UBAPI2		;NO--SO DON'T TRY TO INIT IT
	MOVEI	T2,UBINIT	;UNIBUS INIT
	WRIO	T2,(T1)		;DO IT
	MOVE	T2,UBAPIT-1(P1)	;GET PI ASSIGNMENTS FOR THIS ADAPTER
	IORI	T2,UNBDTR	;SET DISABLE XFER BIT
	WRIO	T2,(T1)		;SET UP AND INIT UNIBUS ADAPTER
UBAPI2:	CAIGE	P1,MAXUBA	;DONE ALL ADAPTERS?
	AOJA	P1,UBAPI1	;NO, DO NEXT
	POPJ	P,		;RETURN

UBAPIT::EXP	UBA1PI		;PI ASSIGNMENT FOR ADAPTER 1
	EXP	UBA2PI		;PI ASSIGNMENT FOR ADAPTER 2
	EXP	UBA3PI		;PI ASSIGNMENT FOR ADAPTER 3
	EXP	UBA4PI		;PI ASSIGNMENT FOR ADAPTER 4
>; END IFN M.KS10
;DEFINE KL10 APR INTERRUPT HANDLER
; IT CALLS CPU INDEPENDENT CODE AS SOON AS POSSIBLE

DEFINE	KL(N)<
	$ABS

AP'N'INT:CONSO	APR,@.C'N'CON	;INTERRUPT FOR APR (MONITOR OR USER ENABLED)
	JRST	.-1		;NO, TRY NEXT DEVICE ON THIS PI CHANNEL
	JRST	APRINT##	;ENTER COMMON CODE

TM'N'INT::EXP	0,0,IC.UOU,TIMINT## ;KL10 INTERVAL TIMER INTERRUPT HANDLER

AP'N'KAF:EXP	0,0,IC.UOU,APRKAF## ;KL10 KEEP-ALIVE FAILURE TRAP HANDLER

EP'N'PDL::BLOCK	<EPLLEN==:60>	;;FIRST WORD IS "P" OF OVERFLOW

> ;END KL10 MACRO
;DEFINE KS10 APR INTERRUPT HANDLER
; IT CALLS CPU INDEPENDENT CODE AS SOON AS POSSIBLE

DEFINE	KS(N)<
	$ABS

AP'N'INT:CONSO	APR,@.C'N'CON	;INTERRUPT FOR APR (MONITOR OR USER ENABLED)
	JRST	.-1		;NO, TRY NEXT DEVICE ON THIS PI CHANNEL
	JRST	APRINT##	;ENTER COMMON CODE

AP'N'KAF:EXP	0,0,IC.UOU,APRKAF## ;KS10 KEEP-ALIVE FAILURE TRAP HANDLER

EP'N'PDL::BLOCK	<EPLLEN==:10>	;;FIRST WORD IS "P" OF OVERFLOW

	$HIGH
>;END KS10 MACRO
;GENERATE APR INTERRUPT CODE DEPENDING ON M.CPU AND KL VS KS
ZZ==0
REPEAT M.CPU,<				;NO OF CPUS IN SYSTEM
	KILS(\ZZ)			;GENERATE INTERRUPT CODE
	ZZ==ZZ+1			;STEP TO NEXT CPU NUMBER
>
	$ABS
SUBTTL EXTERNS TO FORCE LIBRARY LOADING

	$HIGH

;GENERATE EXTERNAL GLOBALS TO CAUSE LOADING OF PROPER ROUTINES FROM
; MONITOR LIBRARY TAPE IF THERE IS ONE


;ALWAYS LOAD CLOCK1,COMCON,CORE1,ERRCON,JOBDAT,PATCH,UUOCON,DATMAN,TMPUUO,
; AND APRSER

EXTERNAL VMSER,VMDTJB,PFH,APRSER

IFE M.KL10,<
	XP	UDTE,CPOPJ	;NO DTE. UUO
>
IFN M.KL10,<
EXTERNAL DTESER,TTDINT,FEDSER
>
EXTERNAL CLOCK1,COMCON,CORE1,ERRCON,CRSINI,PATCH,UUOCON,DATMAN,TMPUUO,MONEND

;LOAD FILE SERVICE ROUTINES, REFRESHER & ONCMOD (EXTRA ONCE ONLY CODE) FOR LEVEL D
;LEVEL D ALSO REQUIRES COMMOD, WHICH IS A SEPARATE FILE OF DISK PARAMETERS
	EXTERN	COMMOD, FILFND,	FILIO,	FILUUO,	ONCMOD,	REFSTR

	$ABS

;ENTER DDT

ENTDDT:	JFCL	DDTX		;FIRST ENTRY PATCHES THIS TO JRST
	EXECAC			;GET AC SET RIGHT
	CONO	APR,AP.IOR	;BLAST
	CONO	PI,CLRPIS	;BLAST
IFN M.KL10,<
	CONO	PAG,0		;INSURE THAT THE CACHE IS OFF
>
	JSP	T4,SYSTR0	;SEE WHICH CPU THIS IS AND SETUP THE EBR
	  JFCL			;REALLY SHOULD BE THE BOOT CPU
	SETZM	.JBEDV##	;PREVENT JUNK FROM SAVE/GET FROM CONFUSING EDDT
	MOVSI	T1,(JRST)	;ONLY NEED (WANT) TO DO THIS ONCE
	HLLM	T1,ENTDDT	; AS MONITOR WILL TURN ON PAGING FOR US
	JRST	DDTX		;ENTER DDT

	EXTERN	DDTX		;LOAD EXEC DDT
	EXTERN	SCHED		;LOAD SCHEDULER
	EXTERN	SWPSER		;LOAD SWAPPER
	EXTERN	SEGCON		;LOAD SEGMENT CONTROL
SUBTTL	KL10 SYSTEM TIME BASE ROUTINES
	$HIGH
IFN M.KL10,<

;ROUTINE TO SETUP INITIAL TIME BASE VALUE, CALLED BY SYSINI AFTER ONCE

SETIME::MOVE	T1,DATE		;GET UNIVERSAL DATE/TIME
	MULI	T1,^D86400	;GET SECONDS SINCE NOV 17,1858
	ASHC	T1,^D17		;PUT BINARY POINT AFTER BIT
				; 35 OF T1 YIELDING
				; SECONDS SINCE NOV 17, 1858
				; IN T1
	MUL	T1,[RTUPS*^D10]	;CONVERT TO 1 USEC UNITS FOR TIME BASE
	ASHC	T1,<^D35-TB.LTP>;ACCOUNT FOR COUNTS/TICK
	CONO	MTR,MO.TOF!MO.CTB ;TURN OFF TIME BASE, CLEAR IT.
	MOVE	T3,.CPEPT	;ADDRESS OF THIS PROCESSOR'S EPT
	DMOVEM	T1,.EPTMB(T3)	;STORE UNIVERSAL DATE TIME BASE (RUNS OUT IN 5028
	MOVEI	T2,MO.LAC!MO.AO!MO.AEN!MO.AIP	;INITIALIZE ACCOUNTING
	MOVEI	T1,ST%XPI	;CHECK IF PI TIME IS EXCLUDED
	TDNE	T1,CNFST2	;SKIP IF IT IS NOT EXCLUDED
	TRZ	T2,MO.AIP	;IT IS, DO NOT INCLUDE
	CONO	MTR,MO.TON+APRCHN(T2) ;TURN TIME BASE ON, DO GOOD STUFF
	RDTIME	.CPRTM		;SET UP TIME BASE FOR APRTIM
	PUSHJ	P,GETIME	;GET TIME SO WE CAN
	MOVEM	T1,.CPXTM	;SET UP THE FIRST LAST TIME
	POPJ	P,


RTUPS==:^D100000		;RESOLUTION OF ACCOUNTING
RTUPS3==:RTUPS/^D1000		;FOR USE IN JOBTIM: ROUTINE
RTUPS5==:RTUPS/^D100000

;GET TIME OF DAY IN RTUPS UNITS/SECOND
; USES ACS T1-T4

GETIME::SETZB	T1,T2		;CLEAR T1,T2 FOR DDIV
	RDTIME	T3		;GET UNIVERSAL TIME IN TIME BASE UNITS
	ASHC	T3,<TB.LTP-^D35>	;ACCOUNT FOR COUNT/TIME BASE TICK
	DDIV	T1,RTCMTT	;DIVIDE BY RTCMAX*10, YIELDING UNIVERSAL
				; DATE IN T1,T2 AND USECS SINCE MIDNITE IN T3,T4
	DIVI	T3,^D10		;CONVERT TO RTUPS UNITS (10 USECS)
	MOVE	T1,T3		;AND GET FINAL ANSWER IN T1
	POPJ	P,		;RETURN

RTCMAX::RTUPS*^D3600*^D24	;RTUPS UNITS/DAY
RTCMTT:	EXP	2,203565660000	;RTUPS*^D3600*^D24*^D10 (MICROSECS/DAY)

>;END IFN M.KL10
SUBTTL	KS10 SYSTEM TIME BASE ROUTINES
IFN M.KS10,<

;ROUTINE TO SETUP INITIAL TIME BASE VALUE, CALLED BY SYSINI AFTER ONCE
; COMPUTES DATE BY CALLING SUDATE

SETIME::MOVE	T1,DATE		;GET UNIVERSAL DATE/TIME
	MULI	T1,^D86400	;GET SECONDS SINCE NOV 17,1858
	ASHC	T1,^D17		;PUT BINARY POINT AFTER BIT
				; 35 OF T1 YIELDING
				; SECONDS SINCE NOV 17, 1858
				; IN T1
	MULI	T1,^D1000	;MILLISECOND RESOLUTION
	ASHC	T1,^D12		;ACCOUNT FOR COUNTS/TICK
	WRTIME	T1		;LOAD TIME BASE
	MOVEI	T1,<^D17>B23	;INTERVAL FOR TIMER
	WRINT	T1		;LOAD INVERVAL FOR TIMER
	RDTIME	.CPRTM		;SET UP TIME BASE FOR APRTIM
	WRAPR	SP.CSF+SP.ESF+SP.ITI+APRCHN ;TURN INTERVAL TIMER ON
	PUSHJ	P,GETIME	;GET TIME SO WE CAN
	MOVEM	T1,.CPXTM	;SET UP THE FIRST LAST TIME
	POPJ	P,		;END RETURN


RTUPS==:^D100000		;RESOLUTION OF ACCOUNTING
RTUPS3==:RTUPS/^D1000		;FOR USE IN JOBTIM: ROUTINE
RTUPS5==:RTUPS/^D100000

;GET TIME OF DAY IN RTUPS UNITS/SECOND
; USES ACS T1-T4

GETIME::SETZB	T1,T2		;CLEAR T1,T2 FOR DDIV
	RDTIME	T3		;GET UNIVERSAL TIME IN TIME BASE UNITS
	DDIV	T1,RTCMTT	;DIVIDE BY TICS/DAY, YIELDING UNIVERSAL
				; DATE IN T1,T2 AND TICS SINCE MIDNITE IN T3,T4
	DIVI	T3,^D41		;CONVERT TO RTWPS UNITS
	MOVE	T1,T3		;GET INTO T1 (IN 10 USEC UNITS)
	POPJ	P,		;RETURN

RTCMAX::RTUPS*^D3600*^D24	;RTUPS UNITS/DAY
RTCMTT:	EXP	12,117226200000	;CLOCK TICS PER DAY AT 4.1 MHZ
RTCDAY==:CPOPJ


>;END IFN M.KS10
;MOS MEMORY

IFN M.MOS,<EXTERN MOSSER>
IFE M.MOS,<EQUATE (GLOBAL,CPOPJ,<SBERR,MOSGTM,MOSGVM,MOSMIN>)>

;DEFINE GLOBALS IF NO EXTENDED ADDRESSING SUPPORT
IFE FTXMON,<
	XP	SSPCS,CPOPJ
	XP	SVPCS,CPOPJ
	XP	STPCS,CPOPJ
	XP	SPCS,CPOPJ
>


SUBTTL PROCESSOR STUFF

;MAKE SURE THAT PROPER VERSION OF FEATURE SWITCH FILES WERE USED TO ASSEMBLE
;THE REST OF THE MONITOR
;THE LOADER WILL PRINT MUL. DEF. GLOBAL IF A MISTAKE HAS BEEN MADE

;DUAL PROCESSOR SYSTEM ROUTINE GETS LOADED HERE
IFG <M.CPU-1>,<EXTERN	CPNSER>

;DEFINE GLOBAL RESTRICTING MAXIMUM SIZE OF CORE FOR ANY SINGLE USER.
;THIS CAN BE ALTERED AT SYSINI TIME BY PATCHING THE RIGHT HALF OF CORLIM.
IFE M.CORE, <
	IFE FTXMON,<COREN==^D256_K2PLSH>
	IFN FTXMON,<COREN==<<MXSECN+1>*^D256>_K2PLSH>
> ;END IFE M.CORE
IFN M.CORE,<COREN==M.CORE>

	$ABS

;NOTE: THESE SYMBOLS WILL GO AWAY SOON SO THAT AP.??? SYMBOLS
; WILL BE USED INSTEAD AS DEFINED IN S.MAC
;APR AND PI BITS

;APR BITS FOR BOTH PDP-6 AND KA10


	CLKBIT==:1
	REPEAT	7-CK0CHN, <CLKBIT==:CLKBIT*2>
	REQCLK==:PI.IIO+CLKBIT	;REQUEST INTERRUPT ON LOW PRIORITY CLK CHANNEL
	ZZ==1
	REPEAT	7-SCNCHN,<ZZ==ZZ*2>
	REQCTY==:PI.IIO+ZZ	;FOR KL10 CTY, MUST INTERRUPT ON SCANNER PI BY HAND
	CLRCTY==:II.CPP+ZZ	;CLEAR PSEUDO-CTY INTERRUPT (KL10)

	CLRPIS==:11577		;CLEAR THE PI SYSTEM

;NOW HARDWARE BITS WHICH DEPEND ON SOFTWARE CONFIGURATION:

	XP	XI.RQC,REQCLK	;CONO PI.XI.RQC REQUESTS CLK INTERRUPT
	XP	II.CCI,II.CPP+CLKBIT
XP XC.UOU,UIOMOD

;DEFINE APR SYMBOLS

	APRCHN==:AP0CHN		;PI CHANNEL
	PIPROG==:77400		;PI STATUS REGISTER
	SYSOFF==:<177_-APRCHN>+PI.TFP ;TURNS OFF ALL PI CHANNELS BELOW APR
	SYSON==:<177_-APRCHN>+PI.TNP ;TURNS ON ALL PI CHANNELS BELOW APR

	AP.NOT==:PIPROG-<400_<7-APRCHN>> ;ALL PI IN PROGRESS FLAGS EXCEPT APR
	AP.APP==:1_<7-APRCHN+10> ;APR PI IN PROGRESS
	AP.ACO==:1_<7-APRCHN>	;APR CHANNEL ON

;NON-EXISTANT MEMORY BIT
IFN M.KL10,<AP.NXM==:LP.NXM>	;NON-EX MEM (APR STATUS WORD)
IFN M.KS10,<AP.NXM==:SP.NXM>

;MASK TO TEST/CLEAR NON-EXISTANT MEMORY ERRORS
IFN M.KL10,<AP.NXE==:LP.CSF+LP.NXM>
IFN M.KS10,<AP.NXE==:SP.CSF+SP.NXM>

;MASK TO TEST/CLEAR MEMORY PARITY ERRORS
IFN M.KL10,<AP.MPE==:LP.CSF!LP.PAR>
IFN M.KS10,<AP.MPE==:SP.CSF!SP.HMP>

;MASK TO RESET APR FOR NULL JOB
IFN M.KL10,<APRNUL==:LP.ESF!LP.CSF+LP.SBE+LP.NXM+LP.PAR+LP.IOF+LP.PWF+LP.CDP+LP.ADP+LP.CSD+APRCHN>
IFN M.KS10,<APRNUL==:SP.ESF!SP.CSF!SP.PWF!SP.ITI!SP.FEI+APRCHN>
	APRRST==:APRNUL+AP.IOR	;RESET APR FOR SYSINI (I/O RESET TOO)

;APR CONSO MASK
IFN M.KL10,<AP.CSO==LP.PAR+LP.PWF+LP.SBE+LP.NXM+LP.IOF+LP.CDP+LP.ADP>
IFN M.KS10,<AP.CSO==SP.PWF+SP.ITI+SP.FEI>

;APR ENABLE BITS
IFN M.KL10,<AP.EEB==LP.NXM+LP.SBE+LP.PAR+LP.PWF+LP.IOF+LP.CDP+LP.ADP+LP.CSD>
IFN M.KS10,<AP.EEB==SP.PWF+SP.ITI+SP.FEI>

;MASK TO CLEAR APR ERRORS
IFN M.KL10,<AP.CAE==LP.CSF+LP.NXM+LP.PAR+LP.IOF+LP.PWF+LP.SBE+LP.CDP+LP.ADP>
IFN M.KS10,<AP.CAE==SP.CSF+SP.PWF+SP.HMP+SP.NXM>
;IF THERE IS ONLY ONE CPU IN THIS SYSTEM DEFINE ALL NECESSARY GLOBALS

IFE <M.CPU-1>,<			;NO SECOND CPU?
	$HIGH
STMPEC::MOVE	P4,.C0EPT
	DPB	P3,P2
	CLRPGT
	POPJ	P,

IFN FTMP,<
	$CSUB

	MSCHED==:SCHEDJ##
	CP1CRS==:SAVPC2##
	CP1MFL==:SAVPC2##
	CPNBPT==:APRABK##
	EQUATE (GLOBAL,CPOPJ,<BECOM0,BECOM1,BRKLOK,BRKSIW,LOKDIE,ULKDIE,BRKDIE>)
	EQUATE (GLOBAL,CPOPJ,<CPUZAP,MSTUUO,DPXST,CLRJSP,SETJSP,ALLJSP,CLRSJ0>)
	EQUATE (GLOBAL,CPOPJ,<SETSJ0,CPUOFS,CPUFND,CPUDET,CPUDTU,CPUATT,CPUATU>)
	EQUATE (GLOBAL,CPOPJ,<GIVMM,DIFMM,UIFMM,REMMM,GGVMM,UPMM,DWNMM,TGVMM>)
	EQUATE (GLOBAL,CPOPJ,<UPMC,DWNMC,LOKSCD,ULKSCD,SBSCD,CLRCCB,CPUCMD>)
	EQUATE (GLOBAL,CPOPJ,<MAPUEC,MAPUC,CHKDIE,ONCPU0,SETCPF,SCDSS1,SETQPB>)
	EQUATE (GLOBAL,CPOPJ,<SETQP1,ONCPUL,ONCPUD,ONCPUN,SETCPN,CP1CHK,RWRTCH>)
	EQUATE (GLOBAL,CPOPJ,<MAPINI>)
	EQUATE (GLOBAL,CPOPJ1,<UXITMP,CP0RC,CP1AC,SPSTOP,DXRUN,GETMM,SCDMM>)
	EQUATE (GLOBAL,CPOPJ1,<MMOWN,CPLCK,CP1STP,SETCPP,ONCPUS,BUFSSN>)
;LOCATIONS IN SLAVE CDB WHICH ARE CHECKED INDIVIDUALLY BY MASTER:
;FOLLOWING LOC ALWAYS ZERO (SINCE NO CPU1)
.E1MP==:0
JBTST3==:0

IFN M.KL10,<			;IF CPNSER NOT LOADED AND KL10
	EQUATE (GLOBAL,CPOPJ,<CLCSN,SETCSN,SETCSJ,CTXSWP,CSREQS,CLRCSH,CKCP1C>)
	EQUATE (GLOBAL,CPOPJ,<CHKSWS,CHKCSH,SBCCSH,SETCSB,SETPCP,UNCACH>)
	EQUATE (GLOBAL,CPOPJ1,<SCDCSH,SWPCSH,MLSCSH>)

	$HIGH
CKNBF::
CHKNB::	HRLZ	T1,DEVNBF(F)
	HRRZS	DEVNBF(F)
	ADDM	T1,DEVNBF(F)
STONBF::POPJ	P,
	$ABS
DT1CMD::
DT1MTD::0
	$HIGH
>;END IFN M.KL10

CHKCPI::AOS	(P)
GETCAM::MOVE	T1,.CPBIT
	POPJ	P,
CHKCPU::
CPUOK::	AOS	(P)
CAMCPU::SETZ	T1,
	POPJ	P,


CRESET::
	SETZM	.C0STS
	POPJ	P,
>	;END IFN FTMP
	$CSUB
	EQUATE (GLOBAL,CPOPJ,<SETCDN>)
	EQUATE (GLOBAL,CPOPJ1,<LSTCPU,ANYRUN,SETCPU,SETCRN,CPSCHK,SCDOWN>)
	EQUATE	(GLOBAL,0,<CPUDIA>)
	$HIGH
ANYCPU::CAME	J,.CPJOB
	AOS	(P)
	POPJ	P,		;TURN ON DEVICE PI LEVEL
GIVLOK::NTGIVE
	POPJ	P,
	$ABS
BCOM0::	POPJ	P,
>	;END IFE M.CPU-1
;INTERNAL HERE FOR 10/40N, MUST BE SAME AS IN COMMOD

	FNCEXC==:1		;EXECUTE ONLY
	FNCRED==:2		;READ
	FNCALL==:3		;ALLOCATE
	FNCDLL==:4		;DEALLOCATE
	FNCAPP==:5		;APPEND
	FNCUPD==:6		;UPDATE
	FNCCRE==:7		;CREATE
	FNCSUP==:10		;SUPERSEDE
	FNCTRN==:11		;TRUNCATE
	FNCCAT==:12		;CHANGE ATTRIBUTES(EXCEPT PRIVILEGE,NAME,DIR)
	FNCDEL==:13		;DELETE
	FNCCNM==:14		;CHANGE NAME
	FNCCPR==:15		;CHANGE PRIVILEGE
	SUBTTL	REAL TIME TRAPPING
IFN FTRTTRP,<
IFG M.RTD,<
	EXTERN	RTTRP
	$HIGH

RTMCAN==:.USMUE
RTMUAC::POINT	4,.USMUO,30	;UUO AC FIELD
RTMUOC::POINT	9,.USMUO,26	;UUO OPCODE FIELD


;TRPGO IS ENTERED FROM THE CHANNEL SAVE ROUTINE DURING A REAL TIME DEVICE
; INTERRUPT. RELAVENT LOCATIONS FROM THE USER PAGE MAP PAGE, TRPFLG, AND
; LOCATION 61 ARE SAVED. THE REAL TIME USER'S UPMP AND TRAP LOCATIONS ARE
; SETUP AND CONTROL IS TRANSFERRED TO THE USER'S INTERRUPT ROUTINE IN USER
; MODE.

TRPGO::	MOVE	T1,@.CPSPT	;SPT
	MOVEM	T1,1(P)		;SAVE THAT
	MOVE	T1,RELTB1##(J)	;REAL TIME PROGRAM'S PROCESS TABLE
	HRRM	T1,@.CPSPT	;PART OF MAKING THE JOB ADDRESSABLE
	DATAO	PAG,RELTB1##(J)	;SETUP THE INTERRUPT LEVEL USER'S BASE REGISTER
	ADD	P,[XWD 22,22]	;OFFSET THE STACK FOR SAVING BACKGROUND
				; CONTEXT OF THE INTERRUPT LEVEL USER
	MOVSI	T1,.USPFT	;STARTING AT THE PAGE FAULT TRAP INSTRUCTION
	HRRI	T1,-20(P)	; THROUGH THE PUBLIC TRAP NEW MUUO PC
	BLT	T1,(P)		; SAVE THE BACKGROUNG UPMP
	MOVE	T1,[XWD RTTUPM,.USPFT]
	BLT	T1,.UPMP+437	;SETUP THE INTERRUPT LEVEL UPMP
	PUSH	P,.USPFW	;SAVE PAGE FAIL WORD
	PUSH	P,.USPFP	; AND OLD P.F. PC
	PUSH	P,.USPFP+1	; ...
	PUSH	P,.USPFN	; AND NEW P.F. PC
	MOVEI	T1,RTTILM	;WHERE TO GO ON ILM
	MOVEM	T1,.USPFN	;STORE THAT
	HRRI	T1,RTTAOF	;ADDRESS OF INTERRUPT LEVEL ARITHMETIC
				; EXCEPTION PROCESSING ROUTINE
IFN M.KL10,<HLL T1,-22(P)>
	MOVEM	T1,.USAOT	;ENABLE OR DISABLE INTERRUPT LEVEL ARITHMETIC
				; TRAPPING
	PUSH	P,.CPDMI	;SAVE 61
	PUSH	P,.CPRTT	;AND LOWER LEVEL TRPFLG
	HRLI	J,400000	;MAKE TRPFLG NEGATIVE, USER MODE OFF
				; FOR CHN TEST ON WHETHER TO SAVE ACS
	MOVEM	J,.CPRTT	;SETUP TRPFLG FOR THIS INTERRUPT LEVEL USER
	MOVE	T1,DISMT1##(J)	;GET THE DISMISS INSTRUCTION FOR THIS INTERRUPT
				; LEVEL
	MOVEM	T1,.CPDMI	;STORE IT IN 61
	JRST	2,@TRPTB1##(J)	;ENTER THE USER'S INTERRUPT ROUTINE IN USER MODE
;DISMIS IS ENTERED FROM THE CHANNEL DISMISS ROUTINE BY A JSP J,DISMIS.
; THE STATE OF THE MACHINE IS RESTORED AND THE ROUTINE RETURNS TO THE
; CHANNEL DISMISS ROUTINE TO RESTORE THE AC'S AND DISMISS THE INTERRUPT.

DSMAPR:
DISMIS:	POP	P,.CPRTT	;RESTORE LOWER LEVEL TRPFLG
	POP	P,.CPDMI	;RESTORE 61
	POP	P,.USPFN	;RESTORE NEW P.F. PC
	POP	P,.USPFP+1	;RESTORE OLD P.F. PC
	POP	P,.USPFP	;...
	POP	P,.USPFW	;RESTORE P.F. WORD
	SUB	P,[XWD 20,20]	;SET STACK OFFSET FOR RESTORING BACKGROUND
				; UPMP
	MOVSI	T1,(P)		; ..
	HRRI	T1,.USPFT	;STARTING AT PAGE FAULT TRAP INSTRUCTION
	BLT	T1,.UPMP+437	; RESTORE UPMP THROUGH PUBLIC TRAP NEW MUUO PC
	MOVE	T1,-1(P)	;SPT AT INTERRUPT
	HRRM	T1,@.CPSPT	;RESTORE THAT

	JRST	(J)		;RESTORE AC'S AND DISMISS THE INTERRUPT

;INTERRUPT LEVEL USER PAGE MAP PAGE

RTTUPM:	RTTILM
	RTTAOF
	RTTPOF
	JFCL
	0
	0
	IC.UOU+RTTILM
	RTTILM
	EXP	MUUO
	EXP	KTUUO
	EXP	SNTUUO
	EXP	STUUO
	EXP	RTCNTU
	EXP	KTUUO
	EXP	RTPNTU
	EXP	KTUUO
;HERE ON A UUO AT INTERRUPT LEVEL

RTCNTU:RTPNTU:
	MOVE	17,.USMUP	;30 BIT PC, NOT REALLY, MUST BE IN SECTION 0
	HLL	17,.USMUO	;UUO FLAGS
	JRSTF	@[IC.UOU+UUOHND##] ;TURN ON USRIOT BY HAND AND DISPATCH TO UUO HANDLER



;HERE ON AN ARITHMETIC EXCEPTION AT INTERRUPT LEVEL

RTTAOF:	SKIPL	.CPRTT		;INTERRUPT IN PROGRESS?
	JRST	.CPDMI		;NO, JUST DISMISS
	MOVEM	T1,.JDAT+.JBCNI##
	MOVEI	T1,AP.AOV+AP.FOV;REASON FOR THE TRAP
	JRST	ERRGO		;JOIN COMMON CODE

;HERE ON A PUSH DOWN LIST OVERFLOW AT INTERRUPT LEVEL

RTTPOF:	SKIPL	.CPRTT		;INTERRUPT IN PROGRESS?
	JRST	.CPDMI		;NO, JUST DISMISS
	MOVEM	T1,.JDAT+.JBCNI##
	MOVEI	T1,AP.POV	;TELL USER THE REASON FOR THE TRAP
	JRST	ERRGO		;JOIN COMMON CODE

;HERE ON AN ILLEGAL MEMORY REFERENCE (PAGE FAULT) AT INTERRUPT LEVEL

RTTILM:	SKIPL	.CPRTT		;INTERRUPT IN PROGRESS?
	JRST	.CPDMI		;NO, JUST DISMISS
	MOVEM	T1,.JDAT+.JBCNI##
	MOVE	T1,.USPFP
	TLNN	T1,(XC.USR)	;PC IN EXEC MODE?
	STOPCD	.,STOP,RTTIME,	;++ILLEGAL (REAL-TIME) MEMORY REFERENCE FROM EXEC
	MOVEM	T1,.USMUO
	MOVE	T1,.USPFP+1
	MOVEM	T1,.USMUP
	MOVEI	T1,AP.ILM	;TELL USER THE REASON FOR THE TRAP
ERRGO:	MOVEM	J,.CPRTS	;SAVE AN AC
	MOVE	J,.CPRTT	;GET INDEX INTO REAL TIME BLOCK
	EXCH	T1,.JDAT+.JBCNI##
	EXCH	T1,.USMUP	;GET THE TRAP PC
	HLL	T1,.USMUO	;FLAGS

	EXCTXU	<MOVEM T1,@APRTB1##(J)>
	HRR	T1,APRTB1##(J)	;ADDRESS OF THE USER'S TRAP HANDLING ROUTINE
	HRRI	T1,1(T1)	;CLEAR ALL FLAGS WHICH COULD CAUSE A TRAP
	TLZ	T1,(XC.OVF+XC.FOV+XC.TRP+XC.FUF+XC.NDV)
	EXCH	T1,.USMUP	;RESTORE T1 AND STORE PC
	MOVE	J,.CPRTS	;RESTORE J
	JRSTF	@.USMUP	;AND ENTER USER'S TRAP HANDLING ROUTINE

	$ABS
ENBSTD==470550+APRCHN

RTBSIZ==:23

RTBLK::	BLOCK	M.RTD*RTBSIZ
>>
IFE FTRTTRP,<IFN M.RTD,<
PRINTX ;PLEASE ASSEMBLE SOURCES WITH FTRTTRP=-1
>>
IFN FTRTTRP,<IFE M.RTD,<
SAV41==:CPOPJ
SAV61==:CPOPJ
>>
	;CREATE JBTRTD TABLE ONLY IF THERE ARE REAL TIME DEVICES OR
	;HIGH PRIORITY QUEUES OR THE HIBERNATE-WAKE FEATURE.
	;LH(JBTRTD) = REAL TIME STATUS BITS FOR HPQ AND HIBERNATE-WAKE
	;RH(JBTRTD) = COUNT OF REAL TIME DEVICES OWNED BY EACH JOB

JBTRTD:: BLOCK JOBN
CLRRTD::SETZM	JBTRTD(J)


;JBTRTD BIT DEFINITIONS

;BITS 27-35	ARE THE COUNT OF THE NUMBER OF REAL TIME DEVICES OWNED BY THIS JOB

;BITS 23-26	ARE TEMPORARY HPQ (SHARABLE DEVICE OWNER)

;BITS 15-17	ARE THE HIBERNATE PROTECTION CODE FOR THIS JOB

;BIT 14		IS TTY INPUT ACTIVITY ENABLE - CHARACTER MODE
;BIT 13		IS TTY INPUT ACTIVITY ENABLE - LINE MODE

;BIT 12		IS PTY ACTIVITY ENABLE

;BIT 11		IS I/O ACTIVITY ENABLE

;BIT 10 IF HIBER UUO AC IS AN ALIAS FOR IPCACE IN JBTRTD
;BIT 10		IS THE WAKE BIT - THIS BIT IS SET TO WAKE THE JOB UP BY HIBER

;BITS 6-9	ARE THE CURRENT HIGH PRIORITY QUEUE POSITION OF THIS JOB

;BITS 2-5	ARE THE CONSOLE COMMAND SETTING OF HPQ FOR THIS JOB

;BIT 1 IS IPCF EVENT ENABLE
;BIT 0 IS ONLY AN EXEC PROCESS CAN WAKE THE JOB
;BIT 0 OF HIBER UUO AC ARG IS 1 IF JOB IS TO BE SWAPPED IMMEDIATELY
;BUT NEVER STORED IN JBTRTD
	$HIGH
TTIALE==:20		;TTY INPUT ACTIVITY - LINE MODE
TTIACE==:10		;TTYINPUT ACTIVITY - CHARACTER MODE
TTILCE==:TTIALE!TTIACE	;TTY INPUT - LINE AND CHARACTER MODE ENABLE
PTYWUE==:40		;PTY WAKE UP ENABLE BIT
IOACE==:100		;I/O ACTIVITY ENABLE BIT
WAKEB==:200		;WAKE UP BIT

	IPCACE==:200000	;IPC EVENT ENABLE
	IPCUUB==:200	;USERS ARG FOR IPC ACTIVITY


TTIUDI==:1B18		;BATCON/MIC ENABLE FLAG
UDIUUB==:(1B9)		;USERS ARG FOR DEMANDING INPUT

MONHBR==:400000		;ONLY THE MONITOR CAN WAKE THIS JOB
			; (STORED IN JBTRTD)
HBRSWP==:400000		;SWAP ME OUT IMMEDIATELY
			; (NOT STORED IN JBTRTD)
HBRSEC==:200000		;TIME IS IN SECONDS

HIBPRT::POINT	7,JBTRTD(J),17	;HIBERNATE PROTECTION CODE


IFN FTHPQ,<
HPQPNT::POINT	4,JBTRTD(J),9	;CURRENT HIGH PRIORITY QUEUE
HPQPT1::POINT	4,JBTRTD(T1),9
HPQPT2::POINT	4,JBTRTD(T2),9
HPQSPT::POINT	4,JBTRTD(J),5	;HIGH PRIORITY QUEUE SET BY CONSOLE COMMAND
HPQPN3::POINT	4,JBTRTD(T3),9
HPQMSK==:170000			;BIT FIELD OF CONSOLE COMMAND HPQ
HPUMSK==:(17B9)		;CURRENT HPQ MASK
>
IFE FTHPQ,<
XP HPQMSK,0			;NO MASK IF NO HIGH PRIORITY QUEUE
>
IFE M.RTD,<
RTINI==:CPOPJ
RTREL==:CPOPJ
RTTRP==:CPOPJ
>

IFE FTLOCK,<
LOKJOB==:CPOPJ
UUNLOK==:CPOPJ
IFN M.LOK,<
PRINTX ;PLEASE ASSEMBLE SOURCES WITH FTLOCK=-1
>>

IFN M.LOK,<
	EXTERN	LOKCON

PDLPNO==:.UUPMP/PAGSIZ
>
IFN FTLOCK,<

	IFE	M.LOK,<

LOKJOB::MOVEI	T1,0		;ERROR CODE 0 MEANS NOT IMPLEMENTED
	JRST	STOTAC##
UNLOCK::MOVSI	T1,NSHF!NSWP
	ANDCAM	T1,JBTSTS(J)
	POPJ	P,

MOVPAG::STOPCD	.,STOP,SMP,	;++ SHOULDN'T MOVE PAGE

EQUATE	(GLOBAL,CPOPJ,<CHKLPG,CKLJB,CKMOL,CONEVA,LOCK0,LOKEVX,LOKINI>)
EQUATE	(GLOBAL,CPOPJ,<LOKPHY,MEMOFL,MEMOFU,NEWCMX,UNLOKH,UUNLOK>)
EQUATE	(GLOBAL,CPOPJ1,<LOKCHK,LOKEVC,LOKHGH,LOKSWP,SETLPR>)
EQUATE	(GLOBAL,0,<EVLPTR,LOKINS>)
>
LOKASK==:M.LOK
LOKMAX==:M.MGC
IFE M.MGC,<LOKMAX==:-1>
>

IFN M.LOK!<M.CPU-1>,<	;ROUTINE REQUIRED IF LOCK OR MULTIPLE CPUS

;SUBROUTINE TO SLEEP A TICK AND THEN RETRY AN OPERATION. ALWAYS RETURNS TO
; CALL MINUS ONE

DELAY1::PUSHJ	P,SAVT		;DON'T CLOBBER CALLERS ACS
	MOVEI	T1,0		;SLEEP 1 TIC
	S0PSHJ	SLEEPF##	;SLEEP BUT DON'T CLOBBER F
	SOS	-5(P)		;BACK UP PC TO THE TEST
	SOS	-5(P)		; ..
	POPJ	P,		;RETURN TO CHECK AGAIN

>;END IFN M.LOK!<M.CPU-1>

SUBTTL HIGH PRIORITY QUEUE UUO

IFN FTHPQ,<
IFG M.HPQ,<
HPQ::	PUSHJ	P,HPQST1	;CHECK HPQ LEGALITY
	JRST	RTM1##		;NO, GIVE ERROR RETURN
	JUMPE	T2,CPOPJ1	;IF NO PRIVILEGES DONT RESCHEDULE
	SYSPIF
	SKIPN	SCDRTF		;IS THERE A FORCED SCHEDULE BEING DONE
	SETOM	SCDRTF		;NO, SO START ONE
	SYSPIN
	SETOM	.CPHQU		;FLAG HPQ UUO DONE SO SCHEDULER WILL
				; REQUEUE CURRENT JOB TO NEW HPQ
	JRST	CPOPJ1		;SKIP RETURN TO USER


HPQPRV:	POINT	4,JBTPRV(J),3+^L<PVHPQ>-^D18	;MAXIMUM HPQ ATTAINABLE BY THIS JOB


HPQSET:	TDZA	T2,T2		;SKIP JACCT TEST
HPQST1:	MOVSI	T2,JACCT	;SET FOR JACCT TEST
	MOVE	T3,JBTPPN(J)	;GET JOB'S ACCOUNT
	CAME	T3,FFAPPN##	;IF OPERATOR ("FULL FILE ACCESS"), OR
	TDNE	T2,JBTSTS(J)	;IF JACCT
	SKIPA	T2,[M.HPQ]	;ASSUME HIGH
	LDB	T2,HPQPRV	;GET HPQ PRIVILEGES FOR THIS JOB
	CAMLE	T1,T2		;IS THIS JOB PRIVILEGED ENOUGH?
	POPJ	P,		;NO, GIVE ERROR RETURN

	SKIPL	T1		;CORRECT FORMAT?
	CAILE	T1,M.HPQ		;LEGAL QUEUE?
	POPJ	P,		;NO
	DPB	T1,HPQPNT	;YES, STORE NEW HPQ VALUE
	JRST	CPOPJ1		;GIVE SUCCESSFUL RETURN

HPQCMD::PUSHJ	P,DECIN1##	;PICK UP HPQ VALUE IN T2
	JRST	.+2		;NO ARGUMENT, ASSUME 0
	PJRST	COMERA##	;ILLEGAL ARGUMENT
	MOVE	T1,T2		;
	PUSHJ	P,HPQSET	;GO CHECK HPQ LEGALITY
	PJRST	PRIERR##	;NOT LEGAL!
	DPB	T1,HPQSPT	;STORE THIS NEW VALUE
	POPJ	P,		;RETURN

> ;IFG M.HPQ
> ;IFN FTHPQ
IFE M.HPQ,<
	HPQ==:CPOPJ

HPQCMD::PJRST	COMERA##
>

IFE FTHPQ,<IFG M.HPQ,<
PRINTX? ;PLEASE ASSEMBLE SOURCES WITH FTHPQ = -1
>>
SUBTTL	PROCESS DATA BLOCK
;PDB
;PROTOTYPE PROCESS DATA BLOCK
;THIS DESCRIBES THE FORMAT OF A PDB, AND IS THE PDB FOR THE NULL JOB
; IF PDBS ARE SWAPPED. IT IS THE PROTOTYPE PDB IF PDBS ARE BUILT
; IN CORE.


PDBPRO::PHASE	0
.PDIPT::!BLOCK	1		;IN CORE PROTECT TIME -- NUMBER OF
				; JIFFIES BEFORE JOB CAN BE SWAPPED OUT.

.PDQNT==:.PDIPT			;QUANTUM RUN TIME -- JIFFIES UNTIL
				; JOB SHOULD GO TO DIFFERENT RUN QUEUE

.PDCNO::!BLOCK	1		;USER'S CHARGE NUMBER


.PDKCT::!BLOCK	1		;PRODUCT OF CORE LENGTH (IN K) * NUMBER OF CLOCK TICKS
				; PROGRAM USED CPU.  USED FOR TIME ACCOUNTING.


.PDNM1::!BLOCK	1		;FIRST HALF OF USER'S NAME IN SIXBIT
.PDNM2::!BLOCK	1		;SECOND HALF OF USER'S NAME


.PDRTM::!BLOCK	1		;TOTAL RUNTIME SINCE LAST RUNTIME OR KJOB
				;NULL TIME FOR TOTAL SYSTEM IS KEPT FOR JOB 0
				;COUNTED BY BOTH CPU'S
				;SEE .CPNUL FOR INDIVIDUAL NULL TIME
.PDTTM::!BLOCK	1		;TOTAL RUNTIME SINCE LAST KJOB IN JIFFIES
.PDTT2::!BLOCK	1		;ADDITIONAL RUNTIME IN JIFFIES *10^-5
IFN FTKL10,<
.PDEBT::!BLOCK	1		;(KL10) TOTAL EBOX TIME USED IN JIFFIES
.PDEB2::!BLOCK	1		;REMAINDER IN EBOX COUNTS
.PDMBT::!BLOCK	1		;(KL10) TOTAL MBOX TIME USED IN JIFFIES
.PDMB2::!BLOCK	1		;REMAINDER IN MBOX COUNTS

>;END IFN FTKL10

.PDPGM::!BLOCK	1		;PROGRAM TO RUN ON CONTROL-C OR

				; RUN COMMAND

IFN M.KL10,<
.PDABS::!BLOCK	1		;ADDRESS BREAK SETTINGS (ZERO IF USER IS
				; NOT ENABLED FOR ADDRESS BREAK).  1B0=1
				; IF BREAKING ON INSTRUCTION FETCH, 1B1=1
				; IF BREAKING ON DATA FETCH, 1B2=1 IF
				; BREAKING ON A WRITE, 1B6 (USER PAGING)
				; ALWAYS A 1, BIT 18-35=BREAK
				; ADDRESS
>; END IFN M.KL10

.PDCVL::!BLOCK	1		;CVPL,,CPPL
.PDMVL::!BLOCK	1		;MVPL,,MPPL

; NOTE THAT THE FOLLOWING ITEMS MUST REMAIN IN THE ORDER AND THAT .EPADR
; MUST BE LAST.
;
; .PDIPC, .PDIPA, .PDIPQ, .PDIPL, .PDPID, .PDIPI, .PDIPN, .PDQSN, .PDEPA
; .EPIPC, .EPIPA, .EPIPQ, .EPIPL, .EPPID, .EPIPI, .EPIPN, .EPQSN, .EPEPA .EPADR

.PDIPC::!BLOCK	1		;LH=POINTER TO FIRST PACKET
				;RH=SEND AND RECEIVE COUNTERS
.PDIPA::!BLOCK	1		;IPCF STATISTICS
.PDIPQ::!BLOCK	1		;FLAGS AND QUOTAS
.PDIPL::!BLOCK	1		;IPCF QUEUE INTERLOCK WORD
				;LH = JCH WHOSE QUEUE WE HAVE INTERLOCKED
				;RH = JCH WHO INTERLOCKED OUR QUEUE
.PDPID::!BLOCK	1		;PID FOR PID SPECIFIC RECEIVES
.PDIPI::!BLOCK	1		;PID OF THIS JOB'S SYS:INFO
.PDIPN::!BLOCK	1		;LH=POINTER TO LAST IN QUEUE
				;RH=0
.PDQSN::!BLOCK	1		;LH=FILE DAEMON SEQUENCE NUMBER
				;RH=QUEUE.  UUO SEQUENCE NUMBER
.PDEPA::!BLOCK	1		;RH=ADDRESS OF PACKET SENT IN RESPONSE TO AN
				;   EXEC PSUEDO-PROCESS IPCF MESSAGE
				;LH=0

.PDEQJ::!BLOCK	1		;LH=0
				;RH=POINTER TO JOB QUEUE
.PDEQQ::!BLOCK	1		;LH=FLAGS
				;RH=ENQ QUOTA
;FLAGS IN LEFT HALF OF PDEQQ:
EQ.HBS==:(1B0)			;THE QUOTA HAS BEEN SET

.PDJSL::!BLOCK	<.SLWDJ>	;JOB SEARCH LIST
.PDJSE==:.			;FIRST WORD PAST SEARCH LIST
.PDTSL::!BLOCK	1		;TEMPORARY SEARCH LIST POINTER

.PDNET==:.			;LEFT HALF IS THE ADDRESS OF A DDB WHICH
				; HAS AN ACTIVE CONNECT/DISCONNECT IN PROCESS.
.PDSCX::!BLOCK	1		;RIGHT HALF WORD IS ADDRESS OF JOB'S SAVED CONTEXT
.PDDIA::!BLOCK	1		;LOC OF DIAG. DDB FOR JOB

.PDSTR::!BLOCK	1		;STR PROGRAM CAME FROM
.PDNAM::!BLOCK	1		;NAME OF THE PROGRAM
.PDDIR::!BLOCK	1		;DIRECTORY PROGRAM CAME FROM
.PDSFD::!BLOCK	MAXLVL		;PATH TO PROGRAM
.PDDFL::!BLOCK	1		;WORD CONTAINING USER DEFINED DEFAULTS
				; 0-8 = DEFAULT FILE PROTECTION (MUST BE HIGH 9 BITS)
				; 1B9 IS NON-ZERO IF DEFAULT PROTECTION WAS SPECIFIED
				; 1B10 IS NON-ZERO IF FILE DAEMON SPECIFIED PROTECTION
				; 1B11 USE DEFAULT FILE SPEC ON RUN,GET
				; 1B12 DON'T ASK ABOUT DETACHED JOBS ON "LOGIN"
				; 1B13 PD.LGN
				; 1B14 .STPGM RUN IN PROGRESS
				; 1B15 LOGOUT UUO IN PROGRESS
				; 18-26 = FILE DAEMON SUPPLIED PROTECTION
				; (MUST BE HIGH 9 BIT OF RH)
				; 27-35 DEFAULT NUMBER OF DISK BUFFERS

.PDCAP::!BLOCK	1		;MAXIMUM PRIVILEGES ALLOWED

.PDACS::!BLOCK	ACTSTL		;ACCOUNT STRING
.PDVKC::!BLOCK	1		;VIRTUAL TIME-CORE INTEGRAL

.PDUUC::!BLOCK	1		;COUNT OF UUOS DONE BY THIS JOB

IFN FTHPQ,<
.PDHZF::!BLOCK	1		;ORIGINAL VALUE OF TIME IF FIT WAS
				; ZEROED BY HPQ JOB
>
IFN FTPSCD,<
.PDPST::!BLOCK	1		;NEGATIVE OF SWAPOUT TIME
>
.PDOBI::!BLOCK	1		;OPERATOR/BATCH INFO
IFN FTMDA,<
.PDSTM::!BLOCK	1		;TIME OF LAST RESET
>
.PDLBS::!BLOCK	1		;DEFAULT SIZE OF LARGE DISK BUFFER
				;LH=SET BY UUO, RH=SET BY COMMAND
.PDOSL::!BLOCK	1		;OLD-STYLE LIB PPN
.PDSJB::!BLOCK	1		;PTR TO DECNET SESSION CONTROL JOB BLOCK
.PDCMN::!BLOCK	1		;AOBJN POINTER TO USER-DEFINABLE COMMAND NAMES
.PDUNQ::!BLOCK	1		;POINTER TO LOCAL UNQTAB,,TABLE OF UDC BLOCKS

IFN M.CTX,<
.PDSAC::!BLOCK	1		;ADDRESS OF FIRST CONTEXT BLOCK
.PDCTC::!BLOCK	1		;ADDRESS OF CURRENT CONTEXT BLOCK
.PDCTQ::!BLOCK	1		;CONTEXT QUOTA WORD
.PDCTU::!BLOCK	1		;CONTEXT USE WORD
> ;END IFN M.CTX
.PDCTX::!BLOCK	1		;CONTEXT FLAG WORD (MUST ALWAYS BE ASSEMBLED)
.PDTMI::!BLOCK	1		;VIRTUAL TIMER TRAP INITIAL VALUE
.PDTMC::!BLOCK	1		;COUNTDOWN FOR VIRTUAL TIMER TRAPS OR OLD PC
.PDVRT::!BLOCK	1		;JOB PAGING RATE

IFN FTSCA,<
.PDSCS::!BLOCK	1		;ADDRESS OF PROCESS QUEUE BLOCK FOR SCS. UUO
>; END IFN FTSCA

IFN FTENET,<
.PDEJB::!BLOCK	1		;ADDRESS OF ETHERNET JOB BLOCK
>; END IFN FTENET

.PDLPN::!BLOCK	1		;LOGGED-IN PPN
;	***   ADD NEW PDB ENTRIES BEFORE HERE   ***

IFDEF M.PCST,<IFN M.PCST,<	;DEFINE PDB SPACE FOR CUSTOMER USE
.PDCST::!BLOCK	M.PCST		;CUSTOMER-SPECIFIC PDB STORAGE
>> ;END IFDEF/IFN M.PCST

.PDLEN::!			;LENGTH OF A PDB IN WORDS

	DEPHASE
	$ABS
	SUBTTL	SCHEDULER QUEUE DEFINITIONS


;SHARABLE DEVICE JUST BECOME AVAILABLE
;APPROPRIATE ENTRY IS SET NON-ZERO WHEN SCHEDULER SHOULD LOOK
;AT THAT QUEUE TO FIND A JOB TO RUN

DEFINE X(A,B,C)
<A'Q==:ZZ
ZZ==ZZ+1>
ZZ==0
QUEUES
DEFINE X(A,B,C)
<A'Q==:.-AVALTB+ZZ
A'AVAL::0
>


AVALTB::RWAITS	;GENERATE THE AVAL FLAGS
LOC=.-AVALTB+ZZ

XP AVTBMQ,AVALTB-ZZ
;TABLE CONTAINING JOB NUMBER OF THE OWNER OF A
; SHARABLE RESOURCE.  THE RIGHT HALF WORD CONTAINS
; THE JOB NUMBER OF THE JOB THAT CURRENTLY
; OWNS THE RESOURCE OR ZERO IF THE RESOURCE IS
; AVAILABLE.  THE LEFT HALF WORD CONTAINS THE JOB
; NUMBER OF THE LAST JOB WHICH GAVE UP THE RESOURCE.
; THIS TABLE IS USEFUL FOR DEBUGGING AND REQUIRED
; SO THAT IN THE EVENT OF CATASTROPIC ERROR, E.G.,
; SWAP READ ERROR, THE RESOURCE MAY BE FREED UP.

DEFINE X(A,B,C)
<	ZZ==ZZ+1>

ZZ==0
	QUEUES

DEFINE X(A,B,C)
<A'USER::	0
>
USRTAB::RWAITS
XP USTBMQ,USRTAB-ZZ

;DEFINE STATE CODES WHICH DO NOT HAVE AVAL AND REQ FLAGS


DEFINE X(A,B,C)
<A'Q==:LOC
LOC==LOC+1
>
	CODES

XP MXCODE,LOC-1	;MAX. JOB STATE CODE
;ANY QUEUES GREATER THAN CMQ MUST BE PROCESSOR QUEUES
CMQ==:LOC		;COMMAND DELAY QUEUE
LOC=LOC+1
PQ1==:LOC
LOC=LOC+1
PQ2==:LOC
LOC=LOC+1

DEFINE HPQCOD(A)
<	HPQ'A==LOC
	LOC==LOC+1>
IFG M.HPQ,<ZZ==1
	REPEAT	M.HPQ,<HPQCOD(\ZZ)
		ZZ==ZZ+1
			>
			>

;DEFINE SYMBOLS FOR PQ2 SUBQUEUES. SQ0=-1, SQ1=-2, ETC.
; USED FOR NEGATIVE INDICES TO JBTSQ.

	DEFINE	CLSGEN(A)
	<SQ'A==:A+1>

	ZZ==0
	REPEAT	M.CLSN,<
	CLSGEN(\ZZ)
	ZZ==ZZ+1>
	$HIGH
;PUT JOB DOWN A Q IF EXCEEDS QUANT. TIME
QRQTAB::XWD	PQ2,-PQ2	;FROM PQ1
	XWD	PQ2,-PQ2	;FROM PQ2
QTTAB::
DEFINE HPQTTB(A)
<	XWD HPQ'A,-HPQ'A>
IFG M.HPQ,<ZZ==1
	REPEAT	M.HPQ,<HPQTTB(\ZZ)
		ZZ==ZZ+1
			>
			>
XP QRQTBL,QRQTAB-PQ1		;TABLE MINUS OFFSET

	$ABS
; BASE QUANTA FOR QUEUES
QADTAB::EXP	0		;PQ1
	EXP	0		;PQ2
QQSTAB::
DEFINE HPQJIF(A)
<	EXP JIFY'A>
IFG M.HPQ,<ZZ==0
	REPEAT	M.HPQ,<ZZZ==M.HPQ-ZZ
	HPQJIF(\ZZZ)
		ZZ==ZZ+1
			>
			>

DEFINE JIFDEF(A)
	<JIFY'A==A*2>
	ZZ==1
REPEAT M.HPQ,<JIFDEF(\ZZ)
	ZZ==ZZ+1>
XP QADTBL,QADTAB-PQ1		;TABLE MINUS PQ1
; MULTIPLIER TABLE FOR RUN QUANTA BY QUEUES
QRANGE:: ^D45		;RANGE IN K BETWEEN SMALLEST AND LARGEST QUANTUM
			;  RUN TIME ASSIGNMENT

; ENTRIES ARE RANGE IN TICKS BETWEEN SMALLEST QUANTUM TO ASSIGN (QADTAB)
;  AND LARGEST QUANTUM TO ASSIGN (QMXTAB)
QMLTAB::EXP	0		;PQ1
	EXP	0		;PQ2
REPEAT M.HPQ,<EXP 0>		;NO MULTIPLIER FOR HPQS
XP QMLTBL,QMLTAB-PQ1		;TABLE MINUS PQ1

;MAXIMUM ALLOWABLE RUN QUANTO FOR QUEUES
QMXTAB::EXP	0		;PQ1
	EXP	0		;PQ2
IFG M.HPQ,<ZZ==0
	REPEAT	M.HPQ,<ZZZ==M.HPQ-ZZ
	HPQJIF(\ZZZ)
		ZZ==ZZ+1
			>
			>
XP QMXTBL,QMXTAB-PQ1		;TABLE MINUS PQ1
	$HIGH
ISCAN::	;SCAN FOR INPUT - GETTAB TABLE 45

DEFINE HPQSCN(A)
<	XWD -HPQ'A,QFOR##>
IFG M.HPQ,<ZZ==0
	REPEAT	M.HPQ,<ZZZ=M.HPQ-ZZ
		HPQSCN(\ZZZ)
		ZZ==ZZ+1
		>
		>

	XWD	-CMQ,QFOR##	;MONITOR COMMAND WHICH NEEDS CORE IMAGE IN CORE
	XWD	-PQ1,IQFOR##	;GET PEOPLE WHO GETSEGED FIRST
	XWD	-PQ2,IGFOR##	;BUT JUST THOSE WITH QUANTA LEFT
FISCAN::XWD	-PQ1,OQFOR##
IFE FTNSCHED,<
	XWD	-PQ2,FOQFOR##	;FAIRNESS HERE
>
IFN FTNSCHED,<
	XWD	-PQ2,FSQFOR##	;FAIRNESS HERE
>
	XWD	-PQ2,IQFOR##
IFN FTNSCHED,<
	XWD	-PQ2,BQFOR##
>
ISTMXL==:<.-ISCAN-1>B26	;MAKE ENTRY IN GETTAB FOR INPUT SWAP SCAN LIST
IFN FTPATT,<
	Z		;PATCH SPACE
	Z
>
	Z		;FINAL ZERO TO FLAG END

ISCAN1::		;ALTERNATE INPUT SCAN
IFG M.HPQ,<ZZ==0
	REPEAT	M.HPQ,<ZZZ=M.HPQ-ZZ
		HPQSCN(\ZZZ)
		ZZ==ZZ+1
		>
		>

	XWD	-CMQ,QFOR##	;MONITOR COMMAND WHICH NEEDS CORE IN
IFE FTNSCHED,<
	XWD	-PQ2,FOQFOR##
>
IFN FTNSCHED,<
	XWD	-PQ2,FSQFOR##
>
	XWD	-PQ1,OQFOR##
	XWD	-PQ2,IGFOR##
	XWD	-PQ1,IQFOR##
	XWD	-PQ2,IQFOR##
IFN FTNSCHED,<
	XWD	-PQ2,BQFOR##
>
IFN FTPATT,<
	Z		;PATCH SPACE
	Z
>
	Z		;FINAL ZERO TO FLAG END

;TABLE FOR SCHED. FUNCTION 30 (SELECT ON A /CPU BASIS ORDER OF Q SCAN
CPSCAN::SSCAN		;SUBFUNCTION 0,SCAN USING SSCAN,(P01,PQ2)
	SSCAN1		;SUBFUNCTION 1,SCAN USING SSCAN1,(PQ2,PQ1)
IFN FTPATT,<
	Z		;PATCH SPACE
	Z
>
CPSTBL==:.-CPSCAN-1	;LENGTH
	$ABS
	SSCN=:-3		;SECONDARY SCAN TABLE ADDRESS
	EXP	SSCAN1
	MFC=:-2		;MAXIMUM FAIRNESS COUNT
	EXP	SFC0
	FSCN=:-1		;ENTRY IN SCAN TABLE OF FIRST FAIR LOCATION
	EXP	FSCAN
SSCAN::			;SCHEDULER SCAN LIST - GETTAB TABLE 47
DEFINE HPQSCN(A)
<	XWD -HPQ'A,IQFOR##>
IFG M.HPQ,<ZZ=0
	REPEAT	M.HPQ,<ZZZ=M.HPQ-ZZ
		HPQSCN(\ZZZ)
		ZZ=ZZ+1
		>
		>

	XWD	-PQ1,IQFOR##	;SCHEDULER'S SCAN FOR NEXT JOB TO RUN
FSCAN:
IFE FTNSCHED,<
	XWD	-PQ2,IRRFOR
>
IFN FTNSCHED,<
	XWD	-PQ2,ISSFOR##
	XWD	-PQ2,IBBFOR##
>
SSTMXL==:<.-SSCAN-1>B26	;MAX ENTRY FOR GETTAB
IFN FTPATT,<
	Z		;FOR PATCHING
	Z
>
	Z		;FINAL ZERO TO FLAG END
;SLAVE PROCESSOR SCAN TABLE FOR CPU SCHEDULING


	EXP	SSCAN		;SECONDARY SCAN TABLE FOR SLAVE
	EXP	SFC1		;MAXIMUM FAIRNESS COUNT
	EXP	FSCAN1		;ENTRY POINT IN SCAN TABLE OF FIRST FAIR TABLE
SSCAN1:

	IFG	M.HPQ,<
		ZZ==0
		REPEAT M.HPQ,<ZZZ=M.HPQ-ZZ
			HPQSCN(\ZZZ)
			ZZ==ZZ+1
			>
			>

IFE FTNSCHED,<
	XWD	-PQ2,IRRFOR
>
IFN FTNSCHED,<
	XWD	-PQ2,ISSFOR##
>
FSCAN1:	XWD	-PQ1,IQFOR##	;IF NO JOBS TRY PQ1
IFN FTNSCHED,<
	XWD	-PQ2,IBBFOR##
>
IFN FTPATT,<
	Z		;FOR PATCHING
	Z
>
	0
	$HIGH
LSCAN::			;SCAN FOR LOST TIME
DEFINE HPQSCN(A)
<	XWD -HPQ'A,OQFOR##>
IFG M.HPQ,<
	ZZ==0
	REPEAT M.HPQ,<ZZZ=M.HPQ-ZZ
		HPQSCN(\ZZZ)
		ZZ==ZZ+1
			>
		>
	XWD	-PQ1,OQFOR##	;PQ1 NO CORE FORWARD
IFE FTNSCHED,<
	XWD	-PQ2,OQFOR##	;PQ2 NO CORE FORWARD
>
IFN FTNSCHED,<
	XWD	-PQ2,OSSFOR##	;PQ2 NO CORE SUB QUEUES FORWARD
				;INCLUDES NO CORE BACKGROUND BATCH
>
	0
;NOTE - FOR BEST RESULTS OSCAN SHOULD BE IN
; REVERSE ORDER OF ISCAN, ELSE SCHEDULER BINDS

OSCAN::	;SCAN FOR OUTPUT - GETTAB TABLE 46
	XWD	-STOPQ,IQFOR##	;UNRUNABLE JOBS FIRST
	XWD	-SLPQ,IQFOR##
	XWD	-EWQ,IQFOR##	;EVENT WAITERS
	XWD	-JDCQ,IQBAK1##
	XWD	-TIOWQ,IQFOR##	;TTY IOW
	XWD	-JDCQ,IQFOR1##
	XWD	-PQIOQ,IQFOR##	;PAGE QUEUE WAIT
OTHQUE==.-1
PQ2QUE:	XWD	-PQ2,OLFOR##	;INCLUDES -PQ2,IQBAK AS SUBCASE
PQ1QUE:	XWD	-PQ1,IQBAK##
CMQUE:	XWD	-CMQ,IQBAK##

DEFINE HPQSCN(A)
<HPQU'A:	XWD -HPQ'A,IQBAK##>
IFG M.HPQ,<ZZ=1
	REPEAT	M.HPQ,<HPQSCN(\ZZ)
		ZZ=ZZ+1
		>
		>

OSTMXL==:<.-OSCAN-1>B26		;MAX. ENTRY IN GETTABS
IFN FTPATT,<
	Z			;PATCH SPACE
	Z
>
	Z			;FINAL ZERO TO FLAG END
; TABLE OF WHAT QUE ENTRY IS LAST TO SCAN FOR SWAP OUT
OSCANT::OTHQUE			;WHERE TO STOP IF NOT CMQ OR PROCESSOR QUEUE
	CMQUE			;WHERE TO STOP IF CMQ
	PQ1QUE			;WHERE TO STOP IF PQ1
	PQ2QUE			;WHERE TO STOP IF PQ2
	DEFINE HPQSTP(A)
<	HPQU'A>
IFG M.HPQ,<
	ZZ=1
	REPEAT M.HPQ,<HPQSTP(\ZZ)
		ZZ=ZZ+1
>
>
OSCNTQ=:OSCANT+1-CMQ		;MAKE AN INDEX INTO STOP TABLE
; SPECIAL SCAN TABLE FOR DECREMENTING IN CORE PROTECT TIMES
; PROCESSOR QUEUES MUST BE IN REVERSE ORDER SO THAT REQUEING
; DUE TO EXPIRATION OF ICPT DOES NOT PUT JOB WHERE WE WILL SEE
; IT AGAIN (QUEUES ARE ALSO SCANNED IN REVERSE)
; MUST ALSO CONTAIN ANY OTHER PHYSICAL QUEUE WHICH IS ALLOWED TO
;  RETAIN ICPT. CURRENTLY THIS IS ONLY SLP AND EW.

DCSCAN::EXP	-EWQ		;EVENT WAIT QUEUE
	EXP	-SLPQ		;SLEEP QUEUE
	EXP	-PQ2		;PQ2
	EXP	-PQ1		;PQ1
	DEFINE HPQSCN(A)
<	EXP	-HPQ'A>
IFG M.HPQ,<
ZZ==1
	REPEAT M.HPQ,<HPQSCN(\ZZ)
		ZZ==ZZ+1
>
>
IFN FTPATT,<
	0
	0
>
	0
IFN FTNSCHED,<
$ABS
;SUBQUEUE INPUT SCAN TABLE
;
;FOR GENERATING PRIMARY SCAN TABLE, ENTRIES CONTAIN:
; PRIORITY COUNTER IN LEFT HALF,
; SUBCLASS NUMBER IN RIGHT HALF.
;
;FOR GENERATING SECONDARY INPUT SCAN, ENTRIES CONTAIN:
; MINUS SUBQUEUE NUMBER IN LEFT HALF,
; SECONDARY QUOTA IN RIGHT HALF.

SQSCAN::BLOCK	M.CLSN

SQCNT::	0			;COUNTER OF LOCATIONS LEFT IN PRIMARY SCAN TABLE
SQPNT::	0			;POINTER TO CURRENT LOC IN PRIMARY SCAN TABLE
SQSUM::	0			;SUM OF SECONDARY PERCENTS
SQSAVJ::0			;NUMBER OF CLASS ALREADY SCANNED
SCNJIL::0			;TIME TO STOP SCANNING JBTJIL
SCNSWP::0			;# TICS SAME PRIMARY SUBQUEUE HAS BEEN SCANNED
SCNBBS::0			;TIME TO SWAP NEXT BB JOB
BBFIT::	0			;NON-ZERO IF BACKGROUND BATCH JOB BEING FIT
BBFLAG::0			;NON-ZERO IF BACKGROUND BATCH QUEUE BEING SCANNED

>;END IFN FTNSCHED
$ABS
SEED::	377775			;SEED FOR RANDOM NUMBER
$HIGH
IFN FTNSCHED,<
$ABS
;SUBQUEUE SCAN TABLE FOR CPU0
;
;ENTRIES CONTAIN:
; MINUS SUBQUEUE NUMBER.
; TABLE TERMINATES WITH A ZERO.

SSSCAN::BLOCK	M.CLSN
	0			;ZERO TERMINATES TABLE
SSCNT::	0			;COUNTER OF ENTRIES LEFT IN PRIMARY SCAN TABLE
SSPNT::	0			;POINTER TO PRIMARY SCAN TABLE FOR CPU0
SSSUM::	0			;SUM OF SECONDARY PERCENTS
IFN FTMP,<
;SUBQUEUE SCAN TABLE FOR CPU1
SSSCN1::BLOCK	M.CLSN
	0			;ZERO TERMINATES TABLE
SSPNT1::0			;POINTER TO PRIMARY SCAN TABLE FOR CPU1
>
;PRIMARY SCAN TABLE
;STORED AS 101 5-BIT ENTRIES, ONE FOR EACH PERCENT OF THE SYSTEM RESOURCES
; ENTRY 101 IS A DUPLICATE OF ENTRY 1.
PSQTAB::BLOCK	^D15		;ROOM FOR 101 ENTRIES
$HIGH
>;END IFN FTNSCHED
SUBTTL MINIMUM CORE USAGE DATA TABLES

;TABLE OF INDICES TO FIRST POSITION ON TABLES BELOW FOR VARIOUS KONTROLLER TYPES
TYPTAB::EXP	FRSTDR		;TYPE 0 (DR) FUTURE DRUM, IF ANY
	EXP	FRSTFH		;TYPE 1 (FH) BURROUGHS DISK OR BRYANT DRUM
	EXP	FRSTDP		;TYPE 2 (DP) RP10 KONTROLLER RP01, RP02, RP03 DRIVES
	EXP	FRSTMD		;TYPE 3 (MD) BRYANT MASS DISK
	EXP	FRSTFS		;TYPE 4 (FS) RH10/RS04
	EXP	FRSTRP		;TYPE 5 (RP) RH10/RP04
	EXP	FRSTRN		;TYPE 6 (RN) RP20
	EXP	FRSTRA		;TYPE 7 (RA) RA80/81/60

;TABLES COMPUTED BY ONCMOD
;UNITS ARE MICROSECONDS

;AVERAGE TIME PER PAGE (K) TABLE COMPUTED BY ONCMOD

MCUATP:: Z			;FUTURE DRUM
	Z			;DITTO
	Z			;RD10
	Z			;RM10B
	Z			;RP01
	Z			;RP02
	Z			;RP03
	Z			;DUAL POSITIONER MD10
	Z			;SINGLE POSITIONER MD10
	Z			;RS04
	Z			;RP04
	Z			;RP06
	Z			;RM03
	Z			;RP07
	Z			;RP20
	Z			;RA80
	Z			;RA81
	Z			;RA60

;AVERAGE LATENCY TIME TABLE COMPUTED BY ONCMOD

MCUALT:: Z			;FUTURE DRUM
	Z			;DITTO
	Z			;RD10
	Z			;RM10B
	Z			;RP01
	Z			;RP02
	Z			;RP03
	Z			;DUAL POSITIONER MD10
	Z			;SINGLE POS. MD10
	Z			;RS04
	Z			;RP04
	Z			;RP06
	Z			;RM03
	Z			;RP07
	Z			;RP20
	Z			;RA80
	Z			;RA81
	Z			;RA60
	SUBTTL	SET PSECT LIMITS

;MACRO TO ACCEPT SYMBOLIC VALUES FOR PSECT LIMITS AND PASS THEM TO LINK
;VIA THE .TEXT PSUEDO-OP.

DEFINE	SETPSL(NAME,MAX),<
	.TEXT	"/LIMIT:'NAME':'MAX'"
>; END DEFINE


;DEFINE LIMIT FOR PSECT .LOW. SO SYMBOLS DON'T OVERLAP PSECT .CSUB. (OR .HIGH.)

IFE FTXMON,<
	SETPSL	(.LOW.,\MONORG)
>; END IFE FTXMON
IFN FTXMON,<
	SETPSL	(.LOW.,\CSBORG)
>; END IFN FTXMON

;DEFINE LIMIT FOR PSECT .HIGH. SO CODE DOESN'T OVERLAP FUNNY SPACE

	SETPSL	(.HIGH.,\HLCSAD)

;DEFINE LIMIT FOR PSECT .INIT. SO CODE DOESN'T OVERLAP RESERVED MAPPINGS

	SETPSL	(.INIT.,\.UPMAP)

;DEFINE LIMIT FOR PSECT .SYMS. SO SYMBOLS DON'T OVERLAP PSECT .XHGH.

IFN FTXMON,<
	SETPSL	(.SYMS.,\XHIORG)
>; END IFN FTXMON

;NOTE THAT THE ABOVE IS INEFFECTIVE, THUS THE FOLLOWING:

IFN FTXMON,<
	CONC(<.TEXT "/UPTO:>,\XHIORG,<">)
>
IFE FTXMON,<
	CONC(<.TEXT "/UPTO:>,\MONORG,<">)
>

;DEFINE LIMIT FOR PSECT .XHGH. SO EXTENDED HIGH SEGMENT DOESN'T
;OVERLAP FUNNY SPACE

IFN FTXMON,<
	SETPSL	(.XHGH.,\<MS.HGH+HLCSAD>)
>; END IFN FTXMON

;DEFINE LIMIT FOR PSECT CSUB SO COMMON SUBROUTINES DON'T OVERLAP PSECT .HIGH.

IFN FTXMON,<
	SETPSL	(.CSUB.,\MONORG)
>; END IFN FTXMON
	$LIT			;GENERATE ALL LITERALS BEFORE RELOC
	LOLOC==ABSLOC-COMORG	;HIGHEST ABSOLUTE ADDRESS USED
	$LOW
	RELOC	LOLOC		;MAKE SURE .LOW. INCLUDES ALL ABSOLUTE CODE

	END	SYSTRT
