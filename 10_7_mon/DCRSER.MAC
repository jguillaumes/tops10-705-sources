TITLE	DCRSER - CARD READER SERVICE FOR MULTIPLE RSX20F CARD READERS - V023
SUBTTL	S. PAAVOLA	17 APR 90

	SEARCH	F,S,DEVPRM,DTEPRM

	$RELOC
	$HIGH

;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED
;  OR COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION
; 1977,1978,1979,1980,1982,1984,1986,1988,1990.
;ALL RIGHTS RESERVED.

.CPYRT<1977,1990>


XP VDCRSR,023			;DEFINE GLOBAL VERSION NUMBER FOR LOADER MAP

	PRMMIN==016		;DTEPRM MUST BE AT LEAST THIS RECENT

   IFL VDTPRM-PRMMIN,<PRINTX ?PLEASE USE LATEST VERSION OF DTEPRM
				PASS2
				END>

DCRSER::ENTRY	DCRSER
SUBTTL	SYMBOL DEFINITIONS

;COLUMN 1 SPECIAL CARD CODES

	COD029==5252		;12-0-2-4-6-8
	COD026==4242		;12-2-4-8
	CODEOF==7400		;12-11-0-1
	NEWEOF==0017		;6-7-8-9

;DEVICE DEPENDENT BITS IN LEFT HALF OF DEVIOS

	CR026==400		;SET WHEN 026 TRANSLATION TO BE MADE
	CRTRBL==4000		;TROUBLE NOTICED AT INTERRUPT LEVEL

;DEVICE DEPENDENT BITS IN RIGHT HALF OF DEVIOS

	SPIMBT==1B29		;IO STATUS BIT FOR SUPER-IMAGE MODE

;BUFFER SIZES

	ASBFSZ==^D18		;BUFFER SIZE FOR ASCII MODE
	BIBFSZ==^D27		;BUFFER SIZE FOR BINARY MODE
	IMBFSZ==^D28		;BUFFER SIZE FOR IMAGE MODE
	SIBFSZ==^D41		;BUFFER SIZE FOR SUPER-IMAGE MODE

;CDR SPECIFIC STATUS BITS FROM RSX-20F

	CR.RCK==1		;READ (PHOTO) CHECK
	CR.PCK==2		;PICK CHECK
	CR.SCK==4		;STACKER CHECK
	CR.HEM==10		;HOPPER EMPTY
	CR.SFL==20		;STACKER FULL

	;STATUS BITS REQUIRING OPERATOR INTERVENTION
	CR.OFL==CR.RCK!CR.PCK!CR.SCK!CR.HEM!CR.SFL
SUBTTL	AUTOCONFIGURE


;DRIVER CHARARCTERISTICS
;	DCR	= DCRCNF
;	CDR	= CARD READER
;	7	= MAXIMUM DEVICES IN SYSTEM
;	0	= KONTROLLER TYPE
;	0	= MAXIMUM DRIVES PER KONTROLLER
;	0	= HIGHEST DRIVE NUMBER ON KONTROLLER
;	MDSEC0	= SECTION FOR KDB/UDB
;	MDSEC0	= SECTION FOR DDB
DRVCHR	(DCR,CDR,7,0,0,0,MDSEC0,MDSEC0,<DR.GCC!DR.NET>)


	 .ORG	DEVLEN
DCRDUX:! BLOCK	1		;UNIT,,DTE
DCRCDN:! BLOCK	1		;CPU,,DTE NUMBERS
DCRCNT:! BLOCK	1		;CARD COUNT
DCRBUF:! BLOCK	^D40		;BUFFER FOR READING A CARD
DCRLEN:!			;LENGTH OF DTE PRINTER DDB
	 .ORG


	$LOW
DCRDDB:	DDBBEG	(DCR,DCRLEN)
	SETWRD	(DEVCHR,<2*HUNGST,,>)		;DEVCHR
	SETWRD	(DEVSER,<EXP DCRDSP>)		;DEVSER
	SETWRD	(DEVMOD,<DVCDR+DVIN,,14403>)	;DEVMOD
	SETWRD	(DEVSPL,<<.TYCDR*.TYEST>!.SPCDR,,0>) ;DEVSPL
	SETWRD	(DEVHCW,<INSVL.(.HCT20,HC.TYP)>) ;DEVHCW
	DDBEND
	$HIGH

EQUATE	(LOCAL,0,<DCRCKT,DCRICD,DCRICL,DCRINT,DCRKDB,DCRKLN,DCRUDB,DCRULN>)
EQUATE	(LOCAL,0,<DCRULB,DCRULP>)

DCRDSX:	DRVDSP	(DCR,0,DCRDDB,DCRLEN,URDDIA##)

;DEFAULT MONGEN'ED DEVICE TABLE
DEFMDT:	MDKL10	(7,200,0,0,<MD.KON>)	;DEVICE CODE 200
	MDKL10	(7,204,0,0,<MD.KON>)	;DEVICE CODE 204
	MDKL10	(7,210,0,0,<MD.KON>)	;DEVICE CODE 210
	MDKL10	(7,214,0,0,<MD.KON>)	;DEVICE CODE 214
	EXP	0
DCRCFG:	XMOVEI	T1,DCRMDT##	;MONGEN'ED DEVICE TABLE
	XMOVEI	T2,DEFMDT	;DEFAULT TABLE
	MOVNI	T3,1		;NO MASSBUS UNIT OR DRIVE INFORMATION
	MOVEI	T4,MD.KON	;MATCH ON KONTROLLER DEFINITION
	PUSHJ	P,AUTMDT##	;SCAN THE TABLES
	  JRST	CPOPJ1##	;NO MATCHES
	MOVE	T1,.CPCPN##	;OUR CPU NUMBER
	HRRZ	F,DTEMAS##(T1)	;FETCH MASTER DTE
	LDB	T1,[POINT 7,ETDCNI(F),9] ;GET DTE NUMBER
	HRRZ	T2,.CPDVC##	;AND DEVICE BEING CONFIGURED
	CAIE	T1,(T2)		;DOING THE MASTER DTE?
	JRST	CPOPJ1##	;NO
	MOVSI	T1,(ED.PPC)	;BIT TO TEST
	TDNE	T1,ETDSTS(F)	;PRIMARY PROTOCOL RUNNING?
	PJRST	DCRRDS		;YES--CAN REQUEST DEVICE STATUS DIRECTLY
	XMOVEI	T1,DCRRDS	;ROUTINE TO REQUEST DEVICE STATUS
	MOVEI	T2,1		;WAIT FOR PRIMARY PROTOCOL TO START
	PUSHJ	P,AUTCLK##	;QUEUE UP A CLOCK REQUEST
	JRST	CPOPJ1##	;MAYBE OTHER DTE-BASED DEVICES EXIST

;HERE WHILE PRIMARY PROTOCOL IS RUNNING TO REQUEST DEVICE STATUS
DCRRDS:	PUSHJ	P,SAVE4##	;SAVE SOME ACS
	MOVE	T1,.CPCPN##	;OUR CPU NUMBER
	HRRZ	F,DTEMAS##(T1)	;FETCH MASTER DTE
	LOAD.	P1,ED.DTN,(F)	;GET MASTER DTE NUMBER
	HRL	P1,.CPCPN##	;INCLUDE OUR CPU NUMBER
	MOVE	P2,[.EMCDR,,.EMRDS] ;FE DEVICE CODE,,FUNCTION CODE
	TDZA	P3,P3		;START WITH UNIT ZERO
DCRRD1:	HLLZS	P3		;JUST NEED UNIT,,0
	MOVE	P4,[POINT 8,P3,9] ;BYTE POINTER TO UNIT NUMBER
	SETZ	S,		;NO POST ADDRESS
	S0PSHJ	DTEQUE##	;QUEUE UP REQUEST FOR DEVICE STATUS
	  JFCL			;SHOULDN'T FAIL
	AOBJN	P3,.+1		;ADVANCE UNIT NUMBER
	TLNN	P3,-1-DCRMAX##+1 ;OVERFLOW?
	JRST	DCRRD1		;LOOP BACK FOR MORE
	JRST	CPOPJ1##	;MAYBE OTHER DTE-BASED DEVICES EXIST


;HERE WHILE PROCESSING A DEVICE STATUS MESSAGE FOR A PREVIOUSLY
;UNKNOWN DTE-BASED DEVICE TO ACTUALLY BUILD THE DTE DEVICE DATA BASE
;P1 - P4 SETUP WITH DEVICE STATUS MESSAGE POINTERS
DCRDTS:	SE1ENT			;ENTER SECTION ONE
	PUSHJ	P,AUTLOK##	;INTERLOCK THE DATA BASE
	  JRST	[PUSHJ	P,DCRRDS ;BUSY & INTERRUPT LEVEL--TRY AGAIN LATER
		   JFCL		;WILL MOST LIKELY SKIP
		 POPJ	P,]	;CALL THIS A FAILURE
	PUSH	P,F		;SAVE DDB ADDRESS OR ZERO
	MOVE	T1,.CPCPN##	;OUR CPU NUMBER
	HRRZ	F,DTEMAS##(T1)	;AND THE MASTER ETD FOR THIS CPU
	LDB	T1,[POINT 7,ETDCNI(F),9] ;DEVICE CODE
	XMOVEI	T2,DCRDSX	;DRIVER DISPATCH
	SETZ	T3,		;NO CHANNEL
	PUSHJ	P,AUTSET##	;SET UP AUTCON CALLS
	POP	P,F		;GET FLAG BACK
	JUMPN	F,DCRDT1	;JUMP IF A KNOWN DEVICE
	PUSHJ	P,AUTADN##	;ALLOCATE A DEVICE NUMBER
	HRLI	T1,'CDR'	;INCLUDE GENERIC DEVICE NAME
	SETZ	T2,		;LOCAL DEVICE
	PUSHJ	P,AUTDDB##	;CREATE A DDB
	  JRST	[PUSHJ	P,AUTULK## ;NO CORE
		 PJRST	AUTDDN##] ;DEALLOCATE DEVICE NUMBER
DCRDT1:	MOVEM	P1,DCRCDN(F)	;SAVE CPU,,DTE NUMBER
	HLLM	P3,DCRDUX(F)	;SAVE FE UNIT (LINE) NUMBER
	HRRM	P1,DCRDUX(F)	;SAVE DTE NUMBER (HISTORICAL)
	XMOVEI	T1,DCRMDT##	;POINT TO MONGEN'ED DEVICE TABLE
	XMOVEI	T2,DEFMDT	;GET DEVICE CODES FROM THE DEFAULT TABLE
	HLLO	T3,P3		;USE FE UNIT FOR UNIT NUMBER
	SETZ	T4,		;IGNORE FLAGS
	PUSHJ	P,AUTMDT##	;SEE IF WE HAVE DATA
	  JRST	DCRDT2		;THERE IS NONE
;ADD FUTURE MDT VALUE TESTS HERE
DCRDT2:	PUSHJ	P,AUTULK##	;RELEASE INTERLOCK
	JRST	CPOPJ1##	;RETURN
SUBTTL	DISPATCH TABLES

;DTESER DISPATCH TABLE FOR CDR

	IFIW	CPOPJ##		;(-1) LOST TO-10 INDIRECT MESSAGE
FCRDSP::DTEFNC			;(??) GENERATE DUMMY TABLE ENTRIES
	DTEFNC	(STR,F11STR)	;(03) TAKE STRING DATA
	DTEFNC	(HDS,F11DVS)	;(07) TAKE DEVICE STATUS


;UUOCON DISPATCH TABLE

	JRST	DCROFL		;OFFLINE CHECK
	JRST	ECOD2##		;SPECIAL ERROR STATUS
	JRST	DCRBSZ		;GET BUFFER SIZE
	JRST	DCRINI		;INITIALIZATION
	JRST	DCRHNG		;HUNG DEVICE
DCRDSP::JRST	DCRREL		;RELEASE
	JRST	ILLOUT##	;OUTPUT CLOSE
	JRST	ILLOUT##	;OUTPUT
	JRST	DCRINP		;INPUT
SUBTTL	INITIALIZATION AND SOME SMALL ROUTINES


;INITIALIZATION

DCRINI:	MOVEI	T1,DCRCNT	;OFFSET TO CARDS READ
	SKIPN	CDROCR##	;ALREADY SET?
	MOVEM	T1,CDROCR##	;SAVE FOR GETTABS
	POPJ	P,


;BUFFER SIZE SETUP ROUTINE - CALLED DURING INIT UUO.

DCRBSZ:	MOVEI	T1,ASBFSZ	;ASSUME ASCII
	TRNN	M,10		;IS IT AN ASCII MODE?
	JRST	DCRBSR		;YES
	MOVEI	T1,BIBFSZ	;NO, ASSUME BINARY
	TRNE	M,4		;IS IT BINARY?
	JRST	DCRBSR		;YES
	MOVEI	T1,IMBFSZ	;NO, MUST BE IMAGE MODE
	TRNE	M,1B29		;SUPER IMAGE MODE?
	MOVEI	T1,SIBFSZ	;YES, 40 WORDS OF DATA
	POPJ	P,		;DONE

DCRBSR:	TRZ	M,1B29		;SUPER-IMAGE MODE NOT ALLOWED
	POPJ	P,		;DONE


;HUNG DEVICE TIMEOUT

DCRHNG:	TLO	S,CRTRBL	;GOT TROUBLE
	PUSHJ	P,DCRREL	;DO THE RELEASE CODE
	AOS	(P)		;SKIP RETURN TO AVOID HUNG MESSAGE
	PJRST	DEVERR##	;TELL OPERATOR


;RELEASE

DCRREL:	PUSHJ	P,SETIOD##	;START UP THE USER
	PUSHJ	P,RTEVM##	;RETURN ANY EVM
	JRST	CLRACT##	;CLEAR IO ACTIVE AND RETURN

;OFF-LINE CHECK

DCROFL:	MOVEI	T1,EM.OFL!EM.NXD ;OFF LINE BITS
	TDNN	T1,DEVSTS(F)	;STILL THERE
	AOS	(P)		;NO, GOOD RETURN
	POPJ	P,		;RETURN
SUBTTL	INPUT UUO

;HERE ON AN INPUT UUO

DCRINP:	PUSHJ	P,SAVE4##	;SAVE P1-P4
DCRGO:	MOVEI	T1,EM.OFL!EM.NXD ;GET OFF-LINE BIT
	TLZN	S,CRTRBL	;TROUBLE FROM INTERRUPT LEVEL?
	TDNE	T1,DEVSTS(F)	; OR DEVICE OFF-LINE?
	  JRST	TKUSER		;YES, TELL USER
	TLZN	S,IOBEG		;FIRST TIME HERE?
	  JRST	DCRIN1		;NO, SKIP FIRST TIME STUFF
	TLZ	S,CR026		;YES, TURN OFF 026 MODE
	MOVSI	T2,PCDRAS##	;ASCII BYTE POINTER
	TRNE	S,10		;IN ASCII MODE?
	MOVSI	T2,PCDRBI##	;NO, BYTE POINTER FOR BINARY OR IMAGE
	MOVEM	T2,DEVPTR(F)	;SET BYTE POINTER INTO DDB
DCRIN1:	PUSHJ	P,NEWBUF##	;INITIALIZE NEW BUFFER
	  JRST	ADRERR##	;ADDRESS ERROR
	MOVE	P1,DCRCDN(F)	;PICK UP CPU#,,DTE#
	MOVE	P2,[.EMCDR,,.EMACK] ;START A CARD FEEDING
	HRRI	P3,2		;ONLY THE LINE NUMBER AS DATA
	MOVE	P4,[POINT 8,P3,9] ;LINE NUMBER IS IN P3
	MOVEM	S,DEVIOS(F)	;SAVE S
	SETZM	S		;NO POST PROCESSING FOR THIS MESSAGE
	PUSHJ	P,DTEQUE##	;QUEUE THE REQUEST
	  JRST	TKUSER		;ERROR, GO TELL USER
	MOVE	S,DEVIOS(F)	;GET BACK S
	TRO	S,IOACT		;SET IO ACTIVE
	SETZM	P3		;ZERO THE BYTE COUNT IF AT INTERRUPT LEVEL
	PJRST	STOIOS##	;SAVE S AND RETURN


;HERE ON OFF-LINE CARD READER

TKUSER:	MOVEM	S,DEVIOS(F)	;SAVE DEVIOS FOR USER
	HRRZ	T2,DEVBUF(F)	;ADR OF BUFFER HEADER
	EXCTUX	<HRRZ T1,@T2>	;CURRENT USER BUFFER
	PUSHJ	P,UADRCK##	;ADDRESS CHECK IT
	EXCTUX	<SKIPGE @T1>	;ANY DATA THERE?
	PJRST	RTEVM##		;YES, RETURN IT TO USER
	PUSHJ	P,HNGSTP##	;NOTIFY OPERATOR
	JRST	DCRGO		;TRY AGAIN
SUBTTL	STRING INPUT

;HERE FROM DTESER ON STRING INPUT FROM THE 11

F11STR:	PUSHJ	P,SETRGS	;SET UP INTERRUPT REGS
	  JRST	EATMSG##	;NO DDB
	MOVSI	S,CRSTR1	;PROCESSING ROUTINE WHEN DATA IS IN
	HRRI	P3,^D160	;160 8 BIT BYTES
	MOVEI	P4,DCRBUF(F)	;GOES INTO DDB BUFFER
	HRLI	P4,(POINT 16,)	;16 BIT BYTES
	MOVEI	T1,SPIMBT	;THE SUPER IMAGE MODE BIT
	TDNN	T1,DEVIOS(F)	;SUPER IMAGE MODE?
	  POPJ	P,		;NO, BACK TO DTESER FOR THE DATA
	MOVSI	S,CRSPIM	;YES, USE THIS ROUTINE INSTEAD
	HRR	P4,DEVPTR(F)	;DATA STRAIGHT TO USER
	ADDI	P4,1
	POPJ	P,		;BACK TO DTESER

;HERE FROM DTESER WHEN SUPER IMAGE MODE DATA HAS ARRIVED

CRSPIM:	PUSHJ	P,SETRGS	;SET UP INTERRUPT REGS
	  JRST	EATMSG##	;NO DDB
	MOVEI	T1,^D40		;JUST READ 40 WORDS
	ADDM	T1,DEVPTR(F)	;ADJUST POINTER APPROPRIATELY
	JRST	CRDON		;FINISH OFF

;HERE FROM DTESER WHEN THE DATA HAS ARRIVED FOR OTHER THAN SUPER IMAGE MODE

CRSTR1:	PUSHJ	P,SETRGS	;SET UP INTERRUPT REGS
	  JRST	EATMSG##	;NO DDB
	MOVE	T4,P4		;GET POINTER TO DATA
	MOVEI	T3,^D80		;80 COLUMNS
	CAMLE	T3,DEVCTR(F)	;BUFFER SMALLER THAN A CARD?
	MOVE	T3,DEVCTR(F)	;YES, USE THE SMALLER NUMBER
	TRNN	S,7		;ASCII OR BINARY?
	TRNN	S,10		;OR NOT IMAGE?
	  JRST	NORMOD		;YES, GO LOOK FOR EOF

;IMAGE MODE

CRIMG:	ILDB	T1,T4		;GET A BYTE
	IDPB	T1,DEVPTR(F)	;GIVE IT TO USER
	SOJG	T3,CRIMG	;LOOP THROUGH CARD
	JRST	CRDON		;NO, FINISH OFF
;EOF CHECKS

NORMOD:	ILDB	T2,P4		;PICK UP COLUMN ONE
	TRZ	T2,-10000	;ONLY THE RAW DATA
	CAIE	T2,CODEOF+NEWEOF;EOF?
	CAIN	T2,CODEOF	;THIS TYPE?
	  JRST	EOFCRD		;YES
	CAIN	T2,NEWEOF	;NEW TYPE EOF?
	  JRST	EOFCRD		;YES
	TRNE	S,14		;BINARY MODE?
	  JRST	CRBIN		;YES, GO PROCESS CARD

;HERE FOR ASCII MODE TO READ EACH BYTE FROM THE CARD READER AND
;	STORE THE CONVERTED CHARACTER IN THE USERS BUFFER.  NOTE THAT
;	OF THE 16 BITS WE GET FROM -20F, BIT 0 = INVALID MULIT-PUNCH,
;	BITS 1-3 = ENCODED ROW PUNCHES 1-7, AND BITS 4-15 = 12 HOLES.

	CAIN	T2,COD026	;026 CARD DEFINITION?
	  JRST	SET026		;YES, GO SET IT UP
	CAIN	T2,COD029	;029 CARD DEFINITION?
	  JRST	SET029		;YES, SET THAT MODE
CRASC:	ILDB	T1,T4		;PICK UP A BYTE
	TRNE	T1,100000	;MULTIPUNCH COLUMN
	JRST	[MOVEI T1,"\"	;YES, GET "INVALID" CHARACTER
		JRST CRASC1]	;AND STORE THAT
	CAIN	T1,5000		;CONVERT [
	MOVEI	T1,24202	;  TO INTERNAL FORM
	CAIN	T1,3000		;ALSO, CONVERT ]
	MOVEI	T1,22202	;  TO INTERNAL FORM
	LDB	T2,[POINT 3,T1,26] ;PICK UP ZONES PLUS LOW ENCODED BIT
	TRNE	T1,3		;AN 8 OR 9 PUNCH?
	TRC	T2,7		;YES, ENCODE THAT
	TRZE	T1,40000	;COPY THIS BIT
	TRO	T2,10		;TO HERE
	TRNE	T1,1		;AND THIS BIT ON
	TRO	T1,10000	;MEANS THIS BIT SHOULD BE ON
	LSH	T1,-^D12	;POSITION THE REMAINING CODE BITS
	TLNE	S,CR026		;026 MODE?
	TRO	T2,20		;YES, ENCODE THAT
	LDB	T1,CRCVPT##(T1)	;PICK UP ASCII CHARACTER
CRASC1:	IDPB	T1,DEVPTR(F)	;PUT IT INTO USER'S BUFFER
	SOJG	T3,CRASC	;LOOP THROUGH CARD
	MOVEI	T1,15		;TACK ON A CR
	IDPB	T1,DEVPTR(F)	;
	MOVEI	T1,12		;  AND A LF
	IDPB	T1,DEVPTR(F)	;
	JRST	CRDON		;FINISH OFF CARD
;BINARY CARD PROCESSING

CRBIN:	MOVEI	T1,-5(T2)	;CHECK FOR 7-9 PUNCH IN COLUMN 1
	TRNE	T1,17		;THERE?
	TRO	S,IOIMPM	;NO, SET IMPROPER MODE BIT
	LSH	T2,-6		;POSITION THE WORD COUNT
	JUMPE	T2,DCRGO	;IGNORE CARD IF COUNT=0
	HRRM	T2,@DEVPTR(F)	;STORE COUNT IN BUFFER
	IMULI	T2,3		;CONVERT TO BYTE COUNT
	CAMGE	T2,T3		;SMALL ENOUGH FOR BUFFER?
	MOVEM	T2,T3		;YES, USE THIS COUNT
	IBP	T4		;SKIP COLUMN ONE
	ILDB	P4,T4		;GET COLUMN 2
	TRZ	P4,-10000	;ONLY COLUMN PUNCHES
	HRLM	P4,@DEVPTR(F)	;STORE IN L.H. OF 1ST DATA WORD
	HRLZ	P4,P4		;POSITION CHECK SUM
CRBIN1:	ILDB	T1,T4		;PICK UP A COLUMN
	IDPB	T1,DEVPTR(F)	;PUT IT INTO USER'S BUFFER
	SOJG	T3,CRBIN1	;LOOP THROUGH CARD
	MOVEI	T2,@DEVIAD(F)	;GET ADDRESS OF BUFFER AGAIN
	PUSHJ	P,CKS12##	;CALCULATE THE CHECKSUM
	CAME	T1,P4		;GOOD CHECKSUM?
	TRO	S,IODTER	;NO, SET THE BIT

;END OF CARD PROCESSING

CRDON:	MOVEI	T1,@DEVPTR(F)	;PICK UP STOPPING PLACE
	MOVEI	T2,@DEVIAD(F)	;PICK UP STARTING PLACE
	SUBI	T1,1(T2)	;COMPUTE NUMBER OF WORDS STORED
	HRRM	T1,1(T2)	;STORE IN 1ST WORD OF BUFFER
	AOS	DCRCNT(F)	;INCREMENT THE CARD COUNTER
	PUSHJ	P,SETIOD##	;LET USER CONTINUE
	PUSHJ	P,ADVBFF##	;ON TO NEXT BUFFER
	SKIPA
	JRST	DCRGO		;THERE IS ONE, START IT
	PUSHJ	P,RTEVM##	;NO BUFFER AVAILABLE, RETURN ANY EVM
	PJRST	CLRACT##	;CLEAR I/O ACTIVE AND RETURN

;MODE SETTING

SET026:	TLOA	S,CR026		;PUT INTO 026 MODE
SET029:	TLZ	S,CR026		;PUT INTO 029 MODE
	JRST	DCRGO		;START A NEW CARD

;EOF CARD PROCESSING

EOFCRD:	TLO	S,IOEND		;SET THE MAGIC BIT FOR UUOCON
	JRST	CRDON		;THAT'S ALL WITH THIS CARD
SUBTTL	ACCEPT DEVICE STATUS FROM 11

;HERE FROM DTESER TO ACCEPT DEVICE STATUS FROM 11 (DTESER ALREADY RECEIVED IT)

F11DVS:	PUSHJ	P,SETRGX	;SET UP INTERRUPT REGS (CHECK EM.NXD ALSO)
	  JRST	EATMSG##	;NO DDB
	ILDB	T2,P4		;GET FIRST (GENERAL) STATUS BYTE
	ILDB	T1,P4		;GET SECOND (CDR) STATUS BYTE
	HRL	T2,T1		;REPACK THE DATA
	MOVE	T3,DEVSTS(F)	;PICK UP OLD STATUS
	MOVEM	T2,DEVSTS(F)	;PUT THE DEVICE STATUS INTO THE DDB
	MOVSI	T1,DVOFLN	;ASSUME DEVICE ON-LINE
	TDNE	T2,[CR.RCK+CR.PCK+CR.SCK,,EM.FER] ;ANY BAD ERRORS?
	  JRST	CRDVS2		;YES
	TRNE	T2,EM.OFL!EM.NXD ;OFF-LINE?
	  JRST	CRDVS3		;YES
	ANDCAM	T1,DEVCHR(F)	;
	MOVSI	T1,CRTRBL	;GET TROUBLE BIT
	ANDCAM	T1,DEVIOS(F)	;MAKE SURE IT'S CLEAR
	TRNE	T3,EM.OFL!EM.NXD
	PUSHJ	P,PSIONL##	;YES, TELL USER IT IS BACK AGAIN
	PJRST	EATMSG##	;EAT THE REST OF THE INDIRECT DATA

CRDVS2:	TRO	S,IODERR	;NOTE DEVICE ERROR
	TLO	S,CRTRBL	;YES, NOTE TROUBLE AT INTERRUPT LEVEL
CRDVS3:	TRNN	S,IOACT		;ANY I/O ACTIVE?
	PJRST	EATMSG##	;NO, JUST EAT THE REST OF THE MESSAGE
	IORM	T1,DEVCHR(F)	;NOTE DEVICE OFF-LINE
	MOVEM	S,DEVIOS(F)	;SAVE NEW STATUS
	PUSHJ	P,DEVERR##	;NOTIFY THE USER
	PJRST	EATMSG##	;AND EAT THE REST OF THE MESSAGE
SUBTTL	SUPPORT SUBROUTINES

;INTERRUPT REGISTER SETUP
;CALL WITH:
;	P1=CPU #,,DTE #
;	P3=LINE,,DATA COUNT
;	P4=BYTE POINTER TO MESSAGE

SETRGX:	MOVE	T1,P4		;COPY BYTE POINTER
	ILDB	T1,T1		;GET GENERAL STATUS BYTE
	TRNE	T1,EM.NXD	;NON-EXISTANT DEVICE?
	POPJ	P,		;THEN WE CERTAINLY DON'T KNOW ABOUT IT
SETRGS:	MOVE	F,DDBTAB##+.TYCDR ;POINT TO PROTOTYPE DDB
SETRG1:	HLRZ	F,DEVSER(F)	;LINK TO NEXT
	JUMPE	F,SETRG2	;GO CONFIGURE IF END OF CHAIN
	LDB	T1,PDVTYP##	;GET DEVICE TYPE
	CAIE	T1,.TYCDR	;STILL LOOKING AT RIGHT TYPE?
	JRST	SETRG2		;NO--MUST CONFIGURE
	HRRZ	T1,DEVSER(F)	;GET DISPATCH
	CAIN	T1,DCRDSP	;OWNED BY US?
	CAME	P1,DCRCDN(F)	;AND CPU,,DTE NUMBERS MATCH?
	JRST	SETRG1		;TRY NEXT DDB
	HLRZ	T1,DCRDUX(F)	;GET FE UNIT (LINE) NUMBER
	HLRZ	T2,P3		;AND THE ONE FROM THE MESSAGE
	CAIE	T1,(T2)		;MATCH?
	JRST	SETRG1		;TRY ANOTHER
	AOS	(P)		;GIVE SKIP RETURN
	PJRST	IOSET##		;GET THE REST OF THE AC'S

SETRG2:	SETZ	F,		;UNKNOWN DEVICE
	PUSHJ	P,DCRDTS	;AUTOCONFIGURE A CARD READER
	  POPJ	P,		;FAILED
	AOS	(P)		;GIVE SKIP RETURN
	PJRST	IOSET##		;GET THE REST OF THE AC'S

	END
