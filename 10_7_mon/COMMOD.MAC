TITLE	COMMOD - COMMON DATA LOCATIONS USED BY LEVEL D DISK SERVICE - V727
SUBTTL	T. HASTINGS/TW/CMF/DAL/JBS/EVS/TW/JAD  03-JUL-90

	SEARCH	F,S,DEVPRM
	$RELOC

;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED
;  OR COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION
; 1973,1974,1975,1976,1977,1978,1979,1980,1982,1984,1986,1988,1990.
;ALL RIGHTS RESERVED.

.CPYRT<1973,1990>


XP VCOMMD,727

	ENTRY	COMMOD

COMMOD:			;CAUSE COMMOD TO LOAD IF IN LIBRARY FILE

;ALL DATA LOCATIONS USED BY FILSER ARE HERE INSTEAD OF COMMON
; NO DATA LOCATIONS SHOULD BE PUT INTO COMMON FOR LEVEL D


REPEAT 0,<
ASSEMBLY INSTRUCTIONS:

.R MACRO
*COMMOD,COMMOD/C=HDWCNF,COMMOD
>
SUBTTL	TABLE OF CONTENTS

;               TABLE OF CONTENTS FOR COMMOD
;
;
;                        SECTION                                   PAGE
;    1. TABLE OF CONTENTS.........................................   2
;    2. CONVERT MONGEN SYMBOLS....................................   3
;    3. DEFAULT SYMBOLS...........................................   9
;    4. GENERAL COMMENTS..........................................  12
;    5. LIMITS OF VARIOUS FIELD WIDTHS IN FILE STRUCTURES.........  19
;    6. DATA STRUCTURE DESCRIPTION................................  20
;    7. BLK - PARAMETERS WHICH APPEAR IN MORE THAN ONE DISK BLOCK.  22
;    8. COR - PARAMETERS WHICH APPEAR IN MORE THAN ONE CORE BLOCK.  23
;    9. ACC:    ACCESS DATA BLOCKS ENTRY..........................  25
;   10. BAF:    BAD ALLOCATION FILE...............................  32
;   11. CHN:    CHANNEL DATA BLOCK................................  35
;   12. DEV:    DEVICE DATA BLOCK (ONE FOR EACH ACTIVE SOFTWARE USER CHANNEL)  44
;   13. DRB:    DISK I/O REQUEST BLOCK............................  53
;   14. HOM:    WORD POSITIONS IN HOME FILE DATA BLOCK............  54
;   15. LNM:    LOGICAL NAME SPECIFICATIONS.......................  59
;   16. MONITOR JOB TABLES - ONE ENTRY PER JOB....................  60
;   18. LBN - LOGICAL DISK BLOCK NUMBERS WITHIN UNIT(NOT STR) ASSIGNED AS ASSEMBLY TIME  78
;   19. MFD     WORD POSITIONS IN MASTER FILE DIRECTORY...........  79
;   20. NMB FILE NAME DATA BLOCK..................................  80
;   21. PATH. UUO PARAMETERS......................................  82
;   22. PTR:    COPY OF RETRIEVAL POINTERS KEPT IN CORE FOR UPDATE FILES  83
;   23. PPB - PROJECT PROGRAMMER NUMBER DATA BLOCK................  84
;   24. RIB     WORD POSITIONS FOR RETRIEVAL INFORMATION BLOCK....  86
;   25. SAT BLOCKS................................................  91
;   26. STR:    FILE STRUCTURE DATA BLOCK.........................  95
;   27. SWI - IN-CORE COPY OF SWITCH.INI..........................  98
;   28. "SYS" - SYSTEM WIDE QUANTITIES............................  99
;   29. LEVEL D GETTAB TABLE...................................... 100
;   30. UFB:    USER FILE DIRECTORY BLOCK......................... 111
;   31. UFD:    USER FILE DIRECTORY BLOCK......................... 113
SUBTTL	CONVERT MONGEN SYMBOLS
REPEAT 0,<

;THIS SECTION CONVERTS NEW MONGEN SYMBOLS TO OLD MONGEN SYMBOLS
;SO THAT THE REST OF COMMON AND MONITOR CAN STILL USE THE OLD
;SYMBOLS.  THIS WAS DONE RATHER THAN CONVERTING ALL OF THE
;MONITOR TO NEW SYMBOLS FOR TWO REASONS:
; 1.  IT IS EASIER AND FASTER AND LESS LIKELY TO INTRODUCE BUGS, AND
; 2.  IT ALLOWS CUSTOMERS TO USE OLD MONGEN WITH A MINIMUM
;OF TROUBLE: ONLY A FEW EXTRA SYMBOLS MUST BE DEFINED.
;THE MONITOR WILL PROBABLY BE CONVERTED TO THE NEW MONGEN SYMBOLS
;AFTER THE 5.04 RELEASE.  THE ORDER HERE PARALLELS THE OLD
;MONGEN ORDER.

>
IFDEF M.C0SN,<
XP JOBN,M.JOB+1
>	;END IFDEF
SUBTTL	DEFAULT SYMBOLS

;SYMBOLS WHICH MAY BE CHANGED AT MONGEN TIME IF A USER DOES NOT LIKE STANDARD
; DEFINITIONS. HOWEVER MOST CUSTOMERS WILL BE HAPPY WITH THE STANDARD VALUES
; SO DO NOT BOTHER TO ASK HIM EXPLICIT MONGEN QUESTION.

ND SWPMAX,^D8		;MAX. NO OF UNITS FOR SWAPPING. - ALLOW CUSTOMER TO
			; MAKE BIGGER OR SMALLER.
ND SWCLSN,^D7		;HIGHEST CLASS # FOR SWAPPING
IFG SWCLSN-^D7,<XP SWCLSN,^D7>	;DONT ALLOW USER TO SPECIFY GREATER THAN 7
ND DSKTRY,^D10		;NO. OF ERROR TRYS ON DISK DATA ERRORS
			; FOR ALL FILE STRUCTURES BEFORE RECALIBRATING
ND SERTRY,^D3		;NO. OF TIMES TO TRY ON SEARCH ERRORS
			; BEFORE RECALIBRATING
ND RCLTRY,^D10		;NO. OF TIMES TO TRY 'DSKTRY' DATA ERRORS
			; OR 'SERTRY' S ERRORS
			; WITH RECALIBRATING IN BETWEEN.
			; I.E. NO. OF RECALIBRATIONS+1.
			; TOTAL NO. TIMES = RCLTRY*DSKTRY.

ND PRVFIL,057		;STANDARD FILE PRIVILEGE
			;OWNER=EVERYTHING,PROJ=READ,REST=NO ACCESS
ND PRVUFD,775		;STANDARD UFD PRIVILEGE
			;OWNER=ALL,PROJ=ALL,REST=READ+LOOKUPS
ND CHVIFP,^D10		;STANDARD INITIAL FAIRNESS COUNT FOR POSITIONING
ND CHVIFT,^D10		;STANDARD INITIAL FAIRNESS COUNT FOR TRANSFERRING
ND PTRLEN,^D7		;NO. OF IN CORE RETRIEVAL POINTERS PER FILE
			; LENGTH AFFECTS SIZE OF DEVICE DATA BLOCK
ND LBFSIZ,1000		;DEFAULT LARGE-BUFFER SIZE (OP.LBF ON IN OPEN)
ND FIL4WD,^D9		;NO. OF 8 WORD CORE BLOCKS PER JOB
			; FOR FILSER NMB,PPB,UFB,ACC CORE
			; BLOCKS(INCLUDING DORMANT ONES)
ND UNVRSF,^D500		;RECIPROCAL SAFETY FACTOR FOR EACH UNIT
			; IE NO. BLKS ON UNIT/UNVRSF
			; IS SUBTRACTED FROM NO OF FREE BLOCKS
			; SEE STRTAL,UNITAL
ND LNMMXL,144		;MAX LENGTH OF ANY LOGICAL NAME SPECIFICATION
IFG LNMMXL-777,<XP LNMMXL,777>	;DONT ALLOW LOGICAL NAMES TO EXCEED FIELD WIDTH
ND LNMMAX,77		;MAX NO OF LOGICAL NAMES
;OTHER SYMBOLS WHICH THE CUSTOMER CAN CHANGE USING MONGEN INCLUDE:
;LBNHOM=	DEFAULT LOG BLOCK WITHIN UNIT FOR 1ST HOME BLOCK
;LB2HOM=	DEFAULT LOG BLOCK WITHIN UNIT FOR 2ND HOME BLOCK
;MFDSIZ=	NO. OF CONTIGUOUS BLOCKS TO ASSIGN TO MFD SO USUALLY NEED
;		ONLY ONE RETRIEVAL POINTER

ND SYRDPR,355000	;NON-PRIVILEGED FILES IN SYS
			; HOME.SYS,SAT.SYS
ND SYNRPR,357000	;PRIVILEGED FILES IN SYS
			; CRASH.SAV, SNAP.SYS,RECOV.SYS,BADBLK.SYS,SWAP.SYS
ND MFDPRV,555000	;MFD PRIVILEGES(ALL CAN READ,LOOKUP)
			; BUT NOT CREATE
ND SYSPRV,775000	;SYS UFD PRIVILEGES(PROJ 1 READ,CREATE
			;LOOKUP, OTHERS READ
			; LOOKUP ONLY

ND PRVSPL,077		;PROTECTION FOR SPOOLED OUTPUT
ND PRVSYS,155		;PROTECTION FOR MOST SYS:
ND PRYSYS,157		;PROTECTION FOR SYS:.SYS

ND LIMLVL,5		;MAX NUMBER OF NESTED SFD'S FOR THIS MONITOR
IFG LIMLVL-5,<PRINTX ?Illegal value for LIMLVL>
ND MAXUSI,^D255		;MAXIMUM NEGATIVE USETI
			;  FOR READING EXTENDED RIBS

IFE FTKS10,<
ND BLKMAX,^D100000	;MAX NUMBER OF BLOCKS TO TRANSFER
			; WITH 1 IOWD (SO WONT LOCK OUT
			; HIGH PRIORITY JOBS TOO LONG)
>;END IFE FTKS10
IFN FTKS10,<
ND BLKMAX,^D252		;MAX NUMBER OF BLOCKS TO TRANSFER
			;AT ONE TIME (UNIBUS ADAPTER MAPPING LIMIT)
>;END IFN FTKS10

ND INDPPN,0		;0 MEANS PROJ-PROG ARE DEPENDENT ACCROSS PROJECTS
			; (IE OWNER IS DETERMINED BY PROGRAMMER FIELD ONLY)
			;777777 MEANS PROJ-PROG NOS ARE INDEPENDENT
			; (IE OWNER IS DETERMINED BY PROJECT AND PROGRAMMER
			; NUMBER FIELDS) - EACH ONE BIT IN INDPPN CAUSES
			; THAT BIT TO BE COMPARED IN PROJECT FIELD FOR
			; TEST OF OWNER
ND M.QSTR,0		;DEFAULT QUESTR
IFN FTCIDSK,<
ND M.BNDT,^D16		;DEFAULT NUMBER OF SECONDS BEFORE BINDING CI
			; DISKS AT ONCE TIME
>; END IFN FTCIDSK

ND M.SETS,0		;DEFAULT DISK SETS THIS MONITOR MOUNTS

ND M.DSIO,0		;NON-ZERO TO DISABLE SUPER USETI/USETO

ND M.CBMX,<JOBN-1>	;DEFAULT BLOCKS IN DISK CACHE

ND M.CBHS,<M.CBMX/2>	;DEFAULT NUMBER OF HASH SLOTS
XP CBHSHL,<<M.CBHS!1>*2> ;WORDS IN HASH TABLE (2 WORD ENTRIES, KEEP
			; ODD FOR BETTER HASH)
SUBTTL	GENERAL COMMENTS

REPEAT 0,<
STEPS TO WRITE NEW SOFTWARE FOR A NEW KONTROLLER TYPE

1. DECIDE ON A 2 LETTER MNEMONIC (FH,MD,DP,FS,RP,RN ARE TAKEN, DR RESERVED FOR DRUM)
2. WRITE KONTROLLER DEPENDENT ROUTINE (EG XX'XKON)
>
LOGIC==0		;MAKE SURE PROGRAM LOGIC FLOW IS NEVER ASSEMBLED
REPEAT	LOGIC,<
	THE	PROGRAM LOGIC FLOW FOR THE LEVEL D DISK SERVICE IS PRODUCED
FROM THE PROGRAM LISTINGS BY USE OF A TECO MACRO.  ALL TEXT INSIDE
REPEAT LOGIC,< AND > IS COPIED INTO THE MANUAL.  PUTTING THE PROGRAM
LOGIC FLOW INTO THE LISTING MAKES IT EASIER TO KEEP THE LOGIC FLOW
UP TO DATE WITH THE ACTUAL CODE.
	THE	PROGRAM LOGIC FLOW IS WRITTEN IN A CLOSE TO ENGLISH MANNER
FOLLOWING SYNTACTIC RULES OF THE MAD (MICHIGAN ALGORITHMIC DECODER)
LANGUAGE.  A MINIMUM OF ACTUAL PROGRAM SYMBOLS ARE USED IN THE STATEMENTS.
HOWEVER THE SYMBOLIC TAGS DO CORRESPOND TO THE ONES USED IN THE PROGRAM
FOR EASE OF RELATING A PIECE OF THE FLOW TO THE CODE.  ENGLISH HAS BEEN
USED FOR A NUMBER OF REASONS.  FIRST, THE ENGLISH FLOW WAS PRODUCED
BEFORE THE CODE WAS WRITTEN.  IN THIS WAY THE DESIGN OF THE DECISION
LOGIC WAS DECOMPOSED FROM THE PROBLEM OF CODING, SUCH AS NAMING SYMBOLS,
BITS, AC USAGE AND SUBROUTINE ORGANIZATION.  SECONDLY THE READER
INTERESTED IN UNDERSTANDING THE FLOW DOES NOT HAVE TO LEARN THE ENTIRE
FLOW BEFORE UNDERSTANDING A PART OF IT; HE DOES NOT NEED TO LEARN AND
REMEMBER A LOT OF SYMBOLS AND THEIR MEANING.  A FEW ABBREVIATIONS HAVE
BEEN USED AND THEY ARE:
	STR	FILE STRUCTURE - A LOGICALLY COMPLETE, SELF CONTAINED,
		AND REMOVABLE PART OF THE DISK SYSTEM.  ALL FILE
		RETRIEVAL POINTERS STORED IN AN STR REFER TO DISK
		ADDRESSES WITHIN THAT STR.
	MFD	MASTER FILE DIRECTORY - LISTS ALL PROJECT PROGRAMMER
		NUMBERS IN A SINGLE FILE STRUCTURE ALONG WITH THE DISK
		ADDRESS WITHIN THE FILE STRUCTURE OF THE ASSOCIATED UFD.
	UFD	USER FILE DIRECTORY - LISTS ALL FILES BELONGING TO A
		USER (IDENTIFIED BY A PROJECT-PROGRAMMER NUMBER PAIR)
		IN A SINGLE FILE STRUCTURE ALONG WITH THE DISK ADDRESS
		THE FILE STRUCTURE OF THE ASSOCIATED FILE.
	RIB	RETRIEVAL INFORMATION BLOCK - ALL FILES (INCLUDING THE
		MFD AND UFD) HAVE A 128 WORD DISK BLOCK (RELATIVE BLOCK 0
		OF THE FILE) WHICH CONTAINS ATTRIBUTES OF THE FILE
		ALONG WITH POINTERS TO THE CONTIGUOUS GROUPS OF 128
		WORD DATA BLOCKS OF THE FILE.  THE MFD AND UFD REALLY
		POINT TO THE RIB WHICH IN TURN POINTS TO ALL PARTS OF
		THE FILE.
>
;	THERE IS A POTENTIAL CONFUSION BETWEEN 3 KINDS OF DISK POINTERS:
;	A.  COMPRESSED UFD POINTERS (CUP) - FOUND ONLY IN DIRECTORIES,
;	    POINT TO UNIT AND FIRST CLUSTER.
;	B.  CLUSTER POINTERS - FOUND MOST EVERYWHERE - POINT TO CLUSTERS.
;	C.  BLOCK POINTERS - SELDOM FOUND IN CORE OR ON DISK.
;	    EXEPTIONS:  RIBUFD, RIBSLF,UNIBLK, HOMSLF, SAFSLF

;USE OF PREFIXES IN DEFINING SYMBOLS
;THERE ARE A NUMBER OF DATA AREAS IN CORE OR ON THE DISK WHICH HAVE
;SYMBOLS WHICH DEFINE EACH POSITION IN THE AREA.  TO MAKE IT
;CLEAR WHICH AREA A SYMBOL IS FROM, EACH SYMBOL HAS A THREE LETTER,
;PRONOUNCEABLE PREFIX.  THIS PREFIX IS DIFFERENT WHEN AREA IS IN CORE
;FROM WHEN THE SAME DATA IS ON THE DISK.   THE FOLLOWING TABLE DEFINES
;THE PREFIXES:

REPEAT	LOGIC,<
	DATA	AREA			DISK	CORE	FILE NAME(IF ANY)

	HOME	FILE DATA BLOCK		HOM
	MASTER	FILE DIRECTORY		MFD		1-1.UFD
	USER	FILE DIRECTORY		UFD	UDB	#-#.UFD
	STORAGE	ALLOCATION FILE		SAF	SAB	SAT.SYS
	STORAGE	ALLOCATION POINTERS		SAP
	BAD	ALLOCATION FILE		BAF	BAT	BAT.SYS
	RETRIEVAL INFO BLOCK		RIB
	  (1 PER GROUP OF BLOCKS)
	DSKCHR	UUO				CHR
	LOOKUP/SEARCH/ENTER/RENAME		ENT
	FILE	STRUCTURE DATA BLOCK		STR
	CHANNEL	DATA BLOCK			CHN
	CONTROLLER DATA BLOCK			CON
	UNIT	DATA BLOCK				UNI
	DEVICE	DATA BLOCK(1 PER			DEV
	  OPEN FILE - USER CHANNEL PAIR)
	PROJECT-PROGRAMMER NUMBER BLOCK		PPB
	FILENAME (WITHIN PPN) BLOCK		NMB
	ACCESS	TABLE(1 PER OPEN FILE		ACC
	  OR RECENTLY CLOSED FILE)
>



REPEAT	LOGIC,<
CONVENTIONS ABOUT SYMBOL PREFIXES.  WITHIN CORE BLOCKS THERE ARE THE
FOLLOWING TYPES OF SYMBOLS:
	ACC,NMB	1. RELATIVE WORD ADDRESS
	ACY	2. RELATIVE OR ABSOLUTE ADDRESS OF A WORD CONTAINING A BYTE POINTER
	ACS	3. SIZES OF A BYTE
	ACP	4. BIT WHICH IS IN RIGHT MOST POSITION OF BYTE OR BIT ITSELF.
		   NOTE: BIT 35 IS DEFINED AS 1, BIT 18 AS 400000,
			BIT 17 AS 1, ETC.
	ACN	5. BIT NUMBER (0...35) OF RIGHT MOST BIT OF BYTE
		   (USED TO DEFINE SYMBOLS FOR BYTE POINTERS)
		   (DO NOT CONFUSE WITH ACP)
	ACR	6. BITS IN A BYTE AFTER IT HAS BEEN RIGHT JUSTIFIED IN AN AC.
	ACV	7. VALUE OF A CODE (MORE THAN 1 BIT FLAG) RIGHT JUSTIFIED IN AN AC
		   FOR USE IN LDB AND DPB
	ACM	8. MASK FOR BYTE, I.E. ONES IN EVERY BIT POSITION
		   (BEFORE BYTE IS RIGHT JUSTIFIED)
	ACJ	9. -NO. OF PLACES TO RIGHT JUSTIFY BYTE IN AC (ALWAYS NEG.)

THE RELATIVE WORD ADDRESS HAS THE FULL 3 LETTER PREFIX OF THE CORE BLOCK.
MANY PREFIXES END WITH B STANDING FOR BLOCK, (NOT BYTE OR BIT).
THE MNEMONIC FOR BYTE IS Y(ITS SECOND LETTER - SORRY ABOUT THAT), FOR SIZE
IS S, FOR POSITION IS P, AND FOR RIGHT-JUSTIFIED IS R.

>
;THE FOLLOWING TABLE DEFINES SOME SUFFIXES
;(THE SAME 3 LETTERS IS USED IF PREFIX ALREADY EXISTS)
REPEAT	0,<
	PARAMETER ADDRESSES

	SUFFIX		DEFINITION

	CHN		CHANNEL DATA BLOCK ADDRESS
	CON		CONTROLLER DATA BLOCK ADDRESS
	UNI		UNIT DATA BLOCK ADDRESS
	CCA		CURRENT CONTROLLER ADDRESS
	CUA		CURENT UNIT DATA BLOCK ADDRESS
	CDA		CURRENT DEVICE DATA BLOCK (FILE) ADDRESS
	TAL		TALLY OF FREE BLOCKS
	BSY		BUSY
	PAR		CONTROL WORD PAIR
	SER		SERVICE ROUTINE ADDRESS
	CUP		COMPRESSED POINTER IN UFD'S
	BYT		BYTE POINTER
	POS		RIGHT MOST BIT OF BYTE POINTER BYTE POSITIONS
	SIZ		SIZE OF BYTE, USED IN BYTE POINTERS
	FIL		FILE NAME IN SIXBIT
	EXT		FILE EXTENSION
	DTE		DATE
	PPN		PROJECT-PROGRAMMER NUMBER
	UFD		LOGICAL BLOCK NUMBER OF UFD
	MOD		DEVICE DATA MODE
	MIN		CREATION TIME IN MINUTES
	PRV		ACCESS PRIVILEGES
	CRE		CREATION DATE
	RDN		READ COUNT
	ENT		LOOKUP/SEARCH/ENTER/RENAME
	K4S		NO. OF K FOR SWAPPING
	HGH		HIGHEST LOGICAL BLOCK NUMBER
	BPU		BLOCKS PER UNIT
	CYL		CYLINDER NUMBER
	BLK		LOGICAL BLOCK WITHIN LOGICAL UNIT
	REL		RELATIVE BLOCK NUMBER WITHIN FILE
	BPC(BYTE)	BLOCKS PER CLUSTER
	BPY(BYTE)	BLOCKS PER SMALLEST CYLINDER
	BPT(BYTE)	BLOCKS PER TRACK
	WPB		WORDS PER BLOCK
	LUN(BYTE)	LOGICAL UNIT NO.(WITHIN FILE STRUCTURE)
	PUN(BYTE)	PHYSICAL UNIT NO.(WITHIN CONTROLLER)
	TYP(BYTE)	DEVICE TYPE (DRM,FHD,DPC,MDF)
	CNP(BYTE)	BLOCK COUNT BYTE. POINTER TO CURRENT RET. PTR.
	CKP(BYTE)	CHECKSUM BYTE POINTER IN RET. PTR. TO CURRENT RET. PTR.
	CLP(BYTE)	CLUSTER BYTE POINTER IN RET. PTR. TO CURRENT RET. PTR.
	ERR		ERROR CODE
	ECT		ERROR COUNT ON CURRENT TRANSFER
	PI		PI CHANNEL NUMBER (1 - 7)
	IFP		INITIAL FAIRNESS SETTING FOR POSITIONING ON UNITS
	CFP		CURRENT FAIRNESS COUNT FOR POSITIONING ON UNITS
	IFT		INITIAL FAIRNESS SETTING FOR TRANSFERS ON CHANNEL
	CFT		CURRENT FAIRNESS COUNT FOR TRANSFERS ON CHANNEL
	COD		STATE CODE FOR FILES AND UNITS (I,PW,P,TW,T)
	DIF		DIFFERENCE
	MIN		MINUS
	STN		FILE STRUCTURE NUMBER
	FSN		FILE STRUCTURE NUMBER (0-35)
	PT1		FIRST RETRIEVAL POINTER
	UN1		FIRST LOGICAL NO. WITHIN STR FOR A FILE
	OVR		-NUMBER OF BLOCKS ALLOWED FOR OVERFLOW
	KNO		KNOW EXISTENCE OF FILE AS YES OR NO IN AN STR
	YES		KNOW EXISTENCE OF A FILE AS YES IN AN STR
	PRV		ACCESS PRIVILEGES
	HID		HOME BLOCK ID=PACK ID
	LBN		LOGICAL BLOCK NUMBER WITHIN UNIT

	CORE	LOCATIONS

	IOC		I/O CONTROL WORD, CHANNEL JUMP
	CCW		FINAL CHANNEL CONTROL WORD
	CMD		CONTAINS FIRST OF MANY CHANNEL COMMAND WORDS
	LAS		LAST CHANNEL COMMAND WORD, ALWAYS 0
>
REPEAT	0,<
THE FOLLOWING SUFFIXES ARE USED FOR ENTRY POINTS INTO DEVICE DEPENDENT
CONTROLLER ROUTINES

	RED		READ BLOCKS
	WRT		WRITE BLOCKS
	RDS		READ AND STOP IF ERROR
	WTS		WRITE AND STOP IF ERROR
	POS		POSITION UNIT
	LTM		RETURN LATENCY TIME


THE FOLLOWING ARE PREFIXES WHICH RELATE TO THE TYPE OF DATA BUT ARE
NOT IN DATA BLOCKS

	TYP		TYPE OF DEVICE (DRM,FHD,DPC,MDF)
	DSK		DISK
	FNC		FUNCTION CODE ON CALL TO CONTROLLER ROUTINES
>
SUBTTL	LIMITS OF VARIOUS FIELD WIDTHS IN FILE STRUCTURES

XP LIMHOM,^D18		;LIMIT ON HIGHEST LOG. BLOCK # THAT CAN BE A HOME BLOCK
XP LIMFRE,^D13		;LIMIT ON NUMBER OF FREE CLUSTERS IN A 128 WORD
			; SAT TABLE
XP LIMNUS,^D6		;NO. OF UNITS IN A RH FILE STRUCTURE (77)
XP LIMCLP,^D23		;UPPERLIMIT ON BYTE SIZE OF CLUSTER ADDRESS IN
			; RETRIEVAL POINTER (I.E. LIMIT ON NUMBER OF
			; CLUSTERS ON A SINGLE UNIT)
XP LLMCLP,^D1		;LOWER LIMIT
XP LIMCKP,^D34		;UPPER LIMIT ON BYTE SIZE CHECKSUM
XP LLMCKP,^D0		;LOWER LIMIT
XP LIMCNP,^D18		;UPPER LIMIT ON BYTE SIZE OF NO. OF CLUSTERS IN A
			; RETRIEVAL POINTER (ELSE RUN INTO UNIT CHANGE BIT)
XP LLMCNP,^D1		;LOWER LIMIT
XP LIMBLK,^D36		;LIMIT ON THE NUMBER OF BLOCKS ON A SINGLE UNIT
XP LIMLEN,^D36		;MAX. NO. OF BLOCKS IN A FILE
XP LIMWPS,^D7		;MAX. NO. OF WORDS PER SAT BLOCK
			; (CANNOT EXCEED CLUSTER SIZE EITHER)
XP LIMSIC,^D8		;MAX. NO. OF SAT BUFFERS IN CORE
XP LIMUFD,^D9		;MAX. NO. OF BLOCKS IN MFD OR UFD
XP LIMQTF,^D27		;MAX. NO. OF FIRST COME FIRST SERVE DISK BLOCKS IN LOGGED IN
			; QUOTA FOR A USER ON A FILE STRUCTURE.
XP LIMBPC,^D9
XP LIMBBF,^D31		;MAX NO OF DEFAULT BLOCKS PER BUFFER
XP LIMBBW,<^D31*^D128>	;MAX NO OF WORDS PER BUFFER
XP LIMUSZ,^D45		;MAX NO OF BLOCKS TO ZERO ON AN ALLOCATING USETO
			; DO ***NOT*** INCREASE THIS NUMBER, IT IS HARDWARE DEPENDENT
			; (3600 WORDS * 3 IOWDS). SEE RH2FX1 IN KLSER

XP MAXLVL,5		;ABSOLUTE MAX NUMBER OF NESTED SFD'S
XP BLKSIZ,^D128		;NO. OF WORDS IN A DISK BLOCK (MUST BE POWER OF 2)
XP MBLKSZ,-BLKSIZ	;MINUS NO. OF WORDS IN A DISK BLOCK
XP BLKLSH,^D7		;NO. OF PLACES TO SHIFT LEFT TO CONVERT FROM
			; BLOCKS TO WORDS
XP MBKLSH,-BLKLSH	;MINUS NO OF PLACES TO SHIFT LEFT (IE RIGHT) TO
			; CONVERT FROM WORDS TO BLOCKS
XP SWBKPP,4		;4 BLOCKS PER PAGE
XP LIMK4S,^D18		;MAX NO OF PAGES FOR SWAPPING ON UNIT
SUBTTL	DATA STRUCTURE DESCRIPTION

;THE FOLLOWING CORE DATA BLOCKS ARE LINKED TOGETHER TO DESCRIBE
;AN ARBITRARY CONFIGURATION OF FILE STRUCTURES ON AN ARBITRARY
;CONFIGURATION OF CHANNELS, KONTROLLERS, POSITIONERS, AND UNITS:
;EACH SYSTEM HAS:
;SYS:	DATA LOCATIONS AND BYTE POINTERS PER SYSTEM
;STR: 1 OR MORE FILE STRUCTURES PER SYSTEM
;CHN: 1 OR MORE CHANNELS (CAN BE SHARED BY MORE THAN 1 FILE STRUCTURE)
;CON: 1 OR MORE KONTROLLERS (DIFFERENT TYPES ON SAME CHANNEL, BUT SAME
;     TYPES IN A GIVEN FILE STRUCTURE) PER CHANNEL
;UNI: 1 OR MORE UNITS PER KONTROLLER
;DEV: 1 OR MORE QUEUED POSITION REQUESTS PER UNIT
;     1 OR MORE QUEUED TRANSFER REQUESTS PER CHANNEL
;PPB: 1 OR MORE ACTIVE OR DORMANT PROJ-PROG NOS BLOCKS PER SYSTEM
;UFB: 1 OR MORE ACTIVE OR DORMANT UFD BLOCKS (1 FOR EACH STR) PER PROJ-PROG NO.
;NMB: 1 OR MORE ACTIVE OR DORMANT FILE NAME BLOCK (INDEPENDENT OF STR)
;	PER PROJ-PROG NO.
;ACC: 1 OR MORE ACTIVE OR DORMANT ACCESS BLOCK (1 FOR EACH VERSION OF A FILE)
;	PER FILEMANE/PROJ-PROG NO. PAIR

;THE FOLLOWING RESTRICTIONS APPLY:
;    1) FILE STRUCTURE MUST BE COMPOSED OF SAME SIZE AND TYPE DEVICES
;	EXCEPTIONS - RD10 (BURROUGHS FHD) AND RM10B (BRYANT DRUM) MAY
;	BE IN SAME FILE STRUCTURE SINCE ON SAME CONTROLLER; ALSO RP01
;	AND RP02 (MEMOREX DISK PACK)
;    2) FILE STRUCTURE MAY BE COMPOSED OF ONE OR MORE CONTROLLERS
;	(OF THE SAME TYPE.)
;    3) EACH UNIT CAN BE A MEMBER OF ONE AND ONLY ONE FILE STRUCTURE
;    4) MORE THAN ONE CONTROLLER IN THE SAME OR DIFFERENT FILE STRUCTURE
;	ON THE SAME CHANNEL (SOFTWARE WILL DO LATENCY OPTIMIZATION ON A
;	CHANNEL BASIS RATHER THAN A CONTROLLER BASIS)

;SOME CORE BLOCKS ARE LINKED TOGETHER BY A ONE DIRECTION STRING OF
;POINTERS TERMINATED WITH A 0.  A "LIST", PTR IN LH.  OTHER CORE BLOCKS
;ARE LINKED TOGETHER BY A ONE DIRECTIONAL STRING OF POINTERS WHICH
;CLOSES ON IT SELF.  A "RING", PTR IN LH.  STILL OTHER BLOCKS POINT
;BACK UP THE TREE TO THEIR FATHER OR THEIR GRANDFATHERS.
;UPWARD POINTERS TEND TO BE IN RH WITH BITS 13-17=0 SO INDIRECTION
;CAN BE USED.
;THE REST OF THE CORE BLOCKS ARE POINTED TO BY ONE CORE BLOCK TABLE
;OF POINTERS - A"FANOUT TABLE" THESE ARE IN RH.
;STATIC ADDRESS OF CORE DATA BLOCKS ASSEMBLED IN OTHER DATA BLOCKS:
;FANOUT TAB	- SYS POINTS TO ALL STR TABLES (TABSTR)
;FANOUT TAB	- EACH KON POINTS TO ALL PHYS UNI WITHIN KONTROLLERS (KONTAB)
;LIST		- EACH STR LINKS TO NEXT STR WITHIN SYS (LH STRSYS)
;LIST		- EACH UNI LINKS TO NEXT UNI WITHIN STR (LH UNISTR)
;LIST		- EACH UNI LINKS TO NEXT UNI WITHIN SYS (LH UNISYS)
;RING		- EACH UNI LINKS TO NEXT UNI WITHIN CHN (UNICHN)
;RING		- EACH UNI LINKS TO NEXT UNI WITHIN KON (UNIKON)
;UPWARD POINTER	- EACH DEV POINTS TO ITS UNI (RH DEVUNI)
;UPWARD    "	- EACH UNI POINTS TO ITS KON (UDBKDB)
;UPWARD    "	- EACH UNI POINTS TO ITS STR (RH UNISTR)
;UPWARD    "	- EACH KON POINTS TO ITS CHN (KDBCHN)
SUBTTL	BLK - PARAMETERS WHICH APPEAR IN MORE THAN ONE DISK BLOCK

BLKNAM==:0		;SIXBIT NAME OF BLOCK(HOM,BAT)
BLKCOD==:176		;SELF IDENTIFYING CODE FOR BLOCK RH ONLY, LH==0
BLKSLF==:177		;LOGICAL BLOCK WITHIN UNIT(NOT STR) TO IDENTIFY SELF
SUBTTL	COR - PARAMETERS WHICH APPEAR IN MORE THAN ONE CORE BLOCK

;OUT OF ALPHABETIC ORDER BECAUSE MUST BE FIRST, SINCE SYMBOLS DEFINED USING
;THEM WITH THE SAME VALUES SO THAT GENERALIZED ROUTINES MAY BE CALLED.
;THESE SYMBOLS SHOULD NOT BE USED UNLESS FOR A GENERALIZED ROUTINE,
;ELSE BUGS SINCE NOT ALL CORE BLOCKS HAVE ALL THE FOLLOWING BYTES.
;HOWEVER ALL BYTES WHICH ARE THE SAME APPEAR IN THE SAME PLACE IN ALL
;CORE BLOCKS IN WHICH THE DATA APPEARS.

	$HIGH

CORWDS==:10		;WORDS/CORE BLOCK
CRWDM1==:CORWDS-1
CORXTR==:7		;EXTRANEOUS BITS IN 8-WORD CORE BLOCK ADR'S

;WORD 0---------------------------------------
CORNAM==:0		;SIXBIT NAME OF BLOCK
			;[PPBNAM,NMBNAM]

;WORD 1---------------------------------------
CORLNK==:1		;LIST LINK WORD IN LH. LH=CORE ADR(ADDRESS POINTER)
			; TO NEXT BLOCK IN LIST WITH SAME FATHER. MAYBE
			; LIST OR RING, [PPBSYS,UFBPPB,NMPPB,ACCNMB]
DIFLNK==:CORLNK-CORWDS
CORUN1==:1		;FIRST LOGICAL UNIT WITHIN STR FOR THIS FILE - WORD ADR.
    COSUN1==^D4		    ;BYTE SIZE
    CONUN1==^D31	    ;BYTE PTR. POS.
    COPUN1==:20		    ;RIGHT MOST BIT
COYUN1::POINT	COSUN1,CORUN1(T2),CONUN1
COR1PT==:CORUN1		;SINGLE RETRIEVAL POINTER FLAG - WORD ADDR.
			;1 IF CORPT1 IS THE ONLY RETRIEVAL POINTER TO FILE
    COS1PT==^D1		    ;BYTE SIZE
    CON1PT==^D27	    ;BYTE PTR. POS.
    COP1PT==:400	    ;SINGLE RETRIEVAL POINTER FLAG - BIT[UFB1PT,NMB1PT,AKB1PT]

;WORD 2---------------------------------------
CORPT1==:2		;COPY OF FIRST RETRIEVAL POINTER TO FILE OR UFD
			; COR1PT=1 IF THIS IS THE ONLY POINTER [UFBPT1,AKBPT1]

;WORD 3---------------------------------------

;WORD 4---------------------------------------
CORFSN==:4		;FIRST FILE STRUCTURE NUMBER - WORD ADR.
    COSFSN==.FSFSN	    ;BYTE SIZE
    CONFSN==COSFSN-1	    ;BYTE PTR. POS. (LEFT JUSTIFIED IN WORD)
COYFSN::POINT	COSFSN,CORFSN(T2),CONFSN	;FILE STRUCTURE NUMBER - BYTE
COZFSN::POINT	COSFSN,CORFSN(T1),CONFSN
COXFSN::POINT	COSFSN,CORFSN(P4),CONFSN
CORZRB==:4		;DIRECTORY HAS EMPTY DATA BLOCKS
    COPZRB==:10		    ;BIT 14=1 IF YES
;WORD 5---------------------------------------
CORKNO==:5		;KNOW WHETHER FILE OR UFD DOES OR DOES NOT EXIST IN
			; IN FILE STRUCTURE N. - WORD ADR.
			; BIT N+1=1 IF KNOW IN STR N [PPBKNO,NMBKNO]
    COSKNO==.SLMAX	    ;BYTE SIZE
    CONKNO==COSKNO-1	    ;BYTE PTR. POS. (LEFT JUST. IN WORD)
    COPKNO==:1B<CONKNO>	    ;RIGHT MOST BIT
    COJKNO==:-^D35+CONKNO   ;REQIRED SHIFT FOR RIGHT JUSTIFICATION

FSNBIT::COPKNO
ALLKNO::<-1>B<CONKNO>		;MASK FOR WHOLE KNO FIELD
COYKNO::POINT	COSKNO,CORKNO(T2),CONKNO
COZKNO::POINT	COSKNO,CORKNO(T1),CONKNO

;WORD 6---------------------------------------
CORYES==:6		;FILE OR UFD DEFINITELY EXISTS IN FILE STRUCTURE N-WORD ADR.
			; IF BIT N+1=1. CORRESPONDING BIT IN CORKNO=1 TOO
    COSYES==COSKNO	    ;BYTE SIZE
    CONYES==CONKNO	    ;BYTE PTR. POS.
    COPYES==:COPKNO	    ;RIGHT MOST BIT
ALLYES==:ALLKNO

;WORD 7---------------------------------------
SUBTTL	ACC:	ACCESS DATA BLOCKS ENTRY

;ONE ACCESS TABLE FOR EVERY VERSION OF AN OPEN FILE.  MANY USERS
;ACCESSING SAME FILE VERSION, SHARE ACCESS TABLE.  DORMANT ACCESS
;TABLE IS LEFT AROUND IN CORE AFTER FILE IS CLOSED BY ALL USERS,
;IN HOPES THAT FILE WILL BE LOOKED UP SOON.

REPEAT LOGIC,<

AN ACCESS TABLE CAN BE IN ONE OF THE FOLLOWING STATES:

	D  DORMANT
	R  BEING READ ON ONE OR MORE USERS-CHANNELS, NO ONE UPDATING
	C  BEING CREATED (BY ONE USER)
	S  SUPERSEDING AN OLDER VERSION AND NO ONE READING OLDER VERSION
	U  BEING UPDATED (SAME CHANNEL ALSO COUNTS AS ONE READER)
	UR	BEING UPDATED AND OTHER READERS (READER COUNT GREATER THAN 1)

FOR A GIVEN FILE STRUCTURE:  FILE.EXT[PROJ,PROG] THERE CAN BE EXACTLY
ONE AND ONLY ONE ACCESS ENTRY IN THE SYSTEM WITH THE FOLLOWING
EXCEPTIONS:
	A.  THERE CAN BE TWO ACCESS TABLE ENTRIES
	    R THE OLDER VERSION BEING READ BY 1 OR MORE USERS
	    S THE NEWER VERSION BEING CREATED BY ONE USER
	    THE SYSTEM IS SAID TO BE IN R+S STATE WITH RESPECT TO THE
	    FILE.
	B.  IN ADDITION TO ANY SINGLE ACCESS ENTRY FOR A GIVEN
	    FILE NAME (D, R, C, S, U, UR) OR THE PAIR R+S, THERE CAN
	    BE AN ARBITRARY NUMBER OF SUCCESSIVELY OLDER VERSIONS
	    STILL BEING READ BY ONE OR MORE USERS AND MARKED FOR
	    DELETION OF THE ACCESS TABLE AND DISK SPACE J WHEN READ
	    COUNT GOES TO 0.
THUS THE SYSTEM COULD BE IN ANY ONE OF THE FOLLOWING STATES WITH
REESPECT TO A FILE NAME ARE:
	NO	ACCESS ENTRY, D, R, C, S, U, UR, R+S, J, D+J, R+J, C+J, S+J
	U+J, UR+J, R+S+J, J+J, D+J+J,...R+S+J+K...K+J+J, ETC.
>
;WORD 0---------------------------------------
ACCALC==:0		;HIGHEST RELATIVE BLOCK ALLOCATED TO FILE BY MONITOR
			; OR USER (NEVER INCLUDING SECOND RIB BLOCK,
			; EVEN THOUGH IT IS ALLOCATED AT THE END OF FILE)

;WORD 1---------------------------------------
ACCNMB==:CORLNK		;LH=CORE ADDRESS(ACROSS POINTER) OF NEXT ACCESS
			; BLOCK WITH SAME NAME (AND PROJ-PROG NO.)
			;LAST ACCESS BLOCK POINTS BACK TO NAMEBLOCK(NMB)
			; MAKING THIS ONE OF THE FEW RINGS INSTEAD OF LISTS
			; IN CORE BLOCK STRUCTURE. THE RING IS NEEDED SINCE
			; THERE IS NOT ROOM IN ACCESS BLOCK FOR A BACKWARD
			; POINTER TO PREVIOUS BLOCK. SINCE ACCESS RING IS
			; USUALLY ONLY ONE LONG, THIS IS NOT TOO INEFFICIENT
			; (WHEN REMOVING DORMANT ACCESS BLOCKS WHEN SPACE IS
			; NEEDED). NOTE: ADVANTAGE IS TAKEN OF THE FACT
			; THAT CORE BLOCKS START AT 0 MODULO 8 ADDRESSES.
			; THE LAST ACCESS ENTRY IN RING POINTS BACK, NOT
			; TO FIRST ADDRESS IN NAME BLOCK BUT TO THE WORD WHICH
			; WHICH MAKES THE NAME BLOCK LOOK JUST LIKE AN
			; ACCESS ENTRY. THUS LOW ORDER BITS ARE ON IN LAST
			; BLOCK POINTING TO NAME BLOCK (OR IN NAME BLOCK
			; (NMBACC) IF NO ACCESS BLOCKS AT ALL IN RING.  IN
			; THIS WAY SCANNING AROUND RING AND DELETION ARE
			; NEVER SPECIAL CASES LAST ACCESS BLOCK OR FIRST
			; ACCESS BLOCK IN RING.
			;RH=USED FOR AN INDEPENDENT QUANTITY.
ACCABC==:1		;THIS FILE HAS ALWAYS BAD CHECKSUM
    ACSABC==1		    ;BYTE SIZE
    ACNABC==^D18	    ;BYTE POINTER POSITION
    ACPABC==:400000	    ;RIGHT MOST BIT
ACCLBS==:1		;LAST BLOCK IN FILE SIZE (NO. OF WORDS WRITTEN IN LAST
			; DATA BLOCK)-WORD ADR.
    ACSLBS==^D8		    ;BYTE SIZE
    ACNLBS==^D26	    ;BYTE PTR. POS.
ACYLBS::POINT	ACSLBS,ACCLBS(T2),ACNLBS	;THE BYTE POINTER
ACZLBS::POINT	ACSLBS,ACCLBS(T3),ACNLBS	;THE BYTE POINTER
ACC1PT==:COR1PT		;FLAG FOR ONLY ONE RETRIEVAL POINTER FOR FILE - WORD ADR.
    ACS1PT==COS1PT	    ;BYTE SIZE
    ACN1PT==CON1PT	    ;BYTE PTR. POS.
    ACP1PT==:COP1PT	    ;RIGHT MOST BIT
ACCUN1==:CORUN1		;1ST. LOGICAL UNIT IN FILE STRUCTURE OF THIS FILE - WORD ADR.
    ACSUN1==COSUN1	    ;BYTE SIZE
    ACNUN1==CONUN1	    ;BYTE PTR. POS.
ACCDIR==:1		;THIS FILE IS A DIRECTORY(UFD OR MFD) - WORD ADR.
    ACSDIR==^D1		    ;BYTE SIZE
    ACNDIR==^D32	    ;BYTE PTR. POS.
    ACPDIR==:10		    ;THIS FILE IS A DIRECTORY(UFD OR MFD) - BIT
ACCNDL==:1		;THIS FILE CANNOT BE DELETED
    ACSNDL==1		    ;BYTE SIZE
    ACNNDL==^D33	    ;BYTE POS
    ACPNDL==:4		    ;THE BIT
ACCSBC==:1		;SOMETIMES BAD CHECKSUM (UPDATE)
    ACSSBC==1		    ;BYTE SIZE
    ACNSBC==^D34	    ;BYTE POSITION
    ACPSBC==:2		    ;THE BIT
ACCNCK==:ACCABC		;DONT CHECK CHECKSUMS FOR THIS FILE - WORD ADR
    ACPNCK==:ACPDIR+ACPABC+ACPSBC
ACCGRB==:ACCABC		;DONT GRAB A.T. - WORD ADDRESS
    ACPGRB==:1		    ;CORE GRABBER WONT TOUCH A.T. IF ON
;WORD 2---------------------------------------
ACCPT1==:CORPT1		;FIRST RETRIEVAL POINTER TO FILE - WORD ADR.
			; ACP1PT BIT=1 IF THIS POINTER COMPLETELY DESCRIBES THE
			; FILE. SO RIB DOES NOT NEED TO BE READ FOR MORE POINTERS.
			; (CLUSTER COUNT, CHECKSUM, CLUSTER ADDRESS)

;WORD 3---------------------------------------
ACCDOR==:3		;TWO WAY THREADED LIST LINK WORD
			;LH=CORE ADDRESS(ACROSS POINTER) OF NEXT ACCESS BLOCK
			; IN DORMANT ACCESS BLOCK LIST FOR SYSTEM
			;RH=CORE ADDRESS(BACKWARD POINTER) OF PREVIOUS ACCESS
			; BLOCK IN DORMANT ACCESS BLOCK LIST FOR SYSTEM.
			;THIS WORD=0 IF ACCESS BLOCK IS NOT DORMANT.
			;THIS IS ONLY FLAG FOR DORMANT.
			;THE DORMANT LIST IS TWO-WAY THREADED, SO THAT AN
			; ACCESS BLOCK CAN BE REMOVED QUICKLY FROM THE
			; MIDDLE WHENEVER THE ACCESS BLOCK BECOMES DORMANT.

;WORD 4---------------------------------------
ACCPPB==:4		;LH=USED FOR AN INDEPENDENT QUANTITY
			;RH=CORE ADDRESS (UPWARD POINTER) TO PROJ-PROG
			; BLOCK (PPB) WHICH THIS ACCESS BLOCK IS IN
ACCFSN==:CORFSN		;FSN # - WORD ADR.
    ACSFSN==COSFSN	    ;BYTE SIZE
    ACNFSN==CONFSN	    ;BYTE PTR. POS.
ACYFSN==:COYFSN		;FILE STRUCTURE NO. IN WHICH FILE STARTS INDEXED BY T2.
ACZFSN==:COZFSN		;FSN INDEXED BY T1

ACCWCT==:ACCPPB		;WRITE COUNT FOR SIMULTANEOUS UPDATERS
    ACSWCT==^D8		    ;BYTE SIZE
    ACNWCT==^D13	    ;BYTE PNTR POSITION
    ACPWCT==:20		    ;RIGHT-MOST BIT
    ACWCNT==:7760	    ;MASK FOR THIS FIELD
ACYWCT::POINT	ACSWCT,ACCWCT(T1),ACNWCT
ACZWCT::POINT	ACSWCT,ACCWCT(T2),ACNWCT
ACCZRB==:CORZRB		;SFD HAS EMPTY DATA BLOCKS WORD ADR
    ACPZRB==:COPZRB	    ; THE BIT
;WORD 5---------------------------------------
ACCADT==:5		;DATE THIS FILE WAS LAST ACCESSED FOR MORE THAN JUST LOOKUP
    ACSADT==^D15	    ;BYTE SIZE
    ACNADT==^D17	    ;BYTE PTR. POS.
			    ;BITS 0-2 HAVE HIGH-ORDER PART OF CEATION DATE

ACCNIU==:5		;FILE NOT IN UFD - WORD ADR.
    ACSNIU==^D1		    ;BYTE SIZE
    ACNNIU==^D18	    ;BYTE PTR. POS.
    ACPNIU==:400000	    ;THE BIT - MUST BE BIT 18

ACCCNT==:ACCNIU		;NO. OF USER CHANS. WHICH HAVE LOOKED UP FILE - WORD ADR.
    ACSCNT==^D9		    ;BYTE SIZE
    ACNCNT==^D27	    ;BYTE PTR. POS.
    ACPCNT==:400	    ;RIGHT MOST BIT
    ACMCNT==:377400	    ;MASK (BEFORE RIGHT JUSTIFIED)
    ACMCNM==:377000	    ;MASK FOR READ COUNT-1
ACCUSE==:ACCCNT		;SAME FIELD, BUT USED AS AN SFD USE-COUNT
    ACPUSE==:ACPCNT
    ACMUCT==:ACMCNT
    ACMUCM==:ACMCNM

ACYCNT::POINT	ACSCNT,ACCCNT(T1),ACNCNT;READ COUNT BYTE POINTER-
			;NO. OF USER CHANNELS
			; WHICH HAVE LOOKED UP FILE(1 MAY BE UPDATING).
ACZCNT::POINT	ACSCNT,ACCCNT(T2),ACNCNT

ACCREN==:ACCSTS		;RENAME UUO IN PROGRESS FOR THIS FILE FLAG - WORD ADR.
			; CAN BE ON WITH OR WITHOUT JUST ONE FLAG BIT IN ACYSTS.
    ACSREN==^D1		    ;BYTE SIZE
    ACNREN==^D28	    ;BYTE PTR. POS.
    ACPREN==:200	    ;THE BIT

ACCDEL==:ACCSTS		;FILE MARKED TO BE DELETED WHEN ALL READERS FINISH-WORD ADR.
			; FILE WILL BE DELETED BY CLOSE UUO
    ACSDEL==^D1		    ;BYTE SIZE
    ACNDEL==^D29	    ;BYTE PTR. POS.
    ACPDEL==:100	    ;THE BIT
ACCSTS==:ACCCNT		;ACCESS TABLE STATUS - WORD ADR.
			; CONTAINS CREATE/SUPERSEDE/UPDATE UNARY STATE CODE
    ACSSTS==^D3		    ;BYTE SIZE
    ACNSTS==^D32	    ;BYTE PTR. POS.
    ACPCRE==:40		    ;CREATING FILE - UNARY STATE CODE
    ACRCRE==:4		    ;CREATING FILE - UNARY STATE CODE RIGHT JUSTIFIED
    ACPSUP==:20		    ;SUPERSEDING ANOTHER FILE - UNARY STATE CODE
    ACRSUP==:2		    ;SUPERSEDING ANOTHER FILE-UNARY STATE CODE RIGHT JUSTIFIED
    ACPUPD==:10		    ;UPDATING FILE - UNARY STATE CODE
    ACRUPD==:1		    ;UPDATING FILE - UNARY STATE CODE RIGHT JUSTIFIED

ACYSTS::POINT	ACSSTS,ACCSTS(T2),ACNSTS	;ACCESS TABLE STATUS
;WORD 5 (CONTINUED)---------------------------------------

ACCSMU==:ACCCNT		;THIS FILE BEING SIMULTANEOUSLY UPDATED
    ACPSMU==:4		    ;THE BIT

ACCPAL==:ACCSTS		;PRE-ALLOCATED FILE
    ACPPAL==:2		    ;IF THIS IT IS ON

;NDR IS SET TO "1" BY QUESER IF ANY "NO DELETE ON RESET"
;REQUESTS ARE MADE ON THIS FILE.
    ACPNDR==:1		    ;THE BIT
;WORD 6---------------------------------------
ACCWRT==:6		;HGHEST RELATIVE BLOCK WRITTEN, NOT COUNTING SECOND
			; RIB. SINCE FIRST RIB IS RELATIVE BLOCK 0, AND
			; FIRST DATA BLOCK IS BLOCK1 THIS QUANTITY IS THE
			; SAME AS THE NUMBER OF DATA BLOCKS WRITTEN.
			;THIS WORD IS CHECKED ON READ FOR END OF FILE.
			;IT IS UPDATED DYNAMICALLY AS FILE IS APPENDED.

;WORD 7---------------------------------------
ACCPRV==:7		;PRIVILEGE WORD. SAME FORMAT AS LOOKUP/ENTER E+2
			; PRIVILEGES(9), MODE(4), CREATION TIME(11),CREATION DATE(12)
			; SEE RIBPRV FOR BIT DEFINITIONS
    ACSPRV==^D9		    ;BYTE SIZE
    ACNPRV==^D8		    ;BYTE PTR. POS.
ACYPRV::POINT	ACSPRV,ACCPRV(T4),ACNPRV	;BYTE PTR.
ACCMOD==:ACCPRV		;FILE MODE - WORD ADR.
    ACSMOD==^D4		    ;BYTE SIZE
    ACNMOD==^D12	    ;BYTE PTR. POS.
ACCCTM==:ACCPRV		;FILE CREATION TIME - WORD ADR.
    ACSCTM==^D11	    ;BYTE SIZE
    ACNCTM==^D23	    ;BYTE PTR. POS.
ACCCDT==:ACCPRV		;FILE CREATION DATE (LOW ORDER PART)
    ACSCDT==^D12	    ;BYTE SIZE
    ACNCDT==^D35	    ;BYTE PTR. POS.
SUBTTL	BAF:	BAD ALLOCATION FILE

; BLOCK AFTER HOME BLOCK IN HOME.SYS
; PROGRAMS SEARCHING HOME.SYS SHOULD LOOK FOR SIXBIT IDENTIFICATION IN
; FIRST WORD OF EACH BLOCK. THEN THEY WILL WORK NO MATTER WHAT THE
; CLUSTER SIZE IS.


BAFNAM==:BLKNAM		;CONTAINS SIXBIT /BAT/ FOR IDENTIFICATION
BAFFIR==:1		;LH=-MAX. POSSIBLE NO. OF WORDS FOR BAD REGIONS MAP AND
			; MONITOR CAN ADD BEFORE BLOCK FILLS UP
			;RH=REL ADR. WITHIN THIS BLOCK OF FIRST BAD REGION PAIR
			; MAP PROGRAM FORCES LH TO BE EVEN NUMBER.
			;ALL PROGRAMS SHOULD SCAN THE BAT BLOCK BY STARTING
			; WITH THIS WORD RATHER THAN KNOWING WHERE DATA PAIRS
			; START.  IN THIS WAY ADDITIONAL HEADER WORDS CAN BE
			; ADDED WITHOUT INVALIDATING ANY PROGRAMS WHICH READ
			; BAT BLOCK.
			;BOTH HALVES WRITTEN BY MAP PROGRAM AND NEVER CHANGED
			; BY MONITOR

BAFNBS==:2		;NO. OF BAD 128 WORD BLOCKS FOUND BY MAP PROGRAM - WORD ADR.
    BASNBS==^D9		    ;BYTE SIZE
    BANNBS==^D8		    ;BYTE PTR. POS.
BAFNBR==:BAFNBS		;# OF BAD REGIONS(=# OF ENTRY PAIRS) FOUND BY MAP
			; PROGRAM - WORD ADR.
    BASNBR==^D9		    ;BYTE SIZE
    BANNBR==^D17	    ;BYTE PTR. POS.
BAFKDC==:2		;KONTROLLER DEVICE CODE USED BY MAP PROGRAM - WORD ADR.
    BASKDC==^D7		    ;BYTE SIZE
    BANKDC==^D24	    ;BYTE PTR. POS. -LEFT JUSTIFIED OCTAL SO PRINT
			    ; LIKE DEVICE CODES.

BAFCNT==:3		;NO. OF DISTINCT BAD REGION WORD PAIRS
			; APPENDED TO LIST BY MONITOR
			;MAP PROGRAM WRITES THIS WORD WITH ZEROES.


BAFREG==:4		;FIRST BAD REGION WORD GOES HERE. THIS SYMBOL NEVER
			; APPEARS IN ANY CODE WHICH READS BAT BLOCK - EXCEPT
			; MAP PROGRAM OR OPTIONAL ONCE ONLY CODE WHICH WRITES
			; IT THE FIRST TIME.  INSTEAD SEE RH OF BAFFIR
			;NOTE: BAFREG MUST BE AN EVEN NUMBER

BAYNBR::POINT	BASNBR,BAFNBR(T3),BANNBR	;BYTE PTR FOR # BAD REGIONS FND BY MAP
;BAYNBS::POINT	BASNBS,BAFNBS(T3),BANNBS	;BYTE PTR FOR # BAD BLOCKS FOUND BY MAP
BAYKDC::POINT	BASKDC,BAFKDC(T3),BANKDC	;BYTE PTR FOR KONTROLLER DEVICE CODE
;THE MAP PROGRAM IS NOT PART OF THE MONITOR - IT RUNS AS A STAND-ALONE PROGRAM
; WHICH WRITES AN INITIAL BAT BLOCK WITH ALL THE BAD REGIONS IT FINDS.
;BOTH THE MAP PROGRAM AND THE MONITOR WRITE TWO WORD ENTRIES OF THE SAME FORMAT
;THE MONITOR ADDS TWO-WORD ENTRIES WHENEVER IT FINDS BAD REGIONS
;WHILE READING, WRITING, OR POSITIONING (READ OR WRITE)
;THE MAP PROGRAM AND MONITOR STORE LOGICAL RATHER THAN PHYSICAL ADDRESSES

BAFNBB==:0		;NUMBER OF BAD BLOCKS-1 IN THIS BAD REGION(NOT CLUSTERS
			; -SINCE BADNESS IS INDEPENDENT
			; OF THE CLUSTER SIZE - WORD ADR(WITHIN 2 WORD ENTRY)
    BASNBB==^D9		    ;BYTE SIZE
    BANNBB==^D8		    ;BYTE PTR. POS.
    BAFNUM==:777	    ;MAX NUMBER OF BAD BLOCKS IN A REGION-1
BAFOTH==:0		;BIT NON-ZERO IF THIS SAME BAD REGION IS DETECTED ON
			; ANOTHER; KONTROLLER OR PROCESSOR THAN THE ONE WHICH
			; ADDED THE ENTRY; IN THE FIRST PLACE - WORD ADR.
    BAPOTH==:400	    ;BIT POS IN LH
BAYNBB::POINT	BASNBB,BAFNBB(T2),BANNBB	;BYTE PTR

BAFPUB==:0		;PHYSICAL UNIT BIT WITHIN CONTROLLER-WORD ADR.
			;BIT 10=UNIT 7, BIT 11=UNIT 6, BIT 17=UNIT 0.
    BASPUB==^D8		    ;BYTE SIZE
    BANPUB==^D17	    ;BYTE PTR. POS.
    BAPPUB==:1		    ;LH BIT POSITION OF RIGHT MOST BIT(UNIT 0) IN BYTE
    BARPUB==:1		    ;RIGHT-HAND BIT
BAFKNM==:0		;LOGICAL KONTROLLER NUMBER OF THIS TYPE - WORD ADR.
			; SEE UNIKNM
    BASKNM==^D3		    ;BYTE SIZE
    BANKNM==^D20	    ;BYTE PTR. POS.
BAYKNM::POINT	BASKNM,BAFKNM(T2),BANKNM	;BYTE PTR.

    BAPNTP==:40000	    ;ON FOR NEW-STYLE BAT BLOCK ENTRIES
BAFAPN==:0		;ARITHMETIC PROCESSOR # (DECIMAL) TO WHICH CONTROLLER
			; IS ATTACHED WHEN ERROR DISCOVERED BY MONITOR - WORD
			; ADR. (WITHIN 2 WORD ENTRY)
			;THIS IS USEFUL TO IDENTIFY THE PHYSICAL UNIT ON WHICH
			; THE ERROR OCCURRED IN CASE SOME UNITS DETECT DIFFERENT
			; SURFACE ERRORS THAN OTHER UNITS WHEN THE PACKS ARE
			; EXCHANGED.
    BASAPN==^D14	    ;BYTE SIZE
    BANAPN==^D35	    ;BYTE PTR POS
BAYAPN::POINT	BASAPN,BAFAPN(T2),BANAPN	;BYTE PTR.

BAFELB==:1		;ERROR LOGICAL BLOCK ADR. WITHIN UNIT - WORD ADR.
			; (WITHIN 2 WORD ENTRY)
			; OF FIRST LOGICAL BLOCK IN BAD REGION OF BLOCKS
REPEAT 0,<		;OLD-STYLE BAT BLOCK ENTRY
BAJCNI==-^D6		;-NO. OF LOW ORDER STATUS BITS WHICH DO NOT CONTAIN
			; INTERESTING CONI ERROR STATUS BITS.
			;LH OF BAFELB IS USED FOR CONI BITS 12 THROUGH 29
			; ON RC-10 AND RP-10 UNITS.  WHEN WE BUILD LARGER
			; UNITS THIS WILL HAVE TO BE CHANGED
>

BAFVER==:1		;BITS 0-2 VERSION NUMBER OF ENTRY (PRESENTLY = 0)
BAFERR==:1		;ERROR BITS (AS OPPOSED TO CONI BITS)
    BAPOTR==:40000	    ;OTHER (NOT DATA OR SEARCH ERROR)
    BAPDTR==:20000	    ;DATA ERROR (PARITY OR ECC HARD)
    BAPHDR==:10000	    ;SEARCH ERROR OR HEADER COMPARE ERROR
    BATMSK==:777000	    ;MASK (LH) FOR BAT ENTRY BLOCK NUMBER
    MBTMSK==:700777	    ;MASK FOR JUST ERROR BITS FOR BAT ENTRY

BAFCOD==:BLKCOD		;CONTAINS UNLIKELY CODE
			;LH=0
    CODBAT==:606060	    ;UNLIKELY CODE FOR BAT BLOCK

BAFSLF==:BLKSLF		;LH=0, RH=THIS BLOCK (NOT CLUSTER) ADR. WITHIN UNIT

BRMAX==:BAFCOD-BAFREG	;MAX LENGTH OF AREA FOR APPENDING BAD REGIONS
MBRMAX==:-BRMAX
	$LOW
SUBTTL	DEV:	DEVICE DATA BLOCK (ONE FOR EACH ACTIVE SOFTWARE USER CHANNEL)

EXTERN	DSKDSP

	$HIGH
DSKDDB::		;ADDRESS OF PROTOTYPE DISK DDB FOR SYSTEM.
			; LINKED TO DDB LIST BUT NEVER USED.
			; (SWPDDB IS LINKED BEFORE DSKDDB)

ZERO13==0
$SWAP==0

REPEAT 2,<


;FIRST COPY IS DISK PROTOTYPE DDB, SECOND IS SWAPPING DDB (SIGN BIT ON IN DEVSWP)
IFN $SWAP, <XLIST>	;DO NOT LIST THE SWAPPING DDB. IT IS REPETITIVE

PHASE	0
IFE $SWAP, <

DEVNAM:!SIXBIT	/DSK/	;DEVICE NAME IN SIXBIT OF STR OR MORE USUALLY GENERIC DSK
>
IFN $SWAP, <
DEVNAM:!SIXBIT	/DSKSWP/ ;DIFFERENT "DEVICE NAME" FOR SWAPPER
>
DEVCHR:!XWD 3*HUNGST,201 ;HUNG TIME COUNT, BUFFER SIZE
DSKTIM==:7		;HUNG TIME (STORED IN UDB, DEC'D EVERY SECOND)
DEVIOS:!0		;LH=MONITOR, RH=USER IO STATUS-SEE FILSER FOR
			; LH BIT DEFINITIONS SINCE LOADER WILL NOT ADD EXTERNS
DEVSER:!EXP DSKDSP	;LH=LINK TO NEXT DDB, RH=DISPATCH TABLE ADDRESS
			; IN FILSER SAME FOR ALL DISKS
DEVMOD:!XWD DVIN+DVOUT+DVDSK+DVDIR+DVLNG,154403 ;LH=CHARACTERISTICS, RH=MODES
DEVRHB==:DEVMOD		;WHOLE WORD ZERO IF REREADING HOME BLOCKS ON POWER UP INTERRUPT
DEVLOG:!0		;LOGICAL NAME IN SIXBIT
DEVBUF:!0		;LH=OUTPUT BUFFER HEADER, RH=INPUT BUFFER HEADER
DEVIAD:!0		;BIT 13=0,BITS 14-17=R, RH=POINTER TO USER INPUT BUFFER

DEVCOD==:DEVIAD		;FILE STATUS CODE (I,SW,S,PW,P,TW,T)-WORD ADR
			; SEE UNISTS FOR DEFINITION
    DESCOD==^D3		    ;BYTE SIZE
    DENCOD==^D2		    ;BYTE PTR POS.
DEVLPC==:DEVIAD		;BIT WHICH SAYS LAST RIB POINTER IS IN CORE
    DESLPC==^D1		    ;BYTE SIZE
    DENLPC==^D4		    ;BYTE POSITION
    DEPLPC==:20000	    ;BIT
DEVSCN==:DEVIAD		;SCANNING SWITCH FOR SFD'S
    DESSCN==^D1		    ;BYTE SIZE
    DENSCN==^D3		    ;POSITION
DEVFNC==:DEVIAD		;HIGHEST FUNCTION THIS USER ALLOWED TO PERFORM ON THIS
			; FILE SET BY CHKPRV ROUTINE
    DESFNC==^D4		    ;BYTE SIZE
    DENFNC==^D8		    ;BYTE PTR POS.
			; FUNCTION CODES ARE DEFINED IN ORDER OF INCREASING POWER
			; 0 - MEANS CHKPRV HAS NOT STORED ANY FUNCTION YET
	FNCEXC==:1		;EXECUTE ONLY
	FNCRED==:2		;READ
	FNCALL==:3		;ALLOCATE
	FNCDLL==:4		;DEALLOCATE
	FNCAPP==:5		;APPEND
	FNCUPD==:6		;UPDATE
	FNCCRE==:7		;CREATE
	FNCSUP==:10		;SUPERSEDE
	FNCTRN==:11		;TRUNCATE
	FNCCAT==:12		;CHANGE ATTRIBUTES(EXCEPT PRIVILEGE,NAME,DIR)
	FNCDEL==:13		;DELETE
	FNCCNM==:14		;CHANGE NAME
	FNCCPR==:15		;CHANGE PRIVILEGE
DEVEUN==:DEVIAD		;LOGICAL UNIT WITHIN STR ON WHICH ERROR REGION - WORD ADR
    DESEUN==^D4		    ;BYTE SIZE
    DENEUN==^D12	    ;BYTE PTR. POS.
DEVOAD::BYTE	(1)$SWAP(8)0(4)0(1)ZERO13(4)0(18)0
			;BIT 13=0, RH=POINTER TO USER OUTPUT BUFFER
DEVSWP==:DEVOAD		;SIGN BIT = 1 FOR SWAPPING DDB
    DEPSWP==:400000
DEVLIB==:DEVOAD		;BIT ON IF LOOKUP FROM LIB/SYS
    DEPLIB==:200000	    ;THE BIT
DEVRLC==:DEVOAD		;RELATIVE ADDRESS (0-127) WITHIN 128 WORD RIB OF FIRST
			; RETRIEVAL POINTER IN DDB (DEVRB1 OR DEVRB1+1)-WORD ADR.
    DESRLC==^D7		    ;BYTE SIZE
    DENRLC==^D8		    ;BYTE PTR.POS.
DEVUWZ==:DEVOAD		;USE TO WRITING ZEROES - WORD ADDR
    DEPUWZ==:400	    ;BIT 9=1 IF MONWRT CALLED FROM USETZ

DEVPP0==:DEVOAD		;E+3 WAS 0 ON LOOKUP - WORD ADR
    DEPPP0==:200	    ;BIT=0 IF E+3 WAS 0
    DESPP0==1
    DENPP0==^D10

DEVFDA==:DEVOAD		;FILE DAEMON SHOULD BE CALLED ON CLOSE
    DEPFDA==:100	    ;BIT=1 IF FILE DAEMON SHOULD BE CALLED ON CLOSE

DEVSTS:!0		;WORD FOR DEVICE CONI
IFE $SWAP,<
DEVSTA:!XWD	<.TYDSK*.TYEST>,DEPEVM
>
IFN $SWAP,<
DEVSTA:!XWD	<TYPMAX+1>*.TYEST,DEPEVM  ;NOT A LEGAL DEVICE TYPE
>

DEVCPT==:DEVSTA		;READ FILE IN 10/11 COMPATABILITY MODE
    DEPCPT==:200000	    ;THE BIT
DEVXTR:!0

DEVUVA==:DEVXTR		;LH = USER VIRT ADR OF CHKSUM WORD
			    ;BITS 18-20 UNUSED (PREVIOUSLY SFD LEVEL)
DEVWRT==:DEVXTR		;THIS DDB IS WRITING (UPDATING)
    DEPWRT==:40000	    ;THE BIT
DEVBFN==:DEVXTR		;NUMBER OF INPUT BUFFERS
    DESBFN==^D9		    ;BYTE SIZE
    DENBFN==^D30	    ;POSITION
DEVPAL==:DEVXTR		;PRE-ALLOCATE FILE
    DEPPAL==:20		    ;BIT 31=1 IF PRE-ALLOCATE
DEVALC==:DEVXTR		;DON'T CHANGE ACCALC WHEN GIVING UP BLOCKS OF A FILE
			; (FORMERLY IOSALC IN S, DEVIOS)
    DEPALC==:10		    ;BIT 32=1 IF DON'T CHANGE
			    ;BITS 33-35 UNUSED (PREVIOUSLY 2ND SFD LEVEL)
DEVEVM:!0
DEVPSI:!0
DEVESE:!0		;EXTENDED SOFTWARE ERROR STATUS
DEVHCW:!0		;HARDWARE CHARACTERISTICS WORD
DEVCPU::!707000,,0	;MULTI-CPU INFORMATION. Q-PROTOCOL 1
DEVISN:!0		;RH = SECTION NUMBER FOR CURRENT I/O OPERATION
IFE $SWAP,<
DEVDRV:!RPXDSP##	;DRIVER DISPATCH
>; END IFE $SWAP
IFN $SWAP,<
DEVDRV:!0		;DRIVER DISPATCH
>; END IFN $SWAP
DEVJOB:!0		;JOB NUMBER AND UNIT NUMBER
DEVFSN==:DEVJOB		;OLD FILE STRUCTURE NUMBER (LAST LOOKUP OR ENTER)
			; USED ON SUPERSEDING FILE AT CLOSE TIME
    DESFSN==.FSSIZ	    ;BYTE SIZE
    DENFSN==^D17	    ;POSITION
DEVLLE==:DEVJOB		;LIB HANDLING ON LOOKUP/ENTER
    DEPDSL==:1000	    ;(LH) DONT SEARCH LIB
    DEPAUL==:2000	    ;(LH) ALLOW UPDATE IN LIB
DEVFCU==:DEVJOB		;FILDAE HAS READ COUNT UP
    DEPFCU==:4000	    ;(LH) BIT ON IF AT COUNT IS UP
DEVNLB==:DEVLLE		;NO LOAD BALANCING ON ENTER
    DEPNLB==:10000	    ;DON'T BALANCE IF ON
DEVFIL:!0		;OLD FILE NAME (LAST LOOKUP OR ENTER) - ARG TO FNDFIL
DEVEXT:!XWD 0,0		;LH=OLD FILE EXTENSION (LAST LOOKUP OR ENTER) -ARG TO FNDFIL
DEVLFT==:DEVEXT		;RH=+NO. OF BLOCKS LEFT IN CURRENT GROUP
			; DECREMENTED AT DATA DONE INTERRUPT
DEVPPN:!0		;OLD DIRECTORY NAME (PROJ,PROG) -NOT ARG TO FNDFIL
IFN FTKL10&FTMP,<
DEVNBF:!0		;NO OF BUFS SWEPT FOR
DEVSBF:!0		;COPY OF DEVNBF
DEVCSN:!0		;SWEEP SERIAL NO
>
DEVDMP::!0		;CURRENT IOWD FOR DUMP MODE OPERATIONS(CURRENT GROUP ONLY)
			; (MAYBE SMALLER THAN ONE OF USER'S IOWD
			;  IF BLOCKS AREN'T CONTIGUOUS)
			; OR CURRENT IOWD FOR MONITOR IO(EXEC ADDRESSES)
			;  SEE MONRED,MONWRT WHICH PUSH DEVDMP BEFORE USING
			; OR LOGICAL DISK ADR. WITHIN UNIT OF DIRECTORY RIB(MFD OR UFD)
DEVRET::!XWD ZERO18,0	;RH=CORE  ADR IN DDB OF CURRENT RETRIEVAL POINTER
			;BITS 0-17=0 FOR CAI TESTING
DEVREL::!0		;RELATIVE BLOCK NUMBER WITHIN FILE TO BE READ OR
			; WRITTEN ON NEXT INPUT OR OUTPUT UUO
DEVDIA==:DEVREL		;DATA FOR DIAG. UUO

DEVUNI::!XWD 0,0	;LH CORE ADR. OF ORIGINAL UNIT DATA BLOCK(I.E. WHERE RIB IS)
			;RH=CORE ADR.(UPWARD PNTR) TO CURRENT UNIT DATA BLOCK
			;DEVUNI IS CLEARED WHEN A F/S IS BEING REMOVED
			; (STRUUO(.FSREM)).  THE UNIT (RH DEVUNI) IS
			; IS REMEMBERED IN DEVFUN.
DEVUFB::!XWD ZERO18,0	;RH=ADDR.(UPWARD POINTER) OF UFD
			; DATA BLOCK THIS FILE IS IN
DEVSFD::!XWD 0,0	;RH=LOC OF NMB FOR FATHER SFD IF FILE IS IN AN SFD
			;LH IS USED IN RENAMING ACCROSS DIRECTORIES
DEVBLK::!0		;THE LOGICAL BLOCK NUMBER WITHIN UNIT NEXT TO BE READ OR
			; WRITTEN BY AN INPUT OR OUTPUT UUO.  UPDATED
			; AFTER (RATHER THAN BEFORE) A SUCCESSFUL DATA
			; TRANSFER AT INTERRUPT LEVEL.
DEVRSU::!XWD 0,0	;LH=NEG. NO. OF RETRIEVAL POINTER POSITIONS TO GO IN
			; RETRIEVAL BLOCK BEFORE RETRIEVAL BLOCK IS FULL
DEVACC==:DEVRSU		;RH=CORE ADDR (UPWARD PTR) TO ACCESS TABLE ENTRY
			; FOR THIS USER CHAN.
DEVFLR::!0		;FLOOR FOR RETRIEVAL POINTERS IN-CORE
			;I.E., THE FIRST RELATIVE BLOCK WITHIN FILE WHICH
			; FIRST IN-CORE RETRIEVAL POINTER POINTS TO
DEVFUN::!XWD 0,0	;RH=UNIT DATA BLOCK ADR. OF FIRST RETRIEVAL POINTER IN CORE
			;RH DEVUNI STORED HERE WHEN F/S BEING REMOVED
			; (STRUUO(.FSREM)).
DEVPTB==:DEVFUN		;LH = BITS
    DEPFFS==:400000	    ;FILE FOUND BY SCANNING SFDS
    DEPFFL==:200000	    ;FILE FOUND IN LIB OR SYS
    DEPUWL==:100000	    ;WRITE LOCK
    DEPSIO==:40000	    ;FILOP. OPEN FOR SUPER I/O
DEVQUE::!XWD 0,0	;LH=ADDRESS OF NEXT DDB IN EITHER SEEK/POSITION
			; WAIT QUEUE OR TRANSFER WAIT QUEUE DEPENDING
			; ON WHICH QUEUE THIS FILE IS ON
			;RH=JOB NUMBER OF DDB WHOSE ADDRESS IS IN LH
			;DEVQUE=0 WHEN DDB IS LAST IN QUEUE - ALSO
			;FOR SAFETY, DEVQUE IS SET 0 WHEN FILE IS IN NEITHER QUEUE
DEVELB::!0		;FIRST LOGICAL BLOCK OF AN ERROR REGION
			    ;BITS 3-8 HAVE ERROR CODE

DEVPRI::!0		;RH = DISK PRIORITY
DEVLRL==:DEVPRI		;LAST DEVREL (USED FOR USETO-1
			; AFTER UPDATE ENTER)
DEVSPN::!0		;ENTERED FILENAME FOR SPOOLED FILE
DEVSPM::!0		;POINTER TO SPOOLING PARAMETER BLOCK

DEVRIB::!0		;UNIT, ADDRESS AND COUNT OF CURRENT RIB
			    ;BIT 0=1 IF AN EXTENDED RIB
    DESRBC==:^D8	    ;COUNT OF RIBS, BYTE SIZE
    DENRBC==^D8		    ;BYTE POSITION, POINTER IS DEYRBC
    DESRBU==^D4		    ;LOGICAL UNIT WITHIN STR, BYTE SIZE
    DENRBU==^D12	    ;BYTE POSITION, POINTER IS DEYRBU
    DESRBA==^D23	    ;CLUSTER ADDRESS, BYTE SIZE
    DENRBA==^D35	    ;BYTE POSITION, POINTER IS DEYRBA

DEVUPP::!0		;"IN YOUR BEHALF" PPN

DEVCUR::!0		;(RH) CURRENT UNIT DOING IO FOR THIS DDB
DEVRAD==:DEVCUR		;RENAME ACROSS DIRECTORIES IN PROGRESS
    DEPRAD==:400000	    ;BIT=1 IF RENAME
DEVPRV==:DEVCUR		;DONT CHECK PRIVS ON LOOKUP
    DEPPRV==:200000	    ;BIT=1 IF DONT CHECK
DEVRRC==:DEVCUR		;AUTO-REWRITE OF RIB ON CHANGE
    DEPRRC==:100000	    ;BIT ON IF ENABLED
    DEPRHC==:40000	    ;BIT ON IF RIB HAS CHANGED
DEVPHO==:DEVCUR		;PHYSICAL-ONLY OPEN
    DEPPHO==:20000	    ;BIT=1 IF PHONLY ON IN INIT
DEVLBF==:DEVCUR		;USER WANTS LARGE BUFFERS
    DEPLBF==:10000	    ;BIT=1 IF MAKE LARGE BUFFERS
DEVNB1==:DEVCUR		;NUMBER OF BLOCKS WE'RE DOING IN 1ST BUFFER
DEVNBB==:DEVCUR		;NUMBER OF BLOCKS PER BUFFER
    DESNBB==^D6		    ;BYTE SIZE (MAX BUFFER IS 17600 WORDS)
    DENNBB==^D17	    ;BYTE POSITION, POINTER IS DEYNBB
    DENNB1==^D11	    ;BYTE POSITION FOR DEVNB1, POINTER IS DEYNB1

DEVGEN::!-1,,0		;LH=GENERATION NUMBER OF UDB WHICH DDB IS CONNECTED TO
DEVCPY==:DEVGEN		;RH=ADDRESS OF CORE-COPY OF RETRIEVAL POINTERS (OR 0)
DEVLNM::!0		;RH=LOC OF LOGICAL NAME SPEC WE ARE USING
			;LH=CURRENT SFD WE'RE LOOKING FOR IN THAT SPEC
DEVRB1::!0		;FIRST RETRIEVAL POINTER GOES HERE IN DDB

;EACH (REAL) RETRIEVAL POINTER CONSISTS OF THREE FIELDS:
;	A. CLUSTER COUNT
;	B. CHECKSUM OF FIRST CHKNUM WORDS IN FIRST BLOCK OF GROUP
;	C. CLUSTER ADDRESS (23 BITS MAX.)

;THE WIDTHS OF THESE FIELDS ARE DIFFERENT FOR EACH FILE STRUCTURE
;	A. STRCNP
;	B. STRCKP
;	C. STRCLP

;IF THE CLUSTER COUNT IS 0, THE POINTER IS NOT A REAL POINTER
;IT MAY BE EITHER:
;	A. A NEW UNIT WITHIN THE FILE STRUCTURE(IF BIT 18 =1)
;	   BITS 19-35 SPECIFY THE LOGICAL UNIT WITHIN FILE STRUCTURE
;	B. AN EOF FLAG IF WHOLE WORD IS 0

MPTRLN==:-PTRLEN	;- NO. OF POINTERS KEPT IN CORE
DEVRB2::!0		;SECOND RETRIEVAL POINTER
	BLOCK	PTRLEN-3	;IN-CORE RET. PTRS HERE 3,4,...RBN-1
DEVRBN::!0		;LAST RETRIEVAL PTR IN CORE

DEVFAK==:DEVRBN-4	;TEMP BLOCK FOR SPOOL-MODE ENTER

DEVDRB::!0		;ADDR OF THE IORB

;THIS WORD IN SWPDDB IS VERY VERY SPECIAL (IT MUST BE CAREFULLY
;INTERLOCKED). A DEVICE DRIVER THAT DOES NOT DO MULTIPLE XFERS
;MAY NOT READ OR WRITE THIS WORD AT ANY TIME. A DEVICE DRIVER
;THAT DOES DO MULTIPLE XFERS MAY READ AND WRITE THE WORD, BUT
;IT MUST HAVE THE SWPSCN INTERLOCK.
;IT IS NOT SUFFICIENT TO MERELY DISABLE DISK INTERRUPTS.
;FOR ALL OTHER DDBS THERE ARE NO RESTRICTIONS. ANY DEVICE DRIVER
;MAY READ OR WRITE THE WORD, AND NO INTERLOCK IS REQUIRED.

DDBLEN==:.-DEVNAM	;LENGTH OF DSK DDB IN WORDS

	DEPHASE
	$LOW

$SWAP==1		;SECOND TIME THROUGH THE REPEAT PRODUCES SWPDDB

	LIST
>	;END REPEAT 2

SWPDDB=:.-DDBLEN	;ADDR OF SWAPPING DDB
			;SYSINI LINKS SWPDDB INTO
			; SYSTEM DEVICE LIST IN FRONT OF THE PROTOTYPE
			; DSKDDB.  ONLY HUNG TIMEOUT USES SWPDDB
	$HIGH
;BYTE POINTERS TO FIELDS IN DEVICE DATA BLOCK
DEYCOD::POINT	DESCOD,DEVCOD(F),DENCOD	;FILE STATUS CODE - I,SW,S,PW,P,TW,T1

DEYRLC::POINT	DESRLC,DEVRLC(F),DENRLC	;RELATIVE ADR (0-127) WITHIN 128 WORD RIB OF
				       ; 1ST RETRIEVAL PTR IN DDB(DEVRB1 OR DEVRB1+1)
DEYFSN::POINT	DESFSN,DEVFSN(F),DENFSN	;OLD FILE STRUCTURE NUMBER (0-15 OCTAL)
				       ; SET ON LAST LOOKUP OR ENTER
				       ; USED AT CLOSE TIME WHEN SUPERSEDING
DEYFNC::POINT	DESFNC,DEVFNC(F),DENFNC	;HIGHEST FUNCTION THIS USER IS ALLOWED TO DO ON
				       ; THIS FILE, SET BY CHKPRV ON FIRST CALL
DEYEUN::POINT	DESEUN,DEVEUN(F),DENEUN	;LOGICAL UNIT WITHIN STR OF
					;ERROR REGION(0... )
DEYELB::POINT	27,DEVELB(F),35		;POINTER TO ERROR BLOCK WITHIN UNIT

DEYRBU::POINT	DESRBU,DEVRIB(F),DENRBU	;LOGICAL UNIT NUMBER OF CURRENT RIB
DEYRBA::POINT	DESRBA,DEVRIB(F),DENRBA	;CLUSTER ADDRESS OF CURRENT RIB
DEYRBC::POINT	DESRBC,DEVRIB(F),DENRBC
DEYNBB::POINT	DESNBB,DEVNBB(F),DENNBB
DEYNB1::POINT	DESNBB,DEVNB1(F),DENNB1
DEYSCN::POINT	DESSCN,DEVSCN(F),DENSCN
DEYPP0::POINT	DESPP0,DEVPP0(F),DENPP0
DEXPRI::POINT	4,DEVPRI(F),29		;INCLUDES DEPUUO BIT
DEYPRI::POINT	3,DEVPRI(F),29		;DOES NOT INCLUDE SET-BY-UUO BIT
JBXPRI::POINT	3,JBTSPL##(T1),26
JBYPRI::POINT	3,JBTSPL##(J),26	;JOB'S CURRENT PRIORITY
JBZPRI::POINT	2,JBTPRV##(J),2		;MAX DISK PRIORITY JOB CAN SET
MXNDPR==:-3				;- HIGHEST DSK PRIORITY POSSIBLE


PINBFN::POINT	DESBFN,DEVBFN(F),DENBFN	;NO OF INPUT BUFFERS
	$LOW
;ERROR CODES FOR UUO'S

;THE FOLLOWING ARE ERROR CODES FOR STRUUO

XP .ERILF,0		;ILLEGAL FUNCTION CODE (TOO LARGE)
XP .ERSNF,1		;1 OR MORE FILE STRUCTURES NOT FOUND (.FSSRC)
XP .ERSSA,2		;1 OR MORE FILE STRUCTURES SINGLE ACCESS ONLY (.FSSRC)
XP .ERILE,3		;1 OR MORE ILLEGAL ENTRIES (.FSSRC)
XP .ERTME,4		;TOO MANY ENTRIES IN SEARCH LIST (.FSSRC)
XP .ERUNA,5		;1 OR MORE UNITS NOT AVAILABLE (.FSDEF)
XP .ERNBM,6		;1 OR MORE UNITS NOT IN BEING MOUNTED STATE (.RSRDY)
XP .ERMCN,7		;CANT REDEFINE FILE STRUCTURE BECAUSE MOUNT COUNT NOT 0(.FSRDF)
XP .ERNPV,10		;NOT PRIVILEGED USER
XP .ERNPM,11		;NO UNITS MENTIONED
XP .ERPST,12		;UNIT NOT IN NO PACK MOUNTED STATE
XP .ERNID,13		;NO UNIT ID SPECIFIED
XP .ERNFS,14		;SYSTEM FULL OF FILE STRUCTURES
XP .ERNCS,15		;NOT ENOUGH FREE CORE FOR DATA BLOCK
XP .ERUNF,16		;ILLEGAL UNIT
XP .ERRSL,17		;FILE STRUCTURE REPEATED IN SEARCH LIST DEFINITION (.FSSRC)
XP .ERNSI,20		;NO SAT INFO IN STR DEFINITION (.FSDEF)
	SUBTTL	DRB:	DISK I/O REQUEST BLOCK

;DEFINE THE FORMAT OF A DISK I/O REQUEST BLOCK (DRB)

	.ORG	0	;DEFINE DRB ENTRIES AS OFFSETS FROM ZERO

DRBLNK::!BLOCK	1	;LINK WORD
DRBGOD::!BLOCK	1	;VALUE RETURNED BY CTGOOD
DRBNUM::!BLOCK	1	;CHNNUM
DRBPRG::!BLOCK	1	;CHANNEL PROGRAM
DRBDMP::!BLOCK	1	;KONDMP
DRBBLK::!BLOCK	1	;UNIBLK
DRBCUR::!BLOCK	0	;LH=DEVCUR
DRBCDA::!BLOCK	1	;RH=UNICDA
DRBSWA::!BLOCK	1	;UNISWA (SWAPPER ONLY)
			;(BITS 0-14) UNUSED
DRBCPU::!BLOCK	0	;(BITS 15-17) CPU (SWAPPER ONLY, OTHERS USE DEYPCL)
    DRSCPU==3
    DRNCPU==^D17
DRBSTS::!BLOCK	0	;(BITS 18-22) KONERM
IF2 <IFN <KONERM-770000>,<PRINTX ?KONERM OVERFLOW>>
			;(BITS 23-24) UNUSED
    DRPTRY==:1B25	    ;(SWAPPER ONLY) PLS TRY AGAIN, IT'S OFF-LINE
    DRPNFI==:1B26	    ;NOT FILLED IN YET
    DRMDFM==:DRPTRY+DRPNFI  ;DON'T FIND ME
DRBJOB::!BLOCK	1	;(BITS 27-35) UNIJOB
    DRSJOB==^D9
    DRNJOB==^D35
DRBTIM::BLOCK	1	;HUNG TIMER
			;*** DON'T RE-ARRANGE THE FOLLOWING
DRBDTI::BLOCK	1	;DATAI AT INTERRUPT FROM DEVICE-DEPENDENT DRIVER
DRBCNI::BLOCK	1	;CONI AT INTERRUPT FROM DEVICE-DEPENDENT DRIVER
			;*** END OF DON'T RE-ARRANGE
IFN FTCIDSK,<
DRBOPC::BLOCK	1	;RH=OPCODE
DRBBHD::BLOCK	1	;BUFFER NAME
DRBCRF::BLOCK	1	;COMMAND REFERENCE NUMBER
>; END IFN FTCIDSK

SIZDRB::!		;SIZE OF A DISK I/O REQUEST BLOCK

	.ORG		;END OF DRB DEFINITION

	$HIGH
DRYJOB::POINT	DRSJOB,DRBJOB(T1),DRNJOB
DRZJOB::POINT	DRSJOB,DRBJOB(P3),DRNJOB
DRYCPU::POINT	DRSCPU,DRBCPU(T1),DRNCPU
DRZCPU::POINT	DRSCPU,DRBCPU(P3),DRNCPU
SUBTTL	HOM:	WORD POSITIONS IN HOME FILE DATA BLOCK

;PREFIX "HOM"
;EACH FILE STRUCTURE HAS ONE HOME FILE HOME.SYS.  IT IS A "SPARSE FILE"
;WITH RETRIEVAL INFORMATION IN FIRST BLOCK OF EACH GROUP.  HOWEVER ONLY
;THE SECOND BLOCK OF EACH GROUP (1 CLUSTER) HAS DATA, THE REMAINING ONES
;(IF  ANY) ARE 0, THE HOME FILE IS CONSTRUCTED SO THAT EACH GROUP IS ON A
;SEPARATE UNIT WHERE 'UNIT' IS A SIDE OF A BRYANT MDF DISK, ONE OUT OF UP TO
;FOUR BURROUGHS FIXED HEAD DISKS, ETC.


;DATA LOCATIONS IN HOME BLOCK:
;WRITTEN BY MAP PROGRAM:

HOMNAM==:BLKNAM		;"HOM" IN SIXBIT (WRITTEN BY MAP PROGRAM)
HOMHID==:1		;SIXBIT UNIT ID (WRITTEN BY MAP PROGRAM)
HOMPHY==:2		;LH=PHYSICAL ADDRESS OF THIS HOME BLOCK ON THIS UNIT
			;RH=PHYSICAL ADDRESS OF OTHER HOME BLOCK ON THIS UNIT
			; BYTE (8) CYL ADR, (5) SURFACE, SECTOR ADR.
			; (WRITTEN AND USED BY MAP PROGRAM)
			; NO WORDS BELOW ARE CHANGED BY THE MAP PROGRAM
;WRITTEN BY OPTIONAL ONCE ONLY DIALOG:

HOMSRC==:3		;LOCICAL POSITION OF THIS STR IN "SYS" SEARCH LIST(0...N)
			; -1 MEANS NOT IN SYS SEARCH LIST
HOMSNM==:4		;SIXBIT FILE STRUCTURE NAME THIS UNIT BELONGS TO
			; 0 INDICATES NOT IN A FILE STRUCTURE
			; [IGNORED BY MONITOR WHEN A PACK IS MOUNTED
			; FILE STRLST.SYS IS FINAL AUTHORITY FOR THE STR NAME]
HOMNXT==:5		;SIXBIT UNIT ID OF NEXT UNIT IN THIS FILE STRUCTURE.
			; 0 IF THIS UNIT IS LAST OR ONLY UNIT IN FILE STRUCTURE.
			; [CHECKED BY MONITOR AND PULSAR WHENEVER PACK IS MOUNTED]
HOMPRV==:6		;SIXBIT UNIT ID OF PREVIOUS UNIT IN THIS FILE STRUCTURE.
			; 0 IF THIS UNIT IS ONLY UNIT IN FILE STRUCTURE.
			; [CHECKED BY MONITOR & PULSAR WHENEVER PACK IS MOUNTED]
HOMLOG==:7		;SIXBIT LOGICAL UNIT NUMBER WITHIN FILE STRUCTURE OF THIS UNIT
			; (E.G. DSKA0,DSKC12)
HOMLUN==:10		;LOGICAL UNIT NUMBER WITHIN FILE STRUCTURE OF THIS UNIT
			; [CHECKED BY MONITOR AND OMOUNT CUSP WHENEVER PACK IS MOUNTED]
HOMPPN==:11		;PROJECT PROGRAMMER NUMBER OF USER WHO REFRESHED DISK
			; UNDER TIME SHARING OR 0.
HOMHOM==:12		;LH=LOGICAL BLOCK NUMBER WITHIN UNIT(NOT STR)
			; FOR 1ST. "HOME" BLOCK.  RH=LOGICAL BLOCK NO. WITHIN UNIT OF
			; REDUNDANT HOME BLOCK(IN CASE FIRST HOME BLOCK IS BAD)
			; NOTE: RESTRICTION THAT HOME BLOCKS ARE RESTRICETED TO FIRST
			; 262,000 BLOCKS ON A UNIT.  KNOWING LOGICAL BLOCK ADR. OF
			; HOME BLOCKS IS USEFUL ONLY TO RECOVERY PROGRAMS WHEN FILE
			; STRUCTURE HAS BEEN CLOBBERRED.  MOST PROGRAMS WILL READ HOME
			; BLOCKS VIA FILE HOME.SYS
HOMGRP==:13		;NO. OF BLOCKS (NOT CLUSTERS) PER GROUP TO TRY FOR
			; ON SEQUENTIAL OUTPUT ALLOCATION
HOMBSC==:14		;# BLOCKS PER SUPER CLUSTER IN THIS STR
HOMSCU==:15		;# SUPER CLUSTERS PER UNIT
HOMCNP==:16		;BYTE POINTER FOR CLUSTER COUNT IN A RETRIEVAL POINTER
HOMCKP==:17		;BYTE POINTER FOR CHECKSUM IN A RETRIEVAL POINTER
HOMCLP==:20		;BYTE POINTER FOR CLUSTER ADDRESS IN A RETRIEVAL POINTER
HOMBPC==:21		;# BLOCKS PER CLUSTER(SAME FOR ALL UNITS IN AN STR)
HOMK4S==:22		;# OF K WORDS OF THIS UNIT USED FOR SWAPPING
			; 0 MEANS NO SWAPPING SPACE ALLOCATED
HOMREF==:23		;NON-ZERO IF FILE STRUCTURE MUST BE REFRESHED
			; BECAUSE SOME PARAMETER FOR THIS UNIT HAS BEEN CHANGED
			; SET BY DISK ONCE ONLY CODE,CHECKED WHEN SYSTEM IS STARTED
			; AND BY PULSAR WHEN PACK MOUNTED
HOMSIC==:24		;# SAT BLOCKS IN CORE
HOMSID==:25		;SWAPPING ID - SIXBIT UNIT ID OF NEXT UNIT IN ACTIVE SWAPPING LIST
			; 0 IF LAST UNIT( OR UNIT NOT IN ACTIVE SWAPPING LIST)
HOMSUN==:26		;LOGICAL UNIT # IN ACTIVE SWAPPING LIST(0,...,7).
			; -1 INDICATES UNIT IS NOT IN ACTIVE SWAPPING LIST.
			; (MAYBE CHANGED AT ONCE TIME WITHOUT REQUIRING REFRESHING
			; PROVIDED SWAPPING SPACE ALLOCATED AT REFRESH TIME.)
HOMSLB==:27		;1ST. LOGICAL BLOCK ON UNIT FOR SWAPPING
HOMCFS==:30		;SWAPPING CLASS FOR UNIT
HOMSPU==:31		;# SAT BLOCKS PER UNIT
HOMOVR==:32		;-# OF BLOCKS OF OVERDRAW ALLOWED A USER ON THIS STR BEFORE
			; NO MORE OUTPUTS ALLOWED.
HOMGAR==:33		;UPPER BOUND ON # OF BLOCKS GUARRANTEED TO USERS BY RESERVED
			; QUOTAS.
;WORDS WRITTEN BY REFRESHER:

HOMTAB==:34		;FIRST LOC OF TABLE OF LOG. BLOCK NOS OF SYSTEM FILES
HOMSAT==:HOMTAB		;LOGICAL BLOCK NO. WITHIN STR(NOT UNIT) OF 1ST RIB FOR SAT.SYS
HOMHMS==:35		; " FOR HOME.SYS
HOMSWP==:36		; " FOR SWAP.SYS
HOMMNT==:37		; " MAINT.SYS
HOMBAD==:40		; " BADBLK.SYS
HOMCRS==:41		; " FOR CRASH.EXE
HOMSNP==:42		; " SNAP.SYS
HOMRCV==:43		; " RECOV.SYS
HOMSUF==:44		; " SYS UFD
HOMPUF==:45		; " PRINTR UFD
HOMMFD==:46		; " FOR MFD [1,1].UFD
HOMPT1==:47		;COPY OF 1ST RETRIEVAL POINTER FOR MFD FOR STR THIS
			; UNIT IS IN.  ONLY CLUSTER ADDRESS PORTION OF HOMPT1
			; SHOULD BE CONSIDERED VALID, SINCE EXPANDING THE MFD
			; MAY CAUSE COUNT FIELD IN 1ST PTR TO CHANGE (CHKADD).
HOMUN1==:50		;LOGICAL UNIT NUMBER OF UNIT ON WHICH MFD BEGINS
HOMLEN==:51		;FIRST ADDRESS OF TABLE OF LENGTHS OF FILES CREATED BY REFRESH
			; LENGTHS NEEDED ARE FOR CRS,SNP,RCV, AND UFDS (IN THAT ORDER)
			;57 IS LAST FILE LENGTH

HOMUTP==:57		;UNIT TYPE ON WHICH HOME BLOCK WAS WRITTEN (SEE UNYUTP)
HOMRIP==:60		;USED BY RIPOFF
HOMKLB==:61		;20 WORDS USED BY PDP-11 IN KL10 SYSTEMS
HOMFEB==:61		;BLOCK NO OF FE.SYS (1ST DATA BLOCK)
    FEVALID==:100000	    ;VALID ADR IF ON
HOMFEL==:62		;LENGTH OF FE.SYS
HOMFEA==:101		;FE-FILE ADDRESS FOR KS10
HOMFES==:102		;FE-FILE LENGTH FOR KS10
HOMTCS==:103		;TRACK/CYL/SECTOR FOR KS10
HOMKLE==:104		;TO FIND FILES FOR BOOTSTRAP/DUMP
HOMK4C==:105
HOMBTS==:106		;BITS IN THE HOME BLOCK
HOMPVS==:HOMBTS		;WORD CONTAINING BIT WHICH SAYS PRIVATE STR
    HOPPVS==:1B35	    ;ON IF THIS UNIT IS CONTAINED IN A PRIVATE STR
    HOSPVS==1		    ;BYTE SIZE
    HONPVS==^D35	    ;BYTE PTR POS.
	$HIGH
HOYPVS::POINT	HOSPVS,HOMPVS(P1),HONPVS  ;BYTE POINTER TO BIT WHICH
			; IF 1 SAYS THIS UNIT IS IN A PRIVATE STR
	$LOW

HOMHWP==:HOMBTS		;WORD CONTAINING BITS WHICH SPECIFIES IF THE STRUCTURE
			; MUST BE HARD OR WRITE PROTECTED WHEN MOUNTED (FOR
			; ARCHIVAL DISKS)
    HOSHWP==1		    ;HARD BYTE SIZE
    HONHWP==^D34	    ;HARD BYTE POINTER POSITION
	$HIGH
HOYHWP::POINT HOSHWP,HOMHWP(P1),HONHWP  ;BP TO HARDWARE WRITE PROTECT BIT

	$LOW
HOMSET==:HOMBTS		;WORD CONTAINING BYTE WHICH SPECIFIES WHICH SET THIS
			; STRUCTURE BELONGS TO
    HOSSET==6		    ;BYTE SIZE
    HONSET==^D32	    ;BYTE POINTER POSITION
	$HIGH
HOYSET::POINT	HOSSET,HOMSET(P1),HONSET ;BYTE POINTER TO BYTE WHICH SPECIFIES
			; WHICH SET THIS STRUCTURE BELONGS TO
	$LOW
HOMSDL==:107		;POSITION OF THIS STR IN SYSTEM DUMP LIST (1...N)
			;-1 OR 0 MEANS NOT IN SDL (0 FOR COMPATABILITY)
HOMOPP==:110		;OWNER PPN OF THIS STRUCTURE
HOMMSU==:111		;FOR FUTURE USE
HOMCUS==:112		;4 WORDS RESERVED TO CUSTOMERS
HOMCUL==:115		;LAST WORD IN THE HOME BLOCK RESERVED TO CUSTOMERS
HOMEND==:115		;LAST WORD CONTAINING VALID DATA IN HOME BLOCK
HOMVID==:165		;VOLUME ID (3 WORDS, 12 PDP-11 BYTES)
HOMOKC==:170		;K FOR CRASH.SAV FILE
HOMOWN==:170		;OWNER NAME
HOMVSY==:173		;SYSTEM TYPE (TOPS-10)
HOMCOD==:BLKCOD		;CONTAINS UNLIKELY CODE, LH=0
    CODHOM==:707070	    ;THE UNLIKELY CODE FOR THE HOME BLOCK
HOMSLF==:BLKSLF		;LH=0, RH=THIS BLOCK (NO.T CLUSTER) ADR. WITHIN UNIT (SELF)

HOMFLG::0		;COUNT OF UNITS NEEDING HOME BLOCKS REREAD
RHBIOW::IOWD	10,HOMBUF ;IOWD TO READ HOME BLOCKS AFTER FREE INTERRUPT
	0
HOMBUF::BLOCK	10
;WORDS IN THE HOME BLOCK USED BY KLDCP AND/OR RSX-20F:

;61	LH	contains 'KL ' in PDP-11 RADIX50 if KLDCP version 1
;			- or -
;	LH	contains 100000 if valid RSX-20F front-end file system exists
;	RH	contains high-order 16 bits of LBN of beginning of RSX-20F's
;			 FILES-11 file system
;62	LH	contains low-order 16 bits of LBN of beginning of RSX-20F's
;			 FILES-11 file system
;	RH	contains length (in blocks) of RSX-20F's FILES-11 file system
;65	LH	contains 'KLA' in PDP-11 RADIX50 if KLDCP version 2
;	RH	contains 'D10' in PDP-11 RADIX50 if KLPDCP version 2
;66	LH	contains cylinder number of KLADFE.SYS
;	RH	contains track/sector numbers of KLADFE.SYS
;67	LH	contains length (in blocks) of KLADFE.SYS
SUBTTL	KONTROLLER PARAMETERS

;THE INTERFACE CAN BE CONSIDERED AS AN INTERFACE TO AN IDEAL DEVICE.
; IT IS THE JOB OF EACH DEVICE DEPENDENT ROUTINE TO MEET THE
; REQUIREMENTS OF THE IDEAL DEVICE.

REPEAT	0,<
DESCRIPTION FOR THE IDEAL KONTROLLER: (CLOSE TO RP10)
ONE OR MORE INDEPENDENT AND SIMULTANEOUS POSITIONERS
ONE DATA TRANSFER AT A TIME
KONTROLLER WILL ACCEPT POSITION COMMANDS ANY TIME EXCEPT DURING A DATA TRANSFER
KONTROLLER WILL INTERRUPT WHENEVER ONE OR MORE POSITIONINGS COMPLETES
	(EXCEPT DURING A DATA TRANSFER IN WHICH CASE FLAGS FOR EACH
	POSITIONER WHICH FINISHED WILL BE SET WHEN DATA TRANSFER DONE
	INTERRUPT OCCURS).  THE POSITION FLAGS ARE ON ONLY ON INTERRUPT,
	RATHER	THAN REMAINING ON AS LONG AS THE POSITIONER IS IN POSITION.
KONTROLLER WILL RETURN THE LAST FUNCTION WHICH IT RECEIVED SO THAT IT
	IS	POSSIBLE TO DETERMINE THE REASON FOR THE INTERRUPT (I.E.,
	POSITIONING OR DATA).
KONTROLLER AUTOMATICALLY POSITIONS TO NEXT CYLINDER FOR A MULTIPLE
	BLOCK	COMMAND LIST WHICH CROSSES FROM ONE CLYINDER TO NEXT.
	PROVIDED THERE WERE NO ERRORS SO FAR, ELSE IT WILL TERMINATE
>
;PROGRAMMING REQUISITES FOR DEVICE DEPENDENT ROUTINES
;	A.  NOT KNOW ABOUT FILE STRUCTURES
;	B.  BE AS SIMPLE AS POSSIBLE
;	C.  ISSUE ALL IO INSTRUCTIONS
;	D.  WHENEVER POSSIBLE DO NOT DEPEND ON HARDWARE STATUS INFO.
;THE FOLLOWING ARGUMENTS ARE PASSED TO DEVICE DEPENDENT ROUTINES

;	1.  ADDRESS OF UNIT DATA BLOCK [AC U AND C(KONCUA(J))]
;	    1.1  LOGICAL BLOCK NO. WITHIN UNIT [C(UNIBLK(U))]
;	    1.2  PHYSICAL UNIT NO. WITHIN KONTROLLER [WORD UDBPDN]
;	2.  ADDRESS OF KONTROLLER DATA BLOCK [AC J]
;	    2.1  LOWER CORE ADDRESS OF CHANNEL WORD PAIR FOR THIS
;	         KONTROLLER [C(KONIOC(J))]
;	    2.2  ADDRESS OF CHANNEL COMMAND LIST [RH OF C(C(KONIOC(J))),
;		 LH C(C(KONIOC(J)))=0]

;NOTE - DEPENDENT ROUTINE MAY CHANGE C(C(KONIOC(J))) AND C(UNIBLK) BEFORE
; DATA TRANSFER IS THRU.  IF DATA MUST BE TRANSFERRED PAST END OF CYLINDER.
; THEN ERROR RETRIES WILL START FROM BEG. OF BAD CYLINDER RATHER THAN START
; OVER.

;NOTE - KONTROLLER ROUTINES MUST NOT ADVANCE PAST AN END OF CYLINDER
; IF THERE ARE ANY ERRORS ON THE FIRST PIECE. IN THIS WAY THE FILSER
; ERROR RETRY LOGIC NEED NEVER REPOSITION ON AN ERROR RETRY.

;	    2.3  CHANNEL COMMAND LIST IN FREE CORE
;	    2.4  THE CONSO INTR. FOR THIS KONTROLLER [C(KONINT(J))]

;THE FOLLOWING CONSTANTS ARE AVAILABLE TO DEVICE DEPENDENT ROUTINES:
;	1.  NUMBER OF BLOCKS PER CYLINDER (BYTE = UNYBPY).  U MUST STILL
;	    BE SETUP.
;	2.  NUMBER OF BLOCKS PER TRACK (BYTE = UNYBPT).  U MUST STILL
;	    BE SETUP.

;THE FOLLOWING LOCATIONS ARE CHANGED BY DEVICE DEPENDENT ROUTINES.
;	1.  CURRENT CYLINDER POSITIONED AT OR SEEKING TOWARDS
;	    [C(UNICYL(U))] ON CALLS TO KONPOS(J) AND END OF CYLINDER.
;	2.  CURRENT LOGICAL BLOCK NUMBER BEING READ OR WRITTEN
;	    [C(UNIBLK(U))] (CHANGED ONLY IF END OF CYLINDER ENCOUNTERED).
;	3.  SOFT POSITIONING ERRORS [RH(UNIPCT(U))], FILSER DOES NOT GET
;	    CONTROL.
;	4.  HARD POSITIONING ERRORS [LH(UNIPCT(U))], T2 INDICATES DEVICE
;	    ERROR.
;ALL TEMPORARY LOCATIONS IN DEVICE DEPENDENT ROUTINES ARE INDEXED BY J
;	THE KONTROLLER DATA BLOCK CONTAINS ALL IO
;	INSTRUCTIONS FOR THE KONTROLLER. IN THIS WAY THE SAME
;	DEVICE DEPENDENT CODE WILL WORK FOR MORE THAN ONE
;	KONTROLLER OF THE SAME TYPE. (ONLY THE CONTENTS OF J
;	AND THE DEVICE CODE IN THE KONTROLLER DATA BLOCK WILL DIFFER
;	FOR EACH KONTROLLER OF SAME TYPE).
;	THE FOLLOWING CALLS ARE PROVIDED FOR EACH KONTROLLER TYPE
;	WHERE XX STANDS FOR KONTROLLER TYPE (DP,FH,DR,MD)

;XX'XRED - READ FROM UNIT STARTING WITH LOGICAL BLOCK WITHIN UNIT C(UNIBLK(U))
;XX'XWRT - WRITE ON UNIT STARTING WITH LOGICAL BLOCK WITHIN UNIT C(UNIBLK(U))
;	   USING CHANNEL COMMAND LIST AT C(KONIOC(J)) AND DO NOT STOP ON ERRORS
;XX'XWTF - WRITE FORMAT (HEADERS)
;	   ONLY IF FTDSUP FEATURE TEST IS ON
;XX'XRDS - SAME AS XX'XRED EXCEPT STOP ON ERRORS (USED FOR ERROR MARKING)
;XX'XWTS - SAME AS XX'XWRT EXCEPT STOP ON ERRORS (USED FOR ERROR MARKING)
;XX'XPOS - POSITION ARM ON UNIT U C(KONIOC(J)) NOT SETUP ON CALL
;XX'XLTM - RETURN LATENCY TIME IN MICROSECONDS TO BEGINNING OF TRANSFER OF
;	   LOGICAL BLOCK WITHIN UNIT C(UNIBLK(U)).
;	   C(KONIOC(J)) NOT SETUP ON CALL.  NOTE AC T1 ALSO SET TO C(UNIBLK(U))
;XX'XUPA - CHECK TO SEE IF KONTROLLER IS ON-LINE(WITHOUT READING OR WRITING)
;	   SKIP RETURN IF YES, NON SKIP IF NOT
;	   CALLED EVERY TIME MONITOR IS STARTED
;XX'XCPY - CHECK CAPACITY & STATE OF UNIT U. RETURNS WITH:-
;	   UNISER(U) = DRIVE SERIAL NUMBER (2 WORDS)
;	   T1= NUMBER OF BLOCKS PER UNIT (REGULAR)
;	   T2= NUMBER OF BLOCKS PER UNIT INCL. MAINT. CYLS
;	   T3= NUMBER OF BLOCKS PER UNIT IN COMPAT. MODE
;	   RH(T4)= UNIT TYPE
;	   LH T4 = 0 IF OK, SIGN BIT = 1 IF ANY ERROR (KOPUHE)
;	   BIT 1 = 1 IF UNIT DOES NOT EXIST (KOPNSU) SO NO ASK OFFLINE QUESTION
;	   W= BLKS PER TRACK,,BLKS PER CYLINDER
;	   SKIP RETURN IF UNIT ON-LINE - NON SKIP IF OFF-LINE
;XX'XRCL - RECALIBRATE UNIT (AFTER 'DSKTRY' SOFT ERRORS)
;	   NON-SKIP RETURN IS DEVICE NOT OK OR DEVICE DOES NOT RECALIBRATE
;XX'XSTP - STOP UNIT, EVEN IF BUSY (USED ONLY IF HUNG)
;	   NON-SKIP RETURN - IF BUSY CANNOT BE TURNED OFF.  NO VALUE RETURNED
;	   SKIP RETURN  T2=CONI STATUS BEFORE BEING RESET
;	   T3=DATAI STATUS BEFORE BEING RESET
;XX'XECC - NON-SKIP IF NO ECC AVAILABLE (HDW ERROR, NOT CALLED UNLESS IOECCX=1)
;	   RETURNS T1=RELATIVE POSITION OF THE ERROR IN THE SECTOR
;	   RETURNS T2,T3= XOR MASK FOR ERROR CORRECTION (NOTE WAY MASK APPLIED)
;XX'XERR - CALLED WITH T1=RETRY NUMBER. ALWAYS RETURNS CPOPJ
;	   RETURNS T1=0 FOR A STRAIGHT RETRY
;	   RETURNS T1=1 OFFSET IS IN PROGRESS (ATTN INTERRUPT WHEN DONE)
;	   RETURNS T1=2 TRY LAST TIME (DISABLE STOP ON ERROR 
;	   RETURNS T1=3 GIVE UP (HARD ERROR)
;	   RETURNS T1=4 RECALIBRATE THE DRIVE
;XX'XALV - ENSURE THAT THE KONTROLLER HAS A PIA, IVI SET UP
;	   ALWAYS RETURNS CPOPJ
;XX'XREG - READ MASSBUS REGISTERS
;	   CALLED AT CLOCK LEVEL, DEVICE WILL INTERRUPT BEFORE RETURN

;ALL ROUTINES GIVE SKIP RETURN IF OK (IO INSTRUCTIONS GIVEN AND ACCEPTED
;BY KONTROLLER).  NO SKIP RETURN IF COULD NOT ISSUE IO INSTRUCTIONS
;(OFF-LINE, WRITE LOCKED, NON-EXISTANT, BUSY)
;ON NON-SKIP RETURN, BITS 18-21 OF T1 MAY CONTAIN ERROR BITS
;  FOR FILSER (KOPOFL ETC.) THESE BITS ARE DEFINED IN COMMON
;  SINCE FILSER ALSO NEEDS THEM
;CALL:	MOVEI	U, ADR. OF UNIT DATA BLOCK
;	MOVE	J,UNIKON(U)	;SETUP ADDRESS KONTROLLER DATA BLOCK
;	PUSHJ	P,@KONYYY(J)	;CALL KONTROLLER ROUTINE
;	  ERROR RETURN
;	OK RETURN
REPEAT	0,<
WHEN AN INTERRUPT OCCURS, THE DEVICE DEPENDENT MODULE PASSES THE FOLLOWING
INFORMATION TO THE DEVICE INDEPENDENT MODULE(FILINT):
	A. FUNCTION WHICH CAUSED INTERRUPT
	   (OPRED,OPWRT,OPRDS,OPWTS,OPPOS,OPCAL,BITS 33-35 OF T1)

FOR FILINT CALL:
	B. POSITIONERS WHICH JUST POSITIONED, IF ANY (BITS 0-7 OF T1 FOR
	   UNITS 0-7)
	C. UNIT LAST CONNECTED TO KONTROLLER FOR POSITION OR TRANSFER
	   COMMAND (BITS 15-17 OF T1)
END OF FOR FILINT CALL

FOR FLHTID CALL:
	B. POSITIONERS WHICH JUST POSITIONED, IF ANY (BITS 0-23 OF T4 FOR
	   UNITS 0-27)
	C. UNIT LAST CONNECTED TO KONTROLLER FOR POSITION OR TRANSFER
	   COMMAND (BITS 12-17 OF T1)
END OF FOR FLHTID CALL

	D. GENERALIZED ERROR FLAGS IF ANY
	   BITS 18-23 OF AC T1 PASS BACK GENERALIZED ERRORS:
	   IOIMPM - IMPROPER MODE
	   IODERR - DEVICE ERROR
	   IODTER - DATA ERROR
	   IOBKTL - BLOCK TOO LARGE
	   IOCHNX - CHANNEL NON-EX MEM - NEVER STORED IN DDB (DEVIOS FULL)
	   IOCHMP - CHANNEL PARITY ERROR - NEVER STORED IN DDB (DEVIOS FULL)
	   IOVRUN - OVERRUN OCCURRED
	   IOHDER - HEADER COMPARE OR SEARCH ERROR
	   IOECCX - CORRECTABLE ECC ERROR OCCURRED
	   FILSER WILL CALL XX'XECC TO GET MASK, POSITION
	IF 3 ERRORS IN A ROW, FILINT WILL ALSO STORE T2 IN
	   TO UNIERR(U), SO THAT A RECORD OF HARD ERRORS IS ALSO KEPT.
	   IF NO ERRORS T2 IS IRRELEVENT.
	ON ANY ERROR MASSBUS DEVICES WILL STORE THE C(KONREG) DRIVE REGISTERS
	IN KONEBK THROUGH KONEBK+N-1. THEY WILL STORE THE LAST DATAO FOR THE
	DRIVE IN UNILAS
	E. ADDRESS OF THE KONTROLLER DATA BLOCK IN AC J.
	F. NOTE AC U IS NOT SETUP
	G. SPECIFIC KONTROLLER DATA WORD (CONI) IN AC T2
	H. SPECIFIC KONTROLLER DATA WORD (DATAI) IN AC T3

CALL:	MOVEI	J,ADDRESS OF KONTROLLER
	MOVE	T1,POSITIONED UNITS,LAST UNIT,ERROR FLAGS,FUNCTION
	MOVE	T2,CONI STATUS
	MOVE	T3,DATAI HARDWARE STATUS
	PUSHJ	P,FILINT	;FILINT MAY PUSHJ BACK TO XX'XRED,XX'XWRT
				; ETC. IN THIS OR ANY OTHER DEVICE DEPENDENT
				; MODULE ALWAYS	RETURN HERE FROM FILSER

>
SUBTTL	LNM:	LOGICAL NAME SPECIFICATIONS

LNMPLN==:0		;NAME OF LOGICAL DEVICE
LNMDEV==:1		;DEVICE (SEARCH LIST)
LNMNAM==:2		;FILE NAME
LNMEXT==:3		;FILE EXTENSION
LNMPPN==:4		;PPN
LNMSFD==:5		;1ST SFD

LNRDEV==:0		;SEARCH LIST, RELATIVE TO CURRENT DEVICE
LNRNAM==:1		;NAME
LNREXT==:2		;EXTENSION
LNRPPN==:3		;PPN, RELATIVE TO DEVICE
LNRSFD==:4		;1ST SFD, RELATIVE TO DEVICE

;BITS IN READ/SET LOGICAL NAME FUNCTIONS OF PATH.
LN.LIB==:400000		;BIT 0 =1 IF THIS IS A LIB
LN.UDF==:200000		;BIT 1=1 IF UNDEFINE THIS LOG NAME
LN.RIT==:100000		;BIT 2 = 1 IF RETURN INFO ABOUT THIS LOG NAME, RATHER
			; THAN NEXT
LN.OVR==:20000		;BIT = 1 IF NAME, EXT OVERRIDE NON-0 IN LOOKUP/ENTER BLOCK

;FORMAT OF TABLE POINTED AT BY .UPLNM:
			    ;BIT 0=1 IF LIB
    LNPOVR==:(1B1)	    ;BIT 1=1 IF OVERRIDE
			    ;BITS 3-11 = LENGTH OF LNM SPEC
			    ;BITS 14-17 = 0
			    ;BITS 18-35 = ADRESS OF LNMNAM
	$HIGH
LNYLEN::POINT	9,@.USLNM,11
	$LOW
SUBTTL	MONITOR JOB TABLES - ONE ENTRY PER JOB

SYSBG3::		;1ST. LOCATION CLEARED BY ACCINI ON 403 (RE)START

JBTSFD::BLOCK	JOBN	;RH(BITS 18-33)= LOC OF DEFAULT SFD NMB OR 0
    JBPSCN==:1		    ;BIT 35=1 IF SCANNING IS ON, =0 IF SCANNING OFF
    JBPUFB==:2		    ;BIT 34=1 IF JBTSFD POINTS TO A UFB
			;LH JBTSFD - USED IF FTLIB ON-
			    ;BITS 0-15=LOC OF PPB FOR LIBRARY
    JBPSYS==:1		    ;BIT 17=1 IF SEARCH SYS AFTER DSK
    JBPXSY==:2		    ;BIT 16=1 IF SEARCH NEW BEFORE SYS

JBTFA::	BLOCK	JOBN	;LH UNUSED
			;RH=NMB FOR WHICH JOB OWNS FA RESOURCE

JBTRCT::BLOCK	JOBN	;NO. OF DISK BLOCKS READ ON ALL STRS SINCE JOB LOGGED IN
			;JOB 0=SWAP READ ON ALL UNITS
JBTIRD==:JBTRCT		;INCREMENTAL READ COUNT - WORD ADR.
			; ACTUALLY IT IS A COPY OF THE LOW ORDER 12 BITS
			; OF THE ACCUMULATED READS FOR THIS JOB.
			; IT IS RESET TO NEW LOW ORDER TOTAL AFTER EVERY
			; "DISK" COMMAND.  IN THIS WAY ONLY ONE COUNT NEED
			; BE INCREMENTED EVERY READ INSTEAD OF TWO.
			; INCREMENTAL DISK BLOCKS READ IS COMPUTED BY:
			;  LDB T1,JBYRCT;LDB T2,JBYIRD;DPB T1,JBYIRD;SUB T1,T2
			;  ANDI T1,JBRIRD
    JBSIRD==^D12	    ;BYTE SIZE
    JBNIRD==^D11	    ;BYTE PTR POS.
    JBRIRD==:1_JBSIRD-1	    ;BITS IN BYTE AFTER RIGHT JUSTIFIED
    JBSRCT==^D24	    ;BYTE SIZE
    JBNRCT==^D35	    ;BYTE PTR POS

JBTWCT::BLOCK	JOBN	;NO. OF DISK BLOCK WRITTEN ON ALL STRS SINCE JOB LOGGED IN
			; INCLUDING ALL OVERHEAD BLOCKS
			;JOB 0=SWAP WRITE ON ALL UNITS
JBDIRD==:JBTWCT-JBTRCT	;DIFFERENCE BETWEEN TWO ORIGINS
MJBDRD==:JBTRCT-JBTWCT	;MINUS DIFFERENCE
JBTIWT==:JBTWCT		;INCREMENTAL WRITE COUNT - WORD ADR
			; SEE JBTIRD
    JBSIWT==^D12	    ;BYTE SIZE
    JBNIWT==^D11	    ;BYTE PTR POS
    JBRIWT==:1_JBSIWT-1	    ;BITS IN BYTE AFTER BEING RIGHT JUSTIFIED
    JBSWCT==^D24	    ;BYTE SIZE
    JBNWCT==^D35	    ;BYTE PTR POS
SYSEN3==:.-1		;LAST LOCATION CLEARED BY ACCINI ON 143 (RE)START
	$HIGH
JBYIRD::POINT	JBSIRD,JBTIRD(J),JBNIRD	;BYTE POINTER
JBYRCT::POINT	JBSRCT,JBTRCT(J),JBNRCT	;BYTE POINTER
;JBYIWT: POINT	JBSIWT,JBTIWT(J),JBNIWT	;BYTE POINTER
JBYWCT::POINT	JBSWCT,JBTWCT(J),JBNWCT	;BYTE POINTER
SFYSCU::POINT	2,JBTSFD(J),35	;POINTER FOR JBPUFB & JBPSCN
	$LOW
	SUBTTL	KON - KONTROLLER DATA BLOCKS

;THE KONTROLLER DATA BLOCK DEFINITIONS ARE FOUND IN DEVPRM.  BYTE
;POINTERS INTO THE KDB FOLLOW:

KOYKTP::POINT	KOSKTP,KOBKTP(J),KONKTP	;KONTROLLER TYPE
KOZKTP::POINT	KOSKTP,KOBKTP(P3),KONKTP ;KONTROLLER TYPE
KOYKNM::POINT	KOSKNM,KOBKNM(J),KONKNM ;KONTROLLER NUMBER
	$LOW
SUBTTL	LBN - LOGICAL DISK BLOCK NUMBERS WITHIN UNIT(NOT STR) ASSIGNED AS ASSEMBLY TIME

;THERE ARE AS FEW OF THESE AS POSSIBLE.  THEY CAN BE CHANGED AT MONGEN TIME
;BY DEFINING SYMBOLS
;BLOCK 0 WITHIN A UNIT IS NOT USED SINCE IT IS THE MOST LIKELY BLOCK TO BE
;WRITTEN IF FILSER HAS A BUG.  FILSER WILL HALT IF BLOCK 0 IS READ OR WRITTEN
; EXCEPT IF FILE BEING ACCESSED IS HOME.SYS OR SUPER USETI 0

ND LBNHOM,^D1		;LOGICAL BLOCK NO. OF HOME BLOCK

ND LB2HOM,^D10		;2ND LOGICAL BLOCK # OF HOME BLOCK (THE REDUNDANT ONE)
			; THIS IS THE DEFAULT FOR ALL UNITS
			; PUT ON A DIFFERENT SURFACE OR RP01 AND RP02 FROM
			; FIRST HOME BLOCK.

XP LBOBAT,1		;# OF BLOCKS BOTH BAT BLOCKS ARE OFFSET FROM HOME BLOCK

			;NOTE THAT ISW BLOCK IS OBSOLETE
XP LBOISW,2		;# OF BLOCKS INITIAL SWAPPING
			; SAT OFFSET FROM HOME BLOCK

;BLOCKS FOR BOOTS:
ND FBOOTB,4		;FIRST LOGICAL BLOCK
			; IN EACH UNIT FOR BOOTS
XP NBOOTB,4		;NO. OF BLOCKS IN BOOTS(DISK BOOTSTRAP)
XP MNBOOT,-NBOOTB	;MINUS NO. OF BLOCKS IN BOOTS
SUBTTL	MFD	WORD POSITIONS IN MASTER FILE DIRECTORY

;PREFIX "MFD"
;THIS IS ALSO THE USER FILE DIRECTORY FOR PROJECT 1, PROGRAMMER 1

MFDNAM==:0	;OCTAL (NOT SIXBIT) NAME OF UFD.  THIS IS PROJECT-PROGRAMMER
		; NUMBER. IN COMMENTS THIS IS WRITTEN AS [PROJ,PROG]. UFD
MFDEXT==:1	;LH=UFD IN SIXBIT (USUALLY)
		;RH=COMPRESSED UFD POINTER (CUP) CONTAINS UNIT AND LOGICAL BLOCK
		; WITHIN UNIT OF FIRST RETIREVAL BLOCK OF FILE.  TO CONVERT
		; FROM A CUP TO UNIT AND LOGICAL BLOCK NUMBER OF FIRST RIB:
		;	SEARCH FILE STRUCTURE TABLE AND FIND
		;	N'TH ENTRY N=1,2...M) WHICH IS FIRST ENTRY WHOSE VALUE
		;	EQUAL TO OR LESS THAN CUP.  (N-1) IS THEN
		;	THE UNIT NUMBER IN THAT FILE STRUCTURE
		;	SUBTRACTING THE (N-1)ST ENTRY(=0, ENTRY = 0) GIVES
		;	CUP INDEX RELATIVE TO THE N'TH UNIT.  MULTIPLYING
		;	BY THE CUP CONVERSION FACTOR FOR UNIT N IN THIS
		;	FILE STRUCTURE GIVES LOGICAL BLOCK NUMBER, WHEW!

ND MFDSIZ,^D30	;NO. OF BLOCKS FOR INITIAL MFD SET BY REFRESHER
		; INCLUDING RIBS.  MAKE IT LARGE ENOUGH SO MFD IS
		; COMPLETELY CONTAINED IN ONE GROUP SO ONLY ONE
		; RETRIEVAL POINTER(FOR SPEED).  FILSER WILL
		; HANDLE MULTIPLE GROUP MFD
SUBTTL	NMB FILE NAME DATA BLOCK

;USED TO REMEMBER FILE NAMES IN A PROJECT-PROGRAMMER NUMBER ACROSS
; ALL FILE STRUCTURES.

;WORD 0---------------------------------------
NMBNAM==:CORNAM		;SIXBIT FILE NAME LEFT JUSTIFIED

;WORD 1---------------------------------------
NMBPPB==:CORLNK		;LH=CORE ADR.(ACCROSS POINTER) OF NEXT NAME BLOCK IN THIS
			; PROJ-PROG NUMBER
    NMPUPT==:2		    ;IF THIS BIT IS ON IN AN NMBPPB, THE ADDRESS-2 IS
			    ; THE LOC OF THE FATHER SFD FOR THIS LIST OF NMB'S
			    ; (IT IS ONLY ON IN THE LAST NMB IN THE LIST)

    NMPSFU==:1		    ;BIT ON (IN AC, NEVER IN CORE) IF THE LOC RETURNED
			    ; (BY UFORSF) IS AN SFD A.T., OFF IF THE LOC IS A UFB
NMBFAJ==:NMBPPB		;RH=JOB NUMBER OF OWNER OF FA RESOURCE FOR THIS NMB

DIFAWU==:ACCWRT-NMPSFU	;DIFFERENCE BETWEEN A.T.LOC+NMPSFU AND ACCWRT

;WORD 2---------------------------------------
NMBRNG==:2		;LH=POINTER TO AN NMB-LIST OF FILES
			; UNDER THE SFD. 0 IF NOT AN SFD
DIFNMC==:NMBRNG-CORLNK
NMBCFP==:2		;RH=COPY OF COMPRESSED FILE POINTER. I.E., COPY OF
			; SECOND WORD OF PAIR IN UFD.(COMPRESSION CONTAINS
			; LOGICAL UNIT NUMBER WITHIN FILE STRUCTURE)

;WORD 3---------------------------------------
NMBACC==:3		;LH=CORE ADR (DOWNWARD POINTER) OF FIRST ACCESS
			; BLOCK IN ACCESS RING WITH THIS FILENAME/PROJ-PROG.
			; IF RING IS EMPTY, LH NOT 0. INSTEAD IT POINTS
			; TO ITSELF-CORLNK.  IN THIS WAY NO SPECIAL
			; CHECKING IS NEED TO ADD OR DELETE ACCESS BLOCKS
			; FROM RING. IT ALSO PROVIDES A SIMPLE CHECK FOR
			; AN EMPTY RING, SINCE TWO LOW ORDER BITS=0
			; IF AN ACCESS BLOCK ADDRESS,=CORLNK IF EMPTY.
DIFNAL==:NMBACC-ACCNMB	;DIFFERENCE BETWEEN LOC. OF DOWNWARD POINTER IN
			; NMB BLOCK AND ACCROSS POINTER IN ACC BLOCK. USED
			; FOR SEARCHING RING.
NMBEXT==:3		;RH=LEFT JUSTIFIED SIXBIT FILE EXTENSION
;WORD 4---------------------------------------
NMBFSN==:CORFSN		;FSN # - WORD ADR.
    NMSFSN==COSFSN	    ;BYTE SIZE
    NMNFSN==CONFSN	    ;BYTE PTR. POS.
NMYFSN==:COYFSN		;RIGHT MOST BIT
NMXFSN==:COXFSN


;WORD 5---------------------------------------
NMBKNO==:CORKNO		;KNOW WHETHER FILE EXISTS OR NOT IN STR N-WORD ADR.
			; BIT NMNKNO-N=1 IF KNOW FOR FS. N
    NMSKNO==COSKNO	    ;BYTE SIZE
    NMNKNO==CONKNO	    ;BYTE PTR. POS.
    NMPKNO==:COPKNO	    ;RIGHT MOST BIT
NMYKNO==:COYKNO
NMZKNO==:COZKNO


;WORD 6---------------------------------------
NMBYES==:CORYES		;FILE OR UFD DEFINITELY EXISTS IN FILE STRUCTURE N
			; IF BIT NMPYES-N=1 -WORD ADR. CORRESPONDING BIT
			; IN NMBKNO=1 TOO.
    NMSYES==COSYES	    ;BYTE SIZE
    NMNYES==CONYES	    ;BYTE PTR. POS.
    NMPYES==:COPYES	    ;RIGHT MOST BIT

;WORD 7---------------------------------------
NMBCNT==:7		;USE-COUNT FOR THE NMB
	SUBTTL	PATH. UUO PARAMETERS

PT.SCN==:3		;SCAN SWITCH
PT.SXS==4		;SEARCH EXP SYS
PT.SYS==10		;SEARCH SYS
PT.DTL==:40		;SET SYS, NEW BIT DON'T TOUCH LIB

PT.LIB==:20		;SEARCH LIB
PT.IPP==:40		;IMPLIED PPN
PT.JSL==:100		;JOB SEARCH LIST
PT.ASL==:200		;ALL SEARCH LIST
PT.SSL==:300		;SYS SEARCH LIST
PT.DLN==:1000		;DEVICE WAS LOGICAL NAME
PT.EDA==:2000		;DEVICE WAS LOGICAL NAME AND ERSATZ DEVICE
PT.FFS==:4000		;FILE FOUND BY SCANNING SFDS
PT.FFL==:10000		;FILE FOUND IN LIB OR SYS

;INTERNAL FLAG BITS FOR SIXBIT OR CHANNEL ARG
PT.ESZ==:(1B1)		;SET IF DEVICE NOT BOTH A LOGICAL NAME AND
			;ERSATZ DEVICE
PT.GEN==:(1B2)		;SET IF DEVICE IS NOT GENERIC DSK
PT.PHO==:PHONLY		;SET IF THIS UUO IS PHYSICAL ONLY
SUBTTL	PTR:	COPY OF RETRIEVAL POINTERS KEPT IN CORE FOR UPDATE FILES

PTRSYS==:0		;LH=LINK TO NEXT IN-CORE COPY
PTRAT==:PTRSYS		;RH=ADDR OF ACCESS TABLE WHICH "OWNS" POINTERS
PTRFLR==:1		;COPY OF DEVFLR FOR 1ST POINTER IN GLUMP
PTRRIB==:2		;COPY OF DEVRIB
PTRFUN==:3		;LH=COPY OF DEVFUN
PTRRLC==:PTRFUN		;RH=DEYRLC BYTE, DEVRSU PLUS SOME BITS
    PTPLPC==:400000	    ;BIT=1 IF DEPLPC IS ON IN DDB
PTRDAT==:4		;1ST POINTER
PTRDND==:PTRDAT+PTRLEN-1	;LAST POINTER
PTRCOR==:<<PTRDND+1+3>/4>*4

	$HIGH
PTYRSU::POINT	7,PTRRLC(T2),28
	$LOW
SUBTTL	PPB - PROJECT PROGRAMMER NUMBER DATA BLOCK

;USED TO ORGANIZE FILES REMEMBERED IN MEMORY ON PPN BLOCK FOR EVERY
; PROJECT-PROGRAMMER NUMBER IN SYSTEM WHICH HAS SOME ACTIVE FILES
; SETUP WHENEVER A NEW PROJECT-PROGRAMMER NUMBER IS LOOKED UP OR
; ENTERED.


;WORD 0---------------------------------------
PPBNAM==:CORNAM		;LH=PROJECT NUMBER (RIGHT JUSTIFIED OCTAL)
			; OR LEFT JUSTIFIED SIXBIT (PROJ NAME)
			;RH=PROGRAMMER NUMBERS RIGHT JUSTIFIED OCTAL)
			; OR LEFT JUSTIFIED SIXBIT (PROJ INITIALS)

;WORD 1---------------------------------------
PPBSYS==:CORLNK		;LH=CORE ADDRESS(ACCROSS POINTER) OF NEXT PPN BLOCK IN SYSTEM

;WORD 2---------------------------------------
PPBUFB==:2		;LH=CORE ADDRESS OF FIRST UFB BLOCK WITH THIS
			; PROJECT-PROGRAMMER NUMBER.  THERE IS ONE UFB
			; BLOCK FOR EVERY FILE STRUCTURE IN WHICH THIS
			; PROJECT-PROGRAMMER NUMBER HAS A UFD
DIFPBC==:PPBUFB-CORLNK

;WORD 3---------------------------------------
PPBNMB==:3		;LH=CORE ADDRESS OF FIRST FILE NAME BLOCK (NMB)
			; WITH THIS PROJECT-PROGRAMMER NUMBER
			;RH=BIT PPPYES-N=1 IF UFD EXISTS (CLOSED IN MFD) IN
			; NTH FILE STRUCTURE IN SYSTEM.  IF BIT PPPYES-N=0
			; EITHER UFD DOES NOT EXIST OR DO NOT KNOW.
			; SEE BIT COPYES-N IN PPBUFB.
DIFPNL==:PPBNMB-NMBPPB	;DIFFERENCE BETWEEN DOWNWARD POINTER IN PPB BLOCK
			; AND ACCROSS POINTER IN NMB BLOCK
PPBNLG==:3		;PROJ PROG NO. NOT LOGGED IN - WORD ADR.
    PPSNLG==^D1		    ;BYTE SIZE
    PPNNLG==^D35	    ;BYTE PTR. POS.
    PPPNLG==:1		    ;PROJ PROG NO. NOT LOGGED IN - THE BIT=0 IF NOT
			    ; USED TO FLUSH PPB IMMEDIATELY WHEN LAST FILE
			    ; BECOMES DORMANT IN PPB

;WORD 4---------------------------------------
PPBCNT==:4		;USE-COUNT FOR THE PPB
;WORD 5---------------------------------------
PPBKNO==:CORKNO		;KNOW WHETHER UFD DOES OR DOES NOT EXIST IN
			; FILE STRUCTURE N-WORD ADR. BITS 18-31 BIT PPPKNO-N=1 IF
			; MONITOR KNOWS(HAS READ UFD),=0 IF HAS NOT.
    PPSKNO==COSKNO	    ;BYTE SIZE
    PPNKNO==CONKNO	    ;BYTE PTR. POS.
    PPPKNO==:COPKNO	    ;RIGHT MOST BIT
;WORD 6---------------------------------------
PPBYES==:CORYES		;UFD DEFINITELY EXISTS IN FILESTRUCTURE - WORD ADR.
    PPSYES==COSYES	    ;BYTE SIZE
    PPNYES==CONYES	    ;BYTE PTR. POS.
    PPPYES==:COPYES	    ;RIGHT MOST BIT

;WORD 7---------------------------------------
PPBLOK==:7		;BIT N+1 =1 IF UFD FOR FSN N IS INTERLOCKED

SUBTTL	RIB	WORD POSITIONS FOR RETRIEVAL INFORMATION BLOCK

;THE FIRST "RIBDDB" LOCATIONS OF THE RIB ARE KEPT IN CORE IN THE
; DDB WHILE THE FILE IS ACTIVE, THEY ARE FLAGGED (DDB).
;SOME OF THE SAME INFORMATION ALSO APPEARS IN THE ACCESS TABLE ENTRY
; THEY ARE FLAGGED (ACT).
;THE ORDER OF THESE ARGUMENTS CORRESPONDS EXACTLY TO THE EXTENDED LOOKUP,
; ENTER, RENAME BLOCKS.  WORDS APPEARING IN EXTENDED LOOKUP, ENTER, RENAME
; ARE FLAGGED WITH (ENT). SEE LEVEL D PROJECT SPECIFICATION FOR MORE
; INFORMATION ON LOOKUP/ENTRY/RENAME ARGUMENTS AND VALUES.
;A FEW EXTRA WORDS WHICH HAVE MEANING FOR UFD'S ONLY HAVE BEEN ADDED
; TO ALL FILES.  THEY HAVE NO MEANING FOR DATA FILES.  THESE WORDS ARE
; FLAGGED (UFD-ONLY).
;ALL QUANTITIES ARE IN BLOCKS EXCEPT THE FILE SIZE (RIBSIZ), WHERE
;USER MAY WANT TO KNOW NO. OF DATA WORDS IN LAST BLOCK

ND MLACTS,^D39		;MAXIMUM LENGTH OF THE ACCOUNT STRING
			; IF NOT DEFINED, 39 CHARACTERS
IFG MLACTS-^D39,<XP MLACTS,^D39>  ;MAXIMUM LENGTH IS 39 CHARACTERS
IFL MLACTS,<XP MLACTS,0>
IFG MLACTS,<XP ACTSTL,MLACTS/^D5+1>	;LENGTH OF ACCOUNT STRING IN WORDS
IFE MLACTS,<XP ACTSTL,0>

RIBFIR==:0		;CONTAINS AOBJN POINTER TO FIRST RETRIEVAL POINTER IN THIS RIB
			; I.E., LH=-MAX. POSSIBLE NO. POINTERS, RH=REL ADR OF FIRST PTR
RIBPPN==:1		;(ACT)(DDB) (ENT) PROJECT,PROGRAMMER # IN OCTAL OR PROJECT
			; NAME (3 CHAR SIXBIT LEFT JUSTIFIED IN LH) OR PROGRAMMER
			; INITIALS (3 CHAR SIXBIT LEFT JUSTIFIED IN RH) (AS LOOKUP ENTER
			; RENAME ARG APPEARS AT RIBSIZ POSITION) OF UFD IN WHICH
			; THIS FILE APPEARS.  NEVER CONVERTED TO DECIMAL BY MAN OR MACHINE.
RIBNAM==:RIBPPN+1	;(ACT)(DDB) (ENT) 6 CHAR FILE NAME IN SIXBIT (OR OCTAL PROJECT
			; PROGRAMMER NO. OR SIXBIT IF THIS FILE IS MDF OR UFD).
RIBEXT==:RIBNAM+1	;(ACT)(DDB) (ENT) LH 3 CHAR FILE EXTENSION IN SIXBIT; BITS 24-35
			; ACCESS DATE. BYTE=RIBACD.
RIBPRV==:4		;(ACT)(DDB) (ENT)FILE ATTRIBUTES 0-8 ACCESS CODE, 9-12 MODE, 13-23
			; CREATION TIME IN MINUTES SINCE MIDNIGHT, 24-35 CREATION DATE
RIBATT==:RIBPRV		;ANOTHER SYMBOL FOR SAME LOCATION
    RISPRV==^D9
    RINPRV==^D8
	$HIGH
RIYPRV::POINT	RISPRV,RIBPRV+1(T3),RINPRV	;BYTE POINTER TO ACCESS PRIVILEGES
	$LOW

;ACCESS PRIVILEGES DEFINED IN INCREASING ORDER OF POWER FOR
; DATA FILES (IE NON-DIRECTORY)
; BITS 0-2 FOR ANY JOB WITH MATCHING PROGRAMMER NO.
; (NO MATTER WHAT THE PROJECT)
; BITS 3-5 FOR ANY JOB WITH MATCHING PROJECT NO.
; (NO MATTER WHAT THE PROG NO.
; BITS 6-8 NEITHER PROJ NOR PROG MATCH
;PRIVILEGE COMES STORED BY MONITOR - COMPLEMENTED FOR USER PROGRAM

XP PRTEXC,1		;EXECUTE ONLY-IE GET, R,RUN ACCESS
XP PRTRED,2		;READ ONLY
XP PRTAPP,3		;APPEND (ALLOCATE, DEALLOCATE, APPEND)
XP PRTUPD,4		;UPDATE
XP PRTWRT,5		;WRITE (SUPERSEDE,TRUNCATE)
XP PRTREN,6		;RENAME (CHANGE ATTRIBUTES, NAME, EXT, DIR)
XP PRTCPR,7		;CHANGE PRIVILEGE

;PROTECTION CODES (SEEN BY USER)

XP PR.NAF,7		;NO ACCESS TO FILE
XP PR.EXC,6		;EXECUTE ONLY
XP PR.RED,5		;READ
XP PR.APP,4		;APPEND (ALLOCATE, DEALLOCATE, APPEND)
XP PR.UPD,3		;UPDATE
XP PR.WRT,2		;WRITE (SUPERSEDE, TRUNCATE)
XP PR.REN,1		;RENAME (CHANGE ATTRIBUTES, NAME, EXT, DIR)
XP PR.CPR,0		;CHANGE PROTECTION

;ACCESS PRIVILEGES FOR DIRECTIORY FILES (RIPDIR SET IN RIBSTS)
; 3 INDEPENDANT ACCESS PRIVILEGES
; BITS 0-2 FOR ANY JOB WITH MATCHING PROG. NO, 3-5 MATCHING PROJ
; 6-8 NEITHER MATCHING

XP RIRXLK,4		;1 ALLOWS LOOKUPS IN DIRECTORY
XP RIRXCR,2		;1 ALLOWS CREATES IN DIRECTORY
			; (IE ADD NAMES WHICH ARE NOT ALREADY THERE)
XP RIRXRD,1		;1 ALLOWS DIRECTORY TO BE READ AS A DATA FILE

RIBSIZ==:5		;(ACT)(DDB) (ENT) LH: WRITTEN LENGTH IN WORDS OR
			; BOTH HALVES POSITIVE LENGTH IN WORDS AS 36 BIT QUANTITY.
			; MAYBE LESS THAN NO. OF WORDS ALLOCATED
RIBVER==:RIBSIZ+1	;(ENT) VERSION NUMBER (LIKE JOBVER)
RIBSPL==:7		;(ENT) POSSIBLE USER FILE NAME WHEN FILE BEING SPOOLED
RIBEST==:10		;(ENT) ESTIMATED LENGTH IN CORE & NR. OF BLOCKS
RIBALC==:11		;(ENT) # OF BLOCKS ALLOCATED TO FILE INCLUDING BOTH RIBS.
RIBPOS==:RIBALC+1	;(ENT) LOGICAL BLOCK OF # WITHIN STR OF LAST ALLOCATED GROUP OF FILE
			; OR 0 IF LAST ALLOCATE DID NOT SPECIFY LOGICAL
			; BLOCK (POSITION)
RIBFT1==:13		;ARG SAVED FOR FUTURE FOR DIGITAL TO DEFINE
RIBUNI==:RIBFT1		;(PRIV'D) UNITS WHICH WROTE FILE
			    ;BITS 10-17 = UNIT
			    ;BITS 18-20 = KONTROLLER
			    ;BITS 21-35 = APR SERIAL NUMBER
RIBNCA==:14		;UNPRIVILEGED ARG FOR EACH CUSTOMER TO DEFINE
RIBLNA==:RIBNCA		;LAST UNPRIVILEGED ARG
RIBMTA==:15		;(ENT) 36 BIT TAPE LABEL IF FILE HAS BEEN PUT ON MAGTAPE
RIBDEV==:16		;VALUE ONLY-FILE STRUCTURE NAME FILE STARTS ON

RIBSTS==:17		;STATUS BITS FOR ALL FILES IN UFD(LH),
			; THIS FILE IN RH

    RIPLOG==:400000	    ;(LH) IF 1 SAYS USER IS LOGGED IN. SET BY LOGIN CUSP
			    ; RENAME UUO.  SET TO 0 BY LOGOUT CUSP RENAME UUO.
			    ; BIT CHECKED BY LOGIN IN ORDER TO DETERMINE IF
			    ; RIBTOT IS TO BE BELIEVED (IF RIBLOG==1) SYSTEM
			    ; MUST HAVE CRASHED OR BEEN RELOADED WITHOUT LOGGING
			    ; OUT ALL USERS.
    RIPCHG==:10000	    ;(LH) FILSER SETS TO 1 IF ANY FILE WRITTEN/RENAMED.
			    ;CLEARED BY BACKUP.
    RIPDIR==:400000	    ;(RH) 1 IF THIS FILE IS A DIRECTORY FILE (UFD OR MFD)
			    ; RATHER THAN A DATA FILE. NEEDED TO PROTECT
			    ; THE SYSTEM FROM THE USER WHO MIGHT TRY
			    ; TO MODIFY A DIRECTORY AS A DATA FILE
    RIPNDL==:200000	    ;(RH)[NO DELETE] 1 IF THIS FILE CANNOT BE
			    ; DELETED EVEN BY A PRIVILEGED PROGRAM.  THESE FILES ARE IN
			    ; SOME SENSE FAKE OR CRUCIAL TO FILE STRUCTURE.
			    ; EG. HOME.SYS, SAT.SYS, MAINT.SYS, SWAP.SYS,BADBLK.SYS
    RIPDMP==:100000	    ;(RH) THIS FILE CONTAINS A MONITOR DUMP NOT YET
			    ; PROCESSED BY THE CRASH COPY PROGRAM
    RIPNFS==:40000	    ;(RH)[NO FAILSAFE] 1 IF THIS FILE SHOULD NOT
			    ; BE DUMPED BY FAILSAFE BECAUSE IT IS A FUNNY FILE AND
			    ; SHOULD NOT BE RESTORED OR IS PART OF THE SKELETON
			    ; FILE STRUCTURE.  (BADBLK.SYS,SAT.SYS,HOME.SYS,SWAP.SYS
			    ; MAINT.SYS,RECOV.SYS).  (SNAP.SYS, CRASH.SAV, UFD'S
			    ; AND MFDS DO NOT HAVE RIPNFS ON, SO THEY ARE ALL SAVED).
    RIPABC==:20000	    ;(RH) ALWAYS BAD CHECKSUM(SWAP.SYS,SAT.SYS)
    RIPCBS==:10000	    ;(RH) COMPRESS BIT SET (RIPCMP) ON ENTRY TO COMPRESSOR
			    ;USED TO SELECTIVELY NOT CLEAR RIPCMP ON EXIT
    RIPABU==:4000	    ;(LH/RH) ALWAYS BACKUP THIS
			    ; UFD/FILE.  USED BY BACKUP TO IGNORE ACCESS
			    ; DATE AND WRITE FILE ANYWAY.
    RIPNQC==:2000	    ;NON QUOTA-CHECKED FILE
    RIPCMP==:1000	    ;(RH) THIS UFD IS BEING COMPRESSED
			    ; FOR ERROR RECOVERY IF CRASH WITH A JOB
			    ; IN THE COMPRESSOR SINCE DUPLICATE ENTRIES MAY APPEAR
    RIPSCE==:400	    ;(LH/RH) 1 IF ANY FILE IN UFD/THIS FILE HAS HAD A SOFTWARE
			    ; CHECKSUM ERROR DETECTED BY MONITOR.(IOIMPM)
    RIPHWE==:200	    ;(LH/RH) 1 IF ANY FILE IN UFD/THIS FILE HAS HARD (3 TIMES)
			    ; WRITE DATA ERROR DETECTED BY MONITOR.(IODTER)
    RIPHRE==:100	    ;(LH/RH) 1 IF ANY FILE IN UFD/THIS FILE HAS HARD (3 TIMES)
			    ; READ DATA ERROR DETECTED BY MONITOR.(IODTER)
    RIPRMS==:40		    ;THIS IS AN RMS FILE
    RIPPAL==:20		    ;(RH) THIS IS A PRE-ALLOCATED FILE
			    ; SUPERSEDE WILL USE THIS ALLOCATION
			    ; WHICH ALREADY EXISTS FOR THIS FILE
    RIPBFA==:10		    ;(LH/RH) 1 IF ANY FILE IN UFD/THIS FILE IN UFD FOUND BAD BY
			    ; FAILSAFE WHEN READING MAGNETIC TAPE TO RESTORE TO DISK.
    RIPCRH==:4		    ;(LH/RH) 1 IF ANY FILE IN UFD/THIS FILE WAS CLOSED AFTER A CRASH
			    ;  (PRINTED BY LOGIN)
    RIPBDA==:1		    ;(LH/RH) 1 IF ANY FILE IN UFD/THIS FILE IN UFD FOUND BAD BY
			    ; DAMAGE ASSESSMENT CUSP


    RIPNCK==:RIPDIR!RIPABC  ;DIRECTORIES HAVE BAD CHECKSUMS
    RIPNDP==:RIPNDL!RIPPAL

;IOSHRE,HWE,SCE ARE S BITS WHICH CORRESPOND TO RIB STATUS BITS
;THEY ARE IN THE SAME POSITIONS AS THE ERROR BITS

XP IOSHRE,RIPHRE
XP IOSHWE,RIPHWE
XP IOSSCE,RIPSCE
XP IOSERR,<IOSHRE+IOSHWE+IOSSCE>
XP IOSMER,<-IOSERR-1>
RIBELB==:20		;LOGICAL BLOCK WITHIN ERROR (SEE RIBEUN)
			; IN WHICH BAD REGION BEGINS. 0 MEANS FILE HAS HAD NO BAD REGIONS
			; BAD REGIONS ARE MARKED ON HARD DATA AND DEVICE ERRORS ONLY(IODTER)
			; DETECTED BY HARDWARE PARITY OR SEARCH HARDWARE.
			; AND SOFTWARE DETECTED ERRORS.
			; DO NOT INVOKE THE BAD REGION MECHANISM(SEE CLOSE).
			;LH=CONI BITS 12-29 ON ERROR (SEE BAFELB)
RIBEUN==:21		;LH=LOGICAL UNIT # WITHIN STR ON WHICH ERROR REGION OCCURED (0..)
RIBNBB==:RIBEUN		;RH=# OF CONSECUTIVE LOGICAL BLOCKS IN BAD REGION
			; (MAY WANDER OUTSIDE OF THIS FILE ALLOCATION)
RIBQTF==:22		;(UFD ONLY) FIRST COME FIRST SERVE LOGGED IN QUOTA IN TOTAL
			; NUMBER OF DATA + RIB BLOCKS (I.E. ALL OVERHEAD BLOCKS TOO
			; EXCEPT NOT UFD + ITS RIB - THAT IS CHARGED TO 1,1) ALLOWED THIS
			; USER IN THIS DIRECTORY IN THIS FILE STRUCTURE WHILE
			; LOGGED-IN.  SET BY LOGIN FROM AUXACC.SYS FILE.  THIS QUANTITY
			; + RIBQTR KEPT IN CORE IN UFB DATA BLOCK

RIBQTO==:23		;(UFD-ONLY) LOGGED-OUT QUOTA IN TOTAL NUMBER OF DATA + RIB
			; BLOCKS ALLOWED THIS USER IN THIS DIRECTORY IN THIS STR
			; WHILE LOGGED-OUT.(I.E. ALL OVERHEAD BLOCKS TOO EXCEPT UFD
			; + ITS RIB -  THAT'S CHARGED TO 1,1).  SET BY LOGIN FROM ACCT.SYS
			; FILE (SO LOGOUT WILL NOT HAVE TO SEARCH ACCT.SYS).
			; LOGOUT WILL FORCE USER TO DELETE ENOUGH FILES SO AS TO BE
			; BELOW THIS LIMIT.  THIS QUANTITY IS NOT KEPT IN CORE

RIBQTR==:24		;(UFD-ONLY) RESERVED LOGGED IN QUOTA IN TOTAL NUMBER
			; OF DATA + RIB BLOCKS (I.E. ALL OVERHEAD BLOCKS TOO EXCEPT
			; UFD+ITS RIB - THAT'S CHARGED TO 1,1).
			; RESERVED BY ADMINISTRATOR FOR THIS USER
			; IN THIS DIRECTORY IN THIS FILE STRUCTURE WHILE LOGGED IN.
			; THIS QUANTITY PLUS RIBQTF KEPT IN CORE IN UFB DATA BLOCK

RIBUSD==:25		;(UFD-ONLY) COUNT OF BLOCKS USED (INCLUDING ALL OVERHEAD BLOCKS)
			; WHEN JOB WAS LOGGED OUT
			; (PROVIDED LOGBIT=0). WRITTEN BY LOGOUT, READ BY LOGIN.
RIBAUT==:26		;PROJ-PROG # OF AUTHOR OF FILE, IE USER DOING
			; CREATE OR SUPERSEDE. (USUALLY THE SAME AS OWNER, IE
			; UFD IN WHICH FILE EXISTS, EXCEPT WHEN A FILE
			; IS CREATED OR SUPERSEDED IN SOMEONE ELSES UFD)
RIBNXT==:27		;(ENT) SIXBIT NAME OF NEXT FILE STRUCTURE IF THIS FILE IS
			; CONTINUED ON ANOTHER FILE STRUCTURE. 0 IF IT IS ONLY
			; ON ONE STR OR THIS IS LAST SUB-FILE STR
RIBPRD==:30		;(ENT) SIXBIT NAME OF PREDECESSOR FILE STR IF THIS
			; SUBFILE IS NOT THE FIRST. 0 IF IT IS FIRST OR ONLY SUBFILE.
RIBPCA==:31		;(ENT) PRIVILEGED ARG FOR EACH CUSTOMER TO DEFINE

RIBUFD==:32		;(ENT) LOGICAL BLOCK NUMBER WITHIN STR OF UFD DATA BLOCK(RATHER THAN
			; CLUSTER NUMBER) IN WHICH THIS FILE APPEARS.  IF 2 OR MORE BLOCKS
			; IN UFD THIS ENTRY CONTAINS THE PROPER BLOCK POINTER.  USED
			; AT CLOSE AND RENAME TIME IF IN CORE AND USED FOR FAST FILE
			; RECOVERY.
RIBFLR==:33		;(ENT) RELATIVE BLOCK NUMBER IN FILE OF FIRST BLOCK IN RIB.
			; IMPLEMENTED FOR EXTENDED RIBS
RIBXRA==:34		;(ENT) (DDB) EXTENDED RIB ADDRESS.  POINTS TO NEXT RIB IN CHAIN.
			; IF 0 THIS IS THE LAST RIB.  FORMAT IDENTICAL TO DEVRIB IN DDB
RIBTIM==:35		;(ENT) CREATION DATE & TIME IN NEW DATE FORMAT
RIBLAD==:36		;LAST ACCOUNTING DATE (UFD)
RIBDED==:37		;DIRECTORY EXPIRATION DATE (UFD)
RIBACT==:40		;AOBJN POINTER TO ACCOUNT STRING

RIBENT==:RIBACT		;LAST ARG OR VALUE ON EXTENDED LOOKUP/ENTER/RENAME

;FIRST RETRIEVAL POINTER STORED HERE
; NO SYMBOL ASSIGNED.  INSTEAD FILSER MUST LOOK IN RIBFIR
; FOR THIS ADDRESS.  THIS IS SO RETRIEVAL DATA CAN BE ADDED
; TO WITHOUT INVALIDATING PREVIOUSLY WRITTEN DISK PACKS.

;FORMAT FOR A RETRIEVAL POINTER IN RIB CONTAINS THREE FIELDS
; DEFINED FOR EACH FILE STRUCTURE AND STORED IN HOME BLOCK.
		;	A - BLOCK COUNT
		;	B - CHECKSUM
		;	C - CLUSTER NUMBER

    RIPNUB==:400000	    ;BIT SET IN NEW UNIT PTR. TO INSURE NON-ZERO

RIBWN1==:RIBENT+PTRLEN  ;RELATIVE LOCATION OF LAST POINTER TO BE
			; COPIED FROM DEVICE DATA BLOCK WINDOW
			; THE FIRST TIME THE RIB IS SET UP.
			; THIS SYMBOL USED IS A BLT ADR.
RIBACS==:RIBCOD-ACTSTL	;BLOCK ACTSTL LONG AT END OF RIB CONTAINS
			;ACCOUNT STRING.  AOBJN POINTER IS RIBACT
RIBCOD==:BLKCOD		;CONTAINS UNLIKELY DATA WORD (I.E., NOT ASCII OR FLOATING POINT)
			;LH=0
    CODRIB==:777777	    ;THE UNLIKELY CODE

MRIBLN==:RIBENT-RIBCOD+1+ACTSTL	;-MAX. NO. OF RETRIEVAL POINTER (AND UNITS AND ETC.)
			; RIBLEN PUT IN LH OF RIBFIR ON ENTER

RIBLEN==:-MRIBLN
RIBSLF==:BLKSLF		;THIS BLOCK (NOT CLUSTER) NUMBER (SELF)
SUBTTL	SAT BLOCKS

;WORD POSITIONS FOR DATA BLOCK IN SAT FILE
;PREFIX "SAF"(SAT IN CORE)
;ALL 128 WORDS ARE USED FOR BITS
;PREFIX IS "SAB" (FOR STORAGE ALLOCATION DATA BLOCK)
;THE PREFIX SAT REFERS TO THE TABLE OF DATA BITS PORTION OF THE SAB
;IT IS VERY IMPORTANT TO DISTINGUISH WHETHER AN INDEX IS RELATIVE TO SAB OR SAT
; THE DIFFERENCE BETWEEN TWO QUANTITIES IS ALWAYS SABBIT
;SAT TABLE HAS MAX. OF 128 WORDS OF BITS
;ONE BIT FOR EACH CLUSTER OF BLOCKS ON UNIT


SABRNG==:0		;LH=NEXT CORE ADDRESS IN SAB TABLE RING ON THIS UNIT
SABTAL==:1		; RH=NO. OF FREE CLUSTERS IN THIS SAT BLOCK

SABSCN==:2		;LH=-NO. OF WORDS IN SAT BUFFER (NEVER CHANGED)
			; RH=FIRST CORE ADDRESS TO START LOOKING
			; FOR FREE SPACE ON NEXT CALL (EACH FIND IS STORED HERE
			; SO EACH SCAN BEGINS WHERE LAST SUCCESSFUL ONE LEFT OFF)

SABFIR==:3		;BITS 0-1 STATUS BITS
    SAPDIF==:400000	    ;BIT 0=1 IF SAT TABLE IN CORE IS DIFFERENT FROM DISK
    SAPBAD==:200000	    ;BIT 1=1 IF THIS SAT BLOCK IS ON A BAD BLOCK ON DISK
		 	    ;BITS 2-12 INDEX OF SAT DISK ADDR. IN SPT TABLE
		 	    ; SO ALL CLUSTERS ARE ASSUMED TO BE IN USE
			    ;BITS 13-35=CLUSTER ADDRESS WITHIN UNIT OF FIRST CLUSTER
			    ;REPRESENTED IN SAT TABLE - SAME SYMBOL CLASIZ, CLAPOS AS
			    ;IN SPT TABLE
			    ;BITS 2-35 SET -1 WHEN NEW F/S CREATED (STRUUO(.FSDEF))
			    ;TO FORCE SAT'S TO BE READ INTO SAB
    SAPDOB==:SAPDIF!SAPBAD  ;THE OR OF BOTH

SABNDX==:SABFIR		;INDEX INTO SPT TABLE WHICH DESCRIBES SAB BLK-WORD ADR.
    SASNDX==^D11	    ;BYTE SIZE
    SANNDX==^D12	    ;BYTE PTR POS.

	$HIGH
SAYNDX::POINT	SASNDX,SABNDX(R),SANNDX
SAZNDX::POINT	SASNDX,SABNDX(P2),SANNDX	;BYTE PTR

SABCLA==:SABFIR
SAYCLA::POINT	CLASIZ,SABCLA(P2),CLAPOS

SABHOL==:4		;NUMBER OF BLOCKS IN LARGEST HOLE (-1 IF DON'T KNOW)
	$LOW
REPEAT 0,<;POSTPONE TO LEVEL E
;THE FOLLOWING WORDS ALSO APPEAR IN SAT BLOCK ON DISK:

SABSAT==:4		;FIRST SAT BLOCK HEADER WORD
			; LH=SIXBIT "SAT",
			;BITS 18-25 = UNUSED
			;BITS 26-35 ARE WRITTEN BY THE REFRESHER AND ARE
			; INCLUDED IN SAT BLOCK TO MAKE IT EASIER FOR PROGRAMS
			; TO READ THE SAT BLOCKS(DSKLST,ONCE-ONLY CODE,ETC)
			; IN FILE SAT.SYS
    SASHED==^D3		    ;NO. OF WORDS IN SAT HEADER - BYTE SIZE
			    ; SAVHED IS STORED HERE
			    ; CANNOT BE CHANGED WITHOUT REFRESHING(COPYING DATA WITH
			    ; MAGTAPE IF WANT TO CONVERT)
    SANHED==^D35	    ;BYTE PTR POS.
SAVHED==:SABHED		;VALUE STORED
    SASWPS==^D7		    ;NO. OF WORDS OF BIT DATA( IE NOT INCLUDING HEADER) - BYTE SIZE
    SANWPS==^D32	    ;BYTE PTR POS.
SABALT==:5		;ALTER NUMBER FOR NO. OF RESERVED BLOCKS IN USE
			; CONTENTS OF STRALT ARE COPIED HERE WHEN SAT BLOCK IS WRITTEN
			; AT OTHER TIMES SABALT IS NOT CURRENT
			; THE PURPOSE OF THE ALTER NUMBER IS TO PROVIDE AN EASY
			; WAY FOR ONCE ONLY TO FIND THE LAST SAT
			; BLOCK WRITTEN ON A FILE STRUCTURE SO THAT IT CAN FIND THE
			; LATEST COPY OF THE NUMBER OF RESERVED BLOCKS(SABRSV) IN USE ON STR
SABRSV==:6		;NO. OF RESERVED BLOCKS ALLOCATED( IN USE) TO USERS FOR THIS STR
			; CONTENTS OF (STRGAR-STRRES) ARE STORED HERE
			; WHEN THIS SAT BLOCK IS WRITTEN.
			; AT OTHER TIMES SABRSV IS NOT CURRENT
SABHED==:4		;NO. OF WORDS IN SAT BLOCK HEADER - STORED IN SABSAT

>
SABBIT==:5		;CONTAINS THE FIRST WORD OF SAT BITS
;"SAF" - FORMAT OF STORAGE ALLOCATION TABLE ON DISK
; SEE "SAB" FOR A DESCRIPTION OF SAT BLOCK HEADER.
; THE REST OF THE WORDS AFTER THE HEADER CONTAIN THE BITS
; EACH BIT REPRESENTS
; ONE CLUSTER OF DISK BLOCKS ON THE PHYSICAL UNIT WHERE THIS BLOCK IS WRITTEN.
; IF 1 CLUSTER IS PART OF A FILE OR CONTAINS SOME BAD BLOCKS (OR BOTH-FIRST TIME
; FILE IS WRITTEN)
;PROGRAMS WHICH READ THE SAT BLOCKS(DSKLST,ONCE-ONLY, ETC)
; MUST NOT LOOK AT WORDS BEYOND THE LAST ONE WHICH CONTAINS
; ALLOCATION DATA SINCE THE HARDWARE IS NOT CONSISTENT WITH RESPECT TO
; WRITING THE REMAINDER OF PARTIAL BLOCKS
; ALSO BECAUSE THE SAT BLOCKS ARE WRITTEN AS A FILE
; IF THE UNIT AND CLUSTER SIZE REQURE MORE THAN 1 128 WORD BLOCK
; EACH SAT BLOCK WILL APPEAR AS THE FIRST BLOCK OF EACH GROUP (=1 CLUSTER)
; THE REMAINING BLOCKS IN EACH SAT.SYS GROUP SHOULD BE IGNORED
; THEY WILL NOT START WITH SIXBIT "SAT" IN LH OF FIRST WORD
;THE SAT BLOCKS ARE SCATTERED ACCROSS EACH UNIT SO THAT
; THEY WILL BE NEAR THE DATA BLOCKS THEY DESCRIBE
;SPT - STORAGE ALLOCATION POINTER TABLE FOR SATS IN CORE AND DISK FOR A UNIT
;THERE IS ONE POINTER WORD IN CORE FOR EACH REAL SAT BLOCK ON UNIT,
; EVEN THOUGH NOT ALL SAT BLOCKS ARE KEPT IN CORE.
;	BITS 0-12=TALLY OF FREE CLUSTERS IN THIS SAT BLOCK
;	BITS 13-35=CLUSTER ADDRESS ON DISK WHERE SAT BLOCK IS WRITTEN
; LAST WORD IN SPT TABLE IS A ZERO.

SPTFIR==:0		;REL. LOC. IN SPT TABLE OF FIRST POINTER TO A
			; SAT BLOCK ON DISK
    TALSIZ==:^D13	    ;SIZE OF BYTE CONTAINING FREE CLUSTER TALLY
			    ; FOR THIS SAT BLOCK
    TALPOS==:^D12	    ;RIGHT MOST BIT OF SAT FREE CLUSTER TALLY
    CLASIZ==:^D23	    ;SIZE OF BYTE CONTAINING CLUSTER ADDRESS ON THIS
			    ; UNIT WHERE SAT BLOCK IS WRITTEN
    CLAPOS==:^D35	    ;RIGHT MOST BIT OF SAT CLUSTER ADDRESS


	$HIGH
SPYTAL::POINT	TALSIZ,SPTFIR(T4),TALPOS	;# OF FREE CLUSTERS FOR THIS SAT BLOCK
SPYCLA::POINT	CLASIZ,SPTFIR(T4),CLAPOS	;CLUSTER ADDR. OF SAT
	$LOW
SUBTTL	STR:	FILE STRUCTURE DATA BLOCK

STRDB::			;ADR OF STR PROTYPE DATA BLOCK

	PHASE	0

STRNAM::!0		;(0)SIXBIT NAME OF FILE STR. (LEFT JUSTIFIED) FIRST 3 CHAR
			; ARE PRIMARY NAME, NEXT 3 CHAR UNUSED UNLESS TWO FILE
			; STR. WITH SAME PRIMARY NAME.
IFN STRNAM-DEVNAM,<PRINTX - STRNAM MUST=DEVNAM>
STRSYS::!XWD 0,0	;(1)LH=CORE ADDRESS OF NEXT FILE STRUCTURE DATA BLOCK IN SYSTEM
STRFSN==:STRSYS	;RH=SYSTEM FILE STRUCTURE NO. OF THIS STR (0....15(OCTAL))
STRUNI::!XWD 0,0	;(2)LH=ADDRESS OF FIRST UNIT DATA BLOCK IN THIS STR
			; END OF LIST IS 0.  LH IN UNI IS UNISTR.  RH = STRK4C.
STRK4C==:STRUNI		;LH=STRUNI;RH=J FOR CRASH.SAV ON THIS STR
STRUNM::!XWD 0,0	;(3)RH=NO. OF UNITS IN THIS FILE STRUCTURE
STRREF==:STRUNM		;LH=NON-ZERO IF THIS STR NEEDS REFRESHING BEFORE IT CAN BE USED
STRHGH::!0		;(4)HIGHEST LOGICAL BLOCK NO. IN THIS STR (0...STRHGH) (SAME AS
			; TOTAL NO OF BLOCKS COUNTING OVERHEAD AND SWAPPING)
			; (EXCEPT IF SMALL UNITS MIXED WITH BIG - SEE STRSIZ)
STRSIZ::!0		;(5)SIZE OF STR IN NO. OF 128 WORD BLOCKS INCLUDING
			; SWAPPING SPACE, BAD BLOCKS, SKELETON FILE STRUCTURE
			; BUT NOT COUNTING NON-EXISTANT LOGICAL ADDRESS SPACE CAUSED
			; BY SMALL PACKS MIXED WITH LARGER UNITS.
STRGAR::!0		;(6)UPPER BOUND ON BLOCKS GUARRANTEED TO USERS BY RESERVED QUOTAS
			; SET BY ONCE FROM HOMGAR
STRRES::!0		;(7)NO. OF RESERVED FREE BLOCKS LEFT IN THIS STR
			; THE ADMINISTRATOR SHOULD NOT OVERSUBSCRIBE RESERVED QUOTAS
			;SET BY ONCE ONLY CODE WHEN IT READS ALL SAT BLOCKS.
			; THE SAT BLOCK WITH THE LARGEST ALTER NUMBER IS USED
			; [STRGAR-RA@RSV WITH MAX. ALTER NUMBER]
STRALT::!0		;(10)ALTER NUMBER FOR THIS STR
			; INCREMENTED BY ONE EACH TIME ANY SAT BLOCK IS WRITTEN
			; FOR THIS STR.  ITS NEW CONTENTS ARE ALSO WRITTEN IN SAT BLOCK
			; HEADER ON DISK - SEE SABALT AND SABPSV
STRTAL::!0		;(11)NO. OF FIRST-COME-FIRST-SERVED FREE BLOCKS LEFT IN THIS STR
			; MINUS A SAFETY FACTOR (STVSFC - MONGEN SYMBOL)
			; THIS SAFETY FACTOR GUARANTEES THAT CLOSES CAN BE DONE
STROVR::!0		;(12)-NO. OF BLOCKS A USER IS ALLOWED TO WRITE OR ALLOCATE
			; BEYOND HIS RESERVED+FCFS QUOTA
STRMNT::!0		;(13)NO. OF DIFFERENT JOBS WHICH HAVE ISSUED MOUNT COMMAND
			; FOR THIS FILE STR.  LOGIN ISSUES AUTOMATIC MOUNT UUOS
			; FOR PUBLIC POOL STR WHICH HAS A USER UFD.
STRSAT==:STRMNT		;THIS LOC TIME-SHARED BY ONCE-ONLY CODE TO REMEMBER LOG BLOCK #
			; OF 1ST RIB WITHIN STR FOR SAT.SYS
STRPT1::!0		;(14)FIRST RETRIEVAL POINTER TO MFD IN THIS FILE STRUCTURE
			; SET WHEN HOME BLOCK READ BY MONITOR
STRUN1::!XWD DSKTRY*STPTRY+SERTRY*STPSER+RCLTRY*STPRCL,0
			;(15)BITS COPUN1-COSUN1=FIRST LOGICAL UNIT
			; NUMBER WITHIN THIS FILE STRUCTURE WHERE MFD STARTS
			; (STRPT1 IS THE FIRST RETRIEVAL POINTER)
STRTRY==:STRUN1		;NO. OF ERROR TRIES(DATA,SEARCH,RECALIBRATE) FOR THIS STR - WORD
			; ADR. MONGEN CAN CHANGE BY REDEFINING DSKTRY,SERTRY,RCLTRY
    STSTRY==^D6		    ;BYTE SIZE
    STNTRY==^D5		    ;BYTE PTR POS.
    STPTRY==:10000	    ;RIGHT MOST BIT
    STSSER==^D6		    ;BYTE SIZE
    STNSER==^D11	    ;BYTE PTR POS.
    STPSER==:100	    ;RIGHT MOST BIT
    STSRCL==^D6		    ;BYTE SIZE
    STNRCL==^D17	    ;BYTE PTR POS.
    STPRCL==:1		    ;RIGHT MOST BIT
STR1PT==:STRUN1		;STP1PT BIT - WORD ADDRESS
    STP1PT==:COP1PT	    ;BIT STP1PT=1 IF STRPT1 IS THE ONLY POINTER TO MFD).
STRPVS==:STRUN1		;BIT STPPVS = 1 IF THIS IS A PRIVATE FILE STR
    STPPVS==:1B35	    ;ON IF A PRIVATE FILE STRUCTURE
    STSPVS==1		    ;BYTE SIZE
    STNPVS==^D35	    ;BYTE PTR POS.

STRHWP==:STRUN1		;BIT STPHWP = 1 IF MUST BE MOUNTED WRITE PROTECTED
    STPHWP==:1B34	    ;ON IF HARDWARE WRITE PROTECT REQUIRED
    STSHWP==1		    ;BYTE SIZE
    STNHWP==^D34	    ;BYTE PTR POS.

STRSET==:STRUN1		;BYTE STYSET CONTAINS SET NUMBER TO WHICH STR BELONGS
    STSSET==6		    ;BYTE SIZE
    STNSET==^D23	    ;BYTE PTR POS.
STRBPU::!0		;(16)NOMINAL NO. OF BLOCKS PER UNIT IN THIS STR
			; IF UNITS ARE NOT SAME SIZE(RPO1,PRO2) THE LARGEST
			; UNIT IS STORED HERE.  THIS QUANTITY IS USED TO CONVERT
			; FROM LOGICAL BLOCKNO. WITHIN STR TO UNIT NO. + LOGICAL
			; BLOCK NO. WITHIN UNIT BY USING A SIMPLE DIVIDE.
STRBSC::!XWD 0,0	;(17)LH=NO. OF BLOCKS PER SUPER CLUSTER IN THIS STR
			; FILES BEGIN AT BEGINNING OF A SUPER CLUSTER, RATHER
			; THAN A CLUSTER SO THAT THE SUPER CLUSTER ADDRESS
			; + UNIT NO. WITHIN STR* NO SUPER CLUSTERS PER UNIT
			; WILL FIT INTO 18 BITS IN UFD
			;COMPUTED BY UNYBPC*(((STRHGH-0)/2*18))+1
STRSCU==:STRBSC		;RH=NO. OF SUPER CLUSTERS PER UNIT
			; COMPUTED BY ((UNIBPU-1)/STRBSC)+1
STRJOB::!0		;(20)=XWD 0,0 IF ZER OR MORE THAN ONE JOB HAS F.S.
			;  MOUNTED (IN ITS SEARCH LIST).
			; =XWD 0,N IF JOB N HAS IT SINGLE ACCESS
			; =XWD -1,N IF JOB N IS ONLY JOB WITH IT MOUNTED BUT
			;  NOT SINGLE ACCESS
STRSRC==:STRJOB		;TIME SHARED LOC. USED BY ONCE ONLY THEN CLEARED
			; CONTAINS POSITION OF STR (0...N) IN SEARCH LIST
			; FOR DEVICE SYS - SEE SYSSRC. -1 IF NOT IN LIST
STYCNP::!POINT 0,T2,0	;(21)BYTE POINTER TO EXTRACT CLUSTER COUNT FIELD FROM A
			;  RETRIEVAL POINTER WHICH IS IN AC T2 (LEFT FIELD)
			;  FOR THIS STR. BITS 6-11=ONCE ONLY QUESTION. CANNOT
			;  EXCEED MIN(LIMCNP,36.-BITS 6-11 STYCLP.
			;  BITS 0-5_36.-BITS 6-11 STYCNP
STYCKP::!POINT 0,T2,0	;(22)BYTE POINTER TO EXTRACT CHECKSUM FIELD FROM A
			;  RETRIEVAL POINTER WHICH IS IN AC T3 (MIDDLE FIELD)
			;  FOR THIS STR.
			;  BITS 6-11_36.-BITS 6-11 STRCNP-BITS 6-11 STYCLP
			;  BITS 0-5_BITS 0-5 STRCNP+BITS 6-11 STYCKP
STYCLP::!POINT 0,T2,35	;(23)BYTE POINTER TO EXTRACT CLUSTER ADDRESS FIELD FROM A
			;  RETRIEVAL POINTER WHICH IS IN AC T2 (RIGHT FIELD)
			;  FOR THIS STR. BITS 6-11=36.-JFFO((UNIBPU-1)/UNYBPC)
			;  CANNOT EXCEED LIMCLP.
STRPPN::!0		;(24) PPN OF THE OWNER OF THIS FILE
			;  STRUCTURE SET BY THE MOUNT SYSTEM
			;  PROGRAM FROM THE SYSTEM ACCOUNTING FILE
STRSDL::!-1		; (25) POSITION OF STR (0...N) IN SYSTEM DUMP LIST
			; -1 IF NOT IN LIST
STRCRS::!0		;(26) LOGICAL BLOCK NUMBER IN STR OF RIB FOR
			;  CRASH.EXE
STRLEN==:.-STRNAM

	DEPHASE

;BYTE POINTER NOT REPLICATED IN EACH STR DATA BLOCK:

	$HIGH
STYTRY::POINT	STSTRY,STRTRY(T2),STNTRY	;BYTE POINTER TO NO. OF ERROR RETRYS
			; BEFORE CONSIDERING IT A HARD ERROR
STYRCL::POINT	STSRCL,STRTRY(T2),STNRCL	;BYTE PTR TO NO. OF RECALIBRATE+1
			; RETRIES FOR BOTH SEARCH AND DATA ERRORS = NO. TRIES
STYSER::POINT	STSSER,STRTRY(T2),STNSER	;BYTE PTR TO NO. OF TRIES
			; ON SEARCH ERROR (RETRIES -1) BEFORE RECALIBRATING.
STY1PT::POINT	COS1PT,STR1PT(T2),CON1PT	;BYTE POINTER TO BIT WHICH
			; IF 1 MEANS ONLY ONE RET PTR FOR MFD FOR THIS STR
STYUN1::POINT	COSUN1,STRUN1(T2),CONUN1	;BYTE PONTER TO FIRST
			; LOGICAL UNIT WITHIN STR FOR MFD
STYPVS::POINT	STSPVS,STRPVS(P2),STNPVS	;BYTE POINTER TO BIT WHICH
			; IF 1 MEANS THIS IS A PRIVATE STR
STYPV2::POINT	STSPVS,STRPVS(T2),STNPVS

STYHWP::POINT	STSHWP,STRHWP(P2),STNHWP	;BP TO HARDWARE W/L BIT

STYSET::POINT	STSSET,STRSET(P2),STNSET ;BYTE POINTER TO FIELD WHICH CONTAINS
			; SET NUMBER TO WHICH STR BELONGS
STYSE2::POINT	STSSET,STRSET(T2),STNSET
	$LOW
SUBTTL	SWI - IN-CORE COPY OF SWITCH.INI

SWILEN==:0		;LENGTH OF IN-CORE COPY
SWIPT1==:1		;COPY OF ACCPT1 FOR FILE
SWIUN1==:2		;COPY OF ACCUN1,,SIZE OF FILE (ACCWRT+ACYLBS)
SWIPRV==:3		;COPY OF ACCPRV
SWIDAT==:4		;START OF DATA FOR SWITCH.INI
SUBTTL	"SYS" - SYSTEM WIDE QUANTITIES

;TABLE OF FILE STRUCTURES IN SYSTEM. A ZERO ENTRY MEANS NO FILE
; STR ASSOCIATED WITH THIS NUMBER

STRAOB::-.SLMAX,,.FSMIN	;AOBJN POINTER FOR TABSTR
TABSTR==:.-.FSMIN	;INDEX THIS ADR WITH FSN. (FSN'S START AT .FSMIN)
TABST0::REPEAT .SLMAX+1,<0>
	SUBTTL	LEVEL D GETTAB TABLE

LVDTBL::!			;GETTAB TABLE NO. 16(OCTAL)-LEVEL D DISK PARAMS


MFDPPN::XWD	1,1		;(0) PROJECT-PROGRAMMER NUMBER FOR STORING
				;    UFDS ONLY (ALL OTHER FILE STRUCTURE FILES
				;    ARE STORED IN DEVICE SYS (SEE SYSPPN))
STDPPN:!			;(1) PROJ-PROG NO. FOR DEVICE 'STD'
SYSPPN::XWD	1,4		;(1) PROJ-PROG NO. FOR DEVICE 'SYS' (I.E.,
				;    CUSPS, LIBRARY)
FFAPPN::XWD	1,2		;(2) PROJ-PROG NO. FOR FULL-FILE-ACCESS/OPERATOR
HLPPPN::XWD	2,5		;(3) PROJ-PROG NO. FOR HELP FILES, GENERAL
				;    "NOT-LOGGED-IN" ACCOUNT (FOR SUCH AS
				;    HELP, SYSTAT, ETC.)
SPLPPN::XWD	3,3		;(4) PROJ-PROG NO. FOR MPB/GALAXY SPOOLING
SYSPPB::XWD	0,0		;(5) LH=FIRST PROJECT-PROGRAMMER NUMBER BLOCK
				;    IN SYSTEM
				;RH=CORE ADDRESS OF NEXT PPB BLOCK TO SCAN
				;    NAME LIST TO RECLAIM GRABBABLE NMB BLOCK
				;    IF RH=0 CORE GRABBER SHOULD START OVER AT
				;    BEGINNING OF PPB LIST (I.E., LH OF SYSPPB)
DIFPPL==:SYSPPB-CORLNK
SYSSTR::XWD	0,STRSYS	;(6) LH=CORE ADDRESS(DOWNWARD POINTER) OF FIRST
				;    FILE STRUCTURE DATA BLOCK IN SYSTEM
				;RH=INDEX IN STR DATA BLOCK FOR PTR TO NEXT STR
DIFSTR==:SYSSTR-STRSYS
SYSUNI::XWD	0,UNISYS	;(7) LH=CORE ADDRESS(DOWNWARD POINTER)OF FIRST
				;    UNIT
				;RH=INDEX IN UNIT DATA BLOCK FOR PTR TO NEXT
				;    UNIT IN SYSTEM
SWPUNI::XWD	0,UNISWP	;(10) LH=CORE ADDR (DOWNWARD PTR) OF FIRST UNIT
				;    FOR SWAPPING
				;RH=INDEX IN UNIT DATA BLOCK FOR PTR TO NEXT
				;    UNIT IN SWAPPING LIST
XP SYS4WD,<FIL4WD*JOBN>		;NO. OF 4 WORD WORD CORE BLOCKS FOR SYSTEM
				;    MULTIPLY BY NO. OF 4 WORD BLOCKS PER JOB
IFL SYS4WD-^D50,<XP SYS4WD,^D50> ;INSURE AT LEAST 50 4-WORD BLOCKS FOR SYSTEM
				;    EVEN IF JUST A 1 JOB SYSTEM
CORNUM::EXP	SYS4WD		;(11) # PERMANENT 4 WORD BLOCKS GENERATED AT
				;    ONCE ONLY TIME
STNPRT::XWD	PRVFIL*1000,0	;(12) STANDARD PRIVILEGE
UFDPRT::XWD	PRVUFD*1000,0	;(13) STANDARD UFD PRIVILEGE
				;    SYMBOL PRVUFD SHOULD NOT BE USED. INSTEAD
				;    UFDPRT SHOULD BE USED, SO CAN PATCH
				;    RUNNING MONITOR.
	EXP	2		;(14) CONTAINS THE NUMBER OF MONITOR BUFFERS
				;    SET AT MONGEN TIME, CAN BE CHANGED AT ONCE
				;    ONLY TIME
QUESTR::EXP	M.QSTR		;(15) SIXBIT NAME OF FILE STRUCTURE
				;    FOR QUEUEING PROGRAMS LIKE PRINT, UMOUNT,
				;    ETC SETUP BY ONCE ONLY CODE TO BE THE
				;    FIRST(FASTEST) STR WHICH IS UP(TABSTR(0)).
XPNPPN::XWD	10,1		;(16) UFD FOR DUMPING CRASHES
SFDLVL::EXP	LIMLVL		;(17) MAX NUMBER OF NESTED SFDS
SPLPRT::XWD	PRVSPL*1000,0	;(20) PROTECTION FOR SPOOLED OUTPUT
SYSPRT::XWD	PRVSYS*1000,0	;(21) PROT FOR MOST SYS FILES
SYSPRY::XWD	PRYSYS*1000,0	;(22) PROT FOR SYS .SYS FILES
MUSTMX::EXP	-MAXUSI		;(23) NEGATIVE MAXIMUM USETI ARGUMENT (FOR
				;    READING EXTENDED RIBS)
MAXTRN::EXP	BLKMAX		;(24) MAX NO OF BLOCKS TO TRANSFER IN 1
				;    OPERATION (SO HIGH PRIORITY IO WON'T
				;    GET LOCKED OUT)
NEWPPN::XWD	1,5		;(25) PPN OF EXPERIMENTAL SYS
OLDPPN::XWD	1,3		;(26) PPN OF OLD SYS
UMDPPN::XWD	6,10		;(27) USER MODE DIAGNOSTICS PPN
				;    (CAN DISABLE ERROR LOGGING)
ND M.DFNB,6
NUMBF::	EXP	M.DFNB		;(30) DEFAULT NO. OF DISK BUFFERS
MAXSWP::EXP	SWPMAX		;(31) MAX NUMBER OF UNITS IN ASL
ALGPPN:	XWD	5,4		;(32) ALGOL LIBRARY
BLIPPN:	XWD	5,5		;(33) BLISS LIBRARY
FORPPN:	XWD	5,6		;(34) FORTRAN LIBRARY
MACPPN:	XWD	5,7		;(35) MACRO LIBRARY
UNVPPN:	XWD	5,17		;(36) UNIVERSAL LIBRARY
PUBPPN:	XWD	1,6		;(37) USER MAINTAINED SYS:
TEDPPN:	XWD	5,10		;(40) TEXT EDITOR LIBRARY
RELPPN:	XWD	5,11		;(41) REL FILE LIBRARY
RNOPPN:	XWD	5,12		;(42) RUNOFF LIBRARY
SNOPPN:	XWD	5,13		;(43) SNOBOL LIBRARY
DOCPPN:	XWD	5,14		;(44) DOC FILE LIBRARY
FAIPPN:	XWD	5,15		;(45) FAIL LIBRARY
MUSPPN:	XWD	5,16		;(46) MUSIC LIBRARY
DECPPN:	XWD	10,7		;(47) LIBRARY FOR DEC DISTRIBUTED SOFTWARE.
	XWD	-SWPMAX,SWPTAB	;(50) POINTER TO ACTIVE SWAPPING LIST
BASPPN:	XWD	5,1		;(51) BASIC LIB PPN
COBPPN:	XWD	5,2		;(52) COBOL LIB PPN
MXIPPN:	XWD	5,3		;(53) PDP-11 LIB PPN
NELPPN:	XWD	5,20		;(54) NEL1AC LIBRARY
DMPPPN:	XWD	5,21		;(55) DUMP LIBRARY
POPPPN:	XWD	5,22		;(56) POP2 LIBRARY
TSTPPN:	XWD	5,23		;(57) TEST PPN
ALLOVR::0			;(60) =0 IF DON'T CALL DAEMON ON SOFT OVERRUNS
				;    RECOVERED ON FIRST RETRY, =1 IF CALL DAEMON
				;    ON ALL OVERRUNS
	XWD	KONREG,UNISCR	;(61) POINTERS TO MASSBUS ERROR LOCATIONS FOR
				;    DAEMON
	XWD	UNYBCT,UNICCT	;(62) POINTERS TO BAT BLOCK + CHANNEL ERROR
				;    INFO FOR DAEMON
DBSPPN:	XWD	5,24		;(63) DBMS LIBRARY
	EXP	CHNETW		;(64) OFFSET OF EXPECTED CHANNEL TERM, WORD
				;    IN CDB FOR DAEMON
MICPPN:	XWD	5,25		;(65) LIBRARY OF MIC MACROS
TPSPPN:	XWD	5,26		;(66) TEXT PROCESSING SYSTEM LIBRARY
CTLPPN:	XWD	5,27		;(67) CTL FILE LIBRARY
GAMPPN:	XWD	5,30		;(70) GAMES
ACTPPN:	XWD	1,7		;(71) SYSTEM ACCOUNTING
APLPPN:	XWD	5,31		;(72) APL LIB

ND RIBERN,0
RIBECT::EXP	RIBERN		;(73) RIB-ERROR THRESHOLD
RIBTOT::0			;(74) TOTAL RIB ERRS
SYSDOR::XWD	0,0		;(75) BEGINNING OF DORMANT ACCESS BLOCK LIST
				;LH=ADDRESS OF FIRST DORMANT ACCESS BLOCK
				;LH=0 IF NO DORMANT ACCESS BLOCKS
				;RH=ADDRESS OF LAST DORMANT ACCESS BLOCK
SYSCOR::XWD	.,ZERO18	;(76) BEGINNING OF PERMANENT 4 WORD BLOCK LIST
				;LH=ADDRESS OF FIRST 4 WORD BLOCK, RH=0 ALWAYS
				;    IF NO FREE BLOCKS, WHOLE WORD=0.
				;    BLOCKS ARE LINKED TOGETHER BY CORLNK WORD.
INTFNC::0			;(77) NUMBER OF TIMES FRONT-END HAD DISK
D60PPN:	XWD	5,32		;(100) DAS60 LOG FILE AREA
	0			;(101) OBSOLETE
	0			;(102) OBSOLETE
	0			;(103) OBSOLETE
	0			;(104) OBSOLETE

	UNICDA			;(105) OFFSET OF UNICDA IN UDB'S
	UNIDES			;(106) OFFSET OF UNIDES IN UDB'S
SYSPTR::0			;(107) POINTER TO IN-CORE COPIES OF RETRIEVAL
				;    POINTERS
	XWD	.SLMXS,.SLMXJ	;(110) LH=MAX STRS IN SYSTEM SEARCH LIST
				; RH=MAX STRS IN JOB SEARCH LIST
	UNISLB			;(111) OFFSET OF UNISLB IN UDB'S
UTPPPN:	XWD	5,33		;(112) UETP AREA
INIPPN:	XWD	5,34		;(113) INITIALIZATION FILES AREA
	0			;(114) OBSOLETE
	0			;(115) OBSOLETE
ND M.DFLB,3
NUMLBF::EXP	M.DFLB		;(116) DEFAULT NUMBER OF LARGE DISK BUFFERS
	EXP	DEVUNI		;(117) OFFSET OF DEVUNI,USED BY SYSTAT
%LDCSZ::0			;(120) SIZE IN BLOCKS OF CACHE
%LDRDC::0			;(121) MONITOR CACHE BLOCK READ CALLS
%LDRDH::0			;(122) MONITOR CACHE BLOCK READ HITS
%LDWRC::0			;(123) MONITOR CACHE WRITE CALLS
%LDWRH::0			;(124) MONITOR CACHE WRITE HITS
%LDHSF::0			;(125) CSHFND CALLS
%LDHSC::0			;(126) CSHFND COLLISIONS IN HASH TABLE
%LDHSL::EXP	CBHSHL		;(127) LENGTH OF CACHE HASH TABLE
%LDHST::EXP	CBHSHT		;(130) ADDRESS OF CACHE HASH TABLE
%LDCHD::EXP	CBHEAD##	;(131) ADDRESS OF CACHE LIST HEADER
	EXP	DEVSPN		;(132) OFFSET FOR SPOOLED FILENAME
	EXP	DEVSPM		;(133) OFFSET FOR SPOOLED PARAMETER BLOCK PTR
	EXP	DEVBLK		;(134) OFFSET FOR I/O BLOCK NUMBER
	EXP	DEVRSU		;(135) OFFSET TO RETRIEVAL /ALL BLOCKS
	EXP	DEVSFD		;(136) OFFSET TO NMB FOR FATHER SFD
UPSPPN:	XWD	5,35		;(137) PPN FOR LIBRARY FOR MAILERS
	EXP	SEQTOP##	;(140) ADDRESS OF POINTER TO FIRST SYSTEM
				;    ERROR BLOCK
ROODRB::0			;(141) NUMBER OF TIMES WE RAN OUT OF DRBS
FNTPPN:	XWD	5,36		;(142) PPN FOR LASER PRINTER FONTS
DSKSET::M.SETS			;(143) BIT MASK FOR DISK SETS THIS MONITOR MOUNTS
SYSDET::XWD	0,UNISYS	;(144) LH=CORE ADDRESS (DOWNWARD POINTER) OF
				;     FIRST DETACHED UNIT
				;RH=INDEX IN UNIT DATA BLOCK FOR PTR TO NEXT
				;    UNIT IN SYSTEM
%LDOCS::EXP	M.CBMX		;(145) ORIGINAL SIZE OF DISK CACHE (SEE %LDCSZ)
ND SWEERN,0
SWEECT::EXP	SWEERN		;(146) SWAP READ ERROR THRESHOLD
SWETOT::0			;(147) TOTAL SWAP READ ERRORS
ACTDRB::XWD	ACTDRB,ACTDRB	;(150) DOUBLY LINKED LIST OF ACTIVE DRBS

LVDMXL==:<.-LVDTBL-1>B26	;END OF GETTAB TABLE
;GETTAB TABLE OF CHANNEL DATA BLOCK OFFSETS
.GTCHN::EXP	CHNSYS		;LINK TO NEXT CHANNEL DATA BLOCK IN SYSTEM
	EXP	CHNLUE		;LAST UDB WITH SOFT OR HARD ERROR
	EXP	CHNICW		;INITIAL CONTROL WORD ON LAST ERROR
	EXP	<CHNDW0-CHNICW>	;NUMBER OF WORDS POINTED TO BY CHNICW
	EXP	CHNMPE		;NUMBER OF MEMORY PARITY ERRORS
	EXP	CHNDPE		;NUMBER OF DATA PARITY ERRORS (FROM DEVICE)
	EXP	CHNNXM		;NUMBER OF NXMS OR DATA LATES (OVER RUN)
	EXP	CHNETW		;EXPECTED TERMINATION CONTROL WORD
CHNMXL==:<.-.GTCHN-1>B26	;LENGTH OF TABLE (GETTAB FORMAT)
;SYSTEM VARIABLES NOT IN GETTAB:

	$HIGH

UN1PTR::POINT	COSUN1,T1,CONUN1 ;BYTE POINTER TO LOGICAL NUMBER WITHIN A
				;FILE STRUCTURE (AFTER DATA WORD MOVED TO T1)
	$LOW
NOWDUC::0			;NUMBER OF UNITS WITH UNPNDU
SYSGEN::0			;HIGHEST UNIGEN ISSUED SINCE SYSTEM WAS LOADED
DINITF::0			;DSK INITIALIZATION IN PROGRESS (ONCE ONLY CODE)
				; REST OF MONITOR NOT AVAILABLE IF ERRORS ETC.
				; [SET NON-ZERO AT BEGINNING OF DSK ONCE ONLY CODE
				; AND DSKINI - CLEARED AT END OF DSKINI]
DISSIO::EXP	M.DSIO		;FLAG INDICATING SUPER USETI/USETO ARE ILLEGAL
IFN FTCIDSK,<
BNDFLG::0			;ZERO IF HAVEN'T CALLED ONCBND YET, NON-ZERO IF HAVE
>; END IFN FTCIDSK
.UONCE::0			;0 IF EXEC MODE, NON-0 IF USER MODE ONCE ONLY
TWCMBF::0			;USED BY TWICE
SWPTAB::BLOCK	SWPMAX+1	;TABLE OF CORE ADDRESSES OF UNITS FOR SWAPPING
				;(CAN BE CHANGED AT MONGEN TIME)
SWPTBE==:.-1			;LAST ADR. OF SWPTAB FOR BLT TO CLEAR TABLE
MSWPMX==:-SWPMAX
SPLGEN::BLOCK	1		;CURRENT NUMBER TO CREATE UNIQUE NAME
				;FOR SPOOLING FILES

SWPUN2::0			;ADR OF 1ST SLOW-CLASS SWAP SPACE
NXTSUN::0			;ADR OF NEXT UNIT IN SWAPPER ALLOCATION ROUND-ROBIN
MIGRAT::0			;IF NON-0 IS THE JOB NUMBER OF A JOB WHICH WE ARE
				; TRYING TO SWAP OFF OF A DISK WHICH IS ABOUT TO
				; BE REMOVED FOR DIAGNOSTIC PURPOSES
DIADSK::0			;DDB TRYING TO SHUT DOWN DSK IO FOR USER-MODE DIAGNOSTIC
				; POSITIVE IF WAITING FOR IO TO CEASE
				; NEGATIVE IF IO HAS STOPPED (JUST DONT DO IO)
DIACHN::0			;CHANNEL (DF10) FOR WHICH IO IS BEING STOPPED
DIADWT::0			;FLAG THAT ANOTHER JOB IS WAITING FOR DIAG

HERLIM::DEC	25		;# OF ERRORS BEFORE TELLING OPR
HERCNT::0			;# OF DSK ERRS SO FAR

IFN FTMP,<
CPUDSQ::0			;QUEUE OF REQUESTS FOR OTHER CPUS
>

CBHSHT::BLOCK	CBHSHL		;DISK CACHE HASH TABLE
;ERSATZ DEVICE TABLES

DEFINE	UERSTZ(DEV,P,PN,SLIST),<
	..T==0
	IFE <SIXBIT/SLIST/>-<SIXBIT/SYS/>,<..T==PT.SSL>
	IFE <SIXBIT/SLIST/>-<SIXBIT/ALL/>,<..T==PT.ASL>
	IFE <SIXBIT/SLIST/>-<SIXBIT/JOB/>,<..T==PT.JSL>
	SD	DEV,[<P,,PN>],..T
>; END UERSTZ

DEFINE EDEVS,<
	LIB	SYS,		;MUST BE FIRST
	LIB	NEW,		;MUST BE SECOND
	LIB	OLD,
	LIB	HLP,
	SD	ALL,[0],PT.ASL
	SD	SSL,[0],PT.SSL
	SD	LIB,[-1],
	SPCEDN			;EXPAND MONGEN'ED CUSTOMER ERSATZ DEVICES
	LIB	BAS,
	LIB	COB,
	LIB	MXI,
	LIB	ALG,
	LIB	BLI,
	LIB	FOR,
	LIB	MAC,
	LIB	UNV,
	LIB	PUB,
	LIB	DEC,
	LIB	STD,
	LIB	XPN,
	LIB	FFA,
	LIB	MFD,
	LIB	UMD,
	LIB	TED,
	LIB	REL,
	LIB	RNO,
	LIB	SNO,
	LIB	DOC,
	LIB	FAI,
	LIB	MUS,
	LIB	NEL,
	LIB	DMP,
	LIB	POP,
	LIB	TST,
	LIB	DBS,
	LIB	MIC,
	LIB	TPS,
	LIB	CTL,
	LIB	GAM,
	LIB	ACT,
	LIB	APL,
	LIB	D60,
	LIB	UTP,
	LIB	INI,
	LIB	UPS,
	LIB	SPL,
	LIB	FNT,
>

DEFINE LIB(DEV),<
	SD	DEV,DEV'PPN,PT.SSL
>

DEFINE	SD(DEV,PPN,SL),<
IFNDEF ED.'DEV,<ED.'DEV==-1>
>

;SET DEFAULT ED.??? TO -1.  IF ED.??? IS DEFINED AS 0 THEN
; DEVICE ??? WILL NOT BE INCLUDED
	EDEVS

;HOWEVER, SYS:,NEW:,OLD:,ALL:,LIB: MUST REMAIN
	ED.SYS==-1
	ED.NEW==-1
	ED.OLD==-1
	ED.ALL==-1
	ED.LIB==-1
DEFINE	SD(A,B,C),<
IFN ED.'A,<
	<SIXBIT	/A/>+C
	IFE	<SIXBIT/A/>-<SIXBIT/ALL/>,<XP ZPPNDX,.-SDVTBL-1>
	IFE	<SIXBIT/A/>-<SIXBIT/LIB/>,<XP LIBNDX,.-SDVTBL-1>
>>
	$HIGH
SDVTBL::EDEVS
	SDVLEN==:.-SDVTBL-1
	SDVMXL==:<SDVLEN>B26

XP SYSNDX,2
XP NEWNDX,1
;TABLE OF PPN'S FOR ERSATZ DEVICES
DEFINE	SD(A,B,C),<
IFN ED.'A,<
	EXP	B
>>
SDVPPN::EDEVS
	$LOW
	$HIGH
ALLSL:	SLALL;		;THE ALL: SEARCH LIST
	$LOW
SYSSL:	SLEMPT(.SLMXS);	;THE SYS: SEARCH LIST
			;JOB SEARCHL LISTS ARE IN THE PDB

	$HIGH
ALLSRC::POINT	.FSSIZ,ALLSL;	;PREDECREMENTED POINTER TO ALL: SL.
SYSSRC::POINT	.FSSIZ,SYSSL;	;PREDECREMENTED POINTER TO SYS: SL.

JOBSRC::POINT	.FSSIZ,.PDJSL##(W);	;PREDECREMENTED POINTER TO JOB SL.
EMTSRC::POINT	.FSSIZ,[SLEMPT(1)];	;PREDECREMENTED POINTER TO THE EMPTY SL.
	$LOW

IFN FTKL10,<ONCTIM==:20>	;HUNG TIMER FOR ONCE
IFN FTKS10,<ONCTIM==:10>
	$HIGH
SUBTTL	UFB:	USER FILE DIRECTORY BLOCK

;ONE DATA BLOCK FOR EVERY UFD-FILE STRUCTURE PAIR WHICH HAS AN ACTIVE FILE
;ALL BLOCKS FOR A FILE STRUCTURE ARE LINKED TOGETHER


;WORD 0---------------------------------------
UFBTAL==:0		;TALLY OF RESERVED+FREE BLOCKS LEFT IN THIS UFD IN THIS
			; FILE STRUCTURE (OVER DRAW IS NEGATIVE).  NO
			; NEW ENTERS ALLOWED IF THIS IS 0 OR NEGATIVE
			; INCLUDES OVERHEAD BLOCKS (RIB).

;WORD 1---------------------------------------
UFBPPB==:CORLNK		;LH=CORE ADDRESS (ACCROSS POINTER) OF NEXT UFD
			; DATA BLOCK FOR THIS PROJECT-PROGRAMMER
			; NUMBER. (I.E. IN ANOTHER FILE STRUCTURE)
UFBPRV==:UFBPPB		;ACCESS PRIVILEGES FOR THIS UFD IN FILE STRUCTURE - WORD ADR.
    UFSPRV==^D9		    ;BYTE SIZE
    UFNPRV==^D26	    ;BYTE PTR. POS.
    UFRXLK==:RIRXLK	    ;CAN DO LOOKUPS OF FILES IN THIS DIRECTORY-RIGHT JUST BIT
			    ; FOR OWNER, PROJECT, OR UNIVERSE
    UFRXCR==:RIRXCR	    ;CAN CREATE FILES IN THIS UFD (IE ENTER NAMES WHICH ARE NOT
			    ; YET THERE AND SO CANNOT PROTECT THEMSELVES)
    UFRXRD==:RIRXRD	    ;CAN READ DIRECTORY (MFD OR UFD) AS A FILE -RIGHT
			    ; JUSTIFIED BIT FOR OWNER, PROJECT OR UNIVERSE
UFYPRV::POINT	UFSPRV,UFBPRV(T4),UFNPRV	;BYTE POINTER FOR ALL THREE PRIVILEGES
			; (OWNER,PROJECT,UNIVERSE)
UFBUN1==:CORUN1		;LOGICAL UNIT NO. WITHIN FILE STRUCTURE
			; ASSOCIATED WITH FIRST RETRIEVAL POINTER.
    UFSUN1==COSUN1	    ;BYTE SIZE
    UFNUN1==CONUN1	    ;BYTE PTR. POS.
UFB1PT==:COR1PT		;IF RETRIEVAL POINTER TO UFD IS THE ONLY ONE - WORD ADR.
    UFS1PT==COS1PT	    ;BYTE SIZE
    UFN1PT==CON1PT	    ;BYTE PTR. POS.
    UFP1PT==:COP1PT	    ;RIGHT-MOST BIT

;WORD 2---------------------------------------
UFBPT1==:CORPT1		;FIRST RETRIEVAL POINTER TO UFD
			; (CLUSTER COUNT,CHECKSUM,CLUSTER ADR.)
;WORD 3---------------------------------------
UFBWRT==:3		;BITS 0-26=LOGGED IN FIRST-COME FIRST-SERVED QUOTA
			; USED TO DISTINGUISH BETWEEN RESERVED
			; AND FCFS FREE BLOCKS LEFT IN UFBTAL
			; (NEVER DECREMENTED)
    UFWMSK==:777	    ;MASK FOR UFBWRT
UFBQTF==:UFBWRT		;FCFS LOGGED IN QUOTA - WORD ADR
    UFSQTF==^D27	    ;BYTE SIZE
    UFNQTF==^D26	    ;BYTE PTR POS
;UFYQTF::POINT	UFSQTF,UFBQTF(),UFNQTF	;BYTE PTR

    UFSWRT==^D9		    ;BYTE SIZE
    UFNWRT==^D35	    ;BYTE TRP POS(MUST BE RIGHT JUST. FOR AOS)
UFYWRT::POINT	UFSWRT,UFBWRT(T3),UFNWRT	;BYTE PTR
UFZWRT::POINT	UFSWRT,UFBWRT(T4),UFNWRT	;BYTE PTR #2
			; BITS 27-35=NO. BLOCKS WRITTEN IN UFD(OR MFD) ITSELF

;WORD 4---------------------------------------
UFBFSN==:CORFSN		;FILE STRUCTURE NUMBER THIS UFB IS ASSOCIATED WITH- WORD ADR.
    UFSFSN==COSFSN	    ;BYTE SIZE
    UFNFSN==CONFSN	    ;BYTE PTR. POS.

UFYFSN==:COYFSN

UFBCHG==:4		;BIT 6=1 IF ANY FILE IN UFD HAS
    UFPCHG==:4000	    ; BEEN WRITTEN OF RENAMED (CLEARED BY BACKUP)

UFBLOG==:4		;BIT 7=1 IF RIPLOG
    UFPLOG==:2000	    ; IS ON IN UFD
UFBZRB==:CORZRB		;UFD HAS EMPTY DATA BLOCKS
    UFPZRB==:COPZRB	    ;BIT =1 IF YES
;WORD 5---------------------------------------

UFBAUJ==:5			;=N IF JOB N OWNS AU FOR THIS UFB

;WORD 6---------------------------------------

UFBWAT==:6			;NON-0 IF JOB WAITING FOR AU

;WORD 7---------------------------------------

	$LOW
SUBTTL	UFD:	USER FILE DIRECTORY BLOCK

;WORD POSITIONS IN USER FILE DIRECTORIES
;PREFIX "UFD"
;THESE HAVE SAME FORMAT AS THE MFD.
;NEITHER THE MFD NOR THE UFD NAME APPEAR IN THE UFD.
;FILE ENTRIES OCCUR IN PAIRS.

UFDNAM==:0		;SIXBIT FILE NAME
UFDEXT==:1		;LH=SIXBIT EXTENSION, RH=CUP WHICH SPECIFIES
			; UNIT WITHIN FILE STRUCTURE AND LOGICAL BLOCK NUMBER OF
			; FIRST RIB OF FILE.  SEE MFDEXT ABOVE.
UFDCFP==:1		;RH=COMPRESSED FILE POINTER TO RETRIEVAL BLOCK OF FILE (RIB)
			; CONTAINS LOGICAL UNIT # WITHIN STR & SUPER CLUSTER ADDRESS.
			;TO GET CLUSTER ADDRESS: DIVIDE BY NO. OF SUPER CLUSTER PER UNIT
			;  RH(STRSCU). QUOTIENT=LOGICAL UNIT NO. WITHIN STR,
			;  REMAINDER=SUPER CLUSTER ADDRESS. MULTIPLY SUPER CLUSTER ADR.
			;  BY NO. OF BLOCKS PER SUPER CLUSTER (LH(STRBSC).


;WORD POSITIONS IN DATA BLOCKS. OF FILES
; THERE IS NO FORMAT FOR DATA BLOCKS.
; THEY CONTAIN 128 WORDS OF USER DATA
SUBTTL	UNI:	UNIT DATA BLOCK

;THE UNIT DATA BLOCK IS DEFINED IN DEVPRM.  BYTE POINTERS INTO
;THE UDB FOLLOW:

	$HIGH
					; ARG TO KONTROLLER ROUTINES
UNYLUN::POINT	UNSLUN,UNILUN(U),UNNLUN	;LOGICAL UNIT # (0-77) WITHIN STR
UNYLN1::POINT	UNSLUN,UNILUN(T1),UNNLUN ;LOGICAL UNIT # - FOR ONCE ONLY
UNYWPS::POINT	UNSWPS,UNIWPS(U),UNNWPS	;+VE NO. OF WORDS PER SAT BLOCK
UNYUTP::POINT	UNSUTP,UNIUTP(U),UNNUTP	;UNIT TYPE(KONTROLLER DEPENDENT)
					; SET BY ONCE ONLY
UNYBPC::POINT	UNSBPC,UNIBPC(U),UNNBPC	;BLOCKS/CLUSTER - ARG TO KONTROLLER ROUTINES
UNYBPT::POINT	UNSBPT,UNIBPT(U),UNNBPT	;BLOCKS/TRACK - ARG TO KONTROLLER ROUTINES
UNYBPY::POINT	UNSBPY,UNIBPY(U),UNNBPY	;BLOCKS PER CYLINDER
					; THE SMALLEST IF CYLINDERS; HAVE DIFFERENT
					; SIZES(MDF) - ARG TO KONTROLLER ROUTINES
UNYLKP::POINT	UNSLKP,UNILKP(U),UNNLKP;LAST KNOWN POSITION
UNYUST::POINT	UNSUST,UNIUST(U),UNNUST	;DRIVE STATUS - DOWN, NOT IN STR,
					; BEING MOUNTED, MOUNTED
UNXUST::POINT	UNSUST,UNIUST(T2),UNNUST
UNYKTP::POINT	UNSKTP,UNIKTP(U),UNNKTP	;KONTROLLER TYPE THIS UNIT IS CONNECTED TO
					; ONCE ONLY USES
UNYSIC::POINT	UNSSIC,UNISIC(U),UNNSIC	;# SAT BLOCKS IN CORE FOR THIS UNIT
UNYCFS::POINT	UNSCFS,UNICFS(U),UNNCFS	;CLASS FOR SWAPPING FOR THIS UNIT
UNYK4S::POINT	UNSK4S,UNIK4S(U),UNNK4S	;K FOR SWAPPING ON THIS UNIT
UNYAWL::POINT	UNSAWL,UNIAWL(U),UNNAWL	;SOFTWARE WRITE LOCK FOR ALL JOBS
UNYSPU::POINT	UNSSPU,UNISPU(U),UNNSPU	;# SAT BLOCKS ON THIS UNIT
UNYKNM::POINT	UNSKNM,UNIKNM(U),UNNKNM	;KONTROLLER NO. WITHIN THIS TYPE
					; START AT 0 FOR A, 1 FOR B, ETC
UNYKOF::POINT	UNSKOF,UNIKOF(U),UNNKOF	;"KONTAB" OFFSET
UNZCFS::POINT	UNSCFS,T1,UNNCFS	;POINTER TO SWAPPING CLASS

UNYBCT::POINT	UNSBCT,UNIBCT(U),UNNBCT	;POINTER TO NUMBER OF SLOTS LEFT IN BAT BLOCK
IFN FTXMON,<
UNYSNS::POINT	UNSSNS,UNISNS(U),UNNSNS	;SECTION NUMBER OF SECTION CONTAINING
					; SWAPPING SATS
>
	$LOW
	SUBTTL	ERROR LOGGING FOR .ESDPE-STYLE DISKS

;HERE IF ANY OLD-STYLE KONTROLLER DRIVERS ARE LOADED WHICH NEED TO DO THIS
;STYLE OF ERROR LOGGING.
;CALL IS FROM FILIO VIA KONELG(J).  SEE MDEELG IN FILIO FOR CALLING SEQUENCE.

DPEDSK==M.DSX+M.DPX+M.FHX		;FLAG FOR DPE-ERROR DRIVERS

IFN DPEDSK,<
	$HIGH

DPEELG::XMOVEI	T2,DPEBEG	;POINT TO OUR TABLE
	PUSHJ	P,XFRSEB##	;ALLOCATE THE BLOCK AND FILL MOST OF IT
	  POPJ	P,		;PUNT IF NO CORE REMAINING
	MOVE	T3,UNIDRC(U)	;DUMP-MODE READS
	ADD	T3,UNIMRC(U)	;PLUS MONITOR READS
	ADDM	T3,.EBHDR+15(T1) ;ADD TO BUFFER READS TO MAKE TOTAL UNIT READS
	MOVE	T3,UNIDWC(U)	;DUMP-MODE WRITES
	ADD	T3,UNIMWC(U)	;PLUS MONITOR WRITES
	ADDM	T3,.EBHDR+16(T1) ;ADD TO BUFFER WRITES TO MAKE TOTAL UNIT WRITES
	MOVE	T3,UNIUSC(U)	;GET USER SEEKS
	ADDM	T3,.EBHDR+17(T1) ;ADD TO MONITOR SEEKS TO MAKE TOTAL UNIT SEEKS
	PJRST	QUESEB##	;SEND THE BLOCK TO DAEMON AND RETURN

DPEBEG:	SEBTBL(.ERDPE,DPEEND,)	;START OF XFR TABLE
	MOVE	UDBNAM(U)	;(R00) PHYSICAL UNIT NAME
	MOVE	UNIHID(U)	;(R01) PACK (HOME BLOCK) ID
	MOVE	UNIHCT(U)	;(R02) HARD ERROR COUNT
	MOVE	UNISCT(U)	;(R03) SOFT ERROR COUNT
	MOVE	UNIECT(U)	;(R04) RETRY COUNT
	MOVE	UNISOF(U)	;(R05) 1CONI - ERROR CONI AFTER INITIAL ATTEMPT
	MOVE	UNIERR(U)	;(R06) 2CONI - ERROR CONI AFTER 1ST RECAL.
	MOVE	UNISDI(U)	;(R07) 1DATAI - AFTER INITIAL ATTEMPT
	MOVE	UNIHDI(U)	;(R10) 2DATAI - AFTER 1ST RECAL.
	MOVE	UNIHBN(U)	;(R11) BLOCK OF LAST (HARD?) ERROR
	MOVE	UNIMCT(U)	;(R12) SOFTWARE-DETECTED ERROR COUNTS
	MOVE	UNIPCT(U)	;(R13) SEEK INCOMPLETE ERRROS
	MOVE	UNIHNG(U)	;(R14) HUNG COUNTS
	MOVE	UNIBRC(U)	;(R15) TOTAL UNIT READS (BUFFERED HERE)
	MOVE	UNIBWC(U)	;(R16) TOTAL UNIT WRITES (BUFFERED HERE)
	MOVE	UNIMSC(U)	;(R17) TOTAL UNIT SEEKS (MONITOR HERE)
	MOVE	UNIDES(U)	;(R20) DSKCHR AC FOR UNIT
	MOVE	UNILOG(U)	;(R21) LOGICAL UNIT NAME
	MOVE	UNICCT(U)	;(R22) NUMBER BAT SLOTS LEFT
	MOVE	DEVFIL(F)	;(R23) FILENAME
	HLLZ	DEVEXT(F)	;(R24) FILE EXTENSION
	MOVE	JBTPPN##(J)	;(R25) USER'S PPN
	MOVE	JBTNAM##(J)	;(R26) USER'S PROGRAM NAME
DPEEND:!

> ;END IFN DPEDSK
	$LOW

COMEND:	END
