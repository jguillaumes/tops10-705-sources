UNIVERSAL NETPRM DEVICE INDEPENDENT NETWORK PARAMETERS - V072
SUBTTL D. TODD / D. MCCLURE  17-APR-90
	SEARCH	F,S
	SALL


;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED
;  OR COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION
;1978,1979,1980,1982,1984,1986,1988,1990.
;ALL RIGHTS RESERVED.

.CPYRT<1978,1990>,.


XP VNETPRM,072		;PUT VERSION NUMBER IN GLOB AND LOADER MAP
                               COMMENT @

NCL PHILOSOPHY

NCL networks consist of two type, "sequential" and "nonsequential".

In a sequential network there is at most one path from any node to any
other node.  A sequential node whose DDCMP acks a message is committed
to pass the message on in order to its destination.  The message may
only be discarded if the destination has died.

In a nonsequential network there may be many paths from any node to any
other node.  A message may become lost and require retransmission (e.g.
an intermediate node DDCMP acks a message and then dies).  Further
messages may arrive out of order in a nonsequential (e.g.  two nodes
have two DDCMP links between themselves).  A nonsequential node whose
DDCMP acks a message should pass the message on to it destination, but
may discard it.

Nonsequential nodes need to determine whether their messages have
arrived at their destinations, so nonsequential nodes maintain an
end-to-end numbering scheme for all important messages.  The NCL-REP,
NCL-ACK, and NCL-NAK messages are used to maintain the message
numbering.

For nonsequential networks it is important that messages not lay around
too long (consider the case of node A sends message 1 to node B and then
retransmits and finally message numbers wrap around and the second copy
of message 1 pops out and node B believes the old message 1 is the new).
So in nonsequential networks, if the DDCMP routine is unable
successfully transmit a message to the next node within a given quantum
of time (we will use 15 seconds), the message will be disposed of and
DDCMP message numbers will be realigned using the RESET and RESAK
messages.  Any node may calculate the maximum length of time a message
will be outstanding ( 15 seconds times max number of links to
destination), and will use a this time for its NCL-REP timer.

;*** Footnote *** 15-Sept-78

     Most of the stuff above is now garbage.  It is included here
primarly for historical interest.

						Matson


                                   @
SUBTTL NCS FIELD DEFINATIONS
;USE THE PDP-11 FORMATS TO DEFINE PDP-10 BIT
;IE:
B0==1B35	;LOW ORDER BIT
B1==1B34	;..
B2==1B33
B3==1B32
B4==1B31
B5==1B30
B6==1B29
B7==1B28	;HIGH ORDER BIT USED FOR A FLAG OR EXTENDING A FIELD
B8==1B27	;LOW ORDER BIT OF NEXT LEFT CHARACTER
B9==1B26
B10==1B25
B11==1B24
B12==1B23
B13==1B22
B14==1B21
B15==1B20
B16==1B19	;HIGH ORDER BIT OF SECOND LEFT CHARACTER
B17==1B18	;LOW ORDER BIT OF SECOND WORD FIRST CHARACTER
B18==1B17
B19==1B16
B20==1B15
B21==1B14
B22==1B13
B23==1B12
B24==1B11	;HIGH ORDER BIT OF SECOND WORDS FIRST CHARACTER
                               COMMENT @

                       SYNCHRONOUS LINE PROTOCOL


05.1  DDCMP MESSAGES (all but DATA are preceded by synchronization
sequence.)

DATA --     SOH  CC1    CC2    MSG#   NMSG  A0  BCC1  n*DATA BCC2
ACK --      ENQ  <001>  FILL   MSG#   FILL  A0  BCC1
NAK --      ENQ  <002>  RNAK   MSG#   FILL  A0  BCC1
REP --      ENQ  <003>  FILL   FILL   NLST  A0  BCC1
RESET* --   ENQ  <004>  FILL   FILL   NNXT  A0  BCC1
RESACK* --  ENQ  <005>  FILL   NEXP   FILL  A0  BCC1
STRT --     ENQ  <006>  FILL   FILL   NBEG  A0  BCC1
STACK --    ENQ  <007>  FILL   NREC   NXMT  A0  BCC1

BOOT --     DLE  CC1    CC2    <000>  <000> A0  BCC1  BOOTDATA      BCC2

	"n" =the number of data bytes, a 16-bit quantity made up of CC1 and
          CC2.
	A0  =1 (Station number;  always one for point to point.)
	ADDR=4 byte field containing the address for  the  core-image  data
          being loaded or dumped.
	BCC1=16 bits of BCC computed on the first 6 bytes of the message.
	BCC2=16 bits of the BCC computed on the "n" data bytes.
	BNUM=2 byte field containing number of bytes to be dumped.
	CC1	=the low order 8 bits  of  the  character  count  of  the  data
          portion.
	CC2	=the high order 8 bits of  the  character  count  of  the  data
          portion.   The  two  high  order  bits of this byte are really
          flags for the multi-point case, but will always  be  zero  for
          the point-to-point case.
	DLE	=220    (This is the starting character for station  management
          messages.)
	ENQ	=005    (This is the starting character for control messages.)
	FILL=0 (Filler;  is checked and must be zero.)
	IDAT="n" bytes of image data, which the station  will  put  at  the
          address contained in ADDR.
	MSG#=number of the last good message received (implies ACK  of  all
          lower numbered messages).
	NBEG=first message number this station will transmit after  startup
          is completed.
	NEXP=message number expected to be sent next(usually NNXT field  of
          REP message).
	NLST=number of last transmitted data message.
	NMSG=the number of this message.
	NNXT=next numbered message to be transmitted  (i.e. lowest  message
          that has not been acked).
	NREC=next message number for reception (usually NBEG field  of  the
          STRT message).
	RNAK=Reason for negative acknowledgement:
          1=Header BCC incorrect
          2=Data BCC incorrect
          3=The last REP message received indicates we lost one or  more
          messages.
          10=Buffer space temporarily unavailable
          11=Receive overrrun (data lost)
          20=Data message is too long
          21=Header format error (e.g. non-zero fill)
	SNAM=software system defined  data  identifying  which  program  to
          load.
	SNUM=a sequential numbering of successive boot messages.
	SOH	=201    (This is the starting character for data messages.)
	BOOTDATA will be one of the following formats:
          BOOT           SNA    <000>
          EXAMINE        SNA    <001>   <adr1> <adr2>
          DEPOSIT        SNA    <002>   <adr1> <data>
          GO TO          SNA    <003>   <adr>
          CLEAR          SNA    <004>   <adr1> <adr2>
          DEBUG          SNA    <005>
          ACCEPT         DNA    <011>   <adr>
          EXAMINE DATA   DNA    <012>   <adr>  <data>
          REJECT         DNA    <013>
          REQUEST BOOT   DNA    <014>   <type> <serial> <description>
          REQUEST LOAD   DNA    <015>   <type> <serial> <description>
	DESCRIPTION=extensible Ascii;  text which describes program  to  be
          loaded, usually a file description.
	DNA=extensible binary, node number the bootstrap message should  be
          routed to.  Zero means default.
	SERIAL=extensible binary;  the serial number  for  the  node  being
          booted.
	SNA=extensible binary;   the  node  number  of  the  station  which
          originated the bootstrap message.
	type=extensbile binary;  code for the type of node requesting load:
                    1=DC71 (PDP8I with DP01).
                    2=DC72 (PDP8E with DP8E).
                    3= (PDP11/40 with DU11).
                    4=DAS82 (PDP11/40 with DQ11).

                                   @
                               COMMENT @
05.2.1  NODE ID Message.

The NODE ID message is necessary for the case of two nodes connected  by
two  links.  It is the first message sent between adjacent nodes after a
DDCMP-START/STACK sequence.   It  is  never  sent  between  non-adjacent
nodes.  SNA and DNA are never present in a NODE ID message.

05.2.2  START/STACK Messages.

4.2.3  Neighbours Messages.

Everytime a node aquires a new  neighbour,  or  loses  a  neighbour,  or
changes  a  link  level,  the node will send a neighbours message to all
nodes it knows.

4.2.4  NCL REPS, ACKS & NAKS

The NCL REP timer must be long enough that a REP will never arrive ahead
of  another message.  The NCL NAK message is sent only in response to an
NCL REP message.  A station which transmits an NCL NAK must discard  all
numbered NCL messages which the NAK doesn't implicitly ACK.

4.2.5  Routing algorithims.

All nodes remember all other nodes and their  neighbours.   A  node  may
give  a  message  to  any other node whose level for the station is less
than the original node's.  A message for another node may  be  given  to
any other node as long as the best route

4.2.6  Sequential nodes.

Nodes which need to  have  the  minimum  subset  of  NCL  will  use  the
SEQUENTIAL subset. Sequential nodes will indicate they are sequential by
never setting the non-sequential bit in the NCT byte.  Sequential  nodes
will  use  zero bytes for transmission of NCA and NCN.  Sequential nodes
will ignore NCA and NCN on input.  Sequential nodes don't send  NCL-ACK,
NCL-NAK,  NCL-REP,  NCL-START, or NCL-STACK messages.  When a sequential
node sends a neighbours message he will list all nodes he will do  route
through for.

Non-sequential  nodes  may  optionally  support  sequential  nodes.    A
non-sequential  node  will  talk  to  the  sequential node as if he were
sequential.

                                   @
SUBTTL  NCS Formats

                               COMMENT	@

unnumbered control --    NCT   SNA   DNA   NCA   NCN   OPD
numbered control --      NCT   SNA   DNA   NCA   NCN   0     CM
DATA --                  NCT   SNA   DNA   NCA   NCN   DLA   dev control

                                   @

;DLA=		;destination message link address, i.e. the index into
		;the node's  connection  database.  Extensible field,
		;maximum of 12 bits. Zero is not a legal device DLA.
		;It is reserved for station control messages.
;DNA=		;destination NNM
;NCA=		;Network Control Ack;  last network message received ok.
;NCN=		;Network Control message Number.  One byte binary field.
;NCT=		;network control message type and flags.  Extensible field.
	NCT.TP==:B0!B1!B2	;bits 0-2=type field
	  NCT.DM==:0		;0=DATA message
	  NCT.AK==:1		;1=ACK.
	  NCT.NK==:2		;2=NAK.
	  NCT.RP==:3		;3=REP.
	  NCT.ST==:4		;4=START.  OPD is NNM SNM SID NVR.
	  NCT.SK==:5		;5=STACK.
	  NCT.ID==:6		;6=NODEID. OPD is NNM SNM SID NIT NIS NVR
	NCT.RH==:B3		;SNA and DNA present.
	NCT.TR==:B4		;trace
	NCT.IT==:B5		;INTERRUPT message (NOP DRQ COUNT)
	NCT.SQ==:B6		;sequential node
	NCT.EX==:B7		;extensible bit
;NIS=		;NodeID sequencer, present only for "broadcast" NodeID type.
		; Extensible binary, maximum of 2 bytes.
;NIT=		;NodeID type, extensible binary.  Current values are NIT.PP=0
		; for point-to-point, and NIT.BC=1 for broadcast (Ethernet).
	NIT.PP==:0		;Point-to-Point (DTE, DMR, etc.)
	NIT.BC==:1		;Broadcast (Ethernet, etc.)
		ND	NCLNIP,0	;NCL ETHERNET PROTOCOL ID
;NNM=		;node name, a binary  extensible  field, maximum  of  12
		;bits, identifying node.  Zero means next node over
		;synchronous line.
;NVR=		;NCL version number of originating node.  Extensible binary.
		;Not present (or zero) before version 25.
	NCLVER==:25		;Our current NCL version number
				; (tracks VDAS85 in DNCNFG.P11)
;OPD=		;optional data (message-type specific).
;SID=		;software identification, extensible ASCII with  two  subfields:
		;1)  name and version of operating system and DEMOS software,
		;2)  creation date.
;SNA=		;source NNM.
;SNM=		;station name is an extensible ASCII field.
SUBTTL NCL NETWORK MESSAGES
                               COMMENT	@
CM = one of the following:

CONNECT --              CNT    <001>  DLA   SLA   DPN   SPN   MML   FEA
DISCONNECT --           CNT    <002>  DLA   SLA   RSN  (HST)
NEIGHBOURS --           CNT    <003>  (NNM  LVL)
REQ CONFIG --           CNT    <004>
CONFIGURATION --        CNT    <005>  OPD
DATA REQUEST --     	CNT    <006>  DLA   DQR
STATION ID --		CNT    <007>  OPD
                                   @

;DEFINE THE PROTOCOL "CM"'S
NC.CNT==<001>
NC.DSC==<002>
NC.NBN==<003>
NC.RCF==<004>
NC.CNF==<005>
NC.DQR==<006>
NC.CTL==<007>
NC.MAX==NC.CTL	;LAST NC MESSAGE TYPE
;CNT=		;count of remaining bytes in message.
;DCD=		;attributes for card reader:
				;bits 0,1=speed
				;         0 = don't care
				;         1 = less than 300 cpm
				;         2 = between 300 and 600 cpm
				;         3 = greater than 600 cpm
				;bit 2=mark sense
				;bit 3=hdw EOF required
				;bit 4=suppress EOF card detection
;DCM=		;data code and mode:
	DCM.AS==:B0		;ASCII
	DCM.EB==:B1		;EBCDIC
	DCM.IM==:B2		;Image
	DCM.HO==:B3		;Hollerith(CDR only)
	DCM.DI==:B4		;DEC image (CDR only)
	DCM.RV==:B5		;reserved
	DCM.CP==:B6		;compressed format
;DDP=		;attributes for DDP (remote DN8x "DDCMP") devices
		;currently, none defined
;DFT=		;type word for device, TTY TYPE or LPT FORMS.
;DLP=		;attributes for line printer:
	DLP.LL==:B2		;lower case
	DLP.FC==:B14		;full character set (e.g., LN01)
	DLP.8B==:B15		;eight-bit printer (no data compression)
;DPN=		;destination PN.
;DTY=		;attributes for teletypes:
	DTY.MC==:B0		;modem control
	DTY.AB==:B1		;auto-baud
	DTY.SB==:B2		;handler can set baud rates
	DTY.27==:B3		;2741 (Obsolete)
	DTY.BD==:B4		;baudot (Obsolete)
	DTY.AD==:B5		;auto dial line (Bell 801)
	DTY.SH==:B6		;remote can do "set host" function
				; (ie can generate connect messages)
	DTY.RI==:B7		;run INITIA (ignored)
	DTY.RA==:B8		;requestable autobaud (.TOEAB supported)
;DRX=		;device attributs for RDX (remote data entry terminal) devices
	DRX.MD==:B0		;multi-drop line
	DRX.PL==:B1		;line accepts a poll sequence
;DVT=		;device specific attributes:  (DCD!DDP!DLP!DTY!DRX)+DVU+DVV
;DVU=		;device unit type (e.g., LP05 vs LN01)
	DVU.LP==:1		;LP05-class
	DVU.LN==:2		;LN01-class
;DVV=		;device controller type (e.g., LP11 vs LP20)
	DVV.L1==:4		;LP11
	DVV.L2==:5		;LP20
;ECD=		;arbitrary number of bytes of echo data.
;ECR=		;the data that was received in the previous echo message (ECD).
;FEA=		;features:  DCM+RLN+DVT+DFT
;LVL=		;link value is a one-byte binary value used to determine the
		;perferred path; 0 means link is down. (Preferred path is
		;that whose sum of link values is lowest.)
DDCMWD==<^D128+^D10>*5
;MML=		;maximum DDCMP message length.
;OBJ=		;object type for process:

	DEFINE OBJTYP<		;;MACRO FOR DEFINING NETWORK OBJECT TYPES
	X	MCR,OBJ.TT,.TYMCR	;;TERMINAL HANDLER (MCR)
	X	TTY,OBJ.TY,.TYTTY	;;TERMINAL
	X	CDR,OBJ.CD,.TYCDR	;;CARD READER
	X	LPT,OBJ.LP,.TYLPT	;;LINE PRINTER
	X	PTR,OBJ.PR,.TYPTR	;;PAPER TAPE READER
	X	PTP,OBJ.PP,.TYPTP	;;PAPER TAPE PUNCH
	X	PLT,OBJ.PL,.TYPLT	;;PLOTTER
	X	MTA,OBJ.MT,.TYMTA	;;MAGNETIC TAPE
	X	DTA,OBJ.DT,.TYDTA	;;DECTAPE
	X	TSK,OBJ.TK,.TYTSK	;;PROCESS (JOB OR TASK)
	X	RDA,OBJ.RD,.TYRDA	;;REMOTE DATA ENTRY
	X	CDP,OBJ.CP,.TYCDP	;;CARD PUNCH
	X	DDP,OBJ.DP,.TYDDP	;;DDCMP DEVICE
>

	DEFINE X(A,B,C)<	;;TEMPORARY MACRO TO DEFINE OBJECT TYPES
	OBJ.MX==:%%%OFF		;;WHILE WE'RE AT IT, COUNT THE OBJECT TYPES
	B==:%%%OFF
	%%%OFF==%%%OFF+1
>
	%%%OFF==0		;START WITH OBJECT TYPE ZERO
	OBJTYP			;DEFINE ALL THE OBJ.?? SYMBOLS
				;200-377=reserved

;PID=		;process identification. For devices this is an extensible
		;binary field, 177 means default choice, 0 - n means unit.  For
		;tasks this is a single extensible ASCII string usually name
		;and qualifier (e.g.  UIC or PPN).
;PN=		;process name, having 2 parts:  1) OBJ, 2) PID.
;RSN=		;reason .  If reason is "RSN.RC" this is followed by an
		; extensible node number to reconnect to.
	RSN.OK==:0		;normal disconnect
	RSN.OT==:1		;object type not available
	RSN.XN==:2		;too many connects to node
	RSN.XP==:3		;too many connects to process
	RSN.NP==:4		;process does not exist at this node
	RSN.RC==:10		;reconnect to another host (set host command)
				;100+ are "mapped" from DECnet codes, for FAL-10
	RSN.KS==:100+^D03	;node is shutting down
	RSN.RD==:100+^D09	;connect rejected by dialog process
	RSN.ID==:100+^D34	;invalid ppn ("userid") and/or password
	RSN.IS==:100+^D36	;invalid account string
	RSN.FE==:100+^D43	;generic "image field format error"
;SLA=		;source link address (1 or 2 byte extensible binary number).
;SPN=		;source PN.
SUBTTL	STATION CONTROL

;STATION CONTROL MESSAGE TYPES

	STC.EX==:1		;EXAMINE 	<L><1><ADDR1><ADDR2>
	STC.DP==:2		;DEPOSIT 	<L><2><ADDR><DATA>
	STC.GT==:3		;GOTO 		<L><3><ADDR>
	STC.CL==:4		;CLEAR 		<L><4><ADDR1><ADDR2>
	STC.DB==:5		;DEBUG 		<L><5>
	STC.MS==:6		;MESSAGE 	<L><6><DATA*><0>
	STC.BD==:7		;BOOT DATA 	<L><7><CNT><DATA>
	STC.AC==:11		;ACCEPT 	<L><11>
	STC.ED==:12		;EXAMINE DATA 	<L><12><ADDR><DATA>
	STC.RJ==:13		;REJECT 	<L><13>
	STC.RB==:14		;REQUEST BOOT 	<L><14><TYPE><SER><MEM SIZ>
	STC.RL==:15		;REQUEST LOAD 	<L><15><TYPE><SER><ASCII TEXT>
SUBTTL   DEVICE CONTROL

                               COMMENT	@

The device control protocol consists of  the  specific  messages  listed
below,  plus  some  data  in  the  optional data part of the NCS connect
message.  This data is the maximum allowable DDCMP  message  length  for
this  device (expressed as an extensible binary number of bytes) and the
features field (FEA).  The features going from the handler to the device
are  those  that  the  handler  would like to see;  those going from the
device to the handler are those that are actually present.


DATA --                    CNT  <001>  (DATA)
DATA with EOR --           CNT  <002>  (DATA)
STATUS --                  CNT  <003>  STC  STD
CONTROL --                 CNT  <004>  DCT  CDT
USER ID --                 CNT  <005>  PPN  PSWD  UNAME  ACCT  GROUP
FILE SPECIFICATION --      CNT  <006>  FST  FEA   FDES

                                   @

;DEFINE THE PROTOCOL FOR DEVICE CONTROL (DAP)
DC.DAT==<001>			;DATA (WITH OUT END OF RECORD)
DC.DAR==<002>			;DATA (WITH END OF RECORD)
DC.STS==<003>			;DEVICE STATUS
DC.CTL==<004>			;DEVICE CONTROL
DC.UID==<005>			;USER ID ?? (WHAT EVER THAT'S GOOD FOR)
DC.FSP==<006>			;FILE SPEC ?? (PROBABLY EVEN LESS USEFUL)
DC.MAX==<006>
SUBTTL BIT AND FIELD DEFINATIONS FOR DEVICE CONTROL (DAP)
;ACCT=		;accounting code(extensible ASCII)
;CDT=		;control data; this optional field contains control data for a
		;device.
		;for terminal characteristics:
		;# of milliseconds after backspace<010>
		;# of milliseconds after horizontal tab<011>
		;# of milliseconds after LF<012>
		;# of milliseconds after vertical tab<013>
		;# of milliseconds after form feed<014>
		;# of milliseconds after carriage return<015>
		;receive speed (bits/sec, 134=2741)
		;transmit speed
		;width of terminal carriage
		;auto CRLF position
		;element number(last 3 digits of IBM part number)
		;"2741" bits:
	CDT.CB==:B0		;"debreak" feature present (obsolete)
	CDT.PL==:B1		;APL MODE
	CDT.TD==:B2		;TIDY MODE (obsolete)
	CDT.8B==:B3		;8-BIT terminal
	CDT.FT==:B4		;Forms-type field is present
				;B5-15=reserved
;CNT=		;length of what follows in bytes (ext. binary)
;DCT=		;device specific control information for terminal
	DCT.EP==:0		;echo pipeline marker (no CDT field)
	DCT.CG==:1		;character gobbler (no CDT field)
	DCT.TC==:2		;teletype characteristics
	DCT.AD==:3		;auto dial
				;CDT=ASCII digits of number to be dialed
	DCT.XF==:4		;Request F.E. to send XOFF (no CDT)
	DCT.AB==:5		;Request F.E. to do autobaud detect (no CDT)

		;for files
	DCT.SI==:0		;set record pointer for input
	DCT.SO==:1		;set record pointer for output

		;line printer
	DCT.LS==:0		;Load skip channel tape (reserved)
	DCT.LR==:1		;Load LP20 RAM (reserved)
	DCT.LF==:2		;Set forms type
;EPM=		;one byte number identifying the echo pipeline marker.
;FDES=		;file description, extensible ascii field of form
		;DEV:[P,PN]FILE.EXT
;FST=		;file status
	FST.IN==:0		;open for input
	FST.OU==:1		;open for output
	FST.AP==:2		;open for appending
	FST.UP==:3		;open for updating
	FST.DL==:4		;delete
;PSWD=		;password
;GROUP=		;group code(extensible ASCII)
;PPN=		;project programmer number(extensible ASCII)
;RLN=		;record length (max if variable):  extensible binary.
;SCD=		;status for card reader:
	SCD.ME==:B0		;master error(not set by EOF)
	SCD.HE==:B1		;hopper empty
	SCD.RE==:B2		;registration error
	SCD.IP==:B3		;invalid punch for character set
	SCD.SF==:B4		;stacker full
	SCD.JF==:B5		;jam on feed
	SCD.PF==:B6		;pick failure on feed
	SCD.CZ==:B7		;EOF card detected
	SCD.HZ==:B8		;hdw EOF
	SCD.OR==:B9		;overrun
	SCD.OF==:B10		;off line
	SCD.SR==:B11		;stop reading
;SDP=		;status for DDP:
	SDP.AV==:B0		;DDCMP ("LBLK") available (L2.DDP set in -11)
	SDP.RN==:B1		;DDCMP protocol is up and running
	SDP.BL==:B12		;"Block too large" error
	SDP.DT==:B13		;"data" error
	SDP.DE==:B14		;"device" error
	SDP.IP==:B15		;"improper mode" error (see SDP.AV)
	    SDP.ER==:SDP.BL!SDP.DT!SDP.DE!SDP.IP  ;any error
;SLP=		;status for line printer:
	SLP.FE==:B0		;fatal error
	SLP.OL==:B1		;offline(+others)
	SLP.PZ==:B2		;page count zero
	SLP.VE==:B3		;VFU error
	SLP.RE==:B4		;RAM error
	SLP.IC==:B5		;illegal character
				;free
	SLP.OV==:B7		;parity error
	SLP.DE==:B8		;demand error
	SLP.ME==:B9		;master sync error
				;free
	SLP.8B==:B14		;8-bit data no compression (depends on DLP.8B)
	SLP.SV==:B15		;suppress VFU (sorta "image" data mode)
;SPP=		;status for paper tape punch:
	SPP.ME==:B0		;master error
	SPP.NP==:B1		;no power
	SPP.NT==:B2		;no tape
;SPR=		;status for paper tape reader:
	SPR.ME==:B0		;master error
	SPR.NP==:B1		;no power
;STC=		;status code:binary values:
	STC.ER==:0		;DEVICE ERROR
	STC.SB==:1		;SET BITS
	STC.CB==:2		;CLEAR BITS
	SCT.XA==:3		;TRANSFER ABORTED
;STD=		;device specific status:  SCD!SDP!SLP!SPP!SPR!STY
;STY=		;status for teletype:
	STY.DE==:B0		;deferred echo
	STY.CV==:B1		;convert LC on input
	STY.XS==:B2		;output frozen by ^S
	STY.II==:B3		;image input
	STY.IO==:B4		;image output
	STY.TP==:B5		;terminal page
	STY.TT==:B6		;terminal tape
	STY.HT==:B7		;hdw tabs
	STY.FF==:B8		;hdw form feed
	STY.8B==:B9		;8-bit I/O mode
;		;B10		;reserved
	STY.CR==:B11		;no cr-lf
	STY.DT==:B12		;data terminal ready (enables auto answer)
	STY.RG==:B13		;if STY.DT=0 then ring
				;if STY.DT=1 then carrier
;		;B14		;reserved
;		;B15		;reserved
;UNAME=		;user name (extensible ASCII)
;MACRO FOR DEFINING THE FIELDS OF THE VARIOUS NETWORK DATA BLOCKS

DEFINE	X(NAME<%%%OFF>,SIZE<1>),<NAME==:<%%%OFF==%%%OFF+<SIZE>>-<SIZE>>
SUBTTL NETDDB -- NETWORK SPECIFIC DDB DEFINITIONS.

	%%%OFF==DEVLLD		;INITIALIZE THE OFFSET

	X	DEVNET		;XWD NDT,NODE-NUMBER
	X	NETXLA		;BYTE (8)RSN(14)SLA(14)DLA
	X	DEVDRQ		;XWD OUTSTANDING-INPUT-DRQ'S,DRQ'S-FOR-OUTPUT
	X	NETATR		;BYTE (4)*FREE*(8)DVV(8)DVU(16)DVT
	X	NETMRL		;BYTE (4)*FREE*(8)DDBLENGTH(12)RLN(12)MML
	X	DEVAXI,2	;FIRST WORD IS BYTE POINTER TO USERS INPUT BUF
				;SECOND IS COUNT OF BYTES LEFT IN BUFFER
	X	DEVAXO,2	;FIRST WORD IS BYTE POINTER TO USERS OUTPUT BUF
				;SECOND IS COUNT OF BYTES LEFT TO OUTPUT
	X	DEVPCB		;XWD ??,QUEUE OF INPUT PCBS FOR THE DEVICE
	X	DEVPBP		;BYTE POINTER TO CURRENT NCL SUB-MESSAGE
	X	DEVNPD		;XWD INCOMING-NPD,PASSIVE-NPD. (USED BY TSK'S)
	X	DEVDFT		;SIXBIT "FORMS TYPE" FOR DEVICE
	X	NETLEN,0	;LENGTH OF A GENERAL NETWORK DDB


;NETWORK DEPENDANT BYTE POINTERS

	NT%RSN==:<POINT  8,NETXLA(F),7>		;REASON FOR DISCONNECT
	NT%SLA==:<POINT 14,NETXLA(F),21>	;SOURCE LINK ADDRESS
	NT%DLA==:<POINT 14,NETXLA(F),35>	;DESTINATION LINK ADDRESS
	NT%ZWD==:<POINT  8,NETMRL(F),11>	;DDB LENGTH
	NT%RLN==:<POINT 12,NETMRL(F),23>	;LOGICAL RECORD LENGTH
	NT%MML==:<POINT 12,NETMRL(F),35>	;MAXIMUM (DATA) MESSAGE LENGTH
	NT%DVV==:<POINT 8,NETATR(F),11>		;DEVICE "CONTROLLER" (DVV) TYPE
	NT%DVU==:<POINT 8,NETATR(F),19> 	;DEVICE "UNIT" (DVU) TYPE
	NT%DVT==:<POINT 16,NETATR(F),35>	;DEVICE ATTRIBUTE (DVT) BITS
;NETWORK DEPENDENT BITS DEFINED IN THE LH OF DEVIOS(F)

	IOSREL==400		;DEVICE HAS BEEN RELEASED.  IN PARTICULAR,
				; DON'T WAKE ANY JOBS IF A DRQ COMES IN.
	IOSCON==1000		;VERY IMPORTANT BIT.  INDICATES DEVICE IS
				; CONNECTED. (SHOULD BE REPLACED BY A
				; MECHANISM)
	IOSZAP==2000		;THIS BIT IS THE MIRROR IMAGE OF IOSCON.
				; WHEREAS IOSCON INDICATES WHEATHER THE NETWORK
				; DOES OR DOESN'T KNOW ABOUT THE DEVICE, IOSZAP
				; INDICATES THAT NO JOB CURRENTLY HAS THE
				; DEVICE.  (IE IT TYPED "^C^C .CORE 0")
	IOSERR==4000		;USED WITHIN DEVICE SERVICE ROUTINES TO SIGNAL
				; THAT I/O CANNOT BE DONE FOR SOME REASON. (IT
				; IS SET BY "NTDSET" IF THE DEVICE IS NO LONGER
				; CONNECTED)
	IOSUSI==10000		;UUOCON STOPPED INPUT. SET BY NTDAIB WHEN THERE
				; ISN'T ANOTHER INPUT BUFFER AVAILABLE.  CAUSES
				; NTDIBA TO FAIL UNTIL CLEARED BY THE DEVICE
				; DRIVER.  *** MUST BE CLEARED BY DRIVER ***
	IOSUSO==20000		;UUOCON STOPPED OUTPUT. SET BY NTDAOB WHEN
				; NO OUTPUT BUFFERS ARE AVAILABLE. CAUSES
				; NTDOBA TO FAIL.  CLEARED BY DEVICE DRIVERS
				; ON OUTPUT UUO.
				;      *** MUST BE CLEARED BY DRIVER ***
	IOSFFB==40000		;FIRST FREE DEVIOS BIT.  USE THIS SYMBOL
				; IN DEVICE DRIVERS WHEN ALLOCATING DEVICE
				; DEPENDENT DEVIOS BITS.
;*** FOOTNOTE ***

COMMENT \

     It should be noted that there is no "IOSHDV" or "hung device" bit.
I do not believe that the -10 should have to worry about device timing.
In my opinion that is the job of the machine that actually has the physical
device.  If the remote does hung timing, it should report hung devices as
"off line" or something.

\
SUBTTL PCB -- PROTOCOL CONTOL BLOCK

                               COMMENT @

                           *** NOTE WELL ***

   1)	Because the DL-10 deiver is not too intelligent, it requires that
	the data it is given reside on contiguous physical pages.  At
	present, the only place where PCB's may reside is in monitor free
	core.  Historically, monitor free core has been contiguous.  If
	this ever changes, you can be sure that your DL-10 will stop
	working!

   2)	All addresses in the PCB (ie. PCBOAD and PCBOA1) are assumed
	to point to exec virtual memory.  (At this point, they should point
	to exec free core.)

                             END COMMENT @

                               COMMENT @

                 ***  Notes on PCB Conversion Codes ***

   1)	PCV.NC  This code instructs the front end not to attempt any conversion
	on the data.

   2)	PCV.LC  This code instructs the front end to attempt LPT compression
	on the secondary buffer pointed to by the PCB.  The last two fields
	of the primary buffer MUST contain the "CNT" and "TYP" fields.  The
	reason for this is that the front end attempts to parse the message
	header backwards from the end of the primary buffer in order to
	determine where to put the updated DAP message length.  (The reason
	that the front end must do this is that the -10 has no idea of what
	the final length of the compressed message will be.)

   3)	PCV.BN  This code tells the front end that it will be getting 36 bit
	binary data (in 12 bit bytes) which it should attempt to pack in 8 bit
	bytes.  The idc "CNT" field is not changed (as it whould be if this
	was LPT compression).  It is up to the -10 to calculate how long the
	message will be AFTER binary conversion, and put the correct value
	in the message in the first place.

                             END COMMENT @
;DEFINE THE PCB OFFSETS

	%%%OFF==0		;INITIALIZE THE OFFSET

	X	PCBBLK		;BYTE (6)FLAGS(4)CONV(8)MSG#(18)LINK-WORD
	   PCB.NM==:(1B0)	;NUMBERED MESSAGE

	   PCV.NC==:0		;NO CONVERSION (8 BIT BYTES)
	   PCV.LC==:1		;LINE-PRINTER COMPRESSION (7 BIT BYTES)
	   PCV.BN==:2		;BINARY CONVERSION (12 BIT BYTES)

;THESE TWO WORDS ARE FOR UGLY BIZZARO "MESSAGE BLOCK" COMPATIBILITY
;WITHIN THE LINE "KONTROLLERS" . . .

	X	PCBFMS		;I'D LIKE TO KILL SOMEONE . . .
	X	PCBDMN		;ON THE KS-10, THE MESSAGE NUMBER IS HERE

;THE REAL PCB INFORMATION

	X	PCBFEK,0	;XWD FEK,??? (USEFUL ONLY FOR NODE-ID MSGS)
	X	PCBNNM		;XWD ???,NODE-NUMBER

IFN FTENET,<			;IF KLNI/ETHERNET HARDWARE,
	X	PCBNIA,2	;ETHERNET ADDRESS (RECEIVE ONLY, FOR NODE-ID)
> ;END IFN FTENET

;THE TWO "MESSAGE SEGMENT DESCRIPTORS" (OVERLY-COMPLICATED SO AS TO LOOK
;LIKE TWO REAL "MSD" BLOCKS FOR OUTBOARD USERS, LIKE ETHSER)

	X	PCBMS1,0	;"FIRST" MSD ADDRESS

	X	PCBNXX		;POINTER TO PCBNXY (USEFUL ONLY TO D8EINT)
	X	PCBPTR,2	;BYTE POINTER TO MESSAGE
	X	PCBCTR		;COUNT OF DATA BYTES IN USE
	X	PCBALN		;ALLOCATED LENGTH OF DATA BUFFER
	X	PCBADR		;ALLOCATED ADDRESS OF DATA BUFFER

	X	PCBMS2,0	;"SECOND" MSD ADDRESS

	X	PCBNXY		;TRAILING "NEXT" POINTER (MSD-STYLE), ALWAYS 0
	X	PCBPT2,2	;SECONDARY BYTE POINTER (OUTPUT ONLY)
	X	PCBCT2		;SECONDARY BYTE COUNT (OUTPUT ONLY)
	X	PCBAL2		;SECONDARY ALLOCATION LENGTH (MBZ)
	X	PCBAD2		;SECONDARY ALLOCATION ADDRESS (MBZ)

;THE REST OF THE PCB

IFN FTKL10,<			;ON THE KL, WE MUST WORRY ABOUT CACHE
	X	PCBCSN		;XWD CPU#,CACHE-SWEEP-SERIAL-NUMBER
>
	X	PCBTAG		;CONTAINS SIXBIT/PCBTAG/ FOR VALID PCB'S
	X	PCBLEN,0	;LENGTH OF A PCB


;BYTE POINTERS INTO THE PCB. (STORAGE RESERVED FOR THEM IN COMDEV)

	PC%PCV==:<POINT 4,PCBBLK(U),9>	;POINTER TO COMPRESSION CODE
	PC%MSN==:<POINT 8,PCBBLK(U),17>	;POINTER TO MESSAGE NUMBER
SUBTTL NDB -- NODE DATA BLOCK DEFINITIONS

	NGHMAX==^D16		;MAXIMUM NUMBER OF NEIGHBORS
	NODMAX==177		;HIGHEST LEGAL NODE NUMBER

	%%%OFF==0		;INITIALIZE THE OFFSET

	X	NDBNNM		;XWD NODE-NUMBER,NEXT-NDB
	X	NDBSID		;XWD -DATE,-CONFIG
	X	NDBNVR,0	;ALTERNATE NAME FOR NCL-VERSION
	X	NDBSNM		;BYTE (18)-NAME(18)NCL-VERSION
	X	NDBMNM,2	;BYTE (8)LAR(8)LAP(8)LMS(8)LMA(4)0
				;BYTE (8)LAS(8)LMR(8)LMP(8)???(4)0
	X	NDBFEK		;XWD COST,FEK
	X	NDBFLG		;BYTE (9)FLAGS(9)TIMER(18)SERVICE-QUEUE-LINK
	   NDB.UP==:(1B0)	;START SENT OR RECIEVED. (NODE IS RUNNING)
	   NDB.SK==:(1B1)	;SENDING STACKS, NOT STARTS
	   NDB.CF==:(1B2)	;CONFIGURATION HAS NOT BEEN REQUESTED
	   NDB.NB==:(1B3)	;NEIGHBORS MESSAGE NEEDS TO BE SENT
	   NDB.TP==:(1B4)	;MARK BIT FOR USE DURING TOPOLOGY RECOMPUTATION
	   NDB.XN==:(1B5)	;NEED TO SEND A NAK. (RESPONSE TO A REP)
	   NDB.NQ==:(1B6)	;SAYS THAT NDB HAS A REQUEST QUEUED.
	   NDB.GF==:(1B7)	;IF ON, THIS NODE HAS BEEN "GREETED"
	   NDB.XC==:(1B8)	;NEED TO SEND A CONFIGURATION MESSAGE
	X	NDBQUE		;XWD INPUT-PCB-QUEUE,OUTPUT-PCB-QUEUE
	X	NDBTOP,NGHMAX/2	;NEIGHBORS TABLE.
	X	NDBOPR		;LDB OF OPR, 0 IF NONE
	X	NDBSTC		;XWD TIMER,JOB OWNING STATION CONTROL
	X	NDBICT		;XWD TIMER,INCOMING STC BLOCK POINTER
	X	NDBMOM		;MAXIMUM OUTSTANDING MESSAGE COUNTER
	X	NDBTMP,3	;TEMP. USED WHEN COMPUTING TOPOLOGY.
	X	NDBDEV,<OBJ.MX/4+1> ;9 BIT BYTES OF HOW MANY OF EACH OBJECT TYPE
	X	NDBSN2		;SIXBIT SYSTEM NAME (POINTED TO FROM NDBSNM)
	X	NDBLEN,0	;SIZE OF AN NDB.
;BYTE POINTERS INTO THE NDB (INDEXED BY "W")

	NB%NXT==:<POINT 18,NDBNNM(W),35>	;ADDRESS OF NEXT NDB
	NB%NNM==:<POINT  9,NDBNNM(W),17>	;NODE NUMBER
	NB%NVR==:<POINT 18,NDBNVR(W),35>	;NCL VERSION NUMBER
	NB%SNM==:<POINT 18,NDBSNM(W),17>	;ADDRESS OF STATION NAME
	NB%TIM==:<POINT  9,NDBFLG(W),17>	;TIMER. IT'S USED AS BOTH
						;A START AND REP TIMER. REP
						;TIMER COUNTS UP, START COUNTS
						;DOWN!! (UGLY)
	NB%NGH==:<POINT 18,NDBTOP(W),17>	;FIRST NEIGHBOR
						;BYTE (9)NODE(9)COST
	  NB%NGN==:<POINT 9,0,26>		;EXTRACT NODE FROM NB%NGH
	  NB%NCS==:<POINT 9,0,35>		;EXTRACT COST FROM NB%NGH
	NB%NGL==:<POINT 18,<NDBTOP+<NGHMAX/2>-1>(W),35>  ;LAST NEIGHBOR
	NB%OPR==:<POINT 18,NDBOPR(W),35>	;ADDRESS OF OPR LDB (IF ANY)
	NB%CTJ==:<POINT 18,NDBSTC(W),35>	;JOB NUMBER OF STATION CTL
	NB%SDT==:<POINT 18,NDBSID(W),17>	;SYSTEM BUILD DATE
	NB%SID==:<POINT 18,NDBSID(W),35>	;SYSTEM ID
	NB%MOM==:<POINT 36,NDBMOM(W),35>	;MAX. OUTSTANDING MSG. COUNT
	NB%DEV==:<POINT 9,NDBDEV(W),8>		;FIRST DEVICE

;POINTERS TO THE OUTPUT MESSAGE NUMBERS

	NB%LAR==:<POINT 8,NDBMNM(W),7>		;LAST ACK RECEIVED
	NB%LAP==:<POINT 8,NDBMNM(W),15>		;LAST OUTPUT MSG ACKED
	NB%LMS==:<POINT 8,NDBMNM(W),23>		;LAST MESSAGE SENT
	NB%LMA==:<POINT 8,NDBMNM(W),31>		;LAST MSG NUMBER ASSIGNED

;POINTERS TO THE INPUT MESSAGE NUMBERS

	NB%LAS==:<POINT 8,NDBMNM+1(W),7>	;LAST ACK SENT
	NB%LMR==:<POINT 8,NDBMNM+1(W),15>	;LAST MESSAGE RECIEVED
	NB%LMP==:<POINT 8,NDBMNM+1(W),23>	;LAST MESSAGE PROCESSED
SUBTTL	NDT -- NETWORK DEVICE TABLE

;THE NETWORK DEVICE TABLE IS USED TO DEFINE THE CHARACTERISTICS OF
; VARIOUS NETWORK DEVICES.

	%%%OFF==0		;MAKE SURE WE START AT ZERO

	X	NDTNAM		;XWD NAME,NAME ;GENERIC DEVICE NAMES
	X	NDTMOD		;EXP DEVMOD
	X	NDTATR		;XWD OBJECT-TYPE,ATTRIBUTES
	X	NDTCHR		;BYTE (6)DEVTYP(12)BUFFER-SIZE(8)SPOOL(10)0
	X	NDTCNI		;ADDRESS OF CONNECT INIT PROCESSOR
	X	NDTDSP		;POINTER TO DEVSER DISPATCH TABLE (@N---DP(T4))
	X	NDTNDP		;POINTER TO NETSER DISPATCH TABLE (@---NDP(T1))
	X	NDTLEN,0	;LENGTH OF THE DEVICE TABLE


;BYTE POINTERS INTO A NETWORK DEVICE TABLE (INDEXED BY "W")

	ND%TYP==:<POINT  6,NDTCHR(W),5>		;DEVTYP BYTE
	ND%BFZ==:<POINT 12,NDTCHR(W),17>	;DEFAULT BUFFER SIZE
	ND%SPL==:<POINT  8,NDTCHR(W),25>	;SPOOL BITS
	ND%DVT==:<POINT 16,NDTATR(W),35>	;DEVICE ATTRIBUTES
	ND%OBJ==:<POINT  8,NDTATR(W),17>	;DEVICE OBJECT TYPE
	ND%DCM==:<POINT 10,NDTATR(W),9>		;DEVICE MODES
SUBTTL NPD -- NETWORK PROCESS DESCRIPTOR BLOCK.

	%%%OFF==0		;INITIALIZE THE OFFSET

	X	NPDBLK		;XWD LENGTH-OF-NPD(WORDS),0
	X	NPDNOD		;EXP NODE-NUMBER (-1 = WILD-CARD)
	X	NPDNLN		;EXP LENGTH OF TASK NAME
	X	NPDNAM		;BLOCK ? WORDS OF TASK NAME



SUBTTL	STC -- STATION CONTROL MESSAGE BLOCKS

	%%%OFF==0		;INITIALIZE THE OFFSET

	X	STCBLK		;XWD LENGTH OF THE MESSAGE (8 BIT BYTES),LINK
	X	STCMSN		;THIS IS ZERO TO IDENTIFY IT AS A ANF-10 MSG
	X	STCLNN		;XWD  BYTE-CNT,LINE-NUMBER (INPUT STC ONLY)
	X	STCDAT		;FIRST WORD OF STC DATA

;LENGTH OF STC BLOCK IN WORDS IS  "2+<LEN+3>/4"
	SUBTTL	KDP -- KDP BLOCK.  ONE FOR EACH KMC-11 THAT DRIVES DUP-11'S


;TRADITIONALY INDEXED BY "W"

	%%%OFF==0		;INITIALIZE FOR "X" MACRO

	KDPQLN==^D32		;32 QUEUE ENTRIES IN TRANSACTION Q (64 WORDS)
	MXNDUP==^D2		;MAXIMUM NUMBER OF DUP-11'S ON THE KMC-11

	X	KDPCSR		;XWD UBA #,ADDRESS OF KMC-11 CSR (KMC1BA)
	X	KDPVEC		;ADDRESS OF KMC-11 VECTOR (540 = KMC1IV)
	X	KDPIMR		;INITIAL MAP REGISTER FOR PAGE
	X	KDPIEA		;INITIAL ELEVEN ADDRESS
	X	KDPNUM		;NUMBER OF THIS KDP. (ZERO UNLESS MORE THAN
				;  ONE KMC-11 ON THE MACHINE)
	X	KDPDPN		;NUMBER OF DUP-11'S ON THIS KMC (AKA. KDPMRC)
	X	KDP1DP		;-11 ADDRESS OF FIRST DUP-11
	X	KDPKDL,MXNDUP	;"XWD FEK,KDL"  ONE PER DUP-11
	X	KDPIVA,15	;CODE FOR INTERRUPT SERVICE (VECTOR A)
	X	KDPIVB,15	;CODE FOR INTERRUPT SERVICE (VECTOR B)
	X	KDPRGS,2	;KMC-11 CSR'S WHEN KMC-11 LAST CRASHED
	X	KDPCPC		;PC OF THE LAST CALLER TO KDPERR.
	X	KDPZER,0	;START ZERO-ING HERE ON A RESTART
	X	KDPSTS		;STATUS.
	    KDPSRU==1B0		;SAYS KMC-11 IS BELIEVED TO BE RUNNING

	X	KDPACT		;COUNT OF VECTOR "A" INTERRUPTS
	X	KDPBCT		;COUNT OF VECTOR "B" INTERRUPTS
	X	KDPIQT		;INPUT QUEUE "TAKER"
	X	KDPIQP		;INPUT QUEUE "PUTTER"
	X	KDPINQ,2*KDPQLN	;KMC-11 INPUT QUEUE.  TWO WORD ENTRYS CONTAIN
				;  XWD 0,SEL2
				;  XWD SEL4,SEL6

	X	KDPLEN,0	;LENGTH OF A KDP BLOCK
	SUBTTL	KDL --  KMC/DUP-11 LINE BLOCKS.  ONE PER DUP-11. INDEXED BY "F"

	KDLMMS==340		;THE MAXIMUM MESSAGE SIZE (WORDS)
				; (THIS IS BASICALLY (((KDLPPL*1000)-KDLEST)/4)
				;  I.E., THE FOUR BUFFERS THAT WILL FIT WITHIN
				;  THE NUMBER OF PAGES AVAILABLE FOR EACH KDL:
				;    KDLMMS==160 (~^D450 BYTES) FOR ONE PAGE;
				;    KDLMMS==360 (~^D960 BYTES) FOR TWO PAGES;
				;  AND SO ON)

	%%%OFF==0		;INITIALIZE FOR "X" MACRO

	X	KDLUSR		;CODE OF FOR THE "USER" OF THE BLOCK
	X	KDLFEK		;BLOCK ADDRESS IF ANF-10 (FROM KDP BLOCK)
	X	KDLDDB		;BLOCK ADDRESS IF PROGRAM (SETUP ON ASSIGN)
	X	KDLLBK		;BLOCK ADDRESS IF DECNET (SETUP ON INIT)
	X	KDLDLX		;BLOCK ADDRESS IF IBM (SET UP ON INIT)
	X	KDLINE		;CONTAINS OUR LINE NUMBER (BSEL3)
	X	KDLFZR,0	;START ZEROING HERE ON AN INIT
	X	KDLKDP		;POINTS TO KDP. (KDPLIN+KDLINE POINTS TO KDL)
	X	KDLCSR		;CONTAINS CSR ADDRESS OF DUP-11 (FOR BASE-IN)
	X	KDLMAP		;ADDRESS OF UBA MAP REGISTER FOR THIS PAGE
	X	KDLADR		;CONTAINS UNIBUS ADDRESS OF THIS PAGE
	X	KDLCPC		;PC OF LAST CALLER OF KDLERR

	X	KDLZER,0	;ZERO FROM HERE ON DOWN
	X	KDLWTO		;QUEUE OF PCB'S AWAITING OUTPUT
	X	KDLWTA		;QUEUE OF PCB'S AWAITING AN ACK
	X	KDLCTA		;COUNT OF PCB'S AWAITING ACK. THIS IS
				;  USED TO PREVENT GETTING MORE THAN "MAXOUT"
				;  MESSAGES "IN THE PIPE" AT ONCE
	X	KDLSTS		;BYTE (18)BITS,(3)STATE,(15)BITS
	X	KDLSTX		;BYTE (18)FREE,(9)TIMER,(9)XNAK
	X	KDLMNM		;BYTE (8)RMN,LMX,LMA (12)REPC

	X	KDLZTM		;SECONDS SINCE COUNTERS WERE CLEARED
;	X	KDLXMC		;TRANSMITTED MESSAGE COUNT
;	X	KDLRMC		;RECEIVED MESSAGE COUNT
	X	KDLCTO,11	;CONTROL OUT COUNTS.
				; (06) ABORT RECEIVED (WE SHOULDN'T GET ANY)
				; (10) INVALID DDCMP HEADER
				; (12) BAD CRC
				; (14) BUFFER NOT AVAILABLE
				; (16) DATASET READ TRANSITION
				; (20) NXM (PDP-11 MEMORY)
				; (22) TRANSMIT UNDERRUN
				; (24) RECEIVE OVERRUN
				; (26) KILL COMPLETE
	X	KDLNKR,10	;COUNT OF RECEIVED NAKS. (SEE NAKTRN)
				; FIRST IS RANDOM, REST BY NAK CODE.
	X	KDLNKX,10	;COUNT OF TRANSMITTED NAKS.
				; FIRST IS RANDOM, REST BY NAK CODE.
	X	KDLDTR		;COUNT OF DATA MESSAGES RECEIVED
	X	KDLMAR		;COUNT OF MAINTENANCE MESSAGES RECEIVED
	X	KDLCTR,7	;COUNT OF CONTROL MESSAGES (BY TYPE)
	X	KDLDTX		;COUNT OF DATA MESSAGES SENT
	X	KDLMAX		;COUNT OF MAINTENANCE MESSAGES SENT
	X	KDLCTX,7	;COUNT OF CONTROL MESSAGES SENT (BY TYPE)
	X	KDLEST,0	;END OF SECTION TO BE RETURNED AS STATUS.

;THE REST OF THE KDL BLOCK IS USED AS BUFFER SPACE FOR THE KDP.  SINCE
;  IT NEEDS ITS DATA BYTES SWAPPED IT IS MOST CONVENIENT TO COPY THE DATA
;  HERE AND SEND IT ALL IN ONE BUFFER DESCRIPTION LIST.
;THERE ARE TWO BUFFERS EACH FOR INPUT AND OUTPUT.  THE FIRST 4 WORDS OF
;  EACH IS USED TO STORE THE BUFFER DESCRIPTOR LIST.

	X	KDLXBC		;COUNT OF TRANSMIT BUFFERS QUEUED
	X	KDLXD1,KDLMMS+4	;FIRST TRANSMITTER BUFFER DESCRIPTOR
;	X	KDLXB1,KDLMMS	;FIRST TRANSMITTER BUFFER (FOLLOWS BDL)
	X	KDLXD2,KDLMMS+4	;SECOND TRANSMITTER BUFFER DESCRIPTOR
;	X	KDLXB2,KDLMMS	;SECOND TRANSMITTER BUFFER
	X	KDLRBC		;COUNT OF RECEIVE BUFFERS QUEUED
	X	KDLRD1,KDLMMS+4	;FIRST RECEIVE BUFFER DESCRIPTOR
;	X	KDLRB1,KDLMMS	;FIRST RECEIVE BUFFER
	X	KDLRD2,KDLMMS+4	;SECOND RECEIVE BUFFER DESCRIPTOR
;	X	KDLRB2,KDLMMS	;SECOND RECEIVE BUFFER

	X	KDLLAL,0	;LENGTH OF KDL
	KDLPPL==<<KDLLAL+PG.BDY>/PAGSIZ> ;CALCULATE THE NUMBER OF PAGES PER KDL
	KDLLEN==KDLPPL*PAGSIZ	;CALCULATE THE TOTAL LENGTH OF THE TABLE
;VALUES OF THE VARIOUS FIELDS IN KDLSTS

;BITS THAT SAY A CONTROL MESSAGE IS REQUIRED (IN "JFFO" PRIORITY ORDER).

	KDSSTR==1B0		;NEED TO SEND A START.
	KDSSTK==1B1		;NEED TO SEND A STACK.
	KDSNAK==1B2		;NEED TO SEND A NAK.
	KDSREP==1B3		;NEED TO SEND A REP.
	KDSDAT==1B4		;NEED TO SEND A DATA MESSAGE.
	KDSACK==1B5		;NEED TO SEND AN ACK.
	XMTBTS==KDSSTR!KDSSTK!KDSNAK!KDSREP!KDSACK ;MASK OF MOSTMSG BITS

;STATES (HIDDEN FROM KMC-11 IN TOP 2 BITS OF HALFWORD)

	KD%DWN==0		;CONTROL-OUT TO START NOT YET GIVEN.
	KD%INI==1		;{ BASE ! CONTROL } OUT HAS BEEN DONE
	KD%FLS==2		;SHUTTING LINE DOWN, BUFFERS FLUSHING.
	KD%MAI==3		;MAINTAINENCE MODE.
	KD%STR==4		;SENDING STARTS STATE.
	KD%STK==5		;SENDING STACK STATE.
	KD%RUN==6		;RUNNING.

;MORE BITS -- USED TO DETERMINE WHICH OF TWO BUFFERS SHOULD BE USED NEXT

	KDSNRB==1_0		;THE NEXT RECEIVE BUFFER THE KMC-11 SHOULD GIVE
	KDSNXB==1_1		;THE NEXT XMIT BUFFER THE KMC-11 SHOULD RETURN
	KDSRFL==1_2		;RECEIVE FLUSH IN PROGRESS (WAIT FOR CTLO26)
	KDSXFL==1_3		;XMIT FLUSH IN PROGRESS.


;BYTE POINTER DEFINITIONS TO STATUS AND COUNTER FIELDS IN THE KDL BLOCK

	KD%STA==:<POINT 03,KDLSTS(F),20>	;DDCMP STATE
	KD%TIM==:<POINT 09,KDLSTX(F),26>	;REP TIMER
	KD%XNK==:<POINT 09,KDLSTX(F),35>	;TRANSMIT NAK CODE

	KD%RMN==:<POINT 08,KDLMNM(F),07>	;RECEIVE MESSAGE NUMBER
	KD%LMX==:<POINT 08,KDLMNM(F),15>	;LAST MSG XMITTED
	KD%LMA==:<POINT 08,KDLMNM(F),23>	;LAST MSG ACK'ED
	KD%RPC==:<POINT 12,KDLMNM(F),35>	;REP COUNTER

	SYN	NETOFF,KDPOFF	;DEFINE THE INTERRUPT OFF
	SYN	NETON, KDPON	;  AND ON MACROS
	SUBTTL	DMR -- DMR11 Line Block.  One/DMR11, indexed by "W"

	%%%OFF==0		;Initialize for "X" macro

	DR%NBF==3		;Number of buffers/DMR XMT/RCV CHANNEL
				;Cost - ~ 700(8) words/increment
				;Make sure DMRPPL is big enf if change
	DMRPPL==3		;Number of pages per line (for bufs)
	DMRMMS==<<DMRPPL*4K-^D128>/<DR%NBF*2>>/4 ;Max msg size in 10 wds
		   ;Byte/pg - bastbl / # bufs * X+R /byte/wd

	X	DMRUSR		;User code for DMR (DD.xxx)
	X	DMRCSR		;Unibus address of DMR's CSR
	X	DMRVEC		;Unibus address of DMR's interrupt vector
	X	DMRMAP		;I/O address of mapping register for comm region
	X	DMREAD		;11 Address of comm region
	X	DMRTAD		;10 Address of comm region
	X	DMRLIN,0	;LH - Synch line number on this node
	X	DMRNUM		;RH - DMR # (0,1,2,...7)
	X	DMRIVA,15	;Vector A interrupt code
	X	DMRIVB,15	;Vector B interrupt code
	X	DMRCPC		;PC of last crash on this DMR
	X	DMRCRG,2	;CSR contents (1/2 wds) at last crash
	X	DMRFEK		;Address of FEK for this DMR
	X	DMRDDP		;Address of owning DDB (set @ OPEN)
	X	DMRLBK		;Address of DECnet Circuit block
	X	DMRDLX		;Address of DLX (for IBM comm)
	X	DMRSTS		;Software status of this line
	X	DMRCTT,11	;Control-out table by wierd code
	X	DMRMST		;Modem status at last interrupt
	X	DMRICT		;Number of times tried to start DMR
	X	DMRLUP		;Number of times we succeeded
	X	DMRLDN		;Number of times line went down
	X	DMRCLR,0	;Area to clear on a restart of this line
	X	DMRZTM		;Seconds since counters zeroed
	X	DMRACT		;Count of vector "A" interrupts
	X	DMRBCT		;Count of vector "B" interrupts
	X	DMRIQT		;Take pointer to input command queue
	X	DMRIQP		;Put pointer to input command queue
	X	DMRINQ,<2*<DMRIQN==40>> ;Input command queue for this DMR
	X	DMRWTO		;Queue of PCBs waiting for output(to DMR)
	X	DMRWTA		;Queue of output PCBs waiting for ack (from DMR)
	X	DMRCTA		;Number of PCBs in WTA queue(limit=comm size)
	X	DMRMAI		;Queue of Maint msgs waiting to be freed
	X	DMRMAC		;Number of messages in MAI queue
	X	DMRXBG		;Last buffer given to DMR
	X	DMRRBC		;Number of receive buffers queued to DMR
	X	DMRRBG		;Pointer to last receive buffer given to DMR
	X	DMRRBT		;Pointer to last receive buffer taken from DMR
	X	DMRRCC,DR%NBF	;Table of received char count for queued buffers
	X	DMRXMC		;Messages sent
	X	DMRRMC		;Messages received

	X	DMRLEN,0	;Length of a DMR block
	;Fields in DMRSTS

	;State codes (Bits 0-2)
	DR%HLT==0		;DMR is halted (probably due to error)
	DR%FLS==1		;DMR is halting (returning buffers)
	DR%MAI==2		;DMR is running in DDCMP maintenance mode
	DR%WT1==3		;DMR is init'd, waiting for a message to xmit
	DR%WTD==4		;DMR is init'd, waiting for a completion
	DR%RUN==5		;DMR is running in DDCMP data mode

	;Status bits
	DMRSSW==1B35		;DMR is connected to a switched line
	DMRSHD==1B34		;DMR is running in HDX mode
	DMRSLS==1B33		;DMR is using Long Start timer
	DMRSMT==1B32		;DMR is to start in maintenance mode
	DMRSTV==1B31		;DMR is starving - needs 1/x/sec attn
	SYN	NETOFF,DMROFF
	SYN	NETON,DMRON
SUBTTL NDP -- NETWORK DISPATCH TABLE

;NEGATIVE DISPATCH ENTRYS ARE NCL
;POSITIVE DISPATCH ENTRYS ARE DAP

	NDPNWD==:-5		;SOME NETWORK NODE WENT DOWN
	NDPDSC==:-4		;DISCONNECT
	NDPCNC==:-3		;CONNECT CONFIRM
	NDPCNI==:-2		;CONNECT INITIATE
	NDPDRQ==:-1		;DATA-REQUEST
	NDPICM==:0		;INTERRUPT LEVEL INPUT MESSAGE
	NDPDAT==:1		;DATA WITH OUT END-OF-RECORD
	NDPDAR==:2		;DATA WITH END-OF-RECORD
	NDPSTA==:3		;STATUS MESSAGE
	NDPCTL==:4		;CONTROL MESSAGE
	NDPUID==:5		;USER ID
	NDPFSP==:6		;FILE-SPEC


;*** FOOTNOTE ***

                               COMMENT @

     For a description of the context in which these entry points are used
see the following routines.

   Entry	    Described in Module(Routine)

NDPNWD			NETSER.MAC(CLNNDB)
NDPDSC - NDPCNI		NETSER.MAC(ICMCNT)
NDPICM - NDPFSP		NETSER.MAC(NTDISP)

                                   @
SUBTTL	RANDOM NETSER PARAMETERS

;SIZE OF NETWORK MESSAGE HISTOGRAM TABLE (BY POWER OF TWO)

NETLNH==<^D36-^L<^D1023>> + 1	;HANDLE UP TO 1023 BYTE MESSAGES
SUBTTL	LAT -- LINK ADDRESS TABLE

;THE LINK ADDRESS TABLE CONTAINS ONE WORD FOR EACH ACTIVE LINK.
; THE FORMAT OF A LAT ENTRY IS
;
;	BYTE	(6)FLAGS(6)STATE(24)DDB/LDB-POINTER
;
;IF THE ENTRY IS 0 THEN IT IS NOT IN USE. INDEX IS BY 'SLA' FIELD


;FIRST THE FLAGS

	LAT.TY==:(1B0)		;IF SET INDICATES THAT THIS IS A TERMINAL
				;  (IE. LDB) ENTRY
	LAT.VT==:(1B1)		;IF SET MEANS THIS IS A LOCAL TERMINAL
				;  "SET HOSTED" TO ANOTHER NODE


;THE STATE'S OF A CONNECT ARE AS FOLLOWS.

	LAT.ID==:0		;THE LAT IS IDLE (NO DDB/LDB ATTACHED)
	LAT.CI==:1		;WAITING FOR A CONNECT INITIATE (PASSIVE TASK)
	LAT.CC==:2		;CONNECT CONFIRM WAIT (DEVICE OR ACTIVE TASK)
	LAT.OK==:3		;NORMAL STATE (FULLY CONNECTED)
	LAT.DC==:4		;DISCONNECT CONFIRM WAIT (ALL TYPES)
	LAT.MX==:LAT.DC		;THE HIGHEST LEGAL STATE

;BYTE POINTERS INTO LAT ENTRIES

	LT%STA==:<POINT 6,0,11>		;POINT TO THE STATE BYTE IN A LAT ENTRY
	LT%PTR==:<POINT 24,0,35>	;POINT TO DDB/LDB ADDRESS IN LAT
					;  IF LAT.TY CLEAR THEN DDB ADDRESS
					;  IF LAT.TY SET THEN LDB ADDRESS
SUBTTL	MACROS

	DEFINE EMRGCY,<		;;SEE NETSER(NTUEFC) FOR DETAILS
	    IFNDEF NTUEFC,<EXTERNAL NTUEFC>
	    SETOM NTUEFC
>




SUBTTL XMT -- MACROS TO SEND NETWORK DATA.

                               COMMENT @

    XMT
	This macro sends the contents of its argument as an extensible
	binary number
    XMTI
	This macro sends its argument as an extensible binary number.
    XMT1 & XMT1I
	Analogous to XMT and XMTI except that the argument is considered to
	be a single eight bit byte.
    XMTB
	This macro takes as its argument the address of a byte pointer, and
	sends the specified byte as an extensible binary number
    XMTS
	This macro assumes that its argument points to a sixbit string of up to
	6 characters, and sends this as an extensible ascii string.
    XMTA
	This macro takes as its argument a byte pointer to an asciz string,
	and sends that string as extensible ascii.

                                   @
DEFINE XMT(A)<
IFDIF <T1><A>,<MOVE T1,A>
IFNDEF BI2EBI,<EXTERNAL BI2EBI>
	PUSHJ	P,BI2EBI
>

DEFINE XMT1(A)<
IFDIF <T1><A>,<MOVE T1,A>
IFNDEF DPBBIN,<EXTERNAL DPBBIN>
	PUSHJ	P,DPBBIN
>

DEFINE XMTI(A)<
IFNDEF BI2EBI,<EXTERNAL BI2EBI>
	MOVEI	T1,A
	PUSHJ	P,BI2EBI
>

DEFINE XMT1I(A)<
IFNDEF DPBBIN,<EXTERNAL DPBBIN>
	MOVEI	T1,A
	PUSHJ	P,DPBBIN
>

DEFINE XMTB(A)<
IFNDEF BI2EBI,<EXTERNAL BI2EBI>
	LDB	T1,A
	PUSHJ	P,BI2EBI
>

DEFINE XMTS(A)<
IFNDEF SX2EAS,<EXTERNAL SX2EAS>
IFDIF <T1><A>,<MOVE T1,A>
	PUSHJ	P,SX2EAS
>

DEFINE XMTA(A)<
IFNDEF AS2EAS,<EXTERNAL AS2EAS>
IFDIF <T1><A>,<MOVE T1,A>
	PUSHJ	P,AS2EAS
>

DEFINE XMTP(A)<
IFNDEF PP2EAS,<EXTERNAL PP2EAS>
IFDIF <T1><A>,<MOVE T1,A>
	PUSHJ	P,PP2EAS
>
;
;PARANOID IS A BITMASK OF SPECIAL THINGS TO CHECK
;

NDL PARANOID,-1			;DEFAULT TO MAXIMUM CONSISTANCY CHECKING

	P$PCB==1_0		;CHECK SELECTED PCB'S FOR VALIDITY
	P$FEK==1_1		;CHECK FEK'S FOR CONSISTANCY (1/SEC)
	P$LAT==1_2		;CHECK TO MAKE SURE ALL LAT ENTRYS ARE VALID
	P$EAT==1_3		;ENABLE THE "TROLL"
	P$DDB==1_4		;CHECK DDB'S
	P$NPD==1_5		;CHECK NETWORK CONNECT DESCRIPTOR BLOCKS
	P$TSK==1_6		;CHECK THE TASK DEVICE
	P$NDB==1_7		;CHECK NDB'S
	P$MCR==1_10		;CHECK MCR'S
	P$VTM==1_11		;CHECK VIRTUAL TERMINALS
	P$COR==1_12		;KEEP A CHAIN OF ALL OF NETSER'S CORE USAGE
	P$NTR==1_13		;KEEP TRACK OF WHO IS USING THE "NT" RESOURCE


	END			;OF NETPRM.MAC
