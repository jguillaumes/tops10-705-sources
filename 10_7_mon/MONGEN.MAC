TITLE	MONGEN - PROGRAM TO DEFINE MONITOR AND NETWORK CONFIGURATIONS - V103
SUBTTL	T. HASTINGS/TH/EP/DAL/JBS	17-APRIL-90

EDITNO==331		;EDIT NUMBER (**MUST MATCH "M.GEN" IN COMMON.MAC**)
VERSION==103		;MAJOR VERSION NUMBER
VMINOR==0		;MINOR VERSION NUMBER
VWHO==0			;WHO LAST EDITED

	SALL
	.DIRECT	FLBLST

;NOTE:	THE COPYRIGHT THAT FOLLOWS IS USED BY FGEN.  KEEP IT CLEAN AND
;	PRETTY SO OUTPUT FILES DON'T LOOK MESSY AND UNPROFESSIONAL.


;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED
;  OR COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
CPYTXT:	ASCIZ	&
      COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION, MAYNARD MASS.
	1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978
	      1979, 1980, 1982, 1984, 1986, 1987, 1988, 1990.
			ALL RIGHTS RESERVED.
&


	LOC	<JOBVER==137>		;VERSION NUMBER
	BYTE	(3)VWHO(9)VERSION(6)VMINOR(18)EDITNO
	RELOC

;SYMBOLS WHICH ARE PARAMETERS OF MONGEN ITSELF(PREFIX MP)
IFNDEF MP.MVN,<MP.MVN==^D704>	;MONITOR VERSION NUMBER
IFNDEF MP.PDL,<MP.PDL==40>	;PD LIST LENGTH
IFNDEF MP.AMX,<MP.AMX==^D10>	;MAX NO. OF ANSWERS INSIDE PARENS
IFNDEF MP.SMX,<MP.SMX==^D1>	;MAX SYSTEM (KL10 = 0, KS10 = 1)
IFNDEF MP.AQB,<MP.AQB==^D200>	;LENGTH OF AUTOCONFIGURE QUESTION BUFFER
IFNDEF MP.LMX,<MP.LMX==^D80>	;MAX. NO. OF CHAR ALLOWED IN INPUT LINE
				; NOT COUNTING EOL OR NULL
IFNDEF MP.FTA,<MP.FTA==^D50>	;NUMBER OF FEATURE TESTS THAT MAY BE ADDED
IFNDEF MP.FTL,<MP.FTL==^D80>	;LENGTH OF CUSTOMER DEFINE FEATURE DESCRIPTION

COMMENT	"

ASSEMBLY INSTRUCTIONS:
.COMPIL MONGEN

LOADING INSTRUCTIONS:
.LOAD MONGEN

DEBUGGING INSTRUCTION:
.DEBUG MONGEN
  BY DEPOSITING NON-ZERO IN LOCATION DEBUG WITH DDT, MONGEN WILL
  OUTPUT ALL FILE STUFF TO TTY TOO INSIDE <>.
"
;MONGEN IS A DIALOG PROGRAM(ACTUALLY 2 PROGRAMS IN ONE) WHICH
;ASKS THE CUSTOMER QUESTIONS ABOUT HIS CONFIGURATION.
;THE RESULTS OF THIS DIALOG ARE OUTPUT AS A FILE OF PARAMETER ASSIGNMENTS
;WHICH CAUSE CONDITIONAL ASSEMBLY IN THE DATA BASE MODULES OF THE MONITOR.
;THUS EACH CUSTOMER IS ABLE TO CUSTOM-MAKE HIS MONITOR FOR THE FEATURES
;HE WISHES DEPENDING ON HARDWARE AND SOFTWARE REQUIREMENTS.
;THESE PARAMETER ASSIGNMENTS TAKE THE FORM OF MACRO CALLS USING
; THE XP MACRO OF TWO ARGUMENTS AS DEFINED IN FILE S.MAC.  THE XP
; MACRO DEFINES THE FIRST SYMBOL TO BE EQUAL TO THE SECOND EXPRESSION
; AND DECLARES THE SYMBOL TO BE INTERNAL AND DDT OUTPUT SUPPRESSED.

;USER INSTRUCTIONS FOR RUNNING MONGEN:
;MONGEN WILL ASK YOU QUESTIONS ABOUT YOUR CONFIGURATION AND
; OUTPUT THEM IN A FILE.  TO HELP YOU ANSWER THESE QUESTIONS,
; MONGEN GIVES THREE LEVELS OF
; GUIDANCE.  SHORT MODE FOR THE VERY EXPERIENCED, PROMPT MODE
; WHERE YOU ARE GIVEN CHOICES, AND LONG MODE WHERE YOU
; ARE GIVEN THE CHOICES ALONG WITH AN EXPLANATION.  YOU MAY CHANGE
; THE MODE FOR A SINGLE QUESTION IF YOU DO NOT UNDERSTAND IT BY SIMPLY TYPING /H
; TO CHANGE THE MODE FOR THE REST OF THE QUESTIONS, TYPE /HELP:X
; WHERE X IS SHORT, PROMPT, OR LONG.  ACTUALLY MONGEN ALWAYS
; ALLOWS ABBREVIATIONS EVERYWHERE, SO S, P, AND L SUFFICE
; ALONG WITH H FOR HELP.
; QUESTIONS ASKING FOR A NUMBER(DECIMAL UNLESS SPECIFICALLY NOTED
; AS OCTAL) ALWAYS INDICATE THE RANGE INSIDE PARENS, IE (MIN-MAX).
; OTHER QUESTIONS ARE ASKING FOR ONE
; OF A LIST OF CHOICES.  THE CHOICES ARE LISTED INSIDE PARENS.
; STILL OTHER QUESTIONS ASK
; FOR Y OR N AND STILL OTHERS ASK FOR JUST A STRING.
; IN ALL QUESTIONS WHICH HAVE PROMPTING INSIDE PARENS, THE FIRST
; ITEM IN THE LIST IS CALLED THE DEFAULT AND IS ASSUMED IF YOU
; ANSWER JUST WITH CARRIAGE RETURN.
; (,ANS0,ANS1,...) MEANS NO DEFAULT ASSUMED ON JUST CR
; CALLER OF ASK ROUTINE MUST CHECK FOR N=0 IN THIS CASE AND TAKE
; APPROPRIATE ACTION.  (THIS FEATURE IS USED BY HELP ITSELF TO ALLOW
; JUST CR TO MEAN NEXT LONGER HELP MODE).


;RULE: ALL SYMBOLS ARE GENERATED ALL OF THE TIME,
; NO MATTER HOW DIALOG BRANCHES.  WHY?  SO USERS READING THE
; DATA BASE MODULES NEVER NEED TO LOOK AT MONGEN TO UNDERSTAND
; THE MONITOR.
;THE ONLY LOCAL STORAGE IN MONGEN IS USED TO STORE ANSWERS IF THE
; VALUES ARE NEEDED LATER FOR ERROR CHECKING.  MOST ANSWERS ARE OUTPUT
; IMMEDIATELY AND SO ARE NEVER STORED IN MEMORY.  BY CONVENTION THE NAMES
; OF VARIABLES WARE THE SAME AS THE ASSOCIATED SYMBOLS OUTPUT IN
; THE FILE.  OUTPUT SYMBOLS ALL START WITH THE TWO LETTERS "M."  OR "FT" THIS MAKES
; IT EASY TO RECOGNIZE SYMBOLS DEFINED BY MONGEN WHEN READING THE REST
; OF THE MONITOR.
;MONGEN IS STUPID AND SIMPLE MINDED.  IS KNOWS AS LITTLE ABOUT
; THE MONITOR AS POSSIBLE.  IT NEVER ADDS TWO ANSWERS TOGETHER, FOR EXAMPLE.
; IT ALWAYS GENERATES ALL SYMBOLS ALL THE TIME, NO MATTER
; HOW THE QUESTIONS ARE ANSWERED.  IT IS UP TO COMMON TO TAKE THE RAW DATA
; AND PERFORM COMPUTATION AND DEFINE NEW AND CONVENIENT SYMBOLS.
;THE FOLLOWING MACROS(AND SUBROUTINES BY THE SAME NAME) ARE USED TO ASK
; CUSTOMER QUESTIONS AND GET HIS ANSWERS:
;SOME ANSWERS ARE NUMERIC, WHILE OTHERS ARE CHOICES LIKE Y OR N
; OR AN ITEM OUT OF A LIST.  ALL ANSWERS ARE CHECKED FOR REASONABLENESS.
; THE GOAL IS TO PREVENT AS MANY ERRORS AS POSSIBLE, SINCE ERRORS
; ARE NOT USUALLY DISCOVERED UNTIL THE MONITOR IS LOADED AND SOMETIMES
; EVEN THEN IT IS HARD TO FIND THE PROBLEM.  ALL NUMERIC ANSWERS ARE
; CHECKED FOR MIN AND MAX AS INDICATED INSIDE PARENS WITH A -
; SEPARATING THE MIN AND MAX.  IF A NUMERIC QUESTION
; DOES NOT HAVE A RANGE SPECIFIED, MONGEN WILL PRINT
; ? INTERNAL MONGEN ERROR - ABOVE QUESTION MUST HAVE (...,MIN-MAX) -
; EDIT MONGEN.
; AND EXIT.  NOTE: (MIN-?) IS OK TO MEAN NO UPPER BOUND
;  THE PROGRAMMER MUST EDIT MONGEN TO FIX HIS BUG.
;  THE CUSTOMER SHOULD NEVER SEE THIS MESSAGE, SINCE IT IS A DEBUGGING
;  AID AND SHOULD BE CAUGHT DURING TESTING.
;EACH MACRO HAS A TEXT QUESTION AS AN ARGUMENT.  THE ANSWER IS RETURNED
; IN AC N.  IF AN ERROR IS DETECTED, THE QUESTION IS
; REASKED AT NEXT HIGHER LEVEL OF VERBOSITY.  RETURN IS ALWAYS WITH
; A SUCCESSFUL VALUE.  THE CUSTOMER MAY HAVE CHANGED LEVELS OF VERBOSITY
; USING THE /HELP: FEATURE.  LOCATION SAVLV HAS CURRENT PERMANENT LEVEL,
; WHILE LEVEL FOR CURRENT QUESTION IS KEPT IN AC LV.

;ASKYN  - ANSWER Y OR N, (Y=1, N=0) NOTE: OPPOSITE FROM ASKLST
;	  HOWEVER MORE USEFUL, SINCE CAN OUTPUT DIRECTLY IN XP MACRO
;	  WHERE XP SYMBOL,1 MEANS Y AND XP SYMBOL,0 MEANS N.
;	(Y,N) MUST APPEAR IN QUESTION AS A PROMPT.  FOR CONSISTENCY
;	THE Y MUST BE BEFORE THE N SO CR ALWAYS MEANS Y.
;ASKDEC - ANSWER DECIMAL NUMBER.  QUESTION SHOULD HAVE (DEFAULT,MIN-MAX).
;	IF NO DEFAULT IS REASONABLE(SUCH AS NUMBER OF JOBS), ONLY
;	(MIN-MAX) IS REQUIRED.
;ASKOCT - ANSWER OCTAL NUMBER.  QUESTION SHOULD HAVE (DEFAULT,MIN-MAX)
;	IF NO DEFAULT IS REASONABLE, ONLY (MIN-MAX) IS REQUIRED.
;ASKLIN - ANSWER OCTAL LINE NUMBER OR CTY
;ASKSTR - ANSWER ARBITRARY STRING.  STORED IN ASCSTR AS ASCIZ.
;	N=NO. OF CHARS IN STRING NOT COUNTING NULL OR CRLF.
;ASKLST - ANSWER ONE OF THE ITEMS IN THE PROMPTING LIST IN PARENS.
;	N=0,1,2,... IE POSITION OF ANSWER IN LIST.  IF ANSWER IS NOT
;	IN LIST OR ABBREVIATION IS NOT UNIQUE, THE QUESTION IS REASKED
;	AT HIGHER LEVEL OF VERBOSITY.  ERROR MESSAGES ARE:
;	? TYPE ENOUGH TO UNIQUELY DISTINGUISH ANSWER
;	? ANSWER WITH ONE OF THE CHOICES INSIDE ( )
;	? INTERNAL MONGEN ERROR - NO "(" IN ABOVE MESSAGE -
;	EDIT MONGEN AND ADD (ANS0,ANS1,...)
;	? INTERNAL MONGEN ERROR - TOO MANY POSSIBLE ANSWERS ABOVE -
;	EDIT MONGEN AND INCREASE MP.AMX
;ASKAUT - ANSWER "NO", "YES", OR "PROMPT" TO AUTOCONFIGURED DEVICE
;	QUESTIONS.
;TO ASK A MULTIPLE LINE QUESTION, THE FOLLOWING SPECIAL MACROS:
;ASKMN  - ANSWER M OR M,N WHERE M AND N ARE OCTAL LINE
;	NUMBERS OR JUST CTY
;ASKMNP - ANSWER M,P OR M-N,P WHERE M,N, AND P ARE OCTAL LINE NUMBERS
;
;ASKTMN - ANSWER M OR M,N OR ALL FOR 7 TRACK TAPE UNITS

;TO OUTPUT TO TTY, FILE OR BOTH, USE THE FOLLOWING:
; USUAL FILE OUTPUT RADIX IS OCTAL, WHILE TTY OUTPUT RADIX IS DECIMAL,
; UNLESS NAME HAS OCT OR DEC IN IT, IN WHICH THE RADICES ARE THE SAME.

;BTHOUT - OUTPUT DECIMAL TO BOTH TTY AND FILE, FILE AS A COMMENT(IE ; INSERTED)
;BTHOCT - OUTPUT OCTAL TO BOTH TTY AND FILE, FILE AS A COMMENT
;FILEOUT - OUTPUT TO FIL ONLY
;FILCOM - OUTPUT TO FILE ONLY AS A MULTI-LINE COMMENT(IE ; INSERTED)
;TTYOUT - OUTPUT TO TTY ONLY(DECIMAL)(USUAL)
;TTYOCT - OUTPUT TO TTY ONLY(OCTAL)(UNUSUAL)
;FILSTR - OUTPUT STRING IN ASCSTR TO FILE
;FILDEC - OUTPUT TO FILE WITH RADIX DECIMAL INSTEAD OF OCTAL
;FILDC2 - OUTPUT TO FILE WITH RADIX DECIMAL, AT LEAST 2 CHARS
;ALL OF THE ABOVE MACROS(AND SUBROUTINES) CAN HAVE A SECOND
; ARGUMENT WHICH IS THE LOCATION OF A VALUE TO BE SUBSTITUTED FOR * IN
; THE FIRST ARGUMENT.  THE VALUE CAN BE LEFT JUSTIFIED SIXBIT OR A NUMBER.
; IF THE LOCATION OF THE VALUE IS AC N, NO EXTRA INSTRUCTION IS GENERATED
; SINCE THE MACRO USUALLY PICKS UP THE LOCATION AND PUTS IT IN N.
; HOWEVER IT IS RECOMENDED THAT N BE INCLUDED AS THE SECOND ARGUMENT
; TO INDICATE TO THE READER THAT A SUBSTITION IS GOING TO TAKE PLACE USING N.
; ELSE NEW CODE MAY BE INTRODUCED WHICH USES N BEFORE THE MACRO CALL.
; WHENEVER THE CHARACTER @ IS SEEN IT IS CONVERTED TO CRLF.  THIS
; MAKES IT NICER FOR FORMATTING THE MESSAGES INSIDE <>, SINCE
; THE <CLOSE ANGLE> CAN ALWAYS BE ON THE SAME LINE, EVEN WHEN CRLF IS WANTED.

;EXAMPLE:
;	ASKYN	<LPT(Y,N)[LINE PRINTER AT STATION *]>,OSN
;	FILOUT	<MACRLP	*@>,N

;ALL SUBROUTINES WHICH IMPLEMENT THE MACROS HAVE THE SAME CALLING
; SEQUENCE:
;CALL:	MOVE	LV,QUESTION LEVEL -1 FOR SHORT, 0 FOR PROMPT, 1 FOR LONG
;	MOVE	N,+NUMBER OR LEFT JUSTFIED SIXBIT TO BE
;				; SUBSTITUTED FOR *
;	MOVEI	T1,ADR OF ASCIZ MESSAGE
;	PUSHJ	P,ASKXXX OR FILXXX OR TTYXXX OR BTHXXX
;	ALWAYS RETURN WITH ANSWER IN N( AND STRING IN ASCSTR) OR
;	ORIGINAL CONTENTS OF N IF JUST OUTPUT ROUTINE.
;ALL SINGLE LINE ANSWERS ARE ANSWERED ON THE SAME LINE AS QUESTIONS.
; THIS SAVES PAPER. THE FORMAT IS QUESTION(WITHOUT QUESTION MARK)
; FOLLOWED BY COLON AND ONE SPACE.

;ONLY THE ASK MACROS ADD ANY CHARACTERS TO THE TEXT IN THE FIRST
; ARGUMENT.  THE BEGINNING OF THE MESSAGE IS INSERTED AN ";	" AS
; A COMMENT FOR THE FIL, AND ": " IS APPENDED TO THE END
; OF THE QUESTION SO THAT ALL QUESTIONS LOOK ALIKE.  NONE OF THE
; OUTPUT ONLY MACROS ADD ANY SPECIAL CHARACTERS.

;BY CONVENTION PROMPTING IN () APPEARS BEFORE LONG DIALOG IN [].
; THUS A USER CAN TYPE ^O IF THE USER GETS BORED, AND GET THE MOST USEFUL
; OUTPUT FIRST.

;IF JUST A CR IS GIVEN TO A QUESTION WHICH HAS A LIST, THE FIRST
; ITEM IS ASSUMED.  THIS IS TRUE FOR DECIMAL AND OCTAL QUESTIONS TOO.

;ALL NUMERIC QUESTIONS MUST HAVE A RANGE SUPPLIED.
; IF ONE IS NOT, THE USER GETS:
; ? INTERNAL MONGEN ERROR - NO (...,MIN-MAX) IN ABOVE QUESTION -
; EDIT MONGEN AND INCLUDE IN QUESTION.

;ALL ERRORS WHICH ARE MONGEN'S RATHER THAN THE CUSTOMER'S, ARE PRECEDED
; WITH ? INTERNAL MONGEN ERROR - FOLLOWED BY THE PROBLEM AND WHAT
; THE PROGRAMMER SHOULD DO TO FIX MONGEN.  NOTE THAT
; THE CUSTOMER SHOULD NEVER SEE THESE, SINCE THEY ARE DEBUGGING AIDS.

;ALL ERROR MESSAGES START WITH "? ". THE SPACE FOLLOWING ? MAKES THEM
; DISTINGUISHABLE FROM MONITOR ERRORS WHICH HAVE NO SPACE.

;ALL STRINGS ARE ASCIZ INCLUDING AS INPUT FROM TTY.
; ALL EOL CHARS(CR,LF,FF,VT,ESC,ALT1,ALT2,^Z,^C) ARE STRIPPED OUT
; AND ARE REPLACED BY A NULL.  THIS MAKES IT EASY TO SCAN STRINGS
; SINCE END IS ALWAYS DETECTED BY JUMPE CH,
; OUTPUT TO FILE MUST PUT CRLF BACK IN EXPLICITLY BY USING
; @ OR FCRLF ROUTINE.  THIS MAKES OUTPUT FILE MORE INDEPENDENT FROM
; USER INPUT.

;TO HELP THE READER OF MONGEN:
; ALL JUMPS ARE DOWN THE PAGE, EXCEPT LOOPS
; MOST PUSHJ ARE TO ROUTINES DOWN THE PAGE

;DEFINE THE MACROS:
; THE FOLLOWING MACROS SUFFIX ": " TO ASK QUESTION
; AND GET ANSWER ON SAME LINE
DEFINE	CAL	(XXX,A,B,%C)<
	XLIST			;;ALWAYS TURN OFF LISTING
IFNB <B>,<IFDIF <B> <N>,<MOVE	N,B>>	;;PICK UP VALUE TO BE SUBSTITUTED FOR *
	JSP	T1,%C		;;SETUP T1 WITH MESSAGE ADR AND JUMP AROUND
				;; MESSAGE WHICH MAY BE TOO BIG TO FIT
				;; IN REMOTE LITERAL.
	ASCIZ	\A: \		;;THE QUESTION WITH ": "
	INTERN	XXX		;;DECLARE INTERN SO MACRO WILL NOT THINK XXX A MACRO
%C:!	PUSHJ	P,XXX		;;CALL THE SUBROUTINE XXX
IFE RJRSTF,<LIST>		;;TURN LISTING BACK ON UNLESS INSIDE RJRST MACRO
>

DEFINE	ASKYN	(A,B)<
	CAL	ASKYN,<A>,B>

DEFINE	ASKDEC	(A,B)<
	CAL	ASKDEC,<A>,B>

DEFINE	ASKOCT	(A,B)<
	CAL	ASKOCT,<A>,B>

DEFINE	ASKLIN	(A,B)<
	CAL	ASKLIN,<A>,B>

DEFINE	ASKSTR	(A,B)<
	CAL	ASKSTR,<A>,B>

DEFINE	ASKLST	(A,B)<
	CAL	ASKLST,<A>,B>

DEFINE	ASKAUT	(A,C,D,E,F),<CALAUT (ASKAUT,A,C,D,<E>,<F>)>


;THE FOLLOWING MACROS DO NOT HAVE ANY CHARACTERS ADDED TO QUESTION

DEFINE	CALAUT	(XXX,A,C,D,E,F),<
	INTERN	XXX		;;AVOID MACRO CONFUSION
	PUSHJ	P,XXX		;;CALL PROCESSOR
	JRST	L.'A		;;ALLOW SKIPS OVER MACRO TO WORK
	EXP	M.'A		;;M.XXXX ADDRESS
	EXP	<SIXBIT	/A/>	;;SIXBIT /M.XXXX/
	EXP	<SIXBIT	/C/>	;;SIXBIT DRIVER NAME
	EXP	D		;;FLAGS
	EXP	[ASCIZ \E\]	;;INTRODUCTORY TEXT
	ASCIZ	\F\		;;LONG TEXT
L.'A:
>

DEFINE	CAL2	(XXX,A,B,%C)<
	XLIST			;;ALWAYS TURN OFF LISTING
IFNB <B>,<IFDIF <B> <N>,<MOVE	N,B>>	;;PICKUP VALUE TO BE SUBSTITUTED FOR *
	JSP	T1,%C		;;SETUP T1 WITH MESSAGE ADR AND JUMP AROUND
				;; MESSAGE WHICH MAY BE TOO LONG FOR MACRO
				;; REMOTE LITERAL TABLE(14 WORDS)
	ASCIZ	\A\		;;THE QUESTION WITH NO ADDED CHARACTERS
	INTERN	XXX		;;DECLARE INTERN SO MACRO WILL NOT THINK XXX A MACRO
%C:!	PUSHJ	P,XXX		;;CALL THE SUBROUTINE TO JUST OUTPUT
IFE RJRSTF,<LIST>		;;TURN LISTING BACK ON UNLESS INSIDE RJRST MACRO
>
;OUTPUT IMMEDIATE VALUE

DEFINE	CAL3	(XXX,A,B,%C)<
	XLIST			;;ALWAYS TURN OFF LISTING
IFNB <B>,<IFDIF <B> <N>,<MOVEI	N,B>>	;;PICKUP VALUE TO BE SUBSTITUTED FOR *
	JSP	T1,%C		;;SETUP T1 WITH MESSAGE ADR AND JUMP AROUND
				;; MESSAGE WHICH MAY BE TOO LONG FOR MACRO
				;; REMOTE LITERAL TABLE(14 WORDS)
	ASCIZ	\A\		;;THE QUESTION WITH NO ADDED CHARACTERS
	INTERN	XXX		;;DECLARE INTERN SO MACRO WILL NOT THINK XXX A MACRO
%C:!	PUSHJ	P,XXX		;;CALL THE SUBROUTINE TO JUST OUTPUT
IFE RJRSTF,<LIST>		;;TURN LISTING BACK ON UNLESS INSIDE RJRST MACRO
>
DEFINE	ASKMN	(A,B)<
	CAL2	ASKMN,<A>,B>

DEFINE	ASKMNP	(A,B)<
	CAL2	ASKMNP,<A>,B>

DEFINE	ASKTMN	(A,B)<
	CAL2	ASKTMN,<A>,B>

DEFINE	BTHOUT	(A,B)<
	CAL2	BTHOUT,<A>,B>

DEFINE	BTHOCT	(A,B)<
	CAL2	BTHOCT,<A>,B>

DEFINE	FILOUT	(A,B)<
	CAL2	FILOUT,<A>,B>

DEFINE	FILCPU	(A,B)<
	CAL2	FILCPU,<A>,B>

DEFINE	FILCOM	(A,B)<
	CAL2	FILCOM,<A>,B>

DEFINE	FILOUD	(A,B)<
	CAL3	FILOUT,<A>,B>

DEFINE	TTYOUT	(A,B)<
	CAL2	TTYOUT,<A>,B
>
DEFINE	TTYOCT	(A,B)<
	CAL2	TTYOCT,<A>,B>

DEFINE	FILSTR	(A,B)<
	CAL2	FILSTR,<A>,B>

DEFINE	FILDEC	(A,B)<
	CAL2	FILDEC,<A>,B>

DEFINE	FILDC2	(A,B)<
	CAL2	FILDC2,<A>,B>

DEFINE	EREXIT	(A,B)<
	CAL2	EREXIT,<A>,B>
;DEFINE REMOTE MACROS WHICH ARE JUMPED TO ON UNUSUAL CASES
; INCLUDE CODE IN-LINE SO READABLE, BUT INDENT 2 TABS, JUST AS
; IF MULTI-LINE LITERAL.
;USED INSTEAD OF MULTI-LINE LITERAL BECAUSE MACRO LISTS
; SOURCE INSIDE OF MACROS INSIDE OF LITERALS

DEFINE	RJRST	(A,%B)<
	XLIST		;;TURN OFF LISTING SOURCE IN EXPANSION
RJRSTF==1		;;FLAG INSIDE OF RJRST, SO CAL MACRO
			;; WILL NOT TURN LIST BACK ON
	SKIPA		;;ALLOW MACRO IN ERROR RETURN OR AFTER TEST INSTR.
	JRST	%B	;;BY PASS UNUSUAL CODE
	A		;;THE UNUSAL CODE
RJRSTF==0		;;FLAG NO LONGER INSIDE RJRST MACRO
			;; SO FUTURE CAL MACROS WILL TURN LIST ON
%B:!	LIST		;;TURN LISTING BACK ON
>

DEFINE	RJUMPE	(AC,A,%B)<
	XLIST
RJRSTF==1		;;FLAG INSIDE OF RJRST, SO CAL MACRO
			;; WILL NOT TURN LIST BACK ON
	SKIPE	AC	;;CONDITION OF UNUSUAL CODE?
	JRST	%B	;;NO, BY PASS UNUSUAL CODE
	A		;;THE UNUSUAL CODE
RJRSTF==0		;;FLAG NO LONGER INSIDE RJRST MACRO
			;; SO FUTURE CAL MACROS WILL TURN LIST ON
%B:!	LIST		;;TURN LISTING BACK ON
>

DEFINE	RJUMPL	(AC,A,%B)<
	XLIST
RJRSTF==1		;;FLAG INSIDE OF RJRST, SO CAL MACRO
			;; WILL NOT TURN LIST BACK ON
	SKIPL	AC	;;CONDITION OF UNUSUAL CODE?
	JRST	%B	;;NO, BY PASS UNUSUAL CODE
	A		;;THE UNUSUAL CODE
RJRSTF==0		;;FLAG NO LONGER INSIDE RJRST MACRO
			;; SO FUTURE CAL MACROS WILL TURN LIST ON
%B:!	LIST
>

DEFINE	RJUMPN	(AC,A,%B)<
	XLIST
RJRSTF==1		;;FLAG INSIDE OF RJRST, SO CAL MACRO
			;; WILL NOT TURN LIST BACK ON
	SKIPN	AC	;;CONDITION OF UNUSUAL CODE?
	JRST	%B	;;NO, BY PASS UNUSUAL CODE
	A		;;THE UNUSUAL CODE
RJRSTF==0		;;FLAG NO LONGER INSIDE RJRST MACRO
			;; SO FUTURE CAL MACROS WILL TURN LIST ON
%B:!	LIST
>
DEFINE	RJUMPGE	(AC,A,%B)<
	XLIST
RJRSTF==1		;;FLAG INSIDE OF RJRST, SO CAL MACRO
			;; WILL NOT TURN LIST BACK ON
	SKIPGE	AC	;;CONDITION OF UNUSUAL CODE?
	JRST	%B	;;NO, BY PASS UNUSUAL CODE
	A		;;THE UNUSUAL CODE
RJRSTF==0		;;FLAG NO LONGER INSIDE RJRST MACRO
			;; SO FUTURE CAL MACROS WILL TURN LIST ON
%B:!	LIST
>

RJRSTF==0		;START FLAG AT 0 MEANING NOT INSIDE RJRST
;PARAMETERS:
;ACS
F=0		;FLAGS
  ;LH(DEFINED AS 36 BIT QUANTITIES):
  F.MTCH==1B0	;MATCH FOUND IN FNDASK ROUTINE
  F.OFO==1B1	;OUTPUT FILE OPEN.  FILE CALLS IGNORED IF 0
		; NEEDED SO ASK ROUTINES CAN BE USED TO ASK ABOUT FILE NAME
  F.TF==1B2	;TTY/FIL FLAG, 1 ON FIRST CHAR TO FILE
		; USED FOR DEBUG FEATURE TO PRINT <> ON TTY
		; SET BY TTYPUT ROUTINE, CLEARED BY FILPUT ROUTINE
  F.CTY==1B3	;CTY IS AN ACCEPTABLE OCTAL NUUMBER IF 1
		; SET BY ASKLIN, CLEARED BY ASKDEC,ASKOCT,ASKNUM ROUTINES
  F.FLF==1B4	;LAST CHAR ON FILE WAS LINE FEED
		; USED TO PRECEDE NEXT CHAR WITH ; TO MAKE A COMMENT IN FILE
		; IF F.COM IS ALSO ON.  SET, CLEARED AND LOOKED AT BY FILPUT ONLY
  F.COM==1B5	;MAKE ALL LINES TO FILE BE COMMENT IF THIS FLAG IS ON
		; USES F.FLF TO KNOW WHEN TO PUT ; OUT
		; SET AND CLEARED BY FILCOM AND TTYIN ROUTINES ONLY
		; LOKED AB BY FILPUT ROUTINE
  F.LPAR==1B6	;LEFT PAREN SEEN BY TTYOUT IN TTY OUTPUT STREAM.
		; USED TO SUPPRESS PROMPTING IF IN SHORT HELP MODE
		; CLEARED WHEN RIGHT PAREN SEEN.  SET, CLEARED,
		; AND USED BY TTYOUT ROUTINE ONLY.
  F.LBRK==1B7	;LEFT BRACKET SEEN BY TTYOUT IN TTY OUTPUT STREAM
		; YSED TO SUPPRESS EXPLANATION UNLESS IN LONG MODE
		; SET, CLEARED AND TESTED BY TTYOUT ROUTINE ONLY
  F.CONZ==1B8	;CONTROL Z TYPED IN ON TTY, SET BY TTYGET
;FREE B9
;FREE B10
;FREE B11
  F.2DEC==1B12	;SET IF WANT AT LEAST TWO CHARS IN DECIMAL OUTPUT
  F.NEG==1B13	;ALLOW NEGATIVE VALUE IN GETOCT/GETDEC/GETNUM
  F.PER==1B14	;SET IF A PERIOD, DOLLAR SIGN  OR PERCENT CAN BE PART OF SYMBOL
		; USED TO DISTINGUISH BETWEEN FILE NAMES AND SYMBOLS
  F.INFO==1B15	;SET BY ASKMNP TO INDICATE MORE INFO WILL FOLLOW M-N OR CTY
		; RESET BY ASKMN TO INDICATE END OF STRING EXPECTED AFTER M,M-N, OR CTY
  F.BANG==1B16	;ALLOW THE INPUT LINE TO CONTAIN A "!" WITHOUT TAKING
		;  IT AS A COMMENT
  F.SUPP==1B17	;SUPPRESS FILE OUTPUT (ONE SHOT)
;RH(F) BITS
	F.DVCP==1B21	;AUTOCONFIGURE - RESERVE DEVICE SLOT PER CPU
	F.MBUS==1B22	;AUTOCONFIGURE - MASSBUS DEVICE
	F.KS10==1B23	;AUTOCONFIGURE - KS10
	F.KL10==1B24	;AUTOCONFIGURE - KL10
	F.NEVR==1B25	;AUTOCONFIGURE - NEVER LOAD DRIVER
	F.LOAD==1B26	;AUTOCONFIGURE - ALWAYS LOAD DRIVER

N=1		;NUMERIC VALUE OF ASKED QUESTION.
		; ALSO USED TO SUBSTITUTE FOR * IN ALL STRINGS.
		; CAN BE LEFT JUSTIFIED SIXBIT.
		; YES ANSWERS ARE 1, NO ANSWERS ARE 0.
T1=2		;TEMPORARY AC. USUALLY ADR OF ASCIZ MESSAGE ON SUB CALL.
T2=T1+1		;FOR REMAINDER IN DIVISION
WD=4		;WORD AC ON CALLS TO GETWRD(LEFT JUSTIFIED SIXBIT)
B=5		;BYTE POINTER TO TEXT STRING
R=6		;INPUT AND OUTPUT RADIX
LV=7		;MODE OF ASKING QUESTIONS(-1=SHORT,0=PROMPT,1=LONG)
I=10		;INDEX FOR LOOP COUNTS
CH=11		;CHARACTER AC
I2=12		;SECOND INDEX FOR LOOP COUNTS
I3=13		;3RD INDEX FOR LOOP COUNTS
;RH12=14	;=0 FOR RH10, =1 FOR RH20	;FREE AC
P1=15		;"PERMANENT" ACS. THE SAVE ROUTINES DON'T EXIST,
P2=16		; USE AT GEN LEVEL FOR LOOP VARIABLES, ETC.
P=17		;PD POINTER

;SPECIAL ASCII CHARACTERS(NEVER CODE IN OCTAL SO CAN USE CREF):
C.RUB==177	;RUBOUT
C.ALT1==175	;OLD ALT MODES
C.ALT2==176	;OLD ALT MODE ON SOME TTYS
C.ESC==33	;MAP ALTS INTO ESCAPE
C.CONZ==32	;CONTROL Z
C.FF==14	;FORM FEED
C.CR==15	;CARIAGE RETURN
C.LF==12	;LINE FEED
C.CONC==3	;CONTROL C
;STANDARD MAXIMUMS FOR QUESTIONS

SM.CPU==6	;MAXIMUM NUMBER OF CPUS
SM.JOB==777	;MAXIMUM NUMBER OF JOBS SYSTEM MAY INCLUDE
SM.PI==7	;MAXIMUM PI CHANNEL NUMBER
SM.AC==17	;HIGHEST AC NUMBER FOR HIGHEST-AC-TO-SAVE
SM.RTD==^D77	;MAXIMUM NUMBER OF REAL TIME DEVICES
SM.HPQ==^D15	;MAXIMUM NUMBER OF HIGH PRIORITY QUEUES
SM.DTA==2	;MAXIMUM NUMBER OF DTA CONTROLLERS
SM.CONN==^D512	;MAXIMUM NUMBER OF CONNECTS
SM.RTY==^D511	;MAXIMUM NUMBER OF REMOTE TTYS
SM.KDUP==^D2	;MAXIMUM NUMBER OF DUP-11S ON A KMC-11
SM.DMRN==^D8	;Maximum number of DMR11s on a 2020
SM.RXK==^D2	;Maximum number of RX211 controllers on a 2020
SM.RXD==^D2	;Maximum number of RX02 drives on an RX02
SM.TTG==^D8	;MAXIMUM NUMBER OF TTY 8-LINE GROUPS
SM.68L==^D100	;MAXIMUM NUMBER OF LINES ON DC68
SM.MPI==^D16384	;MAXIMUM NUMBER OF PAGES SUPPORTED ON KL10
SM.XTC==4	;MAXIMUM NUMBER OF DA28C CHANNELS
SM.D78==^D8	;MAXIMUM NUMBER OF DAS78S (IBM 360,370,2780 SUPPORT)
SM.D60==^D7	;MAXIMUM NUMBER OF DN60S (IBM BSC INTERFACES)
SM.LMC==^D100	;MAXIMUM NUMBER OF SIMULTANEOUS LAT CIRCUITS
;DEFAULT VALUES OUTPUT BY MONGEN, MOSTLY FOR OLD SYMBOLS

IFNDEF MD.SEG,<MD.SEG==0>	;ALWAYS NO EXTRA SEGMENTS
;IO CHANNELS:
TTYCHN==0	;TTY INPUT AND OUTPUT CHANNEL
FILCHN==1	;FILE OUTPUT CHANNEL
MICCHN==2	;CHANNEL TO WRITE .MIC FILE ON

;IO STATUS BITS:
IO.EOF==20000	;END OF FILE

;NUMBER OF I/O BUFFERS
NFILBF==2	;NUMBER OF BUFFERS FOR FILE OUTPUT
NMICBF==2	;NUMBER OF BUFFERS FOR MIC FILE

;OPDEFS:
OPDEF	PJRST	[JRST]		;EQUIVALENT TO PUSHJ POPJ PAIR
OPDEF	PJUMPE	[JUMPE]		;EQUIVALENT TO JUMPE [PJRST]
OPDEF	GETTAB	[CALLI 41]	;READ MONITOR TABLE
OPDEF	SAVE.	[CALLI 210]	;SAVE. UUO

;UUOSYM SYMBOLS

.GTPRG==3			;PROGRAM NAME
.GTRDV==135			;DEVICE PROGRAM IS RUN FROM
.GTRDI==136			;DIRECTORY PROGRAM IS RUN FROM
.GTRFN==137			;FILE PROGRAM IS RUN FROM
.GTRS0==145			;SFD PROGRAM IS RUN FROM
.PTPPN==2			;PPN OF THE PATH
.PTSFD==3			;BEGIN SFDS IN PATH BLOCK
.PTMAX==11			;LENGTH OF PATH BLOCK
SUBTTL	INITIALIZATION, AND DISPATCH TO PROPER GEN, CLOSE FILES

BEGINA:	JFCL			;NOT CCL
	;THERE ONCE WAS MISGUIDED CODE TO TRY AND DO THIS BUT ONCE.
	;SAID CODE FORGOT THAT RESET CHANGED .JBFF TO LH(.JBSA).
	;SAID CODE ISN'T NEEDED, AS WE USE GETTAB, NOT SAVGET ACS NOW.
	HRROI	T1,.GTRDV	;GET DEVICE WE RAN FROM
	GETTAB	T1,
	  SETZ	T1,		;ERROR, ZERO THE AC
	MOVEM	T1,RUNDEV	;STORE
	HRROI	T1,.GTRDI	;GET THE PPN WE RAN FROM
	GETTAB	T1,
	  SETZ	T1,		;ERROR. ZERO THE AC
	MOVEM	T1,RUNPPN	;STORE
	MOVEM	T1,RUNPTH+.PTPPN;STORE PPN IN PATH BLOCK TOO
	MOVSI	T2,-5		;SET UP AOBJN FOR SFD GETTABS

BEGINB:	HRROI	T1,.GTRS0(T2)	;GET AN SFD NAME
	GETTAB	T1,
	  JRST	BEGINC		;NO MORE SFDS
	JUMPE	T1,BEGINC	;END OF SFDS
	MOVEM	T1,RUNPTH+.PTSFD(T2)	;STORE THE SFD NAME IN THE PATH BLOCK
	AOBJN	T2,BEGINB	;GET NEXT SFD

BEGINC:	SETZM	RUNPTH+.PTSFD(T2);ZERO NEEDS TO TERMINATE THE PATH BLOCK
	MOVEI	T1,RUNPTH	;GET ADDRESS OF PATH BLOCK
	SKIPE	RUNPTH+.PTSFD	;ANY SFDS?
	MOVEM	T1,RUNPPN	;YES. POINT TO PATH BLOCK FOR LOOKUP

BEGIN0:	RESET			;RESET IO DEVICES
	SETOM	INIFLG		;IN INITIALIZATION
	MOVE	P,[IOWD MP.PDL,PDLIST]	;INITIALIZE PD PTR
	SETZM	MICFLG		;NO MIC YET
	MOVE	LV,SAVLV	;PROMPT VALUE
	SETZ	F,		;INIT FLAGS
	ASKYN	<Write MONGEN.MIC (YES,NO) [
YES causes MONGEN to write a .MIC/.CTL file which may be used to automate 
future runs of MONGEN.]>
	SETOM	MICFLG		;ASSUME OK
	SKIPN	N		;SKIP IF NO (WHO WOULD SAY NO?)
	 SETZM	MICFLG		;SPIDER WAS RIGHT, SOMEONE DID.  SIGH.
	JUMPE	N,BEGIN		;DON'T WANT TO WRITE FILE, SKIP THE ENTER
	INIT	MICCHN,1	;MIC FILE
	 SIXBIT	/DSK/
	 XWD	MOBUF,0
	  SETZM	MICFLG		;ERROR
	MOVEI	T1,3+1B18	;NON-SUPER ENTER
	SETZ	T2,		;PPN
	DMOVE	T2+1,[SIXBIT /MONGENMIC/]
	ENTER	MICCHN,T1	;OPEN FILE
	 HRRZM	T1+3,MICFLG	;ERROR
	SKIPL	MICFLG		;STILL OK?
	JRST	BEGIN		;NOPE
	PUSH	P,.JBFF##	;SAVE JOBFF
	MOVEI	T1,MICBUF	;ADDR OF MIC BUFFERS
	MOVEM	T1,.JBFF	;SET UP JOBFF TO ALLOCATE OUR BUFFERS
	OUTBUF	MICCHN,NMICBF	;ALLOCATE BUFFERS
	POP	P,.JBFF##	;RESTORE JOBFF
	MOVEI	T1,[ASCIZ	/.RUN /]
	PUSHJ	P,MICSTR
	SKIPN	T1,RUNDEV	;DEVICE
	 MOVSI	T1,(SIXBIT/DSK/)
	PUSHJ	P,MICSIX	;SORTA-LIKE DEEP-SIX
	MOVEI	CH,":"
	PUSHJ	P,MICPUT
	HRROI	T1,.GTPRG	;FILE
	GETTAB	T1,
	 SETZ	T1,
	SKIPN	T1
	 MOVE	T1,[SIXBIT /MONGEN/]
	PUSHJ	P,MICSIX
	SKIPN	T1,RUNPTH+.PTPPN
	 JRST	BG0.ND		;DONE
	MOVEI	R,10		;OCTAL OUTPUT
	HLRZ	T1,T1		;PROJ
	MOVEI	CH,"["
	PUSHJ	P,MICPUT
	PUSHJ	P,MICNUM
	MOVEI	CH,","
	PUSHJ	P,MICPUT
	HRRZ	T1,RUNPTH+.PTPPN;PROG
	PUSHJ	P,MICNUM
	MOVSI	N,-5
BG0.SF:	SKIPN	T1,RUNPTH+.PTSFD(N);ANY SFDS?
	 JRST	BG0.ED		;NO, END DIRECTORY
	MOVEI	CH,","
	PUSHJ	P,MICPUT
	PUSHJ	P,MICSIX	;PRINT SFD NAME
	AOBJN	N,BG0.SF	;LOOP FOR ALL

BG0.ED:	MOVEI	CH,"]"
	PUSHJ	P,MICPUT

	;NO DIRECTORY
BG0.ND:	MOVEI	T1,[ASCIZ /
;Write MONGEN.MIC (YES,NO)
*Y
/]
	PUSHJ	P,MICSTR
BEGIN:	MOVE	P,[IOWD MP.PDL,PDLIST]	;RESET PD PTR, SINCE HERE ON IO ERRORS
				; FROM ROUTINE DEEP IN STACK
	SETZB	F,VARBEG	;CLEAR ALL FLAGS AND VARIABLE AREA
				; EXCEPT SAVLV WHERE VERBOSITY
				; LEVEL IS SAVED AND DEBUG AND HELPF
	MOVE	LV,SAVLV	;SETUP HELP LEVEL FOR NEXT QUESTION
				; FROM LONG TERM VALUE(INITIALLY PROMPT)
				; ^C START REMEMBERS LAST PERMANENT LEVEL
				; SINCE SAVLV IS NOT CLEARED
	MOVE	T1,[XWD VARBEG,VARBEG+1]
	BLT	T1,VAREND	;CLEAR VARIABLE AREA
	INIT	TTYCHN,1	;TTY IN LINE MODE
	SIXBIT	/TTY/
	XWD	TOBUF,TIBUF	;OUTPUT,INPUT BUFFER HEADERS
	  RJRST	<EREXIT	<Cannot INIT TTY>,,>	;TYPE ? INTERNAL ERR AND EXIT
	SKIPLE	MICFLG		;MIC FILE OK?
	 PUSHJ	P,[SKIPN INIFLG	;HAVE WE HAD A CHANCE TO COMPLAIN BEFORE?
		    POPJ P,	;YES, LET US NOT REPEAT OURSELF
		   SETZM INIFLG	;TTY IS OK BY NOW
		   TTYOUT <@% DSK:MONGEN.MIC will not be written@>
		   SKIPG N,MICFLG;SKIP IF ERROR CODE AVAIL
		    POPJ P,	;NOPE
		   SETZM MICFLG	;WE SAW IT, FLAG MEANS SOMETHING DIFFERENT NOW
		   CAIN	N,4	;IS THIS ERAEF%?
		    JRST [TTYOUT <% File DSK:MONGEN.MIC already exists@>
			 POPJ	P,]
		   TTYOCT <% ENTER error * >
		   POPJ	P,]
	SETZM	INIFLG		;TTY IS OK NOW
	AOSG	HELPF		;ALREADY TOLD USER ABOUT HELP?
	PUSHJ	P,TTYHLP	;NO, ASK USER FOR LEVEL OF VERBOSITY WITH /HELP
	TLZ	F,(F.CONZ)	;CLEAR CONTROL Z TYPED FLAG

ASKGEN:	ASKLST	<Which GEN (SYS,F) [
Type SYS to define hardware and software configuration, or type F to define 
software features.  To EXIT, type CTRL/Z.]>
	TLNE	F,(F.CONZ)	;DID USER TYPE CONTROL Z?
	  RJRST	<SKIPN	MICFLG	;MIC FILE OPEN?
		  EXIT		;NO
		 CLOSE	MICCHN,	;SAVE MIC FILE
		 TTYOUT	<@DSK:MONGEN.MIC written@>
		 EXIT>		;YES, EXIT TO MONITOR
	MOVEM	N,WCHGEN	;STORE WHICH GEN(0=SYS, 1=F)

;LOOP TO ASK FOR FILE UNTIL SUCCESSFUL ENTER CAN BE DONE.  SO INIT VARIABLES.
ASKFIL:	MOVSI	T1,(SIXBIT /DSK/) ;ASSUME DSK
	MOVEM	T1,OUTDEV	;IF USER DOES NOT SPECIFY DEVICE
	MOVE	N,WCHGEN	;THE GEN NUMBER(0-1)
	MOVE	N,FILTAB(N)	;DEFAULT FILE NAME FOR THIS GEN
				; SYSCNF,F
	HLLZM	N,WCHNAM	;STORE NAME OF THIS GEN(SYS,F)
	MOVEM	N,OUTNAM	;ALSO SETUP DEFAULT FILE NAME FOR THIS GEN
	MOVSI	T1,(SIXBIT /MAC/) ;ASSUME EXTENSION OF MAC
	MOVEM	T1,OUTEXT	;FOR FILE EXTENSION
	SETZM	OUTDAT		;CLEAR DATE ARG
	SETZM	OUTPPN		;AND PROJECT,PROGRAMMER ARG
	ASKSTR	<Output(DSK:*.MAC)>,OUTNAM ;ASK FOR FILE SPEC
	MOVEI	WD,0		;SET WORD VALUE TO 0 AS FLAG THAT NO SPEC
	JUMPE	CH,OPNDEV	;IF CHARACTER IS 0, JUST CR TYPED
	PUSHJ	P,GETWRD	;GO GET WHAT MAY BE DEV: OR FILENAME
	CAIE	CH,":"		;IS BREAK DEVICE SEPARATOR?
	JRST	OPNDEV		;NO, SAVE FILE NAME AND GO INIT DEVICE
	MOVEM	WD,OUTDEV	;YES, STORE USER SUPPLIED DEVICE NAME
	PUSHJ	P,GETWRD	;GET NEXT WORD USER TYPED(FILE NAME)
OPNDEV:	INIT	FILCHN,1	;INIT FILE CHANNEL IN ASCII LINE MODE
OUTDEV:	SIXBIT	/DSK/		;DEVICE NAME
	XWD	FOBUF,0		;OUTPUT BUFER HEADER
	  RJRST	<TTYOUT <? Device * not available@>,OUTDEV ;TYPE ERROR
		 JRST	ASKFIL>	;GO ASK FOR FILE SPEC AGAIN
	PUSH	P,.JBFF##	;SAVE JOBFF
	MOVEI	T1,FILBUF	;ADDR OF FILE BUFFERS
	MOVEM	T1,.JBFF	;SET UP JOBFF TO ALLOCATE OUR BUFFERS
	OUTBUF	FILCHN,NFILBF	;ALLOCATE BUFFERS
	POP	P,.JBFF		;RESTORE JOBFF
	JUMPE	WD,OUTDV0	;WAS NO FILE NAME TYPED?
	MOVEM	WD,OUTNAM	;STORE CUSTOMER SUPPLIED FILE NAME

OUTDV0:	CAIE	CH,"."		;NO, WELL BETTER BE EXTENSION NEXT
	JRST	OUTDV3		;NO, GO CHECK FOR BRACKET FOR PPN
	PUSHJ	P,GETWRD	;GO GET EXTENSION
	HLLM	WD,OUTEXT	;AND STORE FOR ENTER
OUTDV3:	JUMPE	CH,OUTDV4	;END OF LINE(CR=0)?
	CAIE	CH,"["		;NO, BETTER BE LEFT BRACKET FOR PPN
OUTDV1:	JRST	FMTERR		;NO, INCREASE VERBOSITY LEVEL AND ASK AGAIN
	PUSHJ	P,GETOCT	;GET PROJ NUMBER
	CAIE	CH,","		;IS BREAK COMMA?
	JRST	FMTERR		;NO, INCREASE VERBOSITY AND ASK AGAIN
	HRLZM	N,OUTPPN	;YES, STORE PROJECT NO.
	PUSHJ	P,GETOCT	;GET PROG NUMBER
	JUMPE	CH,OUTDV2	;JUMP IF END OF LINE, END OF PPN
	CAIE	CH,"]"		;IS BREAK RIGHT BRACKET?
FMTERR:	RJRST	<TTYOUT	<? Not DEV:FILE.EXT[P,PN]@>
		AOJA	LV,ASKFIL>	;INCREASE LEV AND ASK AGAIN
OUTDV2:	HRRM	N,OUTPPN	;STORE PROG NUMBER
	JUMPE	CH,OUTDV4	;JUMP IF END OF LINE
	PUSHJ	P,GETWRD	;GET NEXT WORD
	JUMPN	WD,FMTERR	;BETTER NOT BE ANYTHING AFTER RIGHT BRACKET
	JUMPN	CH,FMTERR	;IS BREAK CR?
OUTDV4:	MOVE	N,OUTPPN	;GET PPN TYPED
	MOVEM	N,SAVPPN	;SAVE FOR LATER
	ENTER	FILCHN,OUTNAM	;TRY TO ENTER FILE ON DEVICE
	  RJRST	<HRRZ N,OUTEXT	;ENTER ERROR CODE FOR *
		 TTYOCT <? Enter error *@>,N
		 JRST ASKFIL>	;ASK FOR FILE NAME AGAIN
	MOVE	LV,SAVLV	;RESTORE PERMANENT HELP LEVEL
	TLO	F,(F.OFO!F.PER)	;FLAG THAT OUTPUT FILE IS NOW OPEN
				; SO FILPUT WONT BE A NO-OP
				; AND ALLOW PERIODS IN SYMBOLS
	MOVE	T1,WCHGEN	;ENTER OK, GET WHICH GEN THIS IS
	PUSHJ	P,@GENTAB(T1)	;DISPATCH TO PROPER GEN
	MOVE	LV,SAVLV	;RESTORE PERMANENT HELP LEVEL
				; IN CASE USER TYPED /H<CR>
	CLOSE	FILCHN,		;CLOSE OUTPUT FILE
	TLZ	F,(F.OFO)	;FLAG THAT OUTPUT FILE IS NOT OPEN
				; SO FILPUT WILL BE A NO-OP
	STATZ	FILCHN,740000	;ANY ERRORS ON LAST BUFFER

;HERE ON ANY FILE ERRORS DURING EXECUTION
FILERR:	  RJRST	<TTYOUT <? File * error>,OUTNAM
		 GETSTS	FILCHN,N ;GET FILE STATUS FROM MONITOR
		 TLZ	N,-1	;MAKE SURE NO STUFF IN LH
		 TTYOCT	<*@>;OUTPUT STATUS NUMBER AND CR
		 JRST .+1>	;CONTINUE
	RELEASE	FILCHN,		;RELEASE FILE CHANNEL
	TTYOUT	<File >
	SKIPN	N,OUTDEV	;SKIP IF DEVICE SPECIFIED
	JRST	CLTY1		;NO, DONT TYPE DEVICE
	TTYOUT	<*:>,N
CLTY1:	TTYOUT	<*>,OUTNAM
	HLLZ	N,OUTEXT	;INCLUDE EXTENSION
	TTYOUT	<.*>,N
	SKIPN	N,SAVPPN	;SKIP IF PPN SPECIFIED
	JRST	CLTY2		;NO, DONT TYPE PPN
	PUSH	P,LV		;SAVE CURRENT HELP LEVEL
	MOVEI	LV,1		;ASSUME LONG SO PPN WILL PRINT
	HLRZS	N		;N=PROJECT
	TTYOCT	<[*,>,N
	HRRZ	N,SAVPPN	;N=PROGRAMMER
	TTYOCT	<*]>,N
	POP	P,LV		;RESTORE CURRENT HELP LEVEL
CLTY2:	TTYOUT	< Closed [
The *GEN portion of the dialogue is finished.
Type CTRL/Z to exit from MONGEN, or select another dialogue option.]@@>,WCHNAM ;ALSO WHICH GEN
	JRST	BEGIN		;GO BACK AND ASK FOR NEXT GEN
				; KEEP SAME HELP LEVEL AND DO NOT ASK /HELP
SUBTTL	FGEN -- PREFACE

;THIS IS A COMPLETE REWRITE OF THE OLD FGEN DIALOGUE.  THE AUXILLIARY
;FILE (FGEN.HLP) NO LONGER EXISTS.  IT WAS REMOVED BECAUSE OF NUMEROUS
;PROBLEMS ENCOUNTERED OVER THE YEARS, WHERE THE WRONG VERSION OF FGEN.HLP
;WAS USED.  THE ESSENCE OF FGEN.HLP IS NOW CONTAINED IN THE MACRO "FET".
;
;FOR REASONS I HAVE NEVER BE ABLE TO FATHOM, SOME CUSTOMER HAVE HAD AN
;UNCONTROLLABLE URGE TO EDIT FGEN.HLP RATHER THAN USE THE MONGEN FACILITIES
;TO MODIFY OR ADD NEW FEATURE TESTS.  I HAVE DECIDED TO BREAK THEM OF THIS
;NASTY HABIT AND FORCE THEM TO USE THE FGEN DIALOGUE TO ALTER FEATURE TEST
;DEFINITIONS.
;
;THE CASUAL OBSERVER WILL NOTICE THAT THE ENTRIES WITHIN THE "FET" MACRO ARE
;IN MIXED CASE, QUITE CONTRARY TO TOPS-10 CODING STANDARDS.  HAVE NO FEAR,
;I HAVEN'T LOST ALL OF MY MARBLES (YET).  THE MIXED CASE ONLY EXISTS FOR
;TTY OUTPUT.  THE RESULTING OUTPUT FILE IS UP CASED IN ACCORDANCE WITH THE
;TOPS-10 CODING STANDARDS.  I'M SURE SOME UNIX FANATICS WILL WANT TO DEBATE
;THIS ISSUE, BUT IT'S NOT OPEN FOR DISCUSSION.
;
;IT WILL BECOME READILY APPARENT THAT THE OUTPUT FILE IS QUITE READABLE,
;UNLIKE ANYTHING YOU THOUGHT MONGEN WAS CAPABLE OF PRODUCING.  THIS WAS
;ACCOMPLISHED PROVIDING OUTPUT ROUTINES TO BE USED ONLY WITH FGEN, THAT
;PRODUCE PRETTY OUTPUT INSTEAD OF WHAT YOU'RE USED TO.  USE OF THE NORMAL
;CRUFTY MACROS WAS AVOIDED WHEREVER POSSIBLE FOR THE SAKE OF READABILITY
;AND MAINTAINABILITY.
;
;					/DPM, 3:39AM, NOV 16,'87
;					MARLBOROUGH, MASSACHUSETTS
SUBTTL	FGEN -- FEATURE TEST DEFINITIONS


DEFINE  FET,<

MT      (<Hardware options>)
  FT	(EMRT  ,<F.KL10>,<EBOX/MBOX user runtime accounting>)
  FT	(KL10  ,<F.KL10>,<KL10 support>)
  FT	(KS10  ,<F.KS10>,<KS10 support>)
  FT	(MP    ,<F.KL10>,<Symmetric Multiprocessing support>)
  FT	(XMON  ,<F.KL10>,<Extended addressing support>)

MT      (<Communications and networks features>)
  FT	(CIDNET,<0>,<DECnet on the CI bus (requires FTSCA)>)
  FT	(DECNET,<F.KL10!F.KS10>,<DECnet software>)
  FT	(EMOP  ,<F.KL10>,<Ethernet maintenance (requires FTENET)>)
  FT	(ENET  ,<F.KL10>,<Ethernet service>)
  FT	(MIC   ,<F.KL10!F.KS10>,<Macro command processor support)>)
  FT	(MLOG  ,<F.KL10!F.KS10>,<MIC log file support (requires FTMIC)>)
  FT	(NET   ,<F.KL10!F.KS10>,<ANF-10 network software>)

MT      (<I/O features>)
  FT	(CIDSK ,<F.KL10>,<Disks on CI bus (requires FTSCA)>)
  FT	(CITAP ,<0>,<Magtapes on CI bus (requires FTSCA)>)
  FT	(DUAL  ,<F.KL10>,<Dual-ported disks>)
  FT	(FDAEM ,<F.KL10!F.KS10>,<File daemon support>)
  FT	(MPXSER,<F.KL10!F.KS10>,<Multiplex devices on I/O channels>)
  FT	(SCA   ,<F.KL10>,<Systems Communication Architecture support>)

MT      (<Scheduler features>)
  FT	(NSCHED,<F.KL10!F.KS10>,<CPU resource allocation code>)
  FT	(PSCD  ,<F.KL10!F.KS10>,<Scheduler performance gathering>)
  FT	(RSP   ,<F.KL10!F.KS10>,<Measure TTY response and other metrics>)

MT      (<UUO features>)
  FT	(HPQ   ,<F.KL10!F.KS10>,<High Priority Queue>)
  FT	(LOCK  ,<F.KL10!F.KS10>,<Allow jobs to lock in core>)
  FT	(PEEKSP,<F.KL10!F.KS10>,<PEEK and SPY UUOs>)
  FT	(POKE  ,<F.KL10!F.KS10>,<POKE UUO>)
  FT	(RTTRP ,<F.KL10>,<Real-time trapping>)

MT      (<Miscellaneous features>)
  FT	(MDA   ,<F.KL10!F.KS10>,<Mountable Device Allocator>)
  FT	(PATT  ,<F.KL10!F.KS10>,<Allocate space to patch tables>)
  FT	(TLAB  ,<F.KL10!F.KS10>,<Tape labeling facility>)

MT      (<Customer defined features>)

> ;END DEFINE FET
SUBTTL	 FGEN -- BUILD THE FEATURE TEST TABLES


DEFINE  MT      (TXT),<EXP -1>
DEFINE  FT      (NAM,CFG,TXT,HLP),<EXP <SIXBIT \'NAM\>>
FTPNAM:  FET
	BLOCK	MP.FTA
FTLEN==.-FTPNAM

DEFINE  MT      (TXT),<EXP -1>
DEFINE  FT      (NAM,CFG,TXT,HLP),<EXP CFG>
FTPCFG:  FET
	BLOCK	MP.FTA

DEFINE  MT      (TXT),<EXP [ASCIZ \'TXT'\]>
DEFINE  FT      (NAM,CFG,TXT,HLP),<EXP	[ASCIZ \'TXT\]>
	ZZ==-1
FTPTXT:  FET
	REPEAT MP.FTA,<EXP FTCTXT+<MP.FTL/5>*<ZZ==ZZ+1>>
SUBTTL	FGEN -- DIALOG INITIALIZATION

FGEN:	SKIPE	FTINI		;ALREADY INITIALIZED?
	JRST	FGEN0		;YES
	MOVE	T1,[FTPNAM,,FTINAM] ;INIT FEATURE TEST NAMES
	BLT	T1,FTINAM+FTLEN-1
	MOVE	T1,[FTPCFG,,FTICFG] ;INIT FEATURE TEST CONFIG BITS
	BLT	T1,FTICFG+FTLEN-1
	SETOM	FTINI		;REMEMBER INITIALIZED

FGEN0:	TLO	F,(F.SUPP)	;SUPPRESS FILE OUTPUT
	ASKLST  <Feature set (KL10,KS10) [
KL10 includes all supported TOPS-10 features for KL10 systems.  KS10 
includes all supported TOPS-10 features for KS10 systems.]>
	HRR	F,[EXP F.KL10,F.KS10](N) ;LOAD UP PROCESSOR TYPE
	TLO	F,(F.SUPP)	;SUPPRESS FILE OUTPUT
	ASKLST	<Standard settings (YES,NO) [
Type YES to use the standard DEC-supported feature test settings.  Type NO 
to change or define the feature test settings to non-standard values.]>
	JUMPE	N,FGEN10	;GO WRITE THE FILE IF ANSWER WAS "YES"

FGEN1:	TLO	F,(F.SUPP)	;SUPPRESS FILE OUTPUT
	ASKSTR	<
@Feature [Respond with one of the following:
	
   1. RETURN               to terminate dialogue
   2. feature name         to list its current setting
   3. ALL                  to list ALL current settings
   4. name,value,comment   to change or define a feature
	
Where   "name"     is a feature test name without the "FT" prefix
        "value"    is either "OFF" or "ON"
        "comment"  is a one-line description]>
	JUMPE	CH,FGEN10	;ALL DONE?
	PUSHJ	P,GETWRD	;GET FEATURE NAME
	SKIPN	WD		;MAKE SURE WE GOT ONE
	AOJA	LV,FGEN1	;CONFUSED USER
	JUMPN	CH,FGEN4	;WANT TO CHANGE OR DEFINE?
;HERE TO LIST THE CURRENT SETTING
FGEN2:	SETOM	FTMOD		;SET OUTPUT MODE TO TERMINAL
	MOVE	T1,WD		;COPY FEATURE TEST NAME
	CAMN	T1,['ALL   ']	;SPECIAL CASE HACK
	JRST	FGEN3		;DO LIST OUT ALL THE FEATURE TESTS
	PUSHJ	P,FFND		;BETTER BE IN THE TABLE
	  JRST	[MOVE	N,WD	;COPY BOGUS NAME
		 TTYOUT	<% No such feature test "FT*"@>,N
		 JRST	FGEN1]	;TRY AGAIN
	PUSH	P,I		;SAVE FEATURE INDEX
	MOVEI	I,(I2)		;GET HEADER INDEX
	PUSHJ	P,FWRT		;WRITE IT OUT
	POP	P,I		;GET FEATURE INDEX
	PUSHJ	P,FWRT		;WRITE IT OUT
	JRST	FGEN1		;ALL DONE

FGEN3:	MOVSI	I,-FTLEN	;AOBJN POINTER TO FEATURE TABLES
	PUSHJ	P,FWRT		;WRITE IT OUT
	AOBJN	I,.-1		;LOOP THROUGH THE TABLE
	JRST	FGEN1		;ALL DONE

;HERE TO CHANGE OR DEFINE A FEATURE TEST
FGEN4:	CAIE	CH,","		;NEED AT LEAST ONE MORE ARGUMENT
	JRST	[TTYOUT <% Syntax error>
		 JRST	FGEN1]	;TRY AGAIN
	CAMN	WD,['ALL   ']	;STUPID ASS CHECK, BUT SOMEONE WILL TRY IT
	JRST	[TTYOUT <% Cannot modify all feature tests at one>
		 JRST	FGEN1]	;GIVE THE FOOL ANOTHER CHANCE
	MOVEM	WD,FTNAM	;SAVE NAME TO ADD OR CHANGE
	PUSHJ	P,GETWRD	;READ NEXT WORD
	MOVNI	T1,1		;ASSUME JUNK ANSWER
	CAMN	WD,['OFF   ']	;OFF?
	MOVEI	T1,0		;YES
	CAMN	WD,['ON    ']	;ON?
	MOVEI	T1,F.KL10!F.KS10 ;YES
	JUMPL	T1,[TTYOUT <% Value must be "OFF" or "ON">
		    JRST FGEN1]	;TRY AGAIN
	MOVEM	T1,FTCFG	;SAVE CONFIG BITS
	MOVE	T1,[FTTXT,,FTTXT+1] ;SET UP BLT
	SETZM	FTTXT		;CLEAR FIRST WORD
	BLT	T1,FTTXT+MP.FTL-1 ;CLEAR BUFFER
	CAIE	CH,","		;DESCRIPTIVE TEXT?
	JRST	FGEN6		;NO
	MOVE	T1,[POINT 7,FTTXT] ;BYTE POINTER TO TEMP STORAGE
	MOVEI	T2,MP.FTL	;BYTE COUNT

FGEN5:	ILDB	CH,B		;READ A CHARACTER
	IDPB	CH,T1		;STORE IT
	SKIPE	CH		;DONE?
	SOJG	T2,FGEN5	;LOOP

FGEN6:	MOVE	T1,FTNAM	;GET NAME TO ADD OR CHANGE
	PUSHJ	P,FFND		;SEE IF ALREADY KNOWN
	  SKIPA	I2,[-<FTLEN-MP.FTA-1>,,<FTLEN-MP.FTA-1>] ;UNKNOWN
	JRST	FGEN7		;ONWARD
	MOVE	I,I2		;COPY HEADER POINTER
	SKIPE	FTINAM(I)	;FREE SLOT?
	AOBJN	I,.-1		;KEEP SEARCHING
	JUMPL	I,FGEN7		;CONTINUE IF FOUND ONE
	TTYOUT <% No storage available for additional feature tests>
	JRST	FGEN1		;GIVE UP

FGEN7:	MOVE	T1,FTNAM	;GET FEATURE TEST NAME
	MOVEM	T1,FTINAM(I)	;CREATE NEW OR UPDATE OLD
	MOVE	T1,FTCFG	;GET FEATURE TEST CONFIG BITS
	MOVEM	T1,FTICFG(I)	;STORE THEM
	SKIPN	FTTXT		;HAVE TEXT?
	JRST	FGEN8		;NO--ALMOST DONE
	MOVE	T1,FTPTXT(I)	;WHERE TEXT WILL GO
	MOVSI	T2,FTTXT	;NEW DESCRIPTIVE TEXT
	HRRI	T2,(T1)		;MAKE A BLT POINTER
	BLT	T2,MP.FTL-1(T1)	;COPY TEXT

FGEN8:	MOVE	WD,FTNAM	;LOAD UP THE NAME
	JRST	FGEN2		;AND GO REPORT CHANGES
FGEN10:	SETZM	FTMOD		;SET OUTPUT MODE TO FILE
	MOVEI	T1,FHEAD	;POINT TO FILE HEADER
	PUSHJ	P,FTXT		;WRITE IT OUT
	PUSHJ	P,FVER		;WRITE OUT THE VERSION NUMBER
	MOVEI	T1,[BYTE(7)15,12,12,0] ;CRLFS
	PUSHJ	P,FTXT		;WRITE THEM OUT
	MOVEI	T1,FCOMB	;BEGIN COMMENT
	PUSHJ	P,FTXT		;WRITE TEXT
	MOVEI	T1,CPYTXT	;POINT TO COPYRIGHT
	PUSHJ	P,FTXT		;WRITE IT OUT
	MOVEI	T1,FCOME	;END COMMENT
	PUSHJ	P,FTXT		;WRITE TEXT
	MOVEI	T1,[ASCIZ /	M.F==:/]
	PUSHJ	P,FTXT		;WRITE START OF SYMBOL DEFINITION
	LDB	T1,[POINT 9,JOBVER,11] ;MAJOR VERSION NUMBER
	PUSHJ	P,FOCT		;WRITE IT OUT
	MOVEI	T1,[ASCIZ /	;MONGEN VERSION/]
	PUSHJ	P,FTXT		;WRITE IT OUT
	MOVEI	T1,[BYTE(7)15,12,12,0] ;CRLFS
	PUSHJ	P,FTXT		;WRITE THEM OUT
	MOVSI	I,-FTLEN	;AOBJN POINTER TO FEATURE TABLES
	PUSHJ	P,FWRT		;WRITE A FEATURE TEST OUT TO THE FILE
	AOBJN	I,.-1		;LOOP THROUGH THE TABLE
	MOVEI	T1,FTRAIL	;POINT TO FILE TRAILER
	PJRST	FTXT		;WRITE IT OUT AND RETURN


FHEAD:	ASCIZ	\UNIVERSAL F - TOPS-10 SOFTWARE FEATURE TESTS
SUBTTL	WRITTEN BY MONGEN %\


FTRAIL:	ASCIZ	\


	END
\

FCOMB:	ASCIZ	\
COMMENT	&

\

FCOME:	ASCIZ	\
&
\
SUBTTL	FGEN -- FFND - FIND A SPECIFIED FEATURE TEST ENTRY


FFND:	MOVSI	I,-FTLEN	;AOBJN POINTER

FFND1:	MOVE	T2,FTINAM(I)	;GET A NAME
	CAME	T2,[EXP -1]	;HEADER?
	JRST	FFND2		;NO
	MOVEI	I2,(I)		;SAVE INDEX
	JRST	FFND3		;ON TO THE NEXT ONE
FFND2:	CAMN	T1,FTINAM(I)	;A MATCH?
	JRST	CPOPJ1		;RETURN GOODNESS

FFND3:	AOBJN	I,FFND1		;LOOP THROUGH TABLE
	POPJ	P,		;GIVE UP
SUBTTL	FGEN -- FWRT - ROUTINE TO WRITE A FEATURE TEST TO FILE


FWRT:	SKIPN	FTINAM(I)	;ENTRY IN USE?
	POPJ	P,		;THEN DO NOTHING
        MOVE    T1,FTINAM(I)	;GET FEATURE NAME
        CAME    T1,[EXP -1]     ;HEADER?
        JRST    FWRT2           ;NO
	MOVEI	T1,[BYTE(7) 15,12,0] ;CRLF
	PUSHJ	P,FTXT		;START WITH A CRLF
	SKIPE	FTMOD		;FILE OUTPUT?
	JRST	FWRT1		;NO
	MOVEI	T1,[BYTE(7) 15,12,0] ;CRLF
	PUSHJ	P,FTXT		;ONE MODE CRLF
	MOVEI	T1,FWRTT	;POINT TO SEPARATOR LINE
	PUSHJ	P,FTXT		;WRITE IT TO THE FILE
	MOVEI	T1,[ASCIZ /;		/]
	PUSHJ	P,FTXT		;START OF EXPLANATION
FWRT1:	MOVE	T1,FTPTXT(I)	;GET TEXT STRING ADDRESS
	PUSHJ	P,FTXT		;WRITE IT OUT
	MOVEI	T1,FWRTT	;ONE MORE SEPARATOR LINE
	SKIPE	FTMOD		;FILE OUTPUT?
	MOVEI	T1,[BYTE(7) 15,12,0] ;NO
	PJRST	FTXT		;WRITE IT OUT AND RETURN

FWRT2:	MOVEI	T1,[ASCIZ /	FT/]
	PUSHJ	P,FTXT		;WRITE START OF FEATURE TEST SWITCH OUT
	MOVE	T1,FTINAM(I)	;GET FEATURE NAME
	PUSHJ	P,FSIX		;WRITE IT OUT
	MOVEI	T1,[ASCIZ/==:0	;/] ; ASSUME FEATURE TURNED OFF
	MOVE	T2,F		;GET CONFIGURATION BITS
	ANDI	T2,F.KL10!F.KS10 ;JUST THE MEANINGFUL BITS PLEASE
	TDNE	T2,FTICFG(I)	;WANT THIS FEATURE TURNED ON?
	MOVEI	T1,[ASCIZ /==:-1	;/] ;YES
	PUSHJ	P,FTXT		;WRITE TEXT
	MOVE	T1,FTPTXT(I)	;GET TEXT ASSOCIATED WITH FEATURE TEST
	PUSHJ	P,FTXT		;WRITE AS A COMMENT
	MOVEI	T1,[BYTE(7) 15,12,0]
	PJRST	FTXT		;END LINE AND RETURN


FWRTT:	ASCIZ	/
;----------------------------------------------------------------------
/
SUBTTL	FGEN -- MISCELLANEOUS OUTPUT ROUTINES


;OCTAL OUTPUT
;CALL:	MOVE	T1, WORD
;	PUSHJ	P,FOCT

FOCT:	IDIVI	T1,10		;DIVIDE BY RADIX
	PUSH	P,T2		;SAVE REMAINDER
	SKIPE	T1		;DONE?
	PUSHJ	P,FOCT		;RECURSE
	POP	P,CH		;GET DIGIT BACK
	ADDI	CH,"0"		;MAKE ASCII
	PJRST	FCHR		;WRITE IT AND RETURN


;SIXBIT OUTPUT
;CALL:	MOVE	T1, WORD
;	PUSHJ	P,FSIX

FSIX:	SKIPN	T2,T1		;COPY WORD
	POPJ	P,		;NOT THERE?

FSIX1:	LSHC	T1,6		;SHIFT IN A CHARACTER
	ANDI	T1,77		;STRIP OFF JUNK
	MOVEI	CH," "(T1)	;CONVERT TO ASCII
	PUSHJ	P,FCHR		;WRITE IT OUT
	JUMPN	T2,FSIX1	;LOOP FOR ALL CHARACTERS
	POPJ	P,		;RETURN


;ASCII STRING OUTPUT
;CALL:	MOVE	T1, STRING ADDRESS
;	PUSHJ	P,FTXT

FTXT:	HRLI	T1,(POINT 7,)	;MAKE A BYTE POINTER

FTXT1:	ILDB	CH,T1		;GET A CHARACTER
	JUMPE	CH,CPOPJ	;RETURN IF END OF TEXT
	SKIPE	FTMOD		;WRITING TO A FILE?
	JRST	FTXT2		;NO
	CAIL	CH,"A"+40	;LOWER
	CAILE	CH,"Z"+40	; CASE?
	SKIPA			;NO
	SUBI	CH,40		;CONVERT TO UPPER CASE

FTXT2:	PUSHJ	P,FCHR		;WRITE CHARACTER OUT
	JRST	FTXT1		;LOOP


;CHARACTER OUTPUT
;CALL:	MOVE	CH, CHARACTER
;	PUSHJ	P,FCHR

FCHR:	SKIPE	FTMOD		;OUTPUT TO FILE?
	PJRST	TTYPU1		;NO--TERMINAL
	PJRST	FILPUT		;WRITE TO FILE
;VERSION OUTPUT
;CALL:	PUSHJ	P,FVER

FVER:	LDB	T1,[POINT 9,JOBVER,11] ;GET MAJOR VERSION
	PUSHJ	P,FOCT		; PRINT IN OCTAL
	LDB	T1,[POINT 6,JOBVER,17] ;GET MINOR VERSION
	JUMPE	T1,FVER2	;IF NON-ZERO,
	SOS	T1		;  PRINT IN MODIFIED
	IDIVI	T1,^D26		;  RADIX 26 ALPHA
	JUMPE	T1,FVER1	;  JUMP IF ONE CHAR
	MOVEI	CH,"A"-1(T1)	;  ISSUE FIRST OF TWO
	PUSHJ	P,FCHR		;  CHARACTERS
FVER1:	MOVEI	CH,"A"(T2)	;  ISSUE "UNITS"
	PUSHJ	P,FCHR		;  CHARACTER
FVER2:	HRRZ	T1,JOBVER	;GET EDIT NUMBER
	JUMPE	T1,FVER3	;IF NON-ZERO,
	MOVEI	CH,"("		;  ISSUE
	PUSHJ	P,FCHR		;  AS OCTAL
	PUSHJ	P,FOCT		;  WITHIN
	MOVEI	CH,")"		;  PARENTHESES
	PUSHJ	P,FCHR		;  ..
FVER3:	LDB	T1,[POINT 3,JOBVER,2] ;GET "WHO" FIELD
	JUMPE	T1,CPOPJ	;IF NON-ZERO,
	MOVEI	CH,"-"		;  PRINT -
	PUSHJ	P,FCHR		;  AND FIELD
	PJRST	FOCT		;  AS OCTAL
SUBTTL	SYSGEN - DIALOG TO DEFINE HARDWARE AND SOFTWARE CONFIGURATION

SYSGEN:	FILOUT	<SUBTTL SYSCNF - SYSTEM CONFIGURATION DEFINITION FILE OUTPUT BY MONGEN@@@>
	FILOUT	<DEFINE XP(A,B),<A==:B>@@@>
	MOVEI	N,EDITNO	;MONGEN<=>COMMON "VERSION" NUMBER
	FILOUT	<M.GEN==:*@>,N	;OUTPUT TO FILE


	PUSHJ	P,ASKSYS	;FIND OUT WHAT TYPE OF SYSTEM
	FILOUT	<M.KL10==:*@>,M.KL10
	FILOUT	<M.KS10==:*@>,M.KS10
	SKIPE	M.KS10
	JRST	HDWGN1
	MOVEI	N,SM.CPU
	ASKDEC	<CPUs (1,1-*) [
Respond with the total number of CPUs in the system you are configuring.
The maximum number of CPUs supported in an SMP configuration is defined in
the SPD.]>
HDWGN1:	MOVEM	N,M.CPU
	MOVEM	N,SMP		;FLAG FOR MULTI-CPU
	SOS	SMP		;NON-ZERO IF SO
	FILOUT	<M.CPU==:*@>,N


ASKNAM:	ASKSTR	<System name [
Type a system name of 24 characters or less.  The system name is displayed 
in the banner line that is printed when the INITIA monitor command is 
issued.]>
	CAILE	N,^D24		;24 OR LESS?
	RJRST	<TTYOUT <% More than 24 characters@>
		 JRST	ASKNMA>
ASKNMA:	MOVEI	N,0		;STORE 0 TO MAKE SURE ONLY 24 CHARS OUTPUT
	DPB	N,[POINT 7,ASCSTR+4,34]
	MOVSI	N,'*  '		;IN CASE "*" IS IN SYSNAM
	FILSTR	<DEFINE	SYSNAM
<	ASCIZ	&*&>@>
ASKDAT:	DATE	T1,		;GET TODAYS DATE
	IDIVI	T1,^D12*^D31	;YEAR + DAYS IN THIS YEAR
	PUSH	P,T2		;SAVE REMAINDER FOR A BIT
	ADDI	T1,^D64		;1964 IS YEAR 0
	MOVEM	T1,M.YEAR	;SAVE FOR SYMBOL OUTPUT NOW, BEFORE TRUNCATION
	IDIVI	T1,^D100	;MAKE SURE WE STAY IN CENTURY
	EXCH	T2,(P)		;SAVE YEARS (00-99), RETRIEVE REMAINDER OF DATE
	MOVE	T1,T2		;NO. DAYS IN CURRENT YEAR
	IDIVI	T1,^D31		;T1=MONTH-1, T2=DAY OF MONTH-1
	PUSH	P,T1		;SAVE MONTH-1 (0-11)
	MOVEI	N,1(T2)		;DAY (1-31)
	FILOUT	<DEFINE	SYSDAT> ;START MACRO DEFINITION IN FILE
	PUSHJ	P,FILLAB	;OUTPUT LEFT ANGLE BRACKET TO FILE, CRLF
	FILDC2	<ASCIZ &*>,N	;OUTPUT DAY
	MOVEM	N,M.DAY		;SAVE FOR SYMBOL OUTPUT TOO
	POP	P,T1		;MONTH-1
	MOVEI	N,1(T1)		;MONTH (1-12)
	MOVEM	N,M.MON		;SAVE FOR SYMBOL OUTPUT
	MOVE	T1,MONNAM(T1)	;GET MONTH NAME (MIXED CASE)
	MOVEM	T1,ASCSTR	;PUT WHERE FILSTR WILL FIND IT
	FILSTR	<-*->		;OUTPUT MONTH NAME
	POP	P,N		;YEAR (00-99)
	FILDC2	<*&>,N		;OUTPUT TO FILE
	PUSHJ	P,FILRAB	;OUTPUT RIGHT ANGLE BRACKET,CRLF
	FILOUT	<M.MON==:*@>,M.MON
	FILOUT	<M.DAY==:*@>,M.DAY
	FILOUT	<M.YEAR==:*@>,M.YEAR
	JRST	ASKSER		;JUMP AROUND MONTH NAME TABLE

MONNAM:				;TABLE OF SHORT MONTH NAMES
DEFINE	YY(SYL),<IRP SYL,<EXP ASCII |SYL|>>
	YY<Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec>
ASKSER:	SETZB	I,CPU		;SET LOOP COUNTER TO 0

;LOOP TO ASK FOR SERIAL NUMBERS FOR ALL CPUS IN SYSTEM
ASKSLP:	ASKDEC	<CPU* serial number (1-10000) [
Respond with the serial number of the CPU, in the range 1 to 10000.  If your 
installation has more than one processor, this question is asked for each 
CPU.  Each serial number must be unique.]>,I ;ASK FOR CPUN
	MOVEM	N,M.C0SN(I)	;SAVE FOR CPU1 CHECK
	SOJL	I,ASKSN1	;ANY PREVIOUS CPUS ALREADY ANSWERED?

;LOOP TO SCAN ALL PREVIOUS CPU SERIAL NUMBERS TO SEE IF THE SAME
ASKSN0:	CAMN	N,M.C0SN(I)	;SAME AS PREVIOUS SERIAL NUMBER?
	RJRST	<TTYOUT	<? Cannot be same as CPU*@>,I
		 JRST	ASKSER>	;ASK ALL CPUS OVER AGAIN
	SOJGE	I,ASKSN0	;ANY MORE PREVIOUS CPUS?
ASKSN1:	MOVE	I,CPU		;CPU NUMBER
	SETZ	N,		;IN CASE THIS IS A KL10 OR KS10
	AOS	I,CPU		;INCREMENT CPU ITERATION COUNTER
	CAMGE	I,M.CPU		;DONE FOR ALL CPUS IN THIS SYSTEM?
	JRST	ASKSLP		;NO, GO BACK AND ASK FOR ANOTHER
	FILOUT	<M.C0SN==:*@>,M.C0SN
	FILOUT	<M.C1SN==:*@>,M.C1SN
	FILOUT	<M.C2SN==:*@>,M.C2SN
	FILOUT	<M.C3SN==:*@>,M.C3SN
	FILOUT	<M.C4SN==:*@>,M.C4SN
	FILOUT	<M.C5SN==:*@>,M.C5SN
	SETZM	M.DN60		;CLEAR COUNT OF DN60 DEVICES IN SYSTEM
	ASKYN	<Exclude monitor overhead from user run time (YES,NO) [
Overhead is CPU time spent clock queue processing, command decoding, 
swapping, and scheduling.  User run time always includes UUO execution and, 
unless EBOX/MBOX runtime accounting is selected (KL10 systems only), 
includes IO interrupt service time.
    If you exclude monitor overhead from user runtime, users recieve a more 
accurate accounting of their processor usage because user runtime is 
calculated independently of any monitor overhead.  However, installations
that charge their customers for processor usage should be aware that the 
exclusion of monitor overhead decreases the user runtime totals by 10 to 
20 percent.
    If you include monitor overhead with user runtime, apportioned monitor
overhead is included in each user's runtime.  Regardless of how you 
respond to this question, monitor overhead is calculated as a separate 
statistic that can be used in determining the amount of CPU time spent for 
overhead.]>
	FILOUT	<M.RTCO==:*@>,N

ASKEMT:	SKIPN	M.KL10		;KL10 SYSTEM?
	JRST	NOEMRT		;NO, NO EBOX/MBOX TIME ACCOUNTING
	ASKYN	<EBOX/MBOX runtime accounting (YES,NO) [
If EBOX/MBOX runtime accounting is selected, user runtime is computed using 
the KL10 internal accounting clocks.
    With EBOX/MBOX accounting, meters are turned off at the beginning of 
the overhead period and turned on again at the end.  For the most accurate 
user runtime calculation, answer YES to this question and exclude priority 
interrupt (PI) time  from the runtime calculation  by answering YES to the
next question.]>
	MOVEM	N,M.EMRT	;SAVE FOR LATER
	FILOUT	<M.EMRT==:*@>,M.EMRT
	SKIPN	M.EMRT
	JRST	NOEMR1		;NO PI EXCLUSION EITHER
	ASKYN	<Exclude PI time from user runtime (YES,NO) [
If you exclude PI time from user runtime, the EBOX and MBOX accounting 
clocks are stopped whenever a priority interrupt is in progress, and users 
will not be charged for CPU time used during interrupts.]>
	MOVEM	N,M.XPI		;SAVE
	FILOUT	<M.XPI==:*@>,M.XPI
	JRST	ASKACV		;NOW GO ASK ABOUT ACCOUNT VALIDATION
NOEMRT:	FILOUT	<M.EMRT==:0@>
NOEMR1:	FILOUT	<M.XPI==:0@>
ASKACV:	ASKYN	<Account verification (YES,NO) [
LOGIN and the batch system will verify that the user has specified a valid 
account.
    If you answer YES, when accounts are associated with their PPNs and 
when ACTDAE is running, users can log in only if they specify a valid 
account string.  If you answer NO, no verification test is made.]>
	FILOUT	<M.ACV==:*@>,N
	MOVEI	N,0		;ASSUME NO MOS MEMORY SUPPORT
	SKIPN	M.KL10		;A KL10?
	JRST	MOSEND		;NO, CAN'T HAVE RECONFIGURABLE MOS
	ASKYN	<MOS memory (YES,NO) [
Include support for the user-mode MOS memory diagnostic TGHA.  TGHA 
collects statistics on single bit memory errors and substitutes the spare 
bit when a single bit error is determined to be hard.
    If you answer YES, the module MOSSER will be loaded with the monitor.  
If you answer NO, MOSSER will not be loaded.]>
MOSEND:	FILOUT	<M.MOS==:*@>,N	;OUTPUT THE ANSWER
	SETOM	CPUN
DOAUT:	MOVE	T1,[Z.ATOB,,Z.ATOB+1] ;SET UP BLT
	SETZM	Z.ATOB		;CLEAR FIRST WORD
	BLT	T1,Z.ATOE	;ZERO OUT AUTOCONFIGURED DEVICE STORAGE
	TRZ	F,F.KL10!F.KS10	;CLEAR ALL CPU BITS
	SKIPE	M.KL10		;KL10?
	TRO	F,F.KL10	;YES
	SKIPE	M.KS10		;KS10?
	TRO	F,F.KS10	;YES
	BTHOUT	<@Autoconfigured device options:@>

	ASKAUT	(SCA,SCASER,F.KL10,<SCA>,<
SCA (Systems Communications Architecture) provides the ability to
communicate with devices on a CI bus.  SCASER and KLPSER are the driver 
modules.
>)

	ASKAUT	(ENET,ETHSER,F.KL10!F.KS10,<Ethernet service>,<
Load monitor modules needed to communicate using Ethernet.  These modules 
include ETHSER and ETHUUO, plus the hardware driver specific to the type of 
DECsystem-10 being built.
>)

	ASKAUT	(SA10,SAXSER,F.KL10,<SA10 device support>,<
SA10 support provides the ability to communicate with IBM channel devices 
using a Systems Concept SA10 channel interface.  SAXSER is the driver 
module.
>)

	ASKAUT	(DPX,DPXKON,F.KL10,<RP01/2/3 disks>,<
RP01, RP02, and RP03 disks are available through the use of an RP10 
interface.  DPXKON is the driver module for these disks.
>)
	MOVE	T1,M.DPX	;ANSWER
	IORM	T1,M.DISK	;ACCUMULATE

	TRO	F,F.NEVR	;NEVER ASK THE QUESTION
	ASKAUT	(DRX,DRXKON,F.KL10,<Future drum>,<
This generates a dummy symbol reserved for a future drum.
>)
	MOVE	T1,M.DRX	;ANSWER
	IORM	T1,M.DISK	;ACCUMULATE

	ASKAUT	(FHX,FHXKON,F.KL10,<Swapping drums>,<
Burroughs disks and Bryant drums are available through the use of an RC10 
interface.  FHXKON is the driver module for these disks.
>)
	MOVE	T1,M.FHX	;ANSWER
	IORM	T1,M.DISK	;ACCUMULATE

	TRO	F,F.MBUS	;MASSBUS DEVICE
	ASKAUT	(FSX,FSXKON,F.KL10,<RS04/5 Massbus disks>,<
RS04 and RS05 disks are available through the use of an RH10/DF10C 
interface.  FSXKON is the driver module for these disks.
>)
	MOVE	T1,M.FSX	;ANSWER
	IORM	T1,M.DISK	;ACCUMULATE

	TRO	F,F.NEVR	;NEVER ASK THE QUESTION
	ASKAUT	(MDX,MDXKON,F.KL10,<Mass disk>,<
This generates a dummy symbol reserved for the Bryant Mass disk.  
Historical note: Code was written, and tested along with the proposed 
hardware but the product was never released.  The device was called the MD 
disk, sometimes incorrectly refered to as the MF disk.  MD stood for Moby 
Disk.  It was a rather large piece of hardware.
>)
	MOVE	T1,M.MDX	;ANSWER
	IORM	T1,M.DISK	;ACCUMULATE

	TRO	F,F.MBUS	;MASSBUS DEVICE
	TRO	F,F.LOAD	;ALWAYS LOAD DRIVER
	ASKAUT	(RPX,RPXKON,F.KL10!F.KS10,<RP0x/RM0x Massbus disks>,<
RP0x and RM0x disks are available through the use of Massbus hardware. 
RPXKON is the driver module for these disks.
>)
	MOVE	T1,M.RPX	;ANSWER
	IORM	T1,M.DISK	;ACCUMULATE

	TRO	F,F.MBUS	;MASSBUS DEVICE
	ASKAUT	(RNX,RNXKON,F.KL10,<DX20/RP20 disks>,<
RP20 IBM channel disks are available through the use of a DX20 channel 
interface with an RP20CT controller.  RNXKON is the driver module for these 
disks.
>)
	MOVE	T1,M.RNX	;ANSWER
	IORM	T1,M.DISK	;ACCUMULATE

	SKIPN	M.SCA		;SCA?
	TRO	F,F.NEVR	;NO, SO DON'T LOAD
	ASKAUT	(RAX,RAXKON,F.KL10,<CI20/HSC disks>,<
RA series disks are available through the use of CI20 interconnect port 
adapter and an HSC series controller.  RAXKON is the driver module for 
these disks.
>)
	MOVE	T1,M.RAX	;ANSWER
	IORM	T1,M.DISK	;ACCUMULATE

	SKIPN	M.SA10		;SA10?
	TRO	F,F.NEVR	;NO, SO DON'T LOAD
	ASKAUT	(DSX,DSXKON,F.KL10,<SA10/IBM disks>,<
3330/3331 IBM channel disks are available through the use of an SA10 
channel interface with a DC830 controller.  DSXKON is the driver module for
these disks.
>)
	MOVE	T1,M.DSX	;ANSWER
	IORM	T1,M.DISK	;ACCUMULATE

	TRO	F,F.MBUS	;MASSBUS DEVICE
	ASKAUT	(TM02,TM2KON,F.KL10!F.KS10,<TM02/TM03 magtapes>,<
TU45 and TU77 magtape units are available through the use of TM02 or TM03 
controllers.  TM2KON is the driver module for these magtapes.
>)
	MOVE	T1,M.TM02	;ANSWER
	IORM	T1,M.TAPE	;ACCUMULATE

	ASKAUT	(TX01,TX1KON,F.KL10,<DX10/TX01/TX02 tapes>,<
TU70, TU71, TU72, and TU73 IBM channel magtapes are available through the 
use of a DX10 channel interface and a TX01 or a TX02 controller.  TX1KON is 
the driver module for these magtapes.
>)
	MOVE	T1,M.TX01	;ANSWER
	IORM	T1,M.TAPE	;ACCUMULATE

	TRO	F,F.MBUS	;MASSBUS DEVICE
	ASKAUT	(DX20,TD2KON,F.KL10,<DX20/TX02 tapes>,<
TU70, TU71, TU72, and TU73 IBM channel magtapes are available through the 
use of a DX20 channel interface and a TX02 controller.  TD2KON is the 
driver module for these magtapes.
>)
	MOVE	T1,M.DX20	;ANSWER
	IORM	T1,M.TAPE	;ACCUMULATE

	TRO	F,F.MBUS	;MASSBUS DEVICE
	ASKAUT	(TM78,T78KON,F.KL10,<TM78/TU78/TU79 magtapes>,<
TU78 and TU79 magtapes are available through the use of a TM78 controller.  
T78KON is the driver module for these magtapes.
>)
	MOVE	T1,M.TM78	;ANSWER
	IORM	T1,M.TAPE	;ACCUMULATE

	TRO	F,F.MBUS	;MASSBUS DEVICE
	ASKAUT	(TM10,TMXKON,F.KL10,<TM10B magtapes>,<
TU40 and TU41 magtapes are available through the use of a TM10B controller.  
TMXKON is the driver module for these magtapes.
>)
	MOVE	T1,M.TM10	;ANSWER
	IORM	T1,M.TAPE	;ACCUMULATE

	TRO	F,F.MBUS	;MASSBUS DEVICE
	ASKAUT	(TC10,TCXKON,F.KL10,<TC10C magtapes>,<
TU43 magtapes are available through the use of a TC10C controller.  TCXKON 
is the driver module for these magtapes.
>)
	MOVE	T1,M.TC10	;ANSWER
	IORM	T1,M.TAPE	;ACCUMULATE

	SKIPN	M.SA10		;SA10?
	TRO	F,F.NEVR	;NO, SO DON'T LOAD
	ASKAUT	(TS10,TS1KON,F.KL10,<SA10/IBM tapes>,<
STC IBM channel magtapes are available through the use of an SA10 channel 
interface and an 8300 controller.  TS1KON is the driver module for these 
magtapes.
>)
	MOVE	T1,M.TS10	;ANSWER
	IORM	T1,M.TAPE	;ACCUMULATE

	ASKAUT	(LP10,LPTSER,F.KL10,<BA10/LP100 printers>,<
This option provides support for I/O bus line printers.
>)
	MOVE	T1,M.LP10	;ANSWER
	ADDM	T1,M.LPT	;ACCUMULATE

	TRO	F,F.DVCP	;RESERVE SLOT PER CPU
	ASKAUT	(DLP,DLPSER,F.KL10,<CFE/LP20 printers>,<
This option provides support for line printers on the RSX-20F front-end.
>)
	MOVE	T1,M.DLP	;ANSWER
	IORM	T1,M.LPT	;ACCUMULATE

	ASKAUT	(LP20,LP2SER,F.KS10,<UNIBUS/LP20 printers>,<
This option provides support for LP20 UNIBUS line printers.
>)
	MOVE	T1,M.LP20	;ANSWER
	IORM	T1,M.LPT	;ACCUMULATE

	ASKAUT	(XY10,PLTSER,F.KL10,<XY10 plotters>,<
This option provides support for I/O bus plotters.
>)
	MOVE	T1,M.XY10	;ANSWER
	IORM	T1,M.PLT	;ACCUMULATE

	ASKAUT	(CR10,CDRSER,F.KL10,<CR10 card readers>,<
This option provides support for I/O bus card readers.
>)
	MOVE	T1,M.CR10	;ANSWER
	IORM	T1,M.CDR	;ACCUMULATE

	TRO	F,F.DVCP	;RESERVE SLOT PER CPU
	ASKAUT	(DCR,DCRSER,F.KL10,<CFE/CD20 card readers>,<
This option provides support for card readers on the RSX-20F front-end.
>)
	MOVE	T1,M.DCR	;ANSWER
	IORM	T1,M.CDR	;ACCUMULATE

	ASKAUT	(CR20,CD2SER,F.KS10,<UNIBUS/CD20 card readers>,<
This option provides support for CD20 UNIBUS card readers.
>)
	MOVE	T1,M.CR20	;ANSWER
	IORM	T1,M.CDR	;ACCUMULATE

	ASKAUT	(CP10,CDPSER,F.KL10,<CP10/CP10D card punches>,<
This option provides support for card punches.
>)
	MOVE	T1,M.CP10	;ANSWER
	IORM	T1,M.CDP	;ACCUMULATE

	ASKAUT	(PTP,PTPSER,F.KL10,<PC04 paper tape punches>,<
This option provides support for paper tape punches.
>)
;	MOVE	T1,M.PTP	;ANSWER
;	IORM	T1,M.PTP	;ACCUMULATE

	ASKAUT	(PTR,PTRSER,F.KL10,<PC04 paper tape readers>,<
This option provides support for paper tape readers.
>)
;	MOVE	T1,M.PTR	;ANSWER
;	IORM	T1,M.PTR	;ACCUMULATE

	TRZ	F,F.KL10!F.KS10	;CLEAR CPU BITS
	FILOUT	<@;ACCUMULATED SYMBOLS@>
	FILOUT	<M.DISK==:*		;DISK SERVICE@>,M.DISK
	FILOUT	<M.TAPE==:*		;TAPE SERVICE@>,M.TAPE
	FILOUT	<M.CDP==:*		;CARD PUNCH SERVICE@>,M.CDP
	FILOUT	<M.CDR==:*		;CARD READER SERVICE@>,M.CDR
	FILOUT	<M.LPT==:*		;LINE PRINTER SERVICE@>,M.LPT
	FILOUT	<M.PLT==:*		;PLOTTER SERVICE@>,M.PLT
	FILOUT	<M.PTP==:*		;PAPER TAPE PUNCH SERVICE@>,M.PTP
	FILOUT	<M.PTR==:*		;PAPER TAPE READER SERVICE@>,M.PTP
;CODE TO ASK ABOUT DTE-20S ON KL10S

ASKDTE:	SKIPN	N,M.KL10		;IF THIS ISN'T A KL10,
	JRST	ASKDT3			; THEN DON'T GENERATE ANY SYMBOLS
	BTHOUT	<@Types of DTE service to load:@>
	ASKYN	<  Load ANF-10 DTE service (YES,NO) [
Do you want to load the driver to support DTE based ANF-10 front ends?]>
	MOVEM	N,M.DN8S		;REMEMBER ABOUT DN87S'S
	FILOUT	<M.DN8S==:*@>,N		;DEFINE THE SYMBOL
	ASKYN	<  Load IBMCOMM DTE service (YES,NO) [
Do you want to load the driver to support DTE based IBM communications 
front ends?]>
	MOVEM	N,M.DN6S		;REMEMBER ABOUT DN60S'S
	FILOUT	<M.DN6S==:*@>,N		;DEFINE THE SYMBOL
	SKIPE	N			;IF WANT D6SINT,
	AOS	M.DN60			;WE WANT D60SER AS WELL
	ASKYN	<  Load DECnet DTE service (YES,NO) [
Do you want to load the driver to support DTE based DECnet-36 front 
ends?]>
	MOVEM	N,M.DDCN		;REMEMBER ABOUT MCB'S
	FILOUT	<M.DDCN==:*@>,N		;DEFINE THE SYMBOL
	SETOM	CPUN			;START OF LOOP
ASKDT1:	AOS	I,CPUN			;GET NEXT CPU
	CAML	I,M.CPU			;STILL IN RANGE?
	JRST	ASKDT2			;NO, FINISH DTES
	FILCPU	<M.DTEN==:4@>		;YES, SAY HOW MANY DTES TO HANDLE
	JRST	ASKDT1			;LOOP OVER ALL CPUS
ASKDT2:	MOVE	N,M.CPU			;NUMBER OF CPUS
	IMULI	N,4			;FOUR DTES PER CPU
ASKDT3:	FILOUT	<M.DTEN==:*@>,N		;DUMP SYSTEM-WIDE VALUE
	;FALL INTO ASKTTY
ASKTTY:	SETOM	CPUN			;START AT CPU0
	TTYOUT	<@Local terminal configuration:@>
	SKIPN	M.KL10
	JRST	TKSGEN
	ASKLST	<  Configure old terminal scanners (NO,YES) [
If you answer YES, you will be prompted to provide information about DC10s, 
DC68s, and DC76s.]>
	MOVEM	N,DLSCAN		;REMEMBER FOR THE LOOP
ASKTT1:	AOS	T1,CPUN			;STANDARD CPU LOOP
	CAML	T1,M.CPU		;IF DONE,
	JRST	ASKTT2			;FINISH HERE
	MOVE	N,CPUN
	ASKDEC	<  How many RSX-20F TTYs on CPU* (0,0-128) [
Respond with the number of terminals on the RSX-20F console front-end for 
this CPU.  Include only timesharing (DH11) lines, not CTY or KLINIK.]>
	ADDI	N,4			;ADD ONE FOR EACH CONTROL LINE
	ADDM	N,M.TTDN		;UPDATE SYSTEM-WIDE TOTAL
	FILCPU	<M.TTDN==:*@>,N		;DEFINE HOW MANY THIS CPU
TTYCPX:	MOVEI	N,0			;NO DC10
	SKIPN	CPUN			;ONLY ON CPU0
	SKIPN	DLSCAN
	 JRST	NODC10
	MOVE	N,CPUN
	ASKDEC	<  How many DC10s on CPU* (1,0-2) [
The DC10 is a data line scanner.]>
NODC10:	SKIPN	CPUN
	MOVEM	N,M.DC10
	MOVEI	N,0			;NO DC68
	SKIPN	CPUN
	SKIPN	DLSCAN
	 JRST	NODC68
	MOVE	N,CPUN
	ASKDEC	<  How many DC68s on CPU* (1,0-2) [
The DC68 is a PDP-8 680 or 680I communications system.]>

NODC68:	SKIPN	CPUN
	MOVEM	N,M.DC68
	MOVEI	N,0		;NO DC76S
	SKIPN	CPUN
	SKIPN	DLSCAN		;DO WE WANT TO ASK?
	 JRST	NODC76		;NO
	MOVE	N,CPUN
	ASKDEC	<  How many DC76s on CPU* (1,0-8) [
The DC76 is a PDP-11 communications system.]>

NODC76:	SKIPE	CPUN
	JRST	ASKTT1
	MOVEM	N,M.DC76
	FILOUT	<M.DC10==:*@>,M.DC10
	FILOUT	<M.DC68==:*@>,M.DC68
	FILOUT	<M.DC76==:*@>,M.DC76
	SKIPN	M.DC10		;HAVE A DC10?
	JRST	ASK68		;NO--DO NOT ASK ABOUT IT
	PUSH	P,[0]		;ASK ABOUT DC10 #0
	PUSHJ	P,ASKDCX	; ..
	AOS	(P)		;ASK ABOUT DC10 #1
	MOVE	N,M.DC10	;GET # OF DC10S
	CAME	N,(P)		;ALL DONE
	PUSHJ	P,ASKDCX	; ..
	POP	P,(P)		;CLEAN UP THE STACK

ASK68:	SKIPN	M.DC68		;ANY DC68 HARDWARE
	JRST	ASK76		;NO--ASK ABOUT DC76
	PUSH	P,[0]		;ASK ABOUT DC68 #0
	PUSHJ	P,ASKD68	; ..
	AOS	(P)		;ASK ABOUT DC68 #1
	SOSE	M.DC68		; IF THERE ARE 2 DC10S
	PUSHJ	P,ASKD68	; ..
	POP	P,(P)		;CLEAN UP THE STACK
ASK76:	SKIPN	M.DC76		;HAVE A DC76?
	JRST	ASKTT1		;NO--DO NOT ASK DC76 QUESTIONS
	PUSH	P,[0]
	PUSHJ	P,ASKD76
	AOS	(P)
	SOSE	M.DC76
	JRST	.-3
	POP	P,(P)
	JRST	ASKTT1
TKSGEN:	FILOUT	<M.DC10==:0@>
	FILOUT	<M.DC68==:0@>
	FILOUT	<M.DC76==:0@>
	ASKDEC	<  DZ-11 TTY lines (0-32) [
Respond with the total number of TTY lines.]>
	MOVEM	N,M.DZNL
	SETZM	CPUN		;FIRST CPU
	FILCPU	<M.DZNL==:*@>,N
ASKTT2:	FILOUT	<M.D70N==:*@>,M.D70N
	FILOUT	<M.D71N==:*@>,M.D71N
	FILOUT	<M.D72N==:*@>,M.D72N
	FILOUT	<M.D73N==:*@>,M.D73N
	FILOUT	<M.D74N==:*@>,M.D74N
	FILOUT	<M.D75N==:*@>,M.D75N
	FILOUT	<M.D76N==:*@>,M.D76N
	FILOUT	<M.D77N==:*@>,M.D77N
	FILOUT	<M.D78N==:0@>	;DUMMY SYMBOLS SINCE DC76 ONLY ON DL10
	FILOUT	<M.D79N==:0@>
	FILOUT	<M.D7AN==:0@>
	FILOUT	<M.D7BN==:0@>
	FILOUT	<M.TTG0==:*@>,M.TTG0
	FILOUT	<M.TTG1==:*@>,M.TTG1
	FILOUT	<M.DSG0==:*@>,M.DSG0
	FILOUT	<M.DSG1==:*@>,M.DSG1
	FILOUT	<M.68L0==:*@>,M.68L0
	FILOUT	<M.68L1==:*@>,M.68L1
	FILOUT	<M.DZNL==:*@>,M.DZNL
	FILOUT	<M.TTDN==:*@>,M.TTDN

	MOVE	N,M.TTG0	;NUMBER OF 8-LINE GROUPS
	ADD	N,M.TTG1	; PLUS NUMBER OF LINES ON DC10 #1
	LSH	N,3		;TIMES 8=NUMBER OF LINES
	ADD	N,M.D70N	;PLUS LINES ON DC76
	ADD	N,M.D71N
	ADD	N,M.D72N
	ADD	N,M.D73N
	ADD	N,M.D74N
	ADD	N,M.D75N
	ADD	N,M.D76N
	ADD	N,M.D77N
	ADD	N,M.DZNL	;PLUS DZ-11 LINES (KS-10)
	ADD	N,M.TTDN	;PLUS RSX-20F LINES (KL-10)
	ADD	N,M.68L0	;PLUS LINES ON DC68
	ADD	N,M.68L1	; = TOTAL NUMBER OF LINES
	MOVEM	N,M.TLTL	;SAVE FOR M.PTY & M.RTTY
	FILOUT	<M.TLTL==:*	;TOTAL LOCAL TTY LINES@@>
;FALL INTO ASKOPR ON NEXT PAGE
ASKOPR:	SOJ	N,		;ADJUST TO GET HIGHEST LINE
	BTHOUT	<@>		;SOME SEPARATION
	ASKLIN	<  OPR octal line number (CTY,0-*) [
Respond with the octal number of the terminal you want to designate as 
device OPR, the operator-privileged terminal.  This is normally the 
terminal that will be running OPR, the operator service program, to control 
the system utility programs such as the device spoolers and the mount 
request processor.  The default is the console terminal (CTY).]>

	FILOUT	<DEFINE	OPRLIN>
	PUSHJ	P,FILLAB
	FILOUT	<@	OPRL	*@>,N
	PUSHJ	P,FILRAB
	FILOUT	<@>

ASKDSD:	FILOUT	<DEFINE	MACDSD>	;START MACRO DEFINITION
	ASKMN	<  Data set lines [
Class of terminal for LOGIN, LOGIN resets line to computer echoing and no 
hardware tabs.
    This question accepts a list of octal terminal line numbers.  The 
terminal line can be indicated by its number (n), a range of terminal lines 
can be indicated by the lowest and highest numbers in the range separated 
by a hyphen (m-n), and the CTY is always indicated by CTY.  Type each 
designator on a separate line and end the list with an extra carriage 
return.]@>

TTYEND:	JRST	ASKJOB			;DONE HERE, ON TO NEXT QUESTION
;SUBROUTINE TO ASK ABOUT DC10 HARDWARE
;CALL WITH:
;	PUSHJ	P,[DC10 NUMBER]
;	PUSHJ	P,ASKDCX

ASKDCX:	MOVE	N,-1(P)		;PICK UP DC10 NUMBER
	TTYOCT	<@  For DC10 *:@>
	MOVEI	N,SM.TTG	;MAX TTY GROUPS
	ASKDEC	<    Number of DC10B [or 632] 8 line data groups (1-*) [
1 is TTY0 through 7, 2 is TTY0 through 17,...8 is TTY0 through 77.]>
	MOVE	T1,-1(P)	;STORE FOR CORRECT DC10
	MOVEM	N,M.TTG0(T1)	; ..
	ASKDEC	<    Number of DC10E data set control groups (0-*)>
	MOVE	T1,-1(P)
	MOVEM	N,M.DSG0(T1)	;STORE FOR CORRECT DC10


ASKCRR:	MOVE	N,-1(P)		;WHICH DC10
	FILOUT	<DEFINE	MACCR*>
	MOVE	T1,-1(P)
	SKIPN	M.DSG0(T1)	;DATA SETS?
	JRST	ASKCR1		;NO, SKIP THIS QUESTION
	ASKMNP	<  Correspondence of DC10E lines to the DC10B lines (M-N,P) [
Type M,P for one pair and M-N,P for a range of pairs, where M is an octal 
DC10E line number, M-N is an octal range of DC10E line numbers, and P is an 
octal DC10B line number.]@>
	POPJ	P,0		;RETURN
ASKCR1:	PUSHJ	P,FILLAB	;OUTPUT NULL MACRO IF DIDNT ASK
	PJRST	FILRAB		;FINISH MACRO IF DIDNT ASK
;SUBROUTINE TO ASK ABOUT DC68 LINES
;CALL WITH:
;	PUSH	P,[DC68 NUMBER]
;	PUSHJ	P,ASKD68

ASKD68:	MOVE	N,-1(P)
	TTYOCT	<@  FOR DC68 *:@>
	MOVEI	N,SM.68L
	ASKOCT	<    Number of DC68 lines, including its console TTY (1-*)>
	MOVE	T1,-1(P)
	MOVEM	N,M.68L0(T1)
	POPJ	P,
;SUBROUTINE TO ASK ABOUT A DC76
;CALL WITH
;	PUSH	P,[DC76 NUMBER]
;	PUSHJ	P,ASKD76

ASKD76:	MOVE	N,-1(P)
	TTYOCT	<@  For DC76 *:@>
	ASKDEC	<    To which DL10 port is the DC76 connected (0,1-7) [
Each PDP-11 is connected to a DL10 port.  If there is only one PDP-11, it 
is always connected to port 0.  If there are two PDP-11s, one is connected 
to port 0 and the other is connected to port 1.]>
	PUSH	P,N
	ASKDEC	<    Decimal lines on DC76 (1-129) [
Each DC76F has 16 lines, plus one line for the console teletype.  A DC76 
with two DC76Fs has 33 lines.]>
	MOVE	T1,(P)
	MOVEM	N,M.D70N(T1)
	POP	P,(P)
	POPJ	P,0
ASKJOB:	BTHOUT	<@>		;SEPARATION
	MOVEI	N,SM.JOB	;MAXIMUM NUMBER OF JOBS
	ASKDEC	<Number of Jobs (1-*) [
Respond with the maximum number of jobs, attached and detached, not 
counting the null job.  Specify only the maximum number of jobs needed.
Monitor size increases proportionally to the maximum number of jobs.]>
	FILOUT	<M.JOB==:*@>,N
	FILOUD	<MD.SEG==:*@>,MD.SEG

ASKCOR:	MOVEI	N,SM.MPI	;MAXMUM NUMBER OF PAGES
	ASKDEC	<Maximum pages of core for each job (0,0-*) [
Answer this question with the maximum amount of physical memory that any 
one job may use.  This value is specified in number of 512-word pages.  A 
response of 0 indicates all of core, or the maximum number of pages 
possible.  The value you specify here can be overridden by the SET CORMAX 
monitor command.]>,N
	FILOUT	<M.CORE==:*@>,N
	MOVEI	N,^D4096	;UP TO 4 MILLION WORDS ALLOWED

ASKNKC:	ASKDEC	<Total amount of system core in K (512-*) [
ONCE-only reports if there is less core at startup.  Answer this question 
with the total amount of physical memory that the system has.  At monitor 
startup time, ONCE prints a message if the actual amount of memory on line 
is less than your response to this question.]>
	FILOUT	<M.NKC==:*@>,N
ASKTPS:	SKIPN	M.KS10		;KS10?
	JRST	ASKRTD		;NO
	ASKLST	<Clock ticks per second (60,50) [
Clock ticks per second corresponds to power line frequency.  In North 
America, the correct response is 60; in most other countries, the correct 
response is 50.]>
	SKIPN	N		;SKIP IF 50
	TROA	N,^D60		;NO, 60
	MOVEI	N,^D50		;50
	FILOUT	<M.TPS==:*@>,N
ASKRTD:	SKIPN	M.KS10		;KS10?
	JRST	ASKRT0		;NO--GO ON
	FILOUT	<M.RTD==:0@>	;YES--NO REAL TIME
	JRST	ASKLOK		;GO ON
ASKRT0:	MOVEI	N,SM.RTD	;MAXIMUM NUMBER OF REAL TIME DEVICES
	ASKDEC	<Number of real-time devices (0,0-*) [
Answer this question with the maximum number of real-time devices that can 
be put on PI channels simultaneously.]>
	FILOUT	<M.RTD==:*@>,N
	JUMPN	N,ASKLK1	;DO NOT ASK ABOUT LOCKING IF REAL TIME
				; SINCE MUST HAVE LOCKING FOR REAL TIME

ASKLOK:	ASKYN	<Allow jobs to be locked in core (YES,NO) [
If you answer NO, no users will be allowed to lock their jobs in core 
memory.
    The ANF-10 network programs DTELDR and NETLDR require the ability to 
lock a job in memory.  Therefore, if you intend to use these programs, you 
must answer this question YES.  This question is always asked for KS 
systems, and is asked for KL systems only if no real-time devices are 
employed.]>
ASKLK1:	FILOUT	<M.LOK==:*@>,N
	MOVEM	N,M.LOK		;SAVE IT FOR LATER TESTS
	JUMPE	N,ASKMG1

ASKMGC:	MOVEI	N,SM.MPI	;MAXIMUM NUMBER OF PAGES ON KI10
	ASKDEC	<Guaranteed number of pages for unlocked jobs (0,0-*) [
Answer this question with the number of pages of memory guaranteed to all 
jobs that are not locked in core.  The default, 0, indicates that all of 
memory is available to unlocked jobs.
    If your answer is 0, no jobs are allowed to be locked, as a safeguard 
against locked jobs usurping all of the system's memory.  The value 
specified in your answer to this question can be overridden by the SET 
CORMIN monitor command.]>
ASKMG1:	FILOUT	<M.MGC==:*@>,N

ASKEVM:	SKIPN	N,M.LOK		;LOCK UUO INCLUDED?
	JRST	ASKEV1		;NO, NO LOCKING IN EVM EITHER
				;DEFAULT (FOR DTELDR) IS 10. PAGES
	ASKDEC	<Number of pages reserved for locking jobs in Exec Virtual Memory (10,0-?) [
The default, 10, is needed for DTELDR.  Extra pages are required for 
running performance analysis tools such as SNOOPY and DNSNUP or for any 
real-time applications using indirect CONSO masks or fast mode.  Reserving
pages for EVM reduces the amount of available system free core by an 
equivalent amount.]>
ASKEV1:	FILOUT	<M.EVM==:*@>,N


ASKHPQ:	MOVEI	N,SM.HPQ	;MAXIMUM NUMBER OF HIGH PRIORITY QUEUES
	ASKDEC	<Number of high priority interrupt queues (0,0-*)>
	FILOUT	<M.HPQ==:*@>,N

ASKMET:	ASKLST	<Meter (NO,YES) [
Do you want to include performance analysis metering with the METER UUO? 
This option has officially been superseded by the PERF. UUO.]>
	FILOUT	<M.METR==:*@>,N

ASKKAS:	ASKLST	<KASER (NO,YES) [
Do you want to include support for simulation of KA10 long floating point 
instructions?]>
	FILOUT	<M.FPS==:*@>,N

ASKMSG:	ASKYN	<MPXSER (YES,NO) [
Do you want to include support for device MPX?  MPX allows more than one 
device to be associated with a given I/O channel.  This feature is required 
for DTELDR.  If you answer YES, the multiplexed-channel software MPX will 
be loaded.]>
	FILOUT	<M.MPX==:*@>,N
ASKPSI:	ASKYN	<PSISER (YES,NO) [
Do you want to load the Programmed Software Interrupt SERvice software? 
PSISER supports the PISYS. UUO, which allows users to specify the 
conditions for which an interrupt is to occur.  PSISER is required for the 
operation of GALAXY-10.]>
	FILOUT	<M.PSI==:*@>,N

ASKIPC:	ASKYN	<IPCF (YES,NO) [
Do you want to load the Inter-Process Communication Facility software?  
IPCF allows jobs and/or system processes to communicate with each other. 
IPCF is required for the operation of MCS-10 and GALAXY-10.]>
	FILOUT	<M.IPCF==:*@>,N

ASKENQ:	ASKYN	<ENQ/DEQ (YES,NO) [
Do you want to load the ENQ/DEQ software?  ENQ/DEQ provides sychronization 
functions which allow simultaneous file updates by multiple co-operating 
processes.]>
	FILOUT	<M.EQDQ==:*@>,N

DSKSET:	ASKSTR	<Disk sets (ALL) [
Answer this question with the list of disk sets to be mounted by this 
system.  If the list is empty, ALL disk sets will be mountable.  Disk set 
numbers range from 1 through 36.  List entries in the form:
	
	3,9-12,14,...
	
]>
	SETZM	M.SETS		;CLEAR OUT OUR VARIABLE
	JUMPE	CH,DSKSE4	;DEFINE EMPTY SYMBOL IF NO SETS TO BE ENABLED
	CAIE	CH,"A"		;DOES IT LOOK LIKE HE TYPED "ALL"
	CAIN	CH,"a"		;IN EITHER CASE?
	TRNA			;YES--LOOK FURTHER
	JRST	DSKSE1		;NO--COLLECT A LIST OF NUMBERS
	MOVEI	T1,[ASCIZ/(ALL)/] ;LIST STRING
	PUSHJ	P,SETASK	;SETUP FOR EXAMINING THE RESPONSE
	PUSHJ	P,FNDAS1	;GET THE RESPONSE
	  JRST	DSKER1		;FORMAT ERROR
	JUMPN	CH,DSKER1	;MUST BE AT EOL
	JRST	DSKSE4		;OK--PRETEND IT WAS A BARE <CR>
DSKSE1:	PUSHJ	P,GETDEC	;READ A DECIMAL SET NUMBER
	JUMPLE	N,DSKERR	;MUST BE POSITIVE
	CAILE	N,^D36		;AND .LE. 36
	JRST	DSKERR		;RANGE ERROR
	MOVE	T1,N		;COPY VALUE IN CASE NOT A RANGE
	CAIE	CH,"-"		;IS THIS FOR A RANGE?
	JRST	DSKSE2		;NO
	PUSH	P,N		;YES, SAVE CURRENT VALUE
	PUSHJ	P,GETDEC	;GET NEXT VALUE
	POP	P,T1		;RESTORE PREVIOUS
	CAILE	N,0		;MUST BE IN RANGE
	CAILE	N,^D36		;OF 1-36
	JRST	DSKERR		;RANGE ERROR IF NOT
	CAML	T1,N		;MAKE SURE OF ASCENDING ORDER
	JRST	DSKER1		;COMPLAIN IF NOT
DSKSE2:	SUB	N,T1		;GET OFF-BY-ONE COUNT OF BITS
	SETCA	N,		;MAKE -VE ACTUAL COUNT
	MOVSS	N		;PUT IN LH
	HRRI	N,-1(T1)	;GET PROPER STARTING BIT NUMBER
DSKSE3:	MOVE	T1,BITTBL(N)	;GET NEXT BIT TO USE
	IORM	T1,M.SETS	;INCLUDE IN OUR MASK
	AOBJN	N,DSKSE3	;LOOP OVER THE ENTIRE RANGE
	JUMPE	CH,DSKSE4	;ALL OK AT EOL
	CAIN	CH,","		;WAS BREAK A COMMA?
	JRST	DSKSE1		;YES, LOOP FOR NEXT
	JRST	DSKER1		;NO, COMPLAIN AND RE-ASK

DSKERR:	TTYOUT	<? Disk set numbers range only from 1 through 36.@>
	AOJA	LV,DSKSET
DSKER1:	TTYOUT	<? Invalid list format@>
	AOJA	LV,DSKSET

DSKSE4:	HLRZ	N,M.SETS	;GET LH OF VALUE
	FILOUT	<M.SETS==:*,,>	;START WITH LH
	HRRZ	N,M.SETS	;GET RH
	FILOUT	<*@>		;FINISH M.SETS DEFINITION
	MOVE	LV,SAVLV	;BACK TO DESIRED HELP LEVEL


;START OF PER-CPU DEVICE QUESTIONS
	SETOM	CPUN
	ASKLST	<Configure non-autoconfigured hardware (NO,YES) [
Do you want to include unsupported hardware in your configuration?]>
	MOVEM	N,UNAUTC	;REMEMBER THE FLAG
ASKDEV:	AOS	N,CPUN
	CAML	N,M.CPU
	JRST	DEVEND
	SKIPE	UNAUTC		;ONLY IF WANT TO PROMPT
	SKIPN	SMP
	JRST	ASKDIS		;SKIP "ON CPU*" IF ONLY ONE
	BTHOUT	<@On CPU*:@>,N
ASKDIS:	MOVEI	N,0		;NO DISPLAYS
	SKIPE	M.KL10
	SKIPN	UNAUTC
	JRST	NODIS		;NO
	SKIPE	CPUN		;CPU0?
	JRST	NODIS		;NO, CAN'T HAVE DISPLAYS ON NON-ZERO CPUS

	ASKLST	<DIS (NO,YES) [
Do you want to include display devices VP10, 340, 30, or VB10C (as 
distinguished from display terminals) in your configuration?]>

NODIS:	JUMPE	N,ASKDS1	;ANY DISPLAYS?
	ASKLST	<Type (VP10,340,VB10C) [
Respond with the specific type of display device you want to include in 
your configuration.  Answer VP10 for Type 30.]>
	AOS	M.VP10(N)	;SET M.VP10, M.340 OR M.VBXC TO 1
ASKDS1:	SKIPE	CPUN		;CPU0?
	JRST	ASKDS2		;NO, JUST DUMP CPU VARIABLES (ZEROS)
	FILOUT	<M.VP10==:*@>,M.VP10
	FILCPU	<M.VP10==:*@>,M.VP10
	FILOUT	<M.340==:*@>,M.340
	FILCPU	<M.340==:*@>,M.340
	FILOUT	<M.VBXC==:*@>,M.VBXC
	FILCPU	<M.VBXC==:*@>,M.VBXC
	SETZ	N,		; FOR FILOUT OF M.DIS
	SKIPN	M.VP10		;SKIP IF VP10 DISPLAY
	SKIPE	M.340		;SKIP IF NOT 340 DISPLAY
	MOVEI	N,1		;FILOUT M.DIS=1 IF EITHER 340 OR VP10
	FILOUT	<M.DIS==:*@>,N	;
	FILCPU	<M.DIS==:*@>,N	;
	JRST	ASKDS3		;SKIP AROUND CPU1-N CASE
ASKDS2:	FILCPU	<M.VP10==:0@>
	FILCPU	<M.340==:0@>
	FILCPU	<M.VBXC==:0@>
	FILCPU	<M.DIS==:0@>
ASKDS3:
ASKDTA:	MOVEI	N,0		;NO DECTAPES
	SKIPE	M.KL10
	SKIPN	UNAUTC		;WANT TO ASK?
	JRST	NODTAS		;NO

	MOVEI	N,SM.DTA	;MAXIMUM NUMBER OF DTA CONTROLLERS
	ASKDEC	<Number of TD10s (0,0-*) [
The TD10 is a DECtape controller.]>

NODTAS:	FILCPU	<M.TD10==:*@>,N
	MOVE	I,N		;SETUP DTA UNIT ITERATION COUNTER
	JUMPE	I,DTEND		;ANY DTA UNIT AT ALL?
DTLOOP:	AOS	N,DTA		;YES, INCREMENT COUNT OF DT CONTROLLERS IN SYSTEM
	ADDI	N,'A'-1		;FORM SIXBIT CONTROLLER LETTER
	ROT	N,-6		;LEFT JUSTIFY
	ASKDEC	<  Number of units on DT* (1-8)>,N
	PUSH	P,N		;SAVE ANSWER(NO OF UNITS ON THIS CONTROLER
	MOVE	N,DTA		;CONTROLLER NUMBER
	ADDI	N,'A'-1		;FORM SIXBIT CONTROLLER LETTER
	ROT	N,-6		;LEFT JUSTIFY
	FILOUT	<M.DT*==:>,N	;FIRST HALF
	EXCH	N,(P)
	FILOUT	<*@>,N		;OUTPUT
	EXCH	N,(P)
	FILCPU	<M.DT*==:>,N	;FIRST HALF
	POP	P,N		;RESTORE NO. OF UNITS ON THIS CONTROLER
	FILCPU	<*@>,N		;OUTPUT
	SOJG	I,DTLOOP	;ANY MORE CONTROLLERS?
DTEND:
ASKRX2:	SETZ	N,		;DEFAULT TO NO RX20S
	SKIPN	M.KL10		;KL10?
	SKIPN	UNAUTC		;WANT TO ASK?
	JRST	RXEND		;NO
	MOVEI	N,SM.RXK	;MAXIMUM NUMBER OF RX02 CONTROLLERS
	ASKDEC	<Number of RX211s (0,0-*) [
The RX211 is a double density "floppy disk" controller.]>
	FILCPU	<M.RX20==:*@>,N
	MOVE	I,N		;SETUP RX02 UNIT ITERATION COUNTER
	JUMPE	I,RXEND		;ANY RX02 UNITS AT ALL?
RXLOOP:	AOS	N,RX20		;YES, BUMP COUNT OF RX CONTROLLERS IN SYSTEM
	ADDI	N,'A'-1		;FORM SIXBIT CONTROLLER LETTER
	ROT	N,-6		;LEFT JUSTIFY
	ASKDEC	<  Number of units on RX* (1-2)>,N
	PUSH	P,N		;SAVE ANSWER(NO OF UNITS ON THIS CONTROLER
	MOVE	N,RX20		;CONTROLLER NUMBER
	ADDI	N,'A'-1		;FORM SIXBIT CONTROLLER LETTER
	ROT	N,-6		;LEFT JUSTIFY
	FILOUT	<M.RX*==:>,N	;FIRST HALF
	EXCH	N,(P)
	FILOUT	<*@>,N		;OUTPUT
	EXCH	N,(P)
	FILCPU	<M.RX*==:>,N	;FIRST HALF
	POP	P,N		;RESTORE NO. OF UNITS ON THIS CONTROLER
	FILCPU	<*@>,N		;OUTPUT
	SOJG	I,RXLOOP	;ANY MORE CONTROLLERS?
RXEND:	SKIPN	M.KL10
	SKIPE	UNAUTC		;DID WE ASK?
	JRST	ASKXTC		;YES
	FILCPU	<M.RX20==:0@>
ASKXTC:	MOVEI	N,0		;NO DA28S
	SKIPE	M.KL10
	SKIPN	UNAUTC
	JRST	NODA28		;NO
	SKIPE	CPUN		;IF NOT CPU0,
	JRST	NODA28		;DON'T ASK

	MOVEI	N,SM.XTC	;MAX # OF DA28S
	ASKDEC	<Number of DA28s (0,0-*) [
The DA28 provides interprocessor channels for PDP8/11/15.]>

NODA28:	FILCPU	<M.XTC==:*@>,N
	SKIPE	CPUN
	JRST	NDA28B
	FILOUT	<M.XTC==:*@>,N
NDA28B:	JUMPE	N,XTCEND
	ASKDEC	<Number of lines for TTY pool (8,0-512) [
The answer you provide specifies the number of lines (up to a maximum of 
512) reserved for use on DA28 channels.]>
	FILOUT	<M.XTL==:*@>,N
	MOVEM	N,M.XTL

XTCEND:	FILCPU	<M.XTL==:*@>,N
ASKD78:	MOVEI	N,0
	SKIPE	M.KL10
	SKIPN	UNAUTC
	JRST	NODS78
	SKIPE	CPUN		;CPU0?
	JRST	NODS78		;NO, CAN'T HAVE ANY HERE
	MOVEI	N,SM.D78	;MAXIMUM NUMBER OF DAS78S
	ASKDEC	<Number of DAS78s (0,0-*) [
The DAS78 provides IBM 360, 370, and/or 2780 support.]>
	ADDM	N,M.DAS78	;ACCUMULATE TOTAL NUMBER IN SYSTEM
NODS78:	MOVEM	N,M.D78N	;SAVE NUMBER ON THIS CPU FOR COUNT DOWN
	JUMPE	N,ASK78B	;SEE IF ANY DAS78S
	PUSH	P,[0]		;PUT A 0 ON THE STACK TO COUNT UP
ASK78A:	PUSHJ	P,ASK78S	;ASK ABOUT THE DAS78S
	AOS	(P)		;SET UP TO ASK ABOUT NEXT ONE
	SOSE	M.D78N		;ASKED ABOUT ALL DAS78S?
	JRST	ASK78A		;NO, ASK ABOUT ANOTHER ONE
	POP	P,(P)		;CLEAN THE STACK
ASK78B:	FILCPU	<M.0D78==:*@>,M.0D78
	FILCPU	<M.1D78==:*@>,M.1D78
	FILCPU	<M.2D78==:*@>,M.2D78
	FILCPU	<M.3D78==:*@>,M.3D78
	FILCPU	<M.4D78==:*@>,M.4D78
	FILCPU	<M.5D78==:*@>,M.5D78
	FILCPU	<M.6D78==:*@>,M.6D78
	FILCPU	<M.7D78==:*@>,M.7D78
	FILCPU	<M.D78L==:*@>,M.D78L
	FILCPU	<M.XXI==:*@>,M.D78L
	FILCPU	<M.XXO==:*@>,M.D78L
	JRST	ASK78C		;DONE DAS78S.

ASK78S:	MOVE	N,-1(P)		;GET A NUMBER FOR DAS78
	TTYOCT	<@For DAS78 *:@@>
	ASKDEC	<To which DL10 port is the DAS78 connected (0,0-7) [
Each DAS78 PDP11 is connected to a DL10 port.]>
	PUSH	P,N		;SAVE PORT NUMBER ON STACK
	ASKDEC	<Decimal lines on the DAS78 (1-16) [
Each DAS78 can support up to 16 IBM 360s, 370s, and/or 2780s.]>
	ADDM	N,M.D78L	;KEEP A SUM OF THE DAS78 LINES
	MOVE	T1,(P)		;GET DAS78 NUMBER
	MOVEM	N,M.0D78(T1)	;SAVE LINES IN PROPER PORT LOC
	POP	P,(P)		;CLEAN STACK
	POPJ	P,		;EXIT
ASK78C:
ASKD60:	MOVE	T1,[M.DN6D,,M.DN6D+1]
	SETZM	M.DN6D
	BLT	T1,M.BD60
	SETZ	N,
	SKIPN	M.KL10
	JRST	ASK60A
	SKIPE	UNAUTC		;SKIP IF WANT NO DN60S
	SKIPE	CPUN
	JRST	ASK60A

	MOVEI	N,SM.D60	;MAXIMUM NUMBER OF DN60S
	ASKDEC	<Number of DN60s (0,0-*) [
The DN60 is an IBM BSC interface.]>
ASK60A:	MOVEM	N,M.DN6D	;SAVE NUMBER FOR COUNT DOWN
	ADDM	N,M.DN60	;ADD TO GENERIC DN60 DEVICE COUNTER TOO
	SKIPE	CPUN
	JRST	ASK60C
	FILOUT	<M.DN6D==:*@>,M.DN6D
	SKIPN	M.DN6D		;SEE IF ANY DN60S
	JRST	ASK60C		;NO DN60S
	PUSH	P,[0]		;PUT A 0 ON THE STACK TO COUNT UP
ASK60B:	PUSHJ	P,ASK60S	;ASK ABOUT THE DN60S
	AOS	(P)		;SET UP TO ASK ABOUT NEXT ONE
	SOSE	M.DN6D		;ASKED ABOUT ALL DN60S?
	JRST	ASK60B		;NO, ASK ABOUT ANOTHER ONE
	POP	P,(P)		;CLEAN THE STACK
ASK60C:	FILCPU	<M.0D60==:*@>,M.0D60
	FILCPU	<M.1D60==:*@>,M.1D60
	FILCPU	<M.2D60==:*@>,M.2D60
	FILCPU	<M.3D60==:*@>,M.3D60
	FILCPU	<M.4D60==:*@>,M.4D60
	FILCPU	<M.5D60==:*@>,M.5D60
	FILCPU	<M.6D60==:*@>,M.6D60
	FILCPU	<M.7D60==:*@>,M.7D60
	FILCPU	<M.D60L==:*@>,M.D60L
	SKIPE	CPUN
	JRST	ASK60D
	FILOUT	<M.0D60==:*@>,M.0D60
	FILOUT	<M.1D60==:*@>,M.1D60
	FILOUT	<M.2D60==:*@>,M.2D60
	FILOUT	<M.3D60==:*@>,M.3D60
	FILOUT	<M.4D60==:*@>,M.4D60
	FILOUT	<M.5D60==:*@>,M.5D60
	FILOUT	<M.6D60==:*@>,M.6D60
	FILOUT	<M.7D60==:*@>,M.7D60
	FILOUT	<M.D60L==:*@>,M.D60L
	JRST	ASK60D		;DONE DN60S.
ASK60S:	MOVE	N,-1(P)		;GET A NUMBER FOR DN60
	TTYOCT	<@For DN60 *:@@>
	ASKOCT	<To which port is the DN60 connected (0,0-7) [
Each DN60 is connected to a DL10 port.  DL10 number 1 connects to ports 0 
through 3, DL10 number 2 connects to ports 4 through 7.]>
	PUSH	P,N		;SAVE PORT NUMBER ON STACK
	ASKDEC	<Decimal lines on the DN60 (1-12) [
Each DN60 can support up to 12 IBM BSC interfaces.]>
	ADDM	N,M.D60L	;KEEP A SUM OF THE DN60 LINES
	MOVE	T1,(P)		;GET DN60 NUMBER
	MOVEM	N,M.0D60(T1)	;SAVE LINES IN PROPER PORT LOC
	POP	P,(P)		;CLEAN STACK
	POPJ	P,		;EXIT

ASK60D:	FILOUT	<M.DN6K==:0@>	;NO DN60 DEVICES ON KMC/DUP-11S
	FILOUT	<M.DN6R==:0@>	;NO DN60 DEVICES ON DMRS
	FILOUT	<M.DN60==:*@>,M.DN60 ;DUMP COUNT OF GENERIC DN60 DEVICES
ASKDUP:	SETZ	P1,			;ASSUME NO DUP-11S
	SKIPN	M.KS10
	JRST	DUPEND
	MOVEI	N,SM.KDUP		;MAXIMUM NUMBER OF DUP-11S
	ASKDEC	<Number of KMC/DUP Lines (0,0-*) [
Respond with the number of DUP11 synchronous line units attached to a KMC11 
controller.]>,N
	FILOUT	<M.KDUP==:*@>,N
	SETZB	I,M.DN6K		;START AT DUP NUMBER 0
	JUMPE	N,ASKDMR		;IF NO KMCS, JUST SEE ABOUT DMRS
	MOVE	P1,N			;COPY NUMBER OF DUP-11S
KSDUP0:	CAML	I,P1			;ARE WE STILL IN RANGE?
	JRST	DUPEND			;NO, WRITE OUT ACCUMULATED STUFF
	MOVE	N,I			;Copy to where it will find it
	ASKLST	<Type of line for KDP* (ANF10,DECNET,USER,IBM) [
This question is asked for each KDP (KMC/DUP line) indicated in the 
previous question.  Type the name of the network product that the line 
will support.]>

D60SZ:	CAIN	N,4-1			;IS THIS AN IBM LINE?
	AOS	M.DN6K			;NOTE THAT WE HAVE A DN60 LINE
	AOS	P2,N			;BUMP TO MAKE DD.XXX SYMBOL
	FILOUT	<M.*KDP==:>,I		;OUTPUT SYMBOL
	FILOUT	<*@>,P2			;OUTPUT VALUE FOR THE SYMBOL
	AOJA	I,KSDUP0		;GO TRY FOR THE NEXT LINE

DUPEND:	MOVEM	P1,M.KDPN		;SAVE NUMBER OF KDPS
ASKDMR:	SETZM	M.DN6R			;NO DMR IBMCOMM...YET
	SETZ	N,			;ASSUME NONE
	SKIPN	M.KS10
	JRST	ASKIBM
	SKIPN	UNAUTC
	JRST	NODMRS			;NO
	MOVEI	N,SM.DMRN		;MAXIMUM NUMBER OF DMR11S
	ASKDEC	<Number of DMR11 Lines (0,0-*) [
Respond with the number of DMR11 synchronous line controllers.]>,N

NODMRS:	FILOUT	<M.DMRN==:*@>,N
	ADD	P1,N			;GET TOTAL COMM LINES
	JUMPE	P1,KSGEN2		;IF NONE, TURN OF DN60, DECNET
	MOVE	P1,N			;SAVE NUMBER OF DMRs
	MOVEM	P1,M.DMRN		;SAVE NUMBER OF DMRS
	SETZ	I,			;START WITH DMR0
KSGENR:	CAML	I,P1			;DONE WITH ALL DMRs?
	 JRST	ASKIBM			;YES
	MOVE	N,I			;GET CURRENT DMR NUMBER
	ASKLST	< DMR* line type (ANF10,DECNET,USER,IBM) [
Type the name of the network product that the line will support.]>
	CAIN	N,4-1			;IS THIS AN IBM LINE?
	AOS	M.DN6R			;NOTE THAT WE HAVE A DN60 LINE
	AOS	P2,N			;BUMP TO MAKE DD.XXX SYMBOL
	FILOUT	<M.*DMR==:>,I		;OUTPUT SYMBOL
	FILOUT	<*@>,P2			;OUTPUT VALUE FOR THE SYMBOL
	MOVE	N,I			;GET CURRENT DMR NUMBER
	ASKYN	< DMR* switched line (YES,NO) [
Does DMR* control a switched (dial-up) line?]>,N
	EXCH	I,N			;NEED TO OUTPUT DMR #
	FILOUT	<DMR*SW==:>,N
	EXCH	I,N			;RESTORE RESPONSE
	FILOUT	<*@>,N
	JUMPE	N,KSGENX		;IF NOT, SKIP REST
	MOVE	N,I
	ASKYN	< DMR* half duplex (YES,NO) [
Does DMR* control a half duplex line?]>,N
	EXCH	I,N
	FILOUT	<DMR*HD==:>,N
	EXCH	I,N
	FILOUT	<*@>,N
	JUMPE	N,KSGENX		;IF NOT, LONG START IS MEANINGLESS
	MOVE	N,I
	ASKYN	< Is DMR* secondary (YES,NO) [
Exactly one end of this link should be a secondary station.  Secondary 
status controls link startup only.]>,N
	EXCH	I,N
	FILOUT	<DMR*LS==:>,N
	EXCH	I,N
	FILOUT	<*@>,N
KSGENX:	TTYOUT	<@>			;SEPERATE DMRS
	AOJA	I,KSGENR		;LOOP FOR NEXT
ASKIBM:	SKIPN	M.KS10
	JRST	IBMEND
	MOVE	T1,M.DN6K		;GET COUNT OF IBMCOM DEVICES
	ADD	T1,M.DN6R		;ADD IN DMR STYLE DN22S
	ADDM	T1,M.DN60		;ACCUMULATE
	SKIPN	M.DN60			;IF SOME LINE WANTED IBMCOMM
	JRST	ASKIB1			;NO
	ASKYN	<Load IBM communications software (YES,NO) [
Do you want to load the IBM communications software?  IBMCOM allows a KDP 
or DMR to talk to a DN22 IBM communications front-end.]>,N
	SKIPE	M.KDPN			;IF KDPS, CONSIDER
	ADDM	N,M.DN6K		; THAT D6KINT WANTED
	SKIPE	M.DMRN			;IF DMRS, CONSIDER
	ADDM	N,M.DN6R		; THAT D6RINT IS WANTED
	MOVE	T1,M.DN6K		;NUMBER OF KDP IBM LINES
	ADD	T1,M.DN6R		;GET TOTAL NUMBER OF COMM LINES
	MOVEM	T1,M.DN60		;THIS IS HOW MANY IBM LINES WE WANT

ASKIB1:	FILOUT	<M.DN60==:*@>,M.DN60	;TELL COMNET ABOUT IBMCOM
	FILOUT	<M.DN6K==:*@>,M.DN6K	;LOAD D6KINT??
	FILOUT	<M.DN6R==:*@>,M.DN6R	;LOAD D6RINT??
	JRST	IBMEND

KSGEN2:	FILOUT	<M.DECN==:0@>		;SAY NO DECNET CODE
	FILOUT	<M.DN60==:0@>		;NO IBM CODE
	FILOUT	<M.DN6K==:0@>
	FILOUT	<M.DN6R==:0@>
IBMEND:
ASK87:	SETZM	M.0D85		;CLEAR OUT FIRST WORD
	MOVE	T1,[M.0D85,,M.0D85+1] ;XFER VECTOR
	BLT	T1,M.7D85	;CLEAR DL10 PORT INFO FOR NON-ZERO CPU
	SKIPN	M.KL10		;KL10?
	JRST	ASK85B		;NO
	SKIPE	UNAUTC
	SKIPE	CPUN
	JRST	ASK85B		;NONE
	ASKDEC	<Number of DC75NPs or DN87s on CPU* (0,0-8) [
The DC75NP and DN87S are network front-ends connected to DL10s.]>
	MOVEM	N,M.DC75	;store number of 75/87s
	FILOUT	<M.DC75==:*@>,M.DC75
	SKIPN	M.DC75		;ask which ports if non-zero
	JRST	ASK85B		;if none, write out symbols as zeros
	MOVEI	P1,1		;Start numbering FEs with 1
;	SETZ	P2,		;P2=0 SAYS DL10 INTERFACE
ASK85A:	PUSHJ	P,ASK85S	;ask which port
	ADDI	P1,1		;increment counter
	SOSE	M.DC75		;are we done?
	JRST	ASK85A		;no, continue
	JRST	ASK85B		;yes, write out symbols
ASK85S:	MOVE	N,P1		;GET FRONT END #
	TTYOCT	<For front end number *:@>;identify which PDP11
;	JUMPN	P2,ASK851	;DO RIGHT MESSAGE FOR DL10/DTE-20
	ASKDEC	<To which DL10 port is the DC75NP or DN87 connected (0,0-7) [
Each DC75NP or DN87S is connected to a DL10 port.  DL10 number 1 connects 
ports 0 through 3, DL10 number 2 connects ports 4 through 7.]>;ask port
;	JRST	ASK852		;SKIP DTE-20 QUESTION

;ASK851: ASKDEC	<To which DTE20 is the DN87S connected (1,1-3)>
ASK852:	MOVE	T1,N		;use answer as index
	MOVEI	N,1		;value to set word M.nD85 to
	MOVEM	N,M.0D85(T1)	;set word to 1 indicating port in use as 85
	POPJ	P,		;return
ASK85B:	FILCPU	<M.0D85==:*@>,M.0D85 ;OUTPUT ALL SYMBOLS
	FILCPU	<M.1D85==:*@>,M.1D85
	FILCPU	<M.2D85==:*@>,M.2D85
	FILCPU	<M.3D85==:*@>,M.3D85
	FILCPU	<M.4D85==:*@>,M.4D85
	FILCPU	<M.5D85==:*@>,M.5D85
	FILCPU	<M.6D85==:*@>,M.6D85
	FILCPU	<M.7D85==:*@>,M.7D85
	JRST	ASKDEV
DEVEND:	FILOUT	<M.TD10==:*@>,DTA
	FILOUT	<M.DAS78==:*@>,M.DAS78
	FILOUT	<M.XXI==:*@>,M.D78L
	FILOUT	<M.XXO==:*@>,M.D78L
	FILOUT	<M.RX20==:*@>,RX20

ASKPTY:	MOVEI	N,SM.RTY	;MAXIMUM NUMBER OF ALLOCATABLE TTYS
	SUB	N,M.TLTL	;KNOCK OFF LOCAL LINES
	SUB	N,M.CPU		;ONE PER CTY
	SOJ	N,		;FRCLIN
	SKIPE	M.KS10		;IF A KS,
	SUB	N,M.CPU		;ACCOUNT FOR KLINIK LINE(S)
	SUB	N,M.XTL		;DISCOUNT DA28 TERMINALS
	MOVEM	N,MAXRTY	;SAVE FOR NETGEN
	ASKDEC	<Number of PTYs (20,1-*) [
A PTY is a pseudo-terminal.  OPSER subjobs and batch jobs use PTYs for I/O.  
Each operator service program and batch stream needs at least one PTY.  You 
must include at least one PTY for your monitor.  Respond with the number of 
pseudo-terminals that your monitor must support.]>
	FILOUT	<M.PTY==:*@>,N
	MOVNS	N		;NEGATE
	ADDM	N,MAXRTY	;KEEP THIS COUNTER UP-TO-DATE
ASKNET:	SETZM	STANAM		;CLEAR OUT STATION NAME
	ASKYN	<@Network software (YES,NO) [
Do you want to include support for communications with other Digital 
operating systems?]>
	FILOUT	<M.NET==:*@>
	JUMPE	N,NETEND
	PUSHJ	P,ASKNOD	;GET THE NODE NAME
	MOVEM	N,STANAM	;SAVE
	FILOUT	<M.SNAM==:<SIXBIT &*&>@>,N

	MOVE	N,MAXRTY	;MAX REMOTE TTYS AVAILABLE
	ASKDEC	<Number of remote TTYs (*,0-*) [
Respond with the maximum number of terminals from remote nodes to be 
handled at any one time.]>,N
	MOVEM	N,M.RTTY	;REMEMBER FOR LATER TESTING
	FILOUT	<M.RTTY==:*@>,N
	JRST	ASKANF		;ONWARD


;ROUTINES TO ASK FOR A NODE NAME
ASKNOD:	ASKSTR	<Node name [
The name may one to six characters in length.]>
	PUSHJ	P,ASKNO1	;GET A NODE NAME
	  AOJA	LV,ASKNOD	;TRY AGAIN WITH MORE HELP
	JUMPN	N,CPOPJ		;ALL IS OK IF NON-NULL
	TTYOUT	<? Must not be null.@>
	AOJA	LV,ASKNOD	;TRY AGAIN TO GET A GOOD NAME

ASKNOX:	MOVE	N,STANAM	;LOAD UP THE DEFAULT
	ASKSTR	<  Node name (*) [
Provide a node name, independent of that used as the system-wide node name.  
The name can be one to six characters in length.  DECnet-10, Version 4 
requires that the first character of the node name be an alphabetic 
character.  The same node name will be used for both ANF-10 and DECnet-10 
communications.]>
	PUSHJ	P,ASKNO1	;GET A NODE NAME
	  AOJA	LV,ASKNOX	;TRY AGAIN WITH MORE HELP
	POPJ	P,		;WON'T BE NULL BY NOW

ASKNO1:	CAILE	N,^D6		;CORRECT NUMBER?
	RJRST	<TTYOUT		<? More than 6 characters.@>
		POPJ	P,>
	PUSHJ	P,GETWRD	;GET SIXBIT QUANTITY
	SKIPN	N,WD		;COPY TO A BETTER PLACE
	MOVE	N,STANAM	;DEFAULT PROPERLY
	JRST	CPOPJ1		;SKIP RETURN ON SUCCESS
ASKANF:	ASKYN	<@ANF-10 software (YES,NO) [
Answer YES if you want to load the monitor modules needed to communicate 
with ANF-10 hosts and remote stations.]>
	FILOUT	<M.ANF==:*@>,N
	JUMPE	N,ASKDCN

	PUSHJ	P,ASKNOX	;ASK FOR ANF-10 STATION NAME
	FILOUT	<M.ANAM==:<SIXBIT &*&>@>,N

	ASKOCT	<  Node number of central site (1,1-77) [
Provide a unique octal number to identify the system to the ANF network.]>
	FILOUT	<M.ANUM==:*@>,N

	SKIPN	N,M.RTTY	;ALLOWING ANY TTY CONNECTS?
	JRST	ANFMC0		;NO, CAN'T ALLOW ANF TTY CONNECTS
	ASKYN	<  Remote terminals (YES,NO) [
Answer YES if you want to include code to allow remote terminals to "SET 
HOST" to this system.]>
ANFMC0:	FILOUT	<M.RMCR==:*@>,N
	JUMPE	N,ANFVT0

	ASKYN	<  Virtual terminals (YES,NO) [
Answer YES if you want to include code to allow local terminals to "SET 
HOST" to other systems.]>,N
ANFVT0:	FILOUT	<M.RVTM==:*@>,N

	ASKYN	<  Remote card readers (YES,NO) [
Answer YES if you want to include code to allow access to card readers on 
ANF remote stations.]>,N
	FILOUT	<M.RCDR==:*@>,N

	ASKYN	<  Remote line printers (YES,NO) [
Answer YES  if you want to include code to allow access to line printers on 
ANF remote stations.]>,N
	FILOUT	<M.RLPT==:*@>,N

ANFPTP:	ASKLST	<  Remote paper tape punches (NO,YES) [
Answer NO to exclude code to allow access to paper tape punches on ANF 
remote stations.]>,N
	FILOUT	<M.RPTP==:*@>,N

ANFPTR:	ASKLST	<  Remote paper tape readers (NO,YES) [
Answer NO to exclude code to allow access to paper tape readers on ANF
remote stations.]>,N
	FILOUT	<M.RPTR==:*@>,N

ANFPLT:	ASKLST	<  Remote plotters (NO,YES) [
Answer NO to exclude code to allow access to plotters on ANF remote 
stations.]>,N
	FILOUT	<M.RPLT==:*@>,N

ANFDDP:	ASKYN	<  Remote DN8x DDCMP devices (YES,NO) [
Answer NO to exclude code to allow access to DN8x LBLK-to-DDCMP devices on 
ANF remote stations.]>,N
	FILOUT	<M.RDDP==:*@>,N
	ASKYN	<  Remote data entry terminals (YES,NO) [
Answer YES to include code to allow access to remote data entry terminals 
(RDX devices).]>,N
	FILOUT	<M.RDX==:*@>,N

	ASKYN	<  Remote task-to-task (YES,NO) [
Answer YES to include code to allow access to remote jobs.  The TSKSER 
module enables ANF-10 intertask communication.]>,N
	FILOUT	<M.RJOB==:*@>,N

	MOVEI	N,SM.CONN/2	;DEFAULT TO HALF THE MAX.
	ASKDEC	<  Number of connects (*,1-512) [
Respond with the maximum number of simultaneous connections allowed.]>,N
	FILOUT	<M.CONN==:*@>
ASKDCN:	ASKYN	<@DECnet software (YES,NO) [
Answer YES if you want to load the monitor modules needed to communicate 
with other DECnet nodes.]>
	FILOUT	<M.DECN==:*@>,N
	JUMPE	N,ASKLAT	;NO, SKIP OVER ALL THIS STUFF

	PUSHJ	P,ASKNOX	;ASK FOR DECNET NODE NAME
	FILOUT	<M.DNAM==:<SIXBIT &*&>@>,N

	ASKDEC	<  Area number of central site (1,1-63) [
Provide a decimal area number for multi-area DECnet network configurations.]>
	FILOUT	<M.DHOM==:*@>,N

	ASKDEC	<  Node number of central site (1,1-1023) [
Provide a unique decimal number to identify this system to other nodes in 
the DECnet network.]>
	FILOUT	<M.DNUM==:*@>,N

	ASKLST	<  Router type (ROUTING,NONROUTING) [
Specify router type.  ROUTING nodes can have multiple circuits and perform 
DECnet routing.  NONROUTING nodes have only an ethernet circuit and perform 
no DECnet routing.
    If you have a KL and want to communicate with a Multifunctions 
Communications Base (MCB), or if you have a KS, answer this question with 
ROUTING.]>
	ADDI	N,4		;CONVERT TO VALUES 4(ROUTING) AND 5(NONROUTING)
	FILOUT	<M.DRTY==:*@>,N

ASKXPW:	ASKSTR	<  Transmit password (DECNET20) [
The transmit password is used when initializing a point-to-point KDP, DTE, 
or DMR link.  You may provide a password of 64 characters or less, or press 
RETURN to accept the default password.]>
	JUMPE	CH,ASKNRT	;SKIP THE MACRO IF DEFAULTING
	CAILE	N,^D64		;64 OR LESS?
	RJRST	<TTYOUT <? More than 64 characters@>
		 JRST	ASKXPW>
	MOVSI	N,'*  '		;IN CASE "*" IS IN PASSWORD
	FILSTR	<DEFINE	%RTXPW<RTRPW <*>>@>

ASKNRT:	SKIPN	N,M.RTTY	;ALLOWING REMOTE TTYS?
	JRST	NRTNON		;NO, CAN'T LOAD NRTSER
	ASKYN	<  Remote terminals (YES,NO) [
Answer YES to include code that allows incoming jobs using DECnet 
connections. The module loaded will be NRTSER.]>
NRTNON:	FILOUT	<M.DNVT==:*@>,N
ASKLAT:	SKIPE	N,M.ENET	;HAVE ETHERNET?
	SKIPN	N,M.RTTY	;ALLOWING REMOTE TTYS?
	JRST	LATNT0		;NO, CAN'T HAVE LATSER
	ASKYN	<@LAT software (YES,NO) [
Answer YES if you want to communicate with Local Area Terminal 
concentrators using Ethernet.  The module loaded will be LATSER.]>
LATNT0:	FILOUT	<M.LAT==:*@>,N
	JUMPE	N,NETEND	;JUMP IF NO LAT WANTED

	PUSHJ	P,ASKNOX	;YES, GET A 'NODE' (SERVICE) NAME
	FILOUT	<M.LNAM==:<SIXBIT &*&>@>,N	;PUT IT IN THE FILE

	MOVEI	N,SM.LMC	;MAXIMUM NUMBER OF SIMULTANEOUS CIRCUITS
	ASKDEC	<  Number of circuits (20,1-*) [
Provide the maximum number of simultaneous LAT circuits required by your 
system.  One is required for each active LAT server.]>,N
	FILOUT	<M.LAMC==:*@>

ASKGRP:	ASKSTR	<  Service groups [
Provide the list of LAT service groups to be enabled by default at system 
start-up time.  If the list is empty, no service groups will be enabled.  
List entries in the form:
	
	3,4-7,9,12-14,...
	
LAT group numbers must be listed in ascending order, may include a range of
numbers, and each entry must be separated from the next with a comma.  The 
range of valid service group numbers is 0 through 255.]>
	JUMPE	CH,ASKGR3	;DEFINE EMPTY MACRO IF NO GROUPS TO BE ENABLED
ASKGR1:	PUSHJ	P,GETDEC	;READ A DECIMAL SERVICE GROUP
	JUMPL	N,GRPERR	;MUST BE POSITIVE
	CAILE	N,^D255		;AND .LE. 255
	JRST	GRPERR		;RANGE ERROR
	CAIE	CH,"-"		;IS THIS FOR A RANGE?
	JRST	ASKGR2		;NO
	PUSH	P,N		;YES, SAVE CURRENT VALUE
	PUSHJ	P,GETDEC	;GET NEXT VALUE
	POP	P,T1		;RESTORE PREVIOUS
	CAIL	N,0		;MUST BE IN RANGE
	CAILE	N,^D255		;OF 0-255
	JRST	GRPERR		;RANGE ERROR IF NOT
	CAML	T1,N		;MAKE SURE OF ASCENDING ORDER
	JRST	GRPER1		;COMPLAIN IF NOT
ASKGR2:	JUMPE	CH,ASKGR3	;ALL OK AT EOL
	CAIN	CH,","		;WAS BREAK A COMMA?
	JRST	ASKGR1		;YES, LOOP FOR NEXT
	JRST	GRPER1		;NO, COMPLAIN AND RE-ASK

GRPERR:	TTYOUT	<? LAT service groups range only from 0 through 255.@>
	AOJA	LV,ASKGRP
GRPER1:	TTYOUT	<? Invalid list format@>
	AOJA	LV,ASKGRP

ASKGR3:	FILOUT	<DEFINE	SPCGRP>	;START MACRO DEFINITION
	PUSHJ	P,FILLAB	;OPEN MACRO BODY
	MOVE	B,[POINT 7,ASCSTR]	;RESET BYTE POINTER
	PUSHJ	P,SKBLNK	;SKIP OVER BLANKS
	JUMPE	CH,GRPEND	;FINISH OFF AT EOL
	FILOUT	<LATGRP	>	;SUB-MACRO
	MOVEI	CH,"<"		;BRACKET CALL FOR IRP
	PUSHJ	P,FILPUT	; ...
	MOVE	B,[POINT 7,ASCSTR]	;RESET BYTE POINTER FOR GETDEC
ASKGR4:	PUSHJ	P,GETDEC	;READ IN A GROUP NUMBER
	CAIN	CH,"-"		;IS THIS A RANGE?
	JRST	ASKGR6		;YES, HANDLE DIFFERENTLY
	PUSH	P,CH		;NO, SAVE BREAK
	FILDEC	<*>,N		;DUMP ANOTHER GROUP
ASKGR5:	POP	P,CH		;RESTORE BREAK
	JUMPE	CH,ASKGR7	;EOL MEANS END CALL
	PUSHJ	P,FILPUT	;STUFF THE COMMA
	JRST	ASKGR4		;LOOP OVER ALL GROUPS
ASKGR6:	MOVEI	CH,"<"		;GROUP THE RANGE ARG
	PUSHJ	P,FILPUT	;FOR COMDEV
	FILDEC	<*,>,N		;FIRST NUMBER AND COMMA FOR SECOND
	PUSHJ	P,GETDEC	;GET SECOND NUMBER IN RANGE
	PUSH	P,CH		;SAVE THE BREAK
	FILDEC	<*>,N		;PUT OUT THE NUMBER
	MOVEI	CH,">"		;END BROCKET
	PUSHJ	P,FILPUT	;TO END THE RANGE ARGUMENT
	JRST	ASKGR5		;COMMON CODE TO TEST FOR END
ASKGR7:	PUSHJ	P,FILRAB	;DUMP THE ">" TO END THE CALL TO LATGRP

GRPEND:	PUSHJ	P,FILRAB	;END THE DEFINE OF SPCGRP
	MOVE	LV,SAVLV	;RESTORE PERMANENT HELP LEVEL
;	JRST	NETEND

NETEND:
ASKDSY:	FILOUT	<@RADIX	10@>;	;SET RADIX TO DECIMAL IN FILE
	BTHOUT	<@Decimal "symbol,value" [
For any decimal symbols to be defined, type one "symbol,value" pair per 
line and terminate the list with an extra carriage return.  The symbols and 
values that you enter here are those that deviate from the defaults defined 
in the distributed common modules (COMMON, COMDEV, and COMMOD).  The radix 
is set automatically for each symbol, in accordance with the radix 
specified in the question.  (In this case, decimal.  You will be given the 
opportunity to change the values for symbols with octal and SIXBIT values 
in the questions that follow.)  For example, to increase the length of a 
memory cycle from 1,000 nanoseconds to 1,760 nanoseconds, 
type:
	
     NSPMEM,1760
	
followed by a carriage return.  Unless you specify otherwise, the symbols 
will be defined with the default values.  If the default values are 
acceptable, press RETURN in response to this question.]@>
DSYLOP:	TLO	F,(F.BANG!F.NEG) ;ALLOW "!" IN EXPRESSIONS AND NEGATIVE VALUES
	PUSHJ	P,TTYIN		;GET NEXT LINE
	  JRST	ASKDSY		;/HELP TYPED, ASK AT PROPER HELP MODE
	JUMPE	CH,DSYEND	;JUST A CR?
	PUSHJ	P,GETWRD	;GET FIRST WORD
	CAIE	CH,","		;IS IT FOLLOWED BY ,
	JRST	DSYERR		;NO, ERROR
	MOVE	CH,B		;COPY PLACE IN LINE
	ILDB	CH,CH		;GET NEXT CHAR
	CAIE	CH,"<"		;AN EXPRESSION? (>)
	 JRST	DSYDEC		;NO, CONTINUE NORMALLY
	PUSHJ	P,WIGEXP	;YES, GET A WIDGETED EXPRESSION
	 JRST	DSYERR		;OOPS.
	JRST	DSYLOP		;OK, STORE THE MESS
DSYDEC:	PUSHJ	P,GETDEC	;GET SECOND WORD AS DECIMAL
	JUMPN	CH,DSYERR	;IS IT LAST WORD ON LINE?
DSYPUT:	FILSTR	<XP *@>;	;YES, WRITE IT OUT
	JRST	DSYLOP		;LOOP BACK FOR NEXT LINE

DSYERR:	TTYOUT	<? Not symbol,value@>
	AOJA	LV,ASKDSY	;TRY AGAIN

DSYEND:	FILOUT	<RADIX	8@>;	;SET RADIX BACK TO NORMAL IN FILE
	MOVE	LV,SAVLV	;RESTORE PERMANENT HELP LEVEL
				; IN CASE HE TYPED /H<CR>


ASKOSY:	BTHOUT	<@Octal "symbol,value" [
For any octal symbols to be defined, type one "symbol,value" pair per line 
and terminate the list with an extra carriage return.  For example, to 
change the standard magtape density from 6250 bits per inch (BPI) to 1600, 
type:
	
     STDENS,4
	
followed by a carriage return.  In this example, 1 = 200 BPI, 2 = 556 BPI, 
3 = 800 BPI, and 5 = 6250  BPI.  If the default values are acceptable, 
press RETURN in response to this question.]@>
OSYLOP:	TLO	F,(F.BANG!F.NEG) ;ALLOW "!" IN EXPRESSIONS AND NEGATIVE VALUES
	PUSHJ	P,TTYIN		;GET NEXT LINE FOR USER
	  JRST	ASKOSY		;/HELP TYPED, ASK IN DESIRED HELP MODE
	JUMPE	CH,OSYEND	;JUST A BLANK LINE?
	PUSHJ	P,GETWRD	;NO, GET FIRST WORD
	CAIE	CH,","		;IS BREAK A COMMA?
	JRST	OSYERR		;NO, ERROR
	MOVE	CH,B		;COPY PLACE IN LINE
	ILDB	CH,CH		;GET NEXT CHAR
	CAIE	CH,"<"		;AN EXPRESSION? (>)
	 JRST	OSYOCT		;NO, CONTINUE NORMALLY
	PUSHJ	P,WIGEXP	;YES, GET A WIDGETED EXPRESSION
	 JRST	OSYERR		;OOPS.
	JRST	OSYLOP		;OK, STORE THE MESS
OSYOCT:	PUSHJ	P,GETOCT	;YES, GET VALUE IN OCTAL
	JUMPN	CH,OSYERR	;IS THIS END OF LINE?
OSYPUT:	FILSTR	<XP *@>		;YES, WRITE IT OUT
	JRST	OSYLOP		;LOOP BACK FOR MORE

OSYERR:	TTYOUT	<? Not symbol,value@>
	AOJA	LV,ASKOSY	;GO TRY AGAIN
;HELPER ROUTINE FOR DECIMAL AND OCTAL INPUT TO PROCESS EXPRESSIONS
;
;CALL KNOWING THAT THE NEXT CHAR IS A LEFT WIDGET
;
;RETURN: CPOPJ IF ERROR, CPOPJ1 IF OK

WIGEXP:	SETZ	I,		;AT LEVEL ZERO
WIGEX0:	ILDB	CH,B		;GET NEXT WIDGET
	JUMPE	CH,CPOPJ	;END OF LINE, ERROR
	CAIN	CH,"<"		;OPEN WIDGET
	 AOJA	I,WIGEX0	;YES, COUNT DEEPER (ALWAYS FIRST CHAR)
	CAIE	CH,">"		;CLOSE WIDGET?
	 JRST	WIGEX0		;NO, JUST WALK ALONG
	SOJG	I,WIGEX0	;YES, LESS DEEP.  CONTINUE IF NOT LAST ONE
	PUSHJ	P,SKBLNK	;SKIP TRAILING BLANKS
	JUMPN	CH,CPOPJ	;RETURN IF NOT AT EOL
	MOVSI	N,'*  '		;IF EXPRESSION MULTIPLIES, INCLUDE IT
	FILSTR	<XP *@>		;WRITE OUT THE ANSWER
	JRST	CPOPJ1		;SUCCESS

OSYEND:	MOVE	LV,SAVLV	;RESTORE PERMANENT HELP LEVEL
				; IN CASE HE TYPED /H<CR>

ASKSSY:	BTHOUT	<@SIXBIT "symbol,value" [
For any SIXBIT symbol to be defined, type one "symbol,value" pair per line 
and terminate the list with an extra carriage return.  For example, to 
change the name of the mail program from MS to PO, type:
	
     M.MAIL,PO
	
followed by a carriage return.   If the default values are acceptable, 
press RETURN in response to this question.]@>
SSYLOP:	PUSHJ	P,TTYIN		;GET NEXT LINE
	  JRST	ASKSSY		;/HELP TYPED, ASK IN PROPER MODE
	JUMPE	CH,SSYEND	;CARRIAGE RETURN?
	PUSH	P,B		;SAVE BYTE POINTER TO STRING
	PUSHJ	P,GETWRD	;GET FIRST WORD
	CAIE	CH,","		;IS BREAK A COMMA?
	JRST	SSYERR		;NO, ERROR
	PUSHJ	P,GETWRD	;GET SECOND WORD
	JUMPN	CH,SSYERR	;ERROR IF MORE TYPE-IN
	POP	P,B		;RESTORE BYTE POINTER
	PUSHJ	P,GETWRD	;GET FIRST WORD AGAIN
	FILOUT	<*==:>,WD	;OUTPUT FIRST WORD
	PUSHJ	P,GETWRD	;GET SECOND WORD
	FILOUT	<<SIXBIT/*/>@>,WD	;OUTPUT SIXBIT VALUE
	JRST	SSYLOP		;AND LOOK FOR MORE

SSYERR:	POP	P,B		;RESTORE PDL
	TTYOUT	<? Not symbol,value@>
	AOJA	LV,ASKSSY	;GO TRY AGAIN

SSYEND:	MOVE	LV,SAVLV	;RESTORE PERMANENT HELP LEVEL
				; IN CASE USER TYPED /H<CR>
ASKSP1:	FILOUT	<@DEFINE	SPCINT>
	PUSHJ	P,FILLAB	;LEFT ANGLE BRACKET,CRLF TO FILE
ASKS1A:	BTHOUT	<@Type "device-mnemonic,PI-channel" for special devices [
This question allows you to build the monitor to support a device driver 
that is not part of the standard monitor.  Type the device name and the 
priority-interrupt channel for a device driver that does not save the ACs 
on a priority interrupt, and that does not require Device Data Blocks 
(DDBs) in the monitor.  A driver of this type can support only one device.
The device mnemonic must be 3 characters or less in length.  Type an extra 
carriage return when through.]@>
SP1LOP:	PUSHJ	P,GETDPI	;GET NEXT LINE AND SCAN FOR DEV:PI
	  AOJA	LV,ASKS1A	;ERROR OR /HELP
	JUMPE	WD,SP1END	;JUST CR TYPED?
	RJUMPN	CH,<TTYOUT <? Not device-mnemonic,PI-channel@>
		AOJA	LV,ASKS1A>  ;GO ASK FOR MORE
	FILSTR	<SPASGINT *@>;	;OUTPUT ANSWER TO FILE
	JRST SP1LOP		;GO GET ANOTHER LINE

SP1END:	PUSHJ	P,FILRAB	;RIGHT ANGLE BRACKET,CRLF TO FILE
	MOVE	LV,SAVLV	;RESTORE PERMANENT HELP LEVEL
				; IN CASE HE TYPED /H<CR>


ASKSP2:	FILOUT	<@DEFINE	SPCDDB>	;START MACRO DEFINITION
	PUSHJ	P,FILLAB	;LEFT ANGLE BRACKET,CRLF TO FILE
ASKS2A:	BTHOUT	<@Type "device-mnemonic,PI-channel,no.-of-devices" [
This question allows you to define a device driver that requires Device 
Data Blocks (DDBs) and will support multiple devices.  Specify the device 
name,  priority-interrupt channel, and number of devices to be supported.
The device-mnemonic must be 3 characters or less in length.  Type an extra 
carriage return when through.]@>
SP2LOP:	PUSHJ	P,GETDPI	;GET NEXT LINE, AND SCAN FOR DEV:PI
	  AOJA	LV,ASKS2A	;/HELP OR ERROR, REASK QUESTION
	JUMPE	WD,SP2END	;JUST CR TYPED?
	CAIE	CH,","		;IS BREAK A COMMA?
	JRST	SP2ERR		;END OF LINE TOO SOON?
	PUSHJ	P,GETDEC	;GET NO. OF DEVICES
	JUMPN	CH,SP2ERR	;IS THIS LAST WORD ON LINE?
	FILSTR	<SPASGDDB *@>;	;YES, OUTPUT TRIPLE
	JRST	SP2LOP		;GO GET ANOTHER LINE

SP2ERR:	TTYOUT	<? Not device-mnemonic,PI-channel, no.-of-devices@>
	AOJA	LV,ASKS2A	;GO GET MORE

SP2END:	PUSHJ	P,FILRAB	;RIGHT ANGLE BRACKET,CRLF TO FILE
	MOVE	LV,SAVLV	;RESTORE PERMANENT HELP LEVEL
				; IN CASE HE TYPED /H<CR>
ASKSP3:	FILOUT	<@DEFINE	SPCSAV>	;START MACRO DEFINITION
	PUSHJ	P,FILLAB	;LEFT ANGLE BRACKET,CRLF
ASKS3A:	BTHOUT	<@Type "device-mnemonic,PI-channel,highest-ac-to-save" [
This question allows you to define device drivers that include a channel 
save routine to save ACs up to the "highest AC to save".  Specify the 
device name, priority-interrupt channel, and the number of the highest AC 
to save on an interrupt.  The device-mnemonic must be 3 characters or less 
in length.  Type extra carriage return when through.]@>
SP3LOP:	PUSHJ	P,GETDPI	;GET NEXT LINE AND SCAN FOR DSK:PI
	  AOJA	LV,ASKS3A	;/HELP OR ERROR, REASK QUESTION
	JUMPE	WD,SP3END	;JUST CR TYPED?
	CAIE	CH,","		;IS BREAK AFTER PI A COMMA?
	JRST	SP3ERR		;NO, ERROR
	PUSHJ	P,GETOCT	;GET HIGHEST AC TO SAVE
	JUMPN	CH,SP3ERR	;IS THIS LAST ITEM ON LINE?
	CAILE	N,SM.AC		;SKIP IF LEGAL AC
	RJRST	<MOVEI	N,SM.AC
		TTYOCT	<? Highest-ac-to-save must be * or less@>
		AOJA	LV,ASKS3A>
	FILSTR	<SPASGSAV *@>;	;OUTPUT TRIPLE TO FILE
	JRST	SP3LOP		;GO GET NEXT LINE

SP3ERR:	TTYOUT	<? Not device-mnemonic,PI-channel,highest-ac-to-save@>
	AOJA	LV,ASKS3A	;GO ASK  FOR MORE
SP3END:	PUSHJ	P,FILRAB	;FILL IN A RIGHT ANGLE BRACKET
	MOVE	LV,SAVLV	;RESTORE PERMANENT PROMP LEVEL IN CASE /HELP


ASKEDN:	FILOUT	<@DEFINE	SPCEDN>	;START MACRO DEFINITION
	PUSHJ	P,FILLAB	;ADD LEFT ANGLE BRACKET
ASKEDA:	BTHOUT	<@Type "ersatz-device,P,Pn,search-list-type" [
This question allows you to define your own ersatz device names.  
Monitor-standard ersatz device names must not be redefined.  To create 
additional site-specific ersatz device names, type a device name in exactly 
3 characters, the Project,Programmer Number (P,PN) associated with the 
device, and which search list to use (either ALL, SYS, or JOB) and press 
RETURN.  You may define another ersatz device, or press RETURN again to 
finish.]@>
EDNLOP:	PUSHJ	P,TTYIN		;GET NEXT INPUT LINE
	  AOJA	LV,ASKEDA	;/HELP OR ERROR
	JUMPE	CH,EDNEND	;ALL DONE
	PUSHJ	P,GETWRD	;GET ERSATZ DEVICE NAME
	CAIE	CH,","		;BREAK ON COMMA
	JRST	EDNER1		;NO, COMMAND ERROR
	TRNN	WD,770000	;MUST BE EXACTLY 3 CHARACTERS
	TLNN	WD,77		;...
	JRST	EDNER1		;ISN'T, GIVE ERROR
	PUSHJ	P,GETOCT	;GET PROJECT NUMBER
	CAIE	CH,","		;BREAKON COMMA
	JRST	EDNER1		;NO, COMMAND ERROR
	PUSHJ	P,GETOCT	;GET PROGRAMMER NUMBER
	CAIE	CH,","		;BREAKON COMMA
	JRST	EDNER1		;NO, COMMAND ERROR
	PUSHJ	P,GETWRD	;GET SEARCH LIST TYPE
	JUMPN	CH,EDNER1	;NOW THAT MUST BE THE LAST
	CAME	WD,[SIXBIT/ALL/] ;CHECK CHOICES
	CAMN	WD,[SIXBIT/SYS/] ;...
	JRST	EDNLO1		;OK, GO WRITE FILE
	CAME	WD,[SIXBIT/JOB/] ;LAST CHANCE
	JRST	EDNER1		;BAD ARGUMENT
EDNLO1:	FILSTR	<UERSTZ	*@>	;OUTPUT TO FILE
	JRST	EDNLOP

EDNER1:	TTYOUT	<?Not ersatz-device,P,Pn,search-list-type@>
	AOJA	LV,ASKEDA	;ASK AGAIN

EDNEND:	PUSHJ	P,FILRAB	;OUTPUT RIGHT ANGLE BRACKET
	MOVE	LV,SAVLV	;RESTORE PROMPT LEVEL AFTER POSSIBLE /HELP
ASKCMD:	FILOUT	<@DEFINE	SPCCMD> ;DEFINE THE MACRO
	PUSHJ	P,FILLAB	;PUT OUT THE LEFT ANGLE BRACKET
ASKCM1:	TLO	F,(F.OFO)	;OUTPUT FILES ARE OPEN
	BTHOUT	<@Type "command-name,dispatch,flags,unique-bits,PRVTAB-name" [
This question allows you to create new monitor commands or to redefine 
existing monitor commands.  The command name that you specify here will run 
the program that you specify, using the characteristics that you specify. 
Type each new command name followed by the information that the monitor 
needs to process the command.  This information is specified by each of the 
following components.  All components must be separated by commas, as shown 
above.  To omit a component, include only the comma in its place.  The 
components are:
	
   1. Command-name.  The command-name is the name of the monitor command to
      be added.  Type the command name as a single SIXBIT alphanumeric word
      or a single SIXBIT character enclosed in angle-brackets, or omit the
      name if you only want to extend PRVTAB.
	
   2. Dispatch address.  The dispatch address identifies the program or 
      routine to run when the command is processed.  This may be the name 
      of the program to run from SYS (file name only), or it may  be 
      omitted if the program name and command name are equivalent.  The 
      dispatch address may also be a location (label) of a routine in the 
      monitor.  For example, #RUNQUE.
	
   3. Flags.  Flags are defined in COMMON to specify the type of command 
      processing for the monitor to use.  Separate the flags with an 
      exclamation point (!).  Some of the possible flags are:
	
         Flag         Meaning
	
         APPFLG       saves your current context
         CMWRQ        requeues the job after command processing
         CUSTMR       reserved for customer implementation
         INCORE       requires that the job be in memory
         NBATCH       not allowed from a batch job
         NOACT        delayed if any devices are active
         NOCORE       core is not required
         NOINCK       can be processed if issued without a job
         NOJOBN       does not require a job number
         NOLOGIN      does not require that a job be logged in
         NOMESS       suppresses output of SET WATCH statistics
         NOPER        monitor must not prompt after command completion
         NORUN        requires that the job be halted
         NXONLY       is not legal if the job is execute-only
         TTYRNC       monitor should put job in monitor mode
         TTYRNU       monitor should put job in user mode       
         TTYRNW       continue I/O wait after command processing
	
   4. Unique bits.  Unique bits are bit numbers you can define to specify 
      the number of characters that make this command unique.  This is 
      specified in the form INIQ.n, where 'n' is the number of characters 
      from 1 to 4.
	
   5. PRVTAB-name.  The PRVTAB-name is the name of the program to place in 
      the monitor table PRVTAB.  This should be equivalent to the dispatch 
      program name and may be omitted if the command should not be included
      in PRVTAB.  PRVTAB is the monitor's list of priviledged CUSPs.
	
Type extra carriage return when through.]@>
ASKCM2:	SETZM	UCMBGN		;ZERO FIRST WORD OF DATA
	MOVE	CH,[UCMBGN,,UCMBGN+1] ;SETUP BLT POINTER
	BLT	CH,UCMEND	;ZERO IT ALL
	TLO	F,(F.BANG)	;ALLOW "!" IN INPUT LINE
	TLZ	F,(F.OFO)	;DON'T LOG THE LINE IN THE .MAC FILE
	PUSHJ	P,TTYIN		;GET THE LINE
	  JRST	ASKCM1		;/HELP TYPED
	TLO	F,(F.OFO)	;ALLOW WRITING TO THE .MAC FILE AGAIN
	JUMPE	CH,ASKC10	;GO IF NO COMMANDS SPECIFIED
	PUSHJ	P,GETWRD	;GET THE COMMAND NAME
	JUMPN	WD,ASKC12	;CHECK TERMINATOR IF GOT A WORD
	CAIN	CH,","		;IF A PRVTAB-ONLY ENTRY,
	JRST	ASKC12		;CHECK OTHER THINGS
	MOVE	WD,CH		;NO, COPY FOR LATER
	CAIE	CH,"<"		;ANGLE-BRACKETED?
	JRST	ASKCME		;NO, REQUIRE ANGLIES FOR 1-CHAR COMMANDS
	ILDB	WD,B		;YES, GET NEXT CHARACTER
	JUMPE	WD,ASKCME	;EOL IS ILLEGAL HERE
	ILDB	CH,B		;GET CLOSE-ANGLE
	CAIE	CH,">"		;IS IT WHAT WE EXPECTED?
	JRST	ASKCME		;NO
ASKC13:	CAILE	WD,40		;MAKE SURE IT'S IN SIXBIT RANGE
	CAILE	WD,137
	JRST	ASKCME		;NO
	TRZ	WD,40		;YES, CONVERT TO SIXBIT
	CAIE	WD,'<'		;IF EITHER FLAVOR
	CAIN	WD,'>'		;OF BROCKET,
	CAIA			;YES, FLAG BY LEAVING RIGHT-ADJUSTED
	LSH	WD,^D30		;ELSE, LEFT-JUSTIFY IN WORD
	ILDB	CH,B		;PICK UP TERMINATOR
ASKC12:	CAIE	CH,","		;TERMINATOR A COMMA?
	JRST	ASKCME		;NO
	MOVEM	WD,UCMCMD	;STORE FOR LATER
	PUSHJ	P,GETWRD	;GET THE DISPATCH
	CAIE	CH,"#"		;WAS IT AN ADDRESS?
	JRST	ASKCM3		;NO, MUST BE A PROGRAM NAME OR NULL
	JUMPN	WD,ASKCME	;CAN'T HAVE XXX#
	SKIPE	WD,UCMCMD	;IF PRVTAB-ONLY, THIS IS ILLEGAL
	PUSHJ	P,GETWRD	;GET THE ADDRESS
	JUMPE	WD,ASKCME	;MUST NOT BE NULL
	CAIE	CH,","		;TERMINATOR A COMMA?
	JRST	ASKCME		;NO
	MOVEM	WD,UCMADR	;STORE FOR LATER
	JRST	ASKCM4		;SKIP PROGRAM NAME STUFF
ASKCM3:	SKIPN	UCMCMD		;IF PRVTAB-ONLY,
	JUMPN	WD,ASKC15	;THE PRVTAB NAME MUST BE LAST
	CAIE	CH,","		;TERMINATOR A COMMA?
	JRST	ASKCME		;NO
	MOVEM	WD,UCMPRG	;SAVE PROGRAM NAME OR NULL
ASKCM4:	MOVEM	B,UCMBP1	;SAVE BYTE POINTER POSITION
ASKCM5:	ILDB	CH,B		;GET NEXT CHARACTER
	JUMPE	CH,ASKCME	;CAN'T HAVE EOL HERE
	CAIE	CH,","		;SKIP THE FLAGS
	JRST	ASKCM5		;CONTINUE
ASKCM6:	ILDB	CH,B		;GET NEXT CHARACTER OF UNIQUE BITS
	JUMPE	CH,ASKCME	;CAN'T HAVE EOL HERE
	CAIE	CH,","		;FIND THE END?
	JRST	ASKCM6		;NO, CONTINUE
	MOVEM	B,UCMBP2	;STORE ENDING BYTE POINTER
	PUSHJ	P,GETWRD	;GET THE PRVTAB NAME
ASKC15:	JUMPN	CH,ASKCME	;MUST HAVE EOL HERE
	SKIPN	UCMCMD		;IF PRVTAB-ONLY ENTRY,
	JUMPE	WD,ASKCME	;REQUIRE A PRVTAB NAME
	PUSH	P,WD		;SAVE FOR LATER
	FILOUT	<UCMDNM >	;START THE LINE
	MOVEI	CH,"<"		;WANT TO BRACKET THE COMMAND
	PUSHJ	P,FILPUT	;BEGIN NAME
	SKIPN	CH,UCMCMD	;GET SIXBIT OR ASCII
	JRST	ASKC14		;NEITHER--LEAVE IT BLANK
	TLNN	CH,(77B5)	;IS IT SIXBIT?
	JRST	[PUSHJ	P,FILPUT	;NO, DUMP AS ASCII FOR BROCKETS
		 JRST	ASKC14]	;MERGE IN AFTER FILOUT
	FILOUT	<*>,UCMCMD	;TYPE COMMAND NAME
ASKC14:	MOVEI	CH,">"		;END BROCKET
	PUSHJ	P,FILPUT	;FINISH COMMAND NAME VALUE
	FILOUT	<,>		;SEPARATE FIELDS WITH A COMMA
	SKIPN	N,UCMPRG	;GET THE PROGRAM NAME
	JRST	ASKCM7		;NULL
	FILOUT	<*>		;PUT IT OUT
ASKCM7:	FILOUT	<,>
	SKIPN	N,UCMADR	;GET THE ADDRESS
	JRST	ASKCM8		;NULL
	FILOUT	<*>		;PUT IT OUT
ASKCM8:	FILOUT	<,>
	SKIPE	T1,UCMBP1	;GET THE INITIAL BYTE POINTER
	JRST	ASKCM9		;GO USE IT
	FILOUT	<,,>		;FILL IN THE MISSING DELIMITERS
	JRST	ASKC16		;AND GO FINISH UP
ASKCM9:	ILDB	CH,T1		;GET NEXT CHARACTER
	CAIE	CH," "		;SKIP SPACES AND
	CAIN	CH,"	"	;  TABS
	JRST	ASKCM9
	PUSHJ	P,FILPUT	;PUT IT OUT
	CAME	T1,UCMBP2	;END OF STRING?
	JRST	ASKCM9		;NO, GET NEXT
ASKC16:	POP	P,N		;GET BACK PRVTAB NAME
	JUMPE	N,ASKC11	;GO IF NO PRVTAB NAME
	FILOUT	<*>		;PUT IT OUT
ASKC11:	FILOUT	<@>		;END THE LINE
	JRST	ASKCM2		;GET NEXT LINE
ASKCME:	TTYOUT	<?Incorrect syntax for user defined command@>
	AOJA	LV,ASKCM1
ASKC10:	PUSHJ	P,FILRAB	;END THE MACRO
	MOVE	LV,SAVLV	;RESTORE PROMPT AFTER /HELP
ASKTRM:	FILOUT	<DEFINE SPCCLS>	;MACRO NAME
	PUSHJ	P,FILLAB	;START DEFINING NEW CLASSES

CLASLP:	MOVE	LV,SAVLV	;RESTORE AT START OF LOOP

CLASL1:	TLO	F,(F.SUPP)	;DON'T CLUTTER THE MACRO
	ASKSTR	<@Terminal class [
A terminal class is defined by the set of attributes and characteristics 
exhibited by the class as a whole.  If you want to define a terminal class, 
type a 1 to 5 character class name and press RETURN.  To end this section, 
just press RETURN.]>
	JUMPE	CH,CLASND
	PUSHJ	P,TRMCLS	;GET CLASS NAME
	   AOJA	LV,CLASL1	;TRY AGAIN ON ERROR
	MOVEM	WD,TCLASS	;SAVE FOR MEMBER-TYPE LOOP

	TLO	F,(F.SUPP)	;DON'T CLUTTER THE MACRO
	ASKDEC	<Width (80,17-255) [
Type the number that corresponds to the terminal carriage width 
characteristic of the member terminals in the terminal class you are 
defining.   Terminal carriage width is the number of characters printed 
horizontally on the page.]>
	MOVEM	N,TWIDTH	;SAVE WIDTH

	TLO	F,(F.SUPP)	;DON'T CLUTTER THE MACRO
	ASKDEC	<Length (0,0-255) [
Type the number that corresponds to the page length characteristic of the 
member terminals in the terminal class you are defining.  Page length is 
the number of lines printed vertically on the page.]>
	MOVEM	N,TLENG		;SAVE LENGTH

	TLO	F,(F.SUPP)	;DON'T CLUTTER THE MACRO
	ASKDEC	<Fill (0,0-3) [
Type the number that corresponds to the filler class characteristic of the 
member terminals in the terminal class you are defining.  Fill characters 
are stored in the remaining data positions of a line if that line is not 
completly occupied.  The filler class you select determines how many null 
characters are necessary to fill a line, with 0 representing no fill 
characters and 3 representing the highest number of fill characters.]>
	MOVEM	N,TFILL		;SAVE FILLER CLASS

CLSCHL:	MOVEI	T1,CLSCHB	;POINT TO CHARACTERISTICS PARSE BLOCK
	PUSHJ	P,TYPCHR	;ASK FOR AND PARSE CHARACTERISTICS

CLSEPT:	MOVE	I,['V100EP']	;LOAD UP DEFAULT
	TLO	F,(F.SUPP)	;DON'T CLUTTER THE MACRO
	ASKSTR	<Address of erase table (*) [
Type the address of the table of sequences to cursor-right and erase to 
EOL, or press RETURN to accept the default.]>,I
	PUSHJ	P,TRMTAB	;GET VALID SIXBIT TOKEN
	   AOJA	LV,CLSEPT	;TRY AGAIN ON ERROR
	MOVEM	WD,TERASE	;SAVE THE TABLE NAME

CLSBPT:	MOVE	I,['VTXXBP']	;LOAD UP DEFAULT
	TLO	F,(F.SUPP)	;DON'T CLUTTER THE MACRO
	ASKSTR	<Address of rubout table (*) [
Type the address of the table of sequences to backspace, space, backspace, 
or press RETURN to accept the default.]>,I
	PUSHJ	P,TRMTAB	;GET VALID SIXBIT TOKEN
	  AOJA	LV,CLSBPT	;TRY AGAIN ON ERROR
	MOVEM	WD,TBACKP	;SAVE THE TABLE NAME

	TLO	F,(F.SUPP)	;DON'T CLUTTER THE MACRO
	ASKDEC	<ANSI conformance level (1,0-15) [
Type the number that indicates the level of conformance to ANS X3.64 of the 
member terminals in the terminal class you are defining.]>
	MOVEM	N,TANSLV

	TLO	F,(F.SUPP)	;DON'T CLUTTER THE MACRO
	ASKDEC	<DEC conformance level (0,0-15) [
Type the number that indicates the level of conformance to DEC STD 070 for 
the member terminals in the terminal class you are defining.]>
	MOVEM	N,TDECLV

CLSATR:	TLO	F,(F.SUPP)	;DON'T CLUTTER THE MACRO
	ASKSTR	<Characteristic attributes [
From the list below, type one or more of the mnemonics that correspond to 
the attributes supported by member terminals in the terminal class you are 
defining.
	
   Mnemonic   Attribute 
	
   8BA        Capable of 8-bit operation
   8BT        Usually operates in 8-bit mode
   AVO        Advanced Video Option present or emulated
   BMT        Block-mode transfers
   BTA        Block transfers are per ANSI rather than DEC VT131
   CID        Character insertion and deletion
   CLR        Screen color can be manipulated by software
   DIS        Display terminal
   ESL        Extra status line exists
   GAT        Guarded Area Transfer
   GPO        ReGIS
   HSR        Horizontal scrolling
   ISO        ISO/Latin-1 rather than DEC/MCS
   JTK        Katakana character set
   LID        Line insertion and deletion
   NKB        No keyboard (asynchronous printer)
   NRC        National Replacement Characters
   OVR        Performs overstriking
   PPO        Printer port
   RCS        Redefinable Character Sets
   SEM        Selective Erase
   SRM        Scrolling regions
   SSU        Multiple sessions
   SXL        SIXEL graphics processing
   TCS        DEC/Technical Character Set
   TEK        4010/4014 emulation
   TSI        Terminal State Interrogation
   UDK        User-definable keys
   UWN        User windows 
   V52        VT52 emulation 
   VFL        Variable forms length
   VFW        Variable forms width
	
Separate the mnemonics in your list with commas.]>
	MOVEI	T1,TCATTR	;POINT TO PARSE BLOCK
	PUSHJ	P,TTYATR	;PARSE THE LIST INTO THE BLOCK
	  AOJA	LV,CLSATR

	TLZ	F,(F.SUPP)	;MAKE SURE WE CAN WRITE OUR DATA
	FILOUT	<TERMCR	(*,*>,TCLASS	;START CLASS DEFINITION
	MOVEI	T1,TCATTR	;POINT TO ATTRIBUTES PARSE BLOCK
	PUSHJ	P,FILATR	;LIST TO FILE
	FILDEC	<,,*>,TWIDTH	;CARRIAGE WIDTH
	FILDEC	<,*>,TLENG	;FORMS LENGTH
	FILDEC	<,*>,TFILL	;FILLER CLASS
	FILDEC	<,*>,TANSLV	;ANSI PORTION OF DECSTD070 SUPPORTED
	FILDEC	<,*>,TDECLV	;FULL SUPPORT LEVEL OF DECSTD070
	FILOUT	<,*>,TERASE	;ERASE TABLE ADDRESS
	FILOUT	<,*>,TBACKP	;BACKSPACE TABLE ADDRESS
	MOVEI	T1,CLSCHB	;CHARACTERISTICS BLOCK
	PUSHJ	P,FILCHR	;TYPE INTO THE FILE
	FILOUT	<)@>		;FINISH THE MACRO INVOCATION

	TTYOUT	<@Now enter member terminal types@>
TYPELP:	TLO	F,(F.SUPP)	;DON'T CLUTTER THE MACRO
	ASKSTR	<@  Terminal type [
Type the name of a terminal type belonging to the terminal class you have 
just defined.  Terminal type names must be 1 to 6 characters in length.  To 
define another class, just press RETURN.]>
	JUMPE	CH,CLASLP	;NEXT CLASS IF NO TYPE NAME
	PUSHJ	P,ASKTYP	;GET TTY TYPE NAME
	   AOJA	LV,TYPELP	;RETRY ON ERROR
	JRST	TYPELP		;GET NEXT MEMBER TYPE

CLASND:	PUSHJ	P,FILRAB	;END SPCCLS MACRO
	BTHOUT	<@Additional terminals for classes:@>
	FILOUT	<DEFINE SPCCLX>
	PUSHJ	P,FILLAB	;OPEN MACRO DEFINITION

CLSEXL:	MOVE	LV,SAVLV	;RESTORE EACH TIME THROUGH LOOP
CLSEX1:	TLO	F,(F.SUPP)	;DON'T CLUTTER THE MACRO
	ASKSTR	<@Class to extend [
Type the name of the terminal class you wish to extend, or press RETURN to 
end this section.]>
	JUMPE	CH,CLSEXN	;DONE EXTENDING IF BLANK LINE
	PUSHJ	P,TRMCLS	;GET CLASS NAME
	   AOJA	LV,CLSEX1	;RETRY ON ERROR
	MOVEM	WD,TCLASS	;REMEMBER IT

TYPEXL:	TLO	F,(F.SUPP)	;DON'T CLUTTER THE MACRO
	ASKSTR	<@  Terminal type [
Type the name of a terminal type belonging to the terminal class you wish 
to extend.  Terminal type names must be 1 to 6 characters in length.  To 
define another class, just press RETURN.]>
	JUMPE	CH,CLSEXL	;NEXT CLASS AT END
	PUSHJ	P,ASKTYP	;GET TYPE NAME
	  AOJA	LV,TYPEXL	;RETRY ON ERROR
	JRST	TYPEXL		;GET NEXT EXTENSION TYPE

CLSEXN:	PUSHJ	P,FILRAB	;END OF MACRO DEFINITION
TTTDEF:	ASKSTR	<@System default terminal type (TTY) [
Type the name of the default termainl type for your system.  The terminal 
type name must be 1 to 6 characters in length.  The monitor will assign 
this type to all lines at system start-up, before INITIA runs.]>
	MOVSI	WD,'TTY'	;LOAD UP THE DEFAULT
	JUMPE	CH,TTDEF1	;USE IT IF SO REQUESTED
	PUSHJ	P,TRMTYP	;GET A TYPE NAME
	   AOJA	LV,TTTDEF	;RETRY ON ERROR
TTDEF1:	FILOUT	<M.DTTT==:<SIXBIT &*&>@>,WD ;DEFINE DEFAULT TTY TYPE
	JRST	TRMEND		;SKIP AROUND THE SUBROUTINES
;HERE TO GET A TABLE ADDRESS (NAME)
TRMTAB:	SKIPN	CH		;IF NO CHARACTERS,
	SKIPA	WD,I		;USE THE DEFAULT,
	PUSHJ	P,GETWRD	;ELSE, GET THE VALUE
	SKIPE	WD		;IF DIDN'T
	SKIPE	CH		;OR JUNK AT EOL
	CAIA			;COMPLAIN
	JRST	CPOPJ1		;WIN IF VALID
	TTYOUT	<? Invalid table address@>
	POPJ	P,		;RETURN FAILURE

;HERE TO GET A TTY CLASS NAME
TRMCLS:	CAILE	N,5		;IN RANGE?
	RJRST	<TTYOUT	<? Must be 1-5 characters@>
		POPJ	P,>
	PUSHJ	P,GETWRD	;GET THE NAME OF THE CLASS
	SKIPE	WD		;MAKE SURE WE GOT ONE
	SKIPE	CH		;AT EOL
	CAIA			;WRONG, GIVE ERROR
	JRST	CPOPJ1		;RETURN WINNITUDE
	TTYOUT	<? Invalid class name@>
	POPJ	P,		;RETURN FAILURE

;HERE TO GET A TTY TYPE NAME
TRMTYP:	CAILE	N,6		;MAKE SURE IN RANGE
	RJRST	<TTYOUT	<? Must be 1-6 characters@>
		POPJ	P,>
	PUSHJ	P,GETWRD	;GET SIXBIT TOKEN
	SKIPE	WD		;MAKE SURE WE GOT ONE
	SKIPE	CH		;AT EOL
	CAIA			;WRONG, GIVE ERROR
	JRST	CPOPJ1		;RETURN SUCCESS
	TTYOUT	<? Invalid terminal type name@>
	POPJ	P,		;RETURN FAILURE
;HERE TO DEFINE THE ATTRIBUTES OF A TERMINAL TYPE
ASKTYP:	PUSHJ	P,TRMTYP	;GET THE TYPE NAME
	  POPJ	P,		;LET CALLER HANDLE THIS ERROR
	MOVEM	WD,TTYPE	;SAVE TYPE NAME

TYPATR:	TLO	F,(F.SUPP)	;DON'T CLUTTER THE MACRO
	ASKSTR	<  Additional attributes to set [
From the list above, type one or more of the mnemonics that correspond to
the additional attributes supported by member terminals in the terminal 
class you are defining.  Separate the mnemonics in your list with commas.]>
	MOVEI	T1,TONATR	;PARSE BLOCK
	PUSHJ	P,TTYATR	;PARSE INTO THE BLOCK
	  AOJA	LV,TYPATR

TYPATF:	TLO	F,(F.SUPP)	;DON'T CLUTTER THE MACRO
	ASKSTR	<  Attributes to clear [
From the list above, type one or more of the mnemonics that correspond to
the attributes defined for the class but are inappropriate to this terminal 
type.]>
	MOVEI	T1,TOFATR	;PARSE BLOCK
	PUSHJ	P,TTYATR	;PARSE INTO THE BLOCK
	  AOJA	LV,TYPATF

	TLZ	F,(F.SUPP)	;SHOULD BE CLEAR, BUT I'M PARANOID
	FILOUT	<TERMCR	(*,>,TTYPE ;START WITH THE TYPE NAME
	FILOUT	<*>,TCLASS	;ADD THE CLASS NAME
	MOVEI	T1,TONATR	;POINT TO ATTRIBUTES TO SET
	PUSHJ	P,FILATR	;ENTER INTO THE FILE
	MOVEI	T1,TOFATR	;POINT TO ATTRIBUTES TO CLEAR
	PUSHJ	P,FILATR	;ENTER THAT INTO FILE
	FILOUT	<)@>		;END THE LINE
	JRST	CPOPJ1		;RETURN SUCCESS
;HERE TO PARSE A LIST OF ATTRIBUTES
TTYATR:	MOVEM	T1,CURATR	;SAVE POINTER TO ATR BLOCK
	MOVSI	I,(T1)		;GET SOURCE ADDRESS
	HRRI	I,1(T1)		;DESTINATION
	SETZM	(T1)		;CLEAR FIRST WORD
	BLT	I,ATRLEN-1(T1)	;THEN THE WHOLE BLOCK
	JUMPE	CH,CPOPJ1	;THAT'S ALL WE NEED FOR A BLANK LINE
	MOVE	I,[-ATRLEN,,ATRTAB]	;AOBJN POINTER TO ATTRIBUTE NAMES
	MOVE	I2,CURATR	;MEMORY BLOCK ADDRESS
	PJRST	TRMPRS		;PARSE USER'S INPUT (PROPAGATING SKIP/ERROR)

DEFINE	YY(SYL),<IRP SYL,<EXP SIXBIT \SYL\>>

ATRTAB:	YY	<8BT,DIS,OVR,8BA,ISO,NRC,LID,CID,SRM,GAT,SEM>
	YY	<AVO,PPO,GPO,SXL,TEK,RCS,UDK,VFW,VFL,V52,ESL>
	YY	<JTK,TCS,TSI,BMT,BTA,HSR,UWN,SSU,CLR>
ATRLEN==.-ATRTAB	;NUMBER OF ATTRIBUTES
;HERE TO PARSE A LIST OF CHARACTERISTICS
TYPCH1:	SKIPA	T1,CURCHR	;START OVER AGAIN ON ERROR
TYPCHR:	MOVEM	T1,CURCHR	;SAVE POINTER TO CHR BLOCK
	MOVSI	I,(T1)		;GET SOURCE ADDRESS
	HRRI	I,1(T1)		;DESTINATION
	SETZM	(T1)		;CLEAR FIRST WORD
	BLT	I,TCRLEN-1(T1)	;THEN THE WHOLE BLOCK
	TLO	F,(F.SUPP)	;DON'T CLUTTER THE MACRO
	ASKSTR	<Characteristics [
From the list below, type one or more of the mnemonics that correspond to 
the characteristics exhibited by member terminals in the terminal class you
are defining.
	
   FF    hardware forms
   TAB   hardware tab support
   LC    transmit and receive lowercase characters
   ALT   need old-style altmode conversion
   XON   XON/XOFF flow control is desired
   CRLF  monitor performs free-CRLF logic
	
Separate the mnemonics in your list with commas.]>
	JUMPE	CH,CPOPJ1	;THAT'S ALL WE NEED FOR A BLANK LINE
	MOVE	I,[-TCRLEN,,TCRTAB]	;AOBJN POINTER TO CHR TABLE
	MOVE	I2,CURCHR	;POINT TO CHR BLOCK
	PUSHJ	P,TRMPRS	;PARSE LIST FROM TABLE INTO BLOCK
	  AOJA	LV,TYPCH1	;ASK OVER AGAIN ON ERROR
	POPJ	P,		;THAT'S ALL WE NEED

TCRTAB:	YY	<FF,TAB,LC,ALT,XON,CRLF>
TCRLEN==.-TCRTAB		;NUMBER OF ENTRIES
;HERE TO LIST OUT CHARACTERISTICS OR ATTRIBUTES TO THE FILE
FILCHR:	SKIPA	I2,[-TCRLEN,,TCRTAB]	;AOBJN POINTER TO CHR TABLE
FILATR:	MOVE	I2,[-ATRLEN,,ATRTAB]	;AOBJN POINTER TO ATR TABLE
	MOVE	I3,T1		;COPY ARG BLOCK POINTER
	MOVEI	CH,","		;SEPARATE FROM WHAT PRECEDES IT
	PUSHJ	P,FILPUT	;WITH A COMMA
	SETO	I,		;FLAG WHETHER LEADING COMMA NEEDED IN LIST
FILAT1:	SKIPN	(I3)		;ANYTHING ON IN THE ARGUMENT BLOCK?
	JRST	FILAT2		;NO, DON'T TYPE IT
	MOVEI	CH,","		;PREPARE TO SEPARATE WITH COMMA
	AOSN	I		;IF NOT THE FIRST,
	MOVEI	CH,"<"		;ELSE START THE LIST
	PUSHJ	P,FILPUT	;DO IT
	MOVE	N,(I2)		;GET THE SIXBIT NAME TO USE
	FILOUT	<*>		;TYPE IT
FILAT2:	AOJ	I3,		;ADVANCE PARSE BLOCK POINTER
	AOBJN	I2,FILAT1	;LOOP OVER ALL VALUES
	MOVEI	CH,">"		;END OF LIST
	AOSE	I		;UNLESS TYPED NO VALUES,
	PUSHJ	P,FILPUT	;CLOSE THE LIST
	POPJ	P,		;RETURN
;HERE TO PARSE A LIST INTO A BLOCK

TRMPRS:	PUSHJ	P,GETWRD	;READ THE NEXT SIXBIT TOKEN
	JUMPE	WD,CPOPJ	;ERROR IF NOT THERE
	CAIE	CH,","		;IF TERMINATER IS NOT COMMA,
	JUMPN	CH,CPOPJ	;MUST BE EOL
	MOVE	T1,I		;COPY SIXBIT LIST
TRMPR1:	CAME	WD,(T1)		;IF NO MATCH,
	AOBJN	T1,TRMPR1	;LOOP OVER LIST
	JUMPGE	T1,CPOPJ	;ERROR IF NO MATCH
	SUBI	T1,(I)		;FIND OFFSET INTO TABLE
	ADDI	T1,(I2)		;FORM OFFSET INTO PARSE BLOCK
	MOVEM	WD,(T1)		;SAVE (JUST FOR GRINS)
	JUMPN	CH,TRMPRS	;LOOP AS LONG AS THERE'S DATA
	JRST	CPOPJ1		;SUCCESS AT LAST!
TRMEND:	MOVE	LV,SAVLV	;RESTORE PERMANENT HELP LEVEL
SYSEND:	FILCOM	<@END OF *>,OUTNAM
	HLLZ	N,OUTEXT	;EXTENSION OF FILE WRITTEN
	FILCOM	<.*@>,N
	POPJ	P,		;END OF SYSGEN, RETURN AND CLOSE FILE
SUBTTL	ASK ROUTINES - ASK QUESTION ON TTY, FILE AND GET ANSWER

;ASKSYS - ROUTINE TO FIND OUT WHAT TYPE OF SYSTEM
;CALL:	PUSHJ	P,ASKSYS
;	RETURN	N=INDEX OF TYPE OF SYSTEM

ASKSYS:	ASKLST	<DECsystem10 (KL,KS) [
The KL is a system with KL10 CPUs.  The KS is a system with a KS10 CPU.]>
	AOS	M.KL10(N)	;SET APPROPRIATE PROCESSOR TYPE
	MOVEM	N,CNFIND	;SAVE INDEX OF SYSTEM TYPE
	POPJ	P,		;DONE
;ASKAUT - ROUTINE TO ASK MONGEN'ED DEVICE TABLE QUESTIONS
; USED ONLY FOR AUTCONFIGURED DEVICE DRIVER QUESTIONS

ASKAUT:	MOVEI	T1,@(P)		;GET ADDRESS OF CALL
	ADDI	T1,1		;POINT TO START OF ARGUMENTS
	PUSHJ	P,MDTSAV	;SAVE ARGUMENTS, BUILD TEXT
	MOVE	T2,MDTBIT	;BITS TO TEST
	TRNN	F,F.NEVR	;NEVER LOAD?
	TDNN	T2,F		;QUESTION VALID FOR THIS CPU TYPE?
	JRST	ASKAU2		;NO
	MOVEI	T1,MDTBUF	;POINT TO QUESTION
	PUSHJ	P,ASKMIC	;PASS TEXT OFF TO MIC
	PUSHJ	P,FCRLF		;OUTPUT CRLF TO FILE
	MOVEI	T1,MDTBUF	;POINT TO QUESTION
	PUSHJ	P,FILCOM	;STUFF IN FILE
	MOVEI	R,^D10		;SET RADIX TO 10
ASKAU1:	MOVEI	T1,MDTBUF	;POINT TO QUESTION
	PUSHJ	P,TTROUT	;OUTPUT TO TTY
	MOVEI	T1,MDTBUF	;POINT TO QUESTION
	PUSHJ	P,SETASK	;SET UP LIST OF CHOICES IN ASKTAB
	PUSHJ	P,TTYIN		;ASK FOR INPUT LINE, OUTPUT TO FILE AS COMMENT
	  JRST	ASKAU1		;/HELP TYPED, ASK AGAIN IN DESIRED HELP MODE
	PUSHJ	P,FNDASK	;VALID ANSWER
	  AOJA	LV,ASKAU1	;STUPID USER, ASK AGAIN WITH MORE HELP
	MOVE	LV,SAVLV	;RESTORE VERBOSITY LEVEL
	TRNE	F,F.LOAD	;ALWAYS LOAD DRIVER?
	AOS	N		;YES--FORCE TO A POSITIVE ANSWER
	TLZA	F,(F.COM!F.2DEC) ;CLEAR FLAG FOR NEXT CALLER

ASKAU2:	SETZ	N,		;FORCE A "NO" ANSWER
	PUSH	P,N		;PRESERVE ANSWER
	SETZM	@MDTSYM		;ASSUME THE ANSWER WAS "NO"
	SKIPE	N		;CHECK IT
	AOS	@MDTSYM		;EITHER "YES" OR "PROMPT"
	MOVE	N,MDTSIX	;SIXBIT SYMBOL NAME
	FILOUT	<@M.*==:>,N	;PUT IN FILE
	MOVE	N,@MDTSYM	;GET VALUE
	FILOUT	<*@>,N		;PUT IN FILE
	MOVE	N,MDTSIX	;SIXBIT NAME
	FILOUT	<DEFINE	MD*,>,N
	PUSHJ	P,FILLAB	;PUT OUT A LEFT WIDGET AND A CRLF
	SKIPN	@MDTSYM		;WANT THIS OPTION?
	JRST	[POP	P,(P)	;PHASE STACK
		 JRST	ASKAU5]	;AND FINISH UP
	MOVE	N,MDTKON	;GET DRIVER NAME
	FILOUT	<	EXTERN	*@>,N ;FORCE IT TO BE LOADED

ASKAU3:	MOVE	N,(P)		;GET RESPONSE BACK
	PUSHJ	P,ASKRES	;ASK FOR RESERVED DEVICES PER CPU
	POP	P,N		;GET RESPONSE BACK
	CAIN	N,2		;NEED TO PROMPT FOR ADDITIONAL DATA?
	PUSHJ	P,ASKMDT	;YES--ASK FOR MONGEN'ED DEVICE TABLE
	TRNN	F,F.DVCP	;RESERVE SPACE ON A PER-CPU BASIS?
	JRST	ASKAU4		;NO
	MOVE	N,M.CPU		;GET NUMBER OF CPUS IN CONFIGURATION
	FILOUT	<	MDPATD	(*)@>,N ;RESERVE "M.CPU" DEVICE SLOTS

ASKAU4:	FILOUT	<	MDTERM@> ;TERMINATE TABLE

ASKAU5:	MOVEI	CH,">"		;RIGHT ANGLE BRACKET
	PUSHJ	P,FILPUT	;PUT IN OUTPUT FILE
	MOVE	N,MDTSIX	;SIXBIT NAME
	FILOUT	< ;;END DEFINE MD*@>,N
	TLZ	F,(F.SUPP)	;SHOULD BE CLEAR BUT PARANOIA PREVAILS
	TRZ	F,F.LOAD!F.NEVR!F.MBUS!F.DVCP ;CLEAR ONE-SHOT BITS
	POPJ	P,		;RETURN
ASKRES:	MOVE	I,[MDTRES,,MDTRES+1] ;SET UP BLT
	SETZM	MDTRES		;CLEAR FIRST WORD
	BLT	I,MDTRES+SM.CPU-1 ;CLEAR STORAGE
	SKIPE	SMP		;ONLY DO THIS IF SMP
	CAIE	N,2		;PROMPTING FOR DATA?
	JRST	ASKRE4		;NO
	TLO	F,(F.SUPP)	;SUPPRESS FILE OUTPUT
	TTYOUT	<    Reserve devices per CPU: [
In multi-CPU configurations, it is often desirable to reserve a number of 
controller or device slots for each CPU which normally has this type of 
device connected to it.  For example, in a dual CPU system, if each CPU has 
two channels for RP06s, one would like the controllers to have the names 
RPA, RPB, RPC, and RPD.
    For devices such as disks, where the controller name varies with each 
driver loaded, this question should be answered for each driver.
    For devices such as magtapes, where the controller designation (MT) is 
the same regardless of the driver being used, this question need only be 
answered for the first driver.
    Typing CR will default the number of controllers or devices to an
appropriate value depending upon the driver.]>
	PUSHJ	P,TTYIN		;GET THE LINE
	  AOJA	LV,ASKRES	;/HELP TYPED--START ALL OVER
	TLZ	F,(F.SUPP)	;CLEAR FILE OUTPUT SUPPRESSION
	MOVN	I,M.CPU		;CPUS IN CONFIGURATION
	HRLZS	I		;MAKE AN AOBJN POINTER
ASKRE1:	PUSHJ	P,GETDEC	;GET A COUNT
	CAILE	N,^D26		;RANGE CHECK
ASKRE2:	AOJA	LV,MDT1		;ERROR
	MOVEM	N,MDTRES(I)	;STORE RESULT
	CAIE	CH,","		;MORE ON THE WAY?
	JRST	ASKRE3		;NO
	AOBJN	I,ASKRE1	;LOOP FOR MORE
ASKRE3:	JUMPN	CH,ASKRE2	;CHECK FOR JUNK AT EOL
ASKRE4:	FILOUT	<	MDCPUN	(>	;START OF MACRO
	MOVSI	I,-SM.CPU	;AOBJN POINTER
ASKRE5:	MOVEI	CH,","		;COMMA
	TRNE	I,-1		;FIRST TIME THROUGH?
	PUSHJ	P,FILPUT	;SEPARATE ARGUMENTS
	MOVE	T1,MDTRES(I)	;GET A COUNT
	PUSHJ	P,MDTOCT	;CONVERT TO SIXBIT
	LSH	N,30		;TWO DIGITS
	FILOUT	<*>,N		;PUT IT OUT
	AOBJN	I,ASKRE5	;LOOP FOR ALL
	FILOUT	<)@>		;END MACRO AND LINE
	POPJ	P,		;RETURN
;MONGEN'ED DEVICE TABLE BITS
	MD.VAL==1B33		;DEVICE SPECIFIER WORD IS VALID
	MD.KON==1B34		;KONTROLLER DEFINITION
	MD.ALL==1B35		;ALL UNITS ON KONTROLLER

ASKMDT:	SKIPN	SMP		;SEE IF SMP
	JRST	ASKMD2		;JUMPE IF NOT PROMPTED FOR PER-CPU STUFF
ASKMD1:	TLO	F,(F.SUPP)	;SUPPRESS FILE OUTPUT
	ASKLST	<    Do you want to specify more data (NO,YES)>
	JUMPE	N,CPOPJ		;PROCEED IF "YES"
ASKMD2:	MOVE	T1,[Z.MDTB,,Z.MDTB+1] ;SET UP BLT
	SETZM	Z.MDTB		;CLEAR FIRST WORD
	BLT	T1,Z.MDTE	;CLEAR STORAGE
;CPU
MDT1:	MOVE	N,M.CPU		;GET NUMBER OF CPUS
	SOJLE	N,MDT2		;MORE THAN ONE?
	TLO	F,(F.SUPP)	;SUPPRESS FILE OUTPUT
	ASKDEC	<    CPU (CR,0-*) [
Type a CPU number or press RETURN for all CPUs.]>
	CAMN	N,['CR    ']	;DEFAULT?
	MOVEI	N,7		;YES
	MOVEM	N,MDTCPU	;SAVE RESULTS
;DEVICE CODE
MDT2:	SKIPN	M.KL10		;KL10?
	JRST	MDT2B		;NO
MDT2A:	TLO	F,(F.SUPP)	;SUPPRESS FILE OUTPUT
	ASKOCT	<    Device code (CR,0-774) [
Press RETURN to accept the standard device code definitions.]>
	TRNE	N,3		;JUNK IN THE LOW ORDER BITS?
	JRST	MDT2A		;TRY AGAIN
	JRST	MDT2C		;CONTINUE
MDT2B:	TLO	F,(F.SUPP)	;SUPPRESS FILE OUTPUT
	ASKOCT	<    Interrupt vector index (CR,0-774) [
Press RETURN to accept the standard interrupt vector index definition.]>
	TRNE	N,3		;JUNK IN THE LOW ORDER BITS?
	JRST	MDT2B		;TRY AGAIN
MDT2C:	CAMN	N,['CR    ']	;DEFAULT?
	SETZ	N,		;YES
	MOVEM	N,MDTDVC	;SAVE DEVICE CODE
	SKIPN	M.KS10		;KS10?
	JRST	MDT3		;NO
MDT2D:	TLO	F,(F.SUPP)	;SUPPRESS FILE OUTPUT
	ASKOCT	<    UNIBUS address (CR,760000-777774) [
Press RETURN to accept the standard UNIBUS address definitions.]>
	CAMN	N,['CR    ']	;DEFAULT?
	SETZ	N,		;YES
	TRNE	N,3		;JUNK IN THE LOW ORDER BITS?
	JRST	MDT2D		;TRY AGAIN
	MOVEM	N,MDTUAD	;SAVE UNIBUS ADDRESS
;MASSBUS UNIT
MDT3:	MOVE	T1,F		;COPY INTERESTING BITS
	ANDI	T1,F.MBUS	;PRESERVE CHANNEL BITS
	PUSH	P,F		;SAVE FOR LATER
	MOVE	N,MDTSIX	;KONTROLLER NAME
	SKIPN	M.KL10		;KL10?
	JRST	MDT3A		;NO
	TLO	F,(F.SUPP)	;SUPPRESS FILE OUTPUT
	TRNN	F,F.MBUS	;MASSBUS DEVICE?
	JRST	MDT3A		;NO
	ASKOCT	<    Massbus device (0,0-7) [
Type the Massbus device number for the * controller.]>,N
	MOVEM	N,MDTUNI	;SAVE
MDT3A:	POP	P,T1		;GET CHANNEL BITS BACK
	TRZ	F,F.MBUS	;CLEAR THEM
	IORM	T1,F		;AND RESTORE WHAT WAS PREVIOUSLY SET
;DRIVE
MDT4:	TTYOUT	<    Drive, slave, or unit: [
Type a decimal drive, slave, or unit number, "ALL" for all units, or "NONE" 
if defining a controller parameter.  An answer to this question must be 
supplied.]>
	TLO	F,(F.SUPP)	;SUPPRESS FILE OUTPUT
	PUSHJ	P,TTYIN		;GET THE LINE
	  AOJA	LV,MDT4		;/HELP TYPED--START ALL OVER
	JUMPE	CH,.-1		;CAN'T BE BLANK
	CAIL	CH,"0"		;RANGE
	CAILE	CH,"9"		; CHECK
	JRST	[PUSHJ	P,GETWRD	;FETCH A KEYWORD
		 CAMN	WD,['ALL   ']	;ALL DRIVES ON KONTROLLER?
		 MOVEI	N,MD.ALL	;THAT'S RIGHT
		 CAMN	WD,['NONE  ']	;PERHAPS KONTROLLER DEFINITION?
		 MOVEI	N,MD.KON	;YES
		 SKIPN	WD,N		;PRESERVE
		 AOJA	LV,MDT4		;NO--TRY AGAIN
		 SETZ	N,		;CLEAR DRIVE NUMBER
		 JRST	.+2]		;AND CONTINUE
	JRST	[SETZ	WD,		;NO FLAGS
		 MOVE	T1,B		;SAVE BYTE POINTER
		 PUSHJ	P,GETDEC	;FETCH A NUMBER
		 CAMN	T1,B		;READ ANY CHARACTERS?
		 AOJA	LV,MDT4		;NO
		 JRST	.+1]		;CONTINUE
	MOVEM	WD,MDTFLG	;SAVE POSSIBLE FLAG
	MOVEM	N,MDTDRV	;SAVE DRIVE NUMBER
;DATA
MDT5:	TTYOUT	<    Data: [
You may provide device-specific information.  The response to this may 
contain a symbolic expression.  If you press RETURN, this indicates that 
there is no device-specific data other than the previously specified device 
code information.]>
	TLO	F,(F.BANG!F.SUPP) ;ALLOW "!" AND SUPPRESS FILE OUTPUT
	PUSHJ	P,TTYIN		;GET THE LINE
	  AOJA	LV,MDT5		;/HELP TYPED--START ALL OVER
	TLZ	F,(F.SUPP)	;CLEAR FILE OUTPUT SUPPRESSION
;WRITE THE DATA OUT
MDT6:	MOVEI	N,MD.VAL	;GET VALID BIT
	IORM	N,MDTFLG	;DIFFERENTIATE FROM ZERO TERMINATOR
	MOVE	N,['KL10  ']	;ASSUME A KL10
	SKIPN	M.KL10		;CHECK IT
	MOVE	N,['KS10  ']	;NO
	FILOUT	<	MD*	(>,N
	MOVE	N,MDTCPU	;GET CPU NUMBER
	FILDEC	<*,>,N
	MOVE	T1,MDTDVC	;DEVICE CODE/IVI
	PUSHJ	P,MDTOCT	;CONVERT TO OCTAL
	HRLZS	N		;ONLY THREE DIGITS
	FILOUT	<*,>,N
	SKIPN	M.KS10		;KS10?
	JRST	MDT6A		;NO
	MOVE	T1,MDTUAD	;GET UNIBUS ADDRESS
	PUSHJ	P,MDTOCT	;CONVERT TO OCTAL
	FILOUT	<*,>,N
MDT6A:	MOVE	N,MDTUNI	;MASSBUS UNIT NUMBER
	FILOUT	<*,>,N
	MOVE	T1,MDTDRV	;DRIVE NUMBER
	PUSHJ	P,MDTDEC	;CONVERT TO DECIMAL
	HRLZS	N		;PUT IN LH
	FILOUT	<*,>,N
	MOVEI	CH,"<"		;LEFT
	PUSHJ	P,FILPUT	; WIDGET
	MOVSI	I,-MDTLEN	;AOBJN POINTER
	MOVNI	I2,1		;INIT COUNTER
MDT6B:	HRRZ	T1,MDTTAB(I)	;GET A BIT
	TDNN	T1,MDTFLG	;WANT TO OUTPUT?
	JRST	MDT6C		;NO
	MOVEI	CH,"!"		;SEPARATOR
	AOSE	I2		;FIRST TIME THROUGH?
	PUSHJ	P,FILPUT	;NO
	HLLZ	N,MDTTAB(I)	;GET NAME
	FILOUT	<MD.*>		;PUT INTO FILE
MDT6C:	AOBJN	I,MDT6B		;LOOP THROUGH TABLE
	MOVEI	CH,">"		;RIGHT
	PUSHJ	P,FILPUT	; WIDGET
	MOVEI	CH,","		;ARGUMENT
	PUSHJ	P,FILPUT	; SEPARATOR
	MOVEI	CH,"<"		;LEFT
	PUSHJ	P,FILPUT	; WIDGET
	HRRZ	T1,B		;START OF PARSED DATA
	FILSTR	<*>		;PUT IT OUT
	MOVEI	CH,">"		;RIGHT
	PUSHJ	P,FILPUT	; WIDGET
	FILSTR	<)@>		;FINISH LINE OFF
	JRST	ASKMD1		;LOOP BACK FOR MORE

MDTTAB:	'VAL',,MD.VAL		;WORD IS VALID
	'KON',,MD.KON		;ALL DRIVES ON KONTROLLER
	'ALL',,MD.ALL		;ALL KONTROLLERS
MDTLEN==.-MDTTAB		;LENGTH OF TABLE
MDTOCT:	SKIPA	I3,[10]		;RADIX 8
MDTDEC:	MOVEI	I3,12		;RADIX 10
	SETZ	N,		;CLEAR RESULT
	PUSHJ	P,MDTNUM	;CONVERT TO PSEUDO-SIXBIT
	TDO	N,['000000']	;MAKE REAL SIXBIT
	POPJ	P,		;AND RETURN
MDTNUM:	IDIVI	T1,(I3)		;DIVIDE
	HRLM	T2,(P)		;STORE RESULT
	SKIPE	T1		;DONE?
	PUSHJ	P,MDTNUM	;RECURSE
	HLRZ	T1,(P)		;GET A DIGIT
	LSH	N,6		;MAKE ROOM
	IOR	N,T1		;INCLUDE DIGIT
	POPJ	P,		;RETURN
MDTSAV:	MOVE	T2,0(T1)	;M.XXXX ADDRESS
	MOVEM	T2,MDTSYM
	MOVE	T2,1(T1)	;SIXBIT /M.XXXX/
	MOVEM	T2,MDTSIX
	MOVE	T2,2(T1)	;SIXBIT DRIVER NAME
	MOVEM	T2,MDTKON
	MOVE	T2,3(T1)	;FLAGS
	MOVEM	T2,MDTBIT
	MOVE	T2,4(T1)	;INTRODUCTORY TEXT
	HRLI	T2,5(T1)	;LONG TEXT
	MOVEM	T2,MDTTXT

;INIT BUFFER
	MOVE	T1,[MDTBUF,,MDTBUF+1] ;SET UP BLT
	SETZM	MDTBUF		;CLEAR FIRST WORD
	BLT	T1,MDTBUF+MP.AQB-1 ;CLEAR TEXT STORAGE
	MOVE	I,[POINT 7,MDTBUF] ;BYTE POINTER
	MOVEI	I2,<MP.AQB*5>-1	;BYTE COUNT

;LEAD IN MESSAGE
	MOVEI	T1,[ASCIZ /  Include /]
	TRNE	F,F.LOAD	;ALWAYS LOAD DRIVER?
	MOVEI	T1,[ASCIZ /  Prompt for /]
	PUSHJ	P,MDTSTO	;STORE STRING

;DRIVER TEXT
	HRRZ	T1,MDTTXT	;INTRODUCTORY TEXT
	PUSHJ	P,MDTSTO	;STORE STRING

;OPTION TEXT
	MOVEI	T1,[ASCIZ / (NO,YES,PROMPT)/]
	TRNE	F,F.LOAD	;ALWAYS LOAD DRIVER?
	MOVEI	T1,[ASCIZ / (NO,YES)/]
	PUSHJ	P,MDTSTO	;STORE STRING

;LONG HELP TEXT
	MOVEI	T1,[ASCIZ /[/]	;START OF LENGTHY TEXT
	PUSHJ	P,MDTSTO	;NEXT LINE
	HLRZ	T1,MDTTXT	;LONG TEXT
	PUSHJ	P,MDTSTO	;STORE STRING
	MOVEI	T1,MDTNYP	;(NO,YES,PROMPT) TEXT
	TRNE	F,F.LOAD	;ALWAYS LOAD DRIVER?
	MOVEI	T1,MDTNY	;(NO,YES) TEXT
	PUSHJ	P,MDTSTO	;STORE STRING
	POPJ	P,		;RETURN

MDTSTO:	HRLI	T1,(POINT 7,)	;MAKE A BYTE POINTER
MDTST1:	ILDB	CH,T1		;GET A CHARACTER
	JUMPE	CH,CPOPJ	;RETURN IF DONE
	IDPB	CH,I		;PUT A CHARACTER
	SOJG	I2,MDTST1	;LOOP FOR MORE
	RJRST	<EREXIT	<MDTBUF full>,>


MDTNY:	ASCIZ	\Respond with one of the following:
	NO      Do not prompt
	YES     Prompt for parameters]: \

MDTNYP:	ASCIZ	\Respond with one of the following:
	NO      Exclude driver
	YES     Include driver
	PROMPT  Include driver and prompt for parameters]: \
;ASKYN - ROUTINE TO ASK AND ACCEPT A Y OR N ANSWER
; USED WHEN ONLY CHOICE OF PRESENCE OR ABSENCE IS POSSIBLE
;CALL:	ASKYN	<...(Y,N)[...]>
;	RETURN	N=1 IF Y, N=0 IF N
; NOTE: (Y,N) MUST BE IN THIS ORDER, SO USER KNOWS DEFAULT ALWAYS IS Y

ASKZYN:
ASKYN:	PUSHJ	P,ASKLS1	;ASK QUESTION, GET ANSWER POSITION IN N
	SKIPE	ASKTAB+2	;MORE THAN TWO CHOICES?
	JRST	ASKYNE		;THAT'S AN ERROR
	MOVS	T1,ASKTAB+0	;IS FIRST PROMPT
	CAIN	T1,'YE '	;FINGER SLIP OFF THE KEYS?
	MOVEI	T1,'YES'	;FIX IT UP
	CAIE	T1,'YES'	;YES?
	CAIN	T1,'Y  '	;ABBREVIATED?
	SKIPA	T1,ASKTAB+1	;OK, GET SECOND POSSIBLE RESPONSE
	JRST	ASKYNE		;ERROR
	MOVSS	T1		;PUT IN RH
	CAIE	T1,'NO '	;NO?
	CAIN	T1,'N  '	;ABBREVIATED?
	SKIPA			;OK
ASKYNE:	RJRST	<EREXIT	<ASKYN called without (Y,N) in above message>,>
	JUMPE	N,ASKY		;FIRST ITEM IN LIST(Y)?

;HERE ON N ANSWER
	TDZA	N,N		;RETURN 0

;HERE ON Y ANSWER
ASKY:	MOVEI	N,1		;RETURN 1
	POPJ	P,
;ROUTINE TO ASK QUESTON WITH PROMPTING ANSWERS IN A LIST IN PARENS
;CALL:	ASKLST	<...(ANS0,ASN1,ANS2,...)[...]>
;	RETURN HERE WITH N=0,1,2,...
;	IF JUST CR TYPED, N=0 TO MEAN FIRST ITEM BY DEFAULT
;ABBREVIATIONS ARE ALLOWED LIKE MONITOR COMMANDS
; IF WRONG ANSWER IS GIVEN, THE FOLLOWING ERROR MESSAGE IS TYPED:
; ? ANSWER MUST BE ONE OF (ANS0,ANS1,ANS2,...)
; FOLLOWED BY A REPEAT OF QUESTION IN NEXT LONGEST MODE
;IF A LIST OF PROMPTINGS IS NOT INCLUDED IN PARENS,
; ? INTERNAL MONGEN ERROR  - NO CHOICES IN PARENS - EDIT MONGEN


ASKLST:	PUSHJ	P,ASKLS1	;ASK AND GET ANSWER
	MOVS	T1,ASKTAB+0	;IS FIRST PROMPT
	CAIE	T1,'Y  '	;Y
	CAIN	T1,'N  '	; OR N?
	JRST	ASKLSE		;YES, ERROR SHOULD USE ASKYL INSTEAD
	MOVS	T1,ASKTAB+1	;IS SECOND PROMPT
	CAIE	T1,'Y  '	;Y
	CAIN	T1,'N  '	;OR N?
ASKLSE:	RJRST	<EREXIT	<ASKLST called with (Y,N) in above question
- Edit MONGEN to call ASKYN instead of ASKLST@>,>
	POPJ	P,		;RETURN WITH N SET TO POSITION OF ANSWER

;SUBROUTINE TO DO THE WORK OF ASKING AND GETTING ANSWER.
;CALLED BY ASKLST AND ASKYN

ASKLS1:	MOVEI	R,^D10		;SET RADIX TO 10(IN CASE * SUBS.)
	PUSHJ	P,ASKBG		;STANDARD ASK ROUTINE BEGINNING
				; SAVE ADR OF QUESTION AND N ON STACK, OUTPUT CRLF
				; TO FILE, OUTPUT QUESTION AS COMMENT TO FILE

;LOOP TO ASK QUESTION OVER AGAIN AFTER ERROR OR /HELP
ASKOVR:	MOVE	N,(P)		;REESTORE ORIGINAL N INCASE THIS IS LOOP
				; SO * SUBSTITUTION WILL BE THE SAME
	HRRZ	T1,-1(P)	;ADR OF MESSAGE
	PUSHJ	P,TTROUT	;OUTPUT TO TTY
	HRRZ	T1,-1(P)	;ADR OF ASK MESSAGE
	PUSHJ	P,SETASK	;SET UP LIST OF CHOICES IN ASKTAB
				; FROM SCANNING LIST OF PROMPTINGS
	PUSHJ	P,TTYIN		;ASK FOR INPUT LINE, OUTPUT TO FILE AS COMMENT
	  JRST	ASKOVR		;/HELP TYPED, REASK IN DESIRED HELP MODE
	PUSHJ	P,FNDASK	;NO, LOOK FOR HIS ANSWER IN ASKTAB
	  AOJA	LV,ASKOVR	;NOT THERE, ASK QUESTION AGAIN WITH MORE HELP
				; BY MAKIN LEVEL ONE HIGHER
	JRST	ASKXIT		;FOUND, RESTORE LEVEL
				; TO THAT BEFORE QUESTION AND RETURN
;ROUTINE TO SCAN MESSAGE FOR PROMPTING ANSWERS
;CALL:	MOVEI	T1,ADR OF ASCIZ STRING
;	PUSHJ	P,SETLST
;	  RETURN ONLY IF ANSWERS IN PARENS FOUND
;	ELSE PRINT ? INTERNAL MONGEN ERROR - NO ( IN ABOVE MESSAGE,
; ADD (ANS0,ASN1,ASN2...) TO MONGEN BY EDITING
; B IS PRESERVED

SETASK:	HRLI	T1,440700	;FORM LH OF BYTE POINTER
	PUSH	P,B		;SAVE BYTE POINTER(NOT AN ARGUMENT)
				; CALLER MAY HAVE SOMETHING IN IT
	PUSH	P,N		;SAVE POSSIBLE SUBSTITUTION

;LOOP TO FIND LEFT PAREN
ASK0:	ILDB	CH,T1		;GET NEXT CHAR IN ASK MESSAGE
	RJUMPE	CH,<EREXIT <? No (ANS0,ASN1,...) in above question - Edit MONGEN>,>
	CAIE	CH,"("		;LEFT PAREN?
	JRST	ASK0		;NO, KEEP LOOKING
	MOVEI	N,0		;SET ANSWER INDEX TO 0
	MOVE	B,T1		;SETYUP BYTE POINTER TO PROMPTING LIST FOR GETWRD

;LOOP TO BREAK PROMPTING ANSWERS - N=0,1,... FOR EACH ANSWER
ASK2:	PUSHJ	P,GETWRD	;GET NEXT WORD INSIDE PARENS
	CAIE	CH,"*"		;SKIP IF WANT SUBSTITUTION
	JRST	ASK2A		;NO, KEEP CHECKING
	JUMPN	WD,ASK2E	;JUMP IF SOMETHING PRECEEDED *, ERROR
	MOVE	WD,(P)		;RESTORE SUBSTITUTION
ASK2A:	MOVEM	WD,ASKTAB(N)	;ANS STORE ANSWER AWAY
	CAILE	N,MP.AMX	;MORE THAN MAX. NO. OF ANSWERS FOR MONGEN?
	RJRST	<EREXIT <Too many prompts in above question - Edit MONGEN@>,>
	CAIN	CH,","		;WAS BREAK CHAR A COMMA?
	AOJA	N,ASK2		;YES, GO BACK AND GET NEXT PROMPTING WORD
	SETZM	ASKTAB+1(N)	;CLEAR LAST ARG PLUS 1 AS END FLAG
	POP	P,N		;RESTORE N
	POP	P,B		;RESTORE CALLERS BYTE POINTER
	CAIN	CH,")"		;NO, WAS BREAK RIGHT PAREN?
	POPJ	P,		;YES, RETURN
ASK3E:	EREXIT	<Special character inside () above
Edit MONGEN and remove it.>,

ASK2E:	EREXIT	<Error in above question - Edit MONGEN@>,
;ROUTINE TO FIND ONE OF A LIST OF ANSWERS IN ASKTAB USING ASCIZ STRING
;CALL:	MOVE	POSSIBLE ANSWERS TO ASKTAB+0,+1,... STORE 0 IN LAST+1
;				(SEE SETASK ROUTINE)
;	MOVE	B,BYTE POINTER TO ASCIZ STRING
;	PUSHJ	P,FNDASK(BREAK = CR) OR FNDAS1(BREAK = ANY)
;	  NOT FOUND RETURN, ERROR MESSAGE PRINTED
;	OK RETURN, N = POSITION OF ANSWER IN LIST = 0,1,2
;	N=0 IF JUST A CR TYPED
; ALLOW 0 IN ASKTAB+0 AS LEGAL ANSWER TO MEAN NO DEFAULT

FNDAS1:	PUSHJ	P,GETWRD	;GET USER SUPPLIED ANSWER
	JRST	FNDAS2		;SKIP CHECK FOR BREAK MUST BE EOL

FNDASK:	PUSHJ	P,GETWRD	;GET USER SUPPLIED ANSWER
	RJUMPN	CH,<TTYOUT <? Type one answer followed by carriage return@>
		popj p,>	;error return, so ask question again
FNDAS2:	TLZ	F,(F.MTCH)	;CLEAR MATCH FOUND FLAG
	SETZB	N,SAVN		;SET ANSWER INDEX TO 0
	JUMPE	WD,ASK8		;JUST A CR TYPED?
	MOVEI	T1,0		;NO, FORM MASK FOR ABBREVIATION
ASK5:	ROT	T1,6		;MOVE MASK LEFT 1 CHAR POSITION
	IORI	T1,77		;SET LOW ORDER CHAR MASK
	TDNN	WD,T1		;ANY CHARS IN THESE LOW ORDER POSITIONS?
	JRST	ASK5		;NO, LOOK AT NEXT CHAR TO LEFT
	LSH	T1,-6		;YES, MOVE MASK SO ONLY COVERS CHARS NOT TYPED
	MOVE	T2,ASKTAB(N)	;GET FIRST POSSIBLE ANSWER. MAYBE 0 IF
				; NO DEFAULT ALLOWED, IE (,ANS0,ANS1,...)

;LOOP TO SCAN FOR MATCH WITH PROMPTING ANSWERS STORED IN ASKTAB
ASK6:	CAMN	T2,WD		;SKIP IF NOT EXACT MATCH
	JRST	ASK9		;YES, TAKE THIS IMMEDIATELY
	TDZ	T2,T1		;CLEAR OUT CHARS USER DID NOT TYPE
	CAME	T2,WD		;MATCH THE CHARS HE DID TYPE?
	JRST	ASK7		;NO, GO GET NEXT ANSWER
	MOVEM	N,SAVN		;YES, SAVE ANSWER INDEX
	TLOE	F,(F.MTCH)	;ALREADY FOUND A MATCH?
	RJRST	<TTYOUT	<? Type enough to uniquely distinguish answer@>
		 POPJ	P,>	;ERROR RETURN
ASK7:	SKIPE	T2,ASKTAB+1(N)	;GET NEXT PROMPT, IS THERE ONE?
	AOJA	N,ASK6		;YES, BUMP ANSWER INDEX
	TLNN	F,(F.MTCH)	;NO, WAS A MATCH FOUND?
	RJRST	<TTYOUT	<? Answer with one of the choices inside parens@>
		 POPJ	P,>	;ERROR RETURN
ASK8:	MOVE	N,SAVN		;YES, RETURN THE MATCH INDEX
ASK9:	SKIPN	ASKTAB(N)	;SKIP IF DEFAULT ALLOWED
	RJRST	<TTYOUT <? No default allowed@>
		POPJ P,>
	JRST	CPOPJ1		;GIVE OK RETURN
;ROUTINE TO ASK QUESTION AND GET DECIMAL ANSWER AND CHECK FOR LIMITS
;CALL:	ASKDEC	<QUESTION(DEFAULT,MIN-MAX)[...]>
;	RETURN HERE WITH N AS VALUE OF ANSWER, CR ASSUMES DEFAULT

ASKDEC:	MOVEI	R,12		;SET RADIX TO DECIMAL
	JRST	ASKNUM		;GO ASK QUESTION AND CHECK ANSWER

;ROUTINE TO ASK QUESTION AND GET OCTAL LINE NUMBER OR CTY
;CALL:	ASKLIN	<QUESTION(DEFAULT,MIN-MAX)[...]>
;	RETURN HERE WITH N AS VALUE OR 'CTY', CR ASSUMES DEFAULT

ASKLIN:	MOVEI	R,10		;SET RADIX TO OCTAL
	TLO	F,(F.CTY)	;FLAG THAT CTY IS OK OCTAL NUMBER
	JRST	ASKNM1		;ASK QUESTION, ETC

;ROUTINE TO ASK QUESTION AND GET OCTAL ANSWER AND CHECK FOR LIMITS
;CALL:	SAME AS ASKDEC, EXCEPT ANSWER CONVERTED AS OCTAL

ASKOCT:	MOVEI	R,10		;SET RADIX TO OCTAL
ASKNUM:	TLZ	F,(F.CTY)	;FLAG THAT CTY IS NOT ACCEPTABLE NUMBER
ASKNM1:	PUSHJ	P,ASKBG		;STANDARD ASK ROUTINE BEGINNING
				; SAVE ADR OF QUESTION AND N ON STACK, OUTPUT CRLF
				; TO FILE, OUTPUT QUESTION AS COMMENT TO FILE

;LOOP TO ASK QUESTON AGAIN IF SYNTAX ERROR OR OUT OF RANGE OR /HELP
ASKAGN:	MOVE	N,(P)		;REESTORE ORIGINAL N IN CASE THIS IS LOOP
				; SO * SUBSTITUTION WILL BE THE SAME
	HRRZ	T1,-1(P)	;ADR OF MESSAGE
	PUSHJ	P,TTROUT	;ASK USER ON TTY
	SETOM	DFAULT		;SET DEFAULT TO NONE FOUND YET
				; USER CANNOT TYPE IN -1
	SETZM	MINLIM		;SET MIN LIMIT TO 0
	MOVSI	T1,'?  '	;SET MAX LIMIT TO BIG POS. NO.
				; WHICH WILL ALSO PRINT IF BELOW MIN
	MOVEM	T1,MAXLIM	;TO VERY BIG NUMBER
	HRRZ	B,-1(P)		;ADR OF QUESTION
	HRLI	B,440700	;FORM BYTE POINTER TO IT

;LOOP TO FIND FIRST PAREN
ASKN0:	ILDB	CH,B		;GET NEXT CHAR
	JUMPE	CH,ASKN2	;ERROR IF END OF STRING FOUND
	CAIE	CH,"("		;LEFT PAREN?
	JRST	ASKN0		;NO, KEEP LOOKING
;LOOP TO LOOK FOR DEFAULT, MIN AND MAX INSIDE PARENS
ASKN1:	PUSHJ	P,GETNUM	;GET NUMERIC FIELD
ASKN1B:	CAIE	CH,"*"		;SKIP IF * FOUND
	JRST	ASKN1C		;NO, PROCEED
	JUMPN	N,ASKN2		;JUMP IF SOMETHING BEFORE THE *
	MOVE	N,(P)		;PICK UP VALUE FOR SUBSTITUTION
	PUSHJ	P,SKBLNK	;SKIP TO NEXT TERMINATOR
	JRST	ASKN1B		;AND LOOP
ASKN1C:	CAIN	CH,"-"		;DASH TO SEPARATE MIN-MAX
	JRST	ASKN3		;YES, FOUND MIN
	CAIN	CH,"C"+40	;IS IT LOWER CASE C?
	TRC	CH,40		;YES, CONVERT IT
	CAIE	CH,"C"		;YES, AND IS BREAK A C?
	JRST	ASKN1A		;NO, GO CHECK OTHER BREAK CHARS
	JUMPN	N,ASKN2		;JUMP IF SOMETHING BEFORE THE *
	PUSHJ	P,GETWRD	;YES, GET REST OF WORD
	MOVEI	N,'CR '		;GET READY IF CR TO STORE CR AS DEFAULT
	CAME	WD,[SIXBIT /R/]	;IS IT R AFTER C?
				;YES,  STORE DEFAULT CR
	TLNN	F,(F.CTY)	;NOT CR, IS CTY A LEGAL ANSWER?
	JRST	ASKN1A		;NO, GO CHECK OTHER BREAKS
	CAME	WD,[SIXBIT /TY/] ;IS REST OF WORD "TY"?
	JRST	ASKN2		;NO, PRINT ERROR
	MOVEI	N,'CTY'		;STORE ARG AS TYPED
ASKN1A:	SKIPGE	DFAULT		;ALREADY STORED DEFAULT?
	MOVEM	N,DFAULT	;NO, STORE DEFAULT, IN CASE JUST TYPES CR
	CAIN	CH,")"		;IS THIS THE ONLY NUMBER
	JRST	ASKN4		;YES, GO GET USER ANSWER
	CAIN	CH,","		;IS BREAK A COMMA?
	JRST	ASKN1		;YES, GO GET NEXT NUMBER IN LIST
ASKN2:	EREXIT	<Above question must have(...,min-max) - Edit MONGEN>,

;HERE WHEN MIN FOUND
ASKN3:	MOVEM	N,MINLIM	;STORE MINIMUM LIMIT
	PUSHJ	P,GETNUM	;GET NEXT NUMBER
	CAIN	CH,"?"		;NO MAX SPECIFIED?
	JRST	ASKN3A		;YES, SET TO INFINITY
	CAIE	CH,"*"		;NO, IS MAX. SUBSTITUTABLE ARG?
	JRST	ASKN3B		;NO, GO CHECK FOR RIGHT PAREN
	SKIPA	N,(P)		;YES, USE VALUE WHICH WAS SUBSTITUTED
ASKN3A:	MOVSI	N,'?  '		;SET MAX TO PLUS INFINITY
	PUSHJ	P,SKBLNK	;SKIP TO NEXT NON-BLANK
ASKN3B:	CAIE	CH,")"		;BETTER BE RIGHT PAREN
	JRST	ASKN2		;NO, ERROR
	MOVEM	N,MAXLIM	;STORE MAX LIMIT

;HERE WHEN FIRST () ALL SCANNED FOR DEFAULT, MIN AND MAX
ASKN4:	PUSHJ	P,TTYIN		;GET USER ANSWER FROM TTY, OUTPUT TO FILE
				; AS COMMENT
	  JRST	ASKAGN		;/HELP TYPED, ASK AGAIN
	JUMPE	CH,ASKN5	;JRST CR TYPED?(GO USE DEFAULT IF YES)
	PUSHJ	P,GETNUM	;NO, GET NUMBER USER TYPED
	JUMPE	CH,ASKN5A	;END OF STRING?
	TLNN	F,(F.CTY)	;NO, IS CTY A POSSIBLE OCTAL NUMBER?
	RJRST	<TTYOUT	<? Type single number followed by carriage return@>
		 AOJA	LV,ASKAGN>  ;ASK AGAIN AT HIGHER LEVEL
	CAIN	CH,"C"+40	;IS IT LOWER CASE C?
	TRC	CH,40		;YES, CONVERT IT
	CAIE	CH,"C"		;YES, WAS BREAK C?
	JRST	ASKN4A		;NO, PRINT ERROR
	JUMPN	N,ASKN4A	;ERROR IF SOMETHING PRECEDED C
	PUSHJ	P,GETWRD	;YES, GET REST OF WORD
	CAMN	WD,[SIXBIT /TY/] ;IS WORD REST OF CTY?
	JRST	ASKN4B		;YES, ALLOW IT
ASKN4A:	RJRST	<TTYOCT	<? Type octal line number or CTY followed by carriage return@>
		 AOJA	LV,ASKAGN> ;ASK AGAIN AT HIGHER LEVEL
ASKN4B:	MOVSI	N,'CTY'		;RETURN LEFT JUSTFIED CTY AS OCTAL NO.
	JRST	ASKN6		;SKIP RANGE CHECK
;HERE IF JUST CR TYPED AS ANSWER, USE DEFAULT IF THERE IS ONE
ASKN5:	MOVS	N,DFAULT	;GET DEFAULT IF ONE SPECIFIED
	CAME	N,[SIXBIT /CR/]	;WAS DEFAULT CR?
	CAMN	N,[SIXBIT /CTY/] ;WAS DEFAULT CTY?
	JRST	ASKN6		;YES, BY PASS RANGE CHECK
	MOVSS	N		;RESTORE TO UNSWAPPED STATE
	RJUMPL	N,<TTYOUT <? No default allowed, type a number@>
		 AOJA	LV,ASKAGN> ;ASK AGAIN AT HIGHER LEVEL
;HERE TO CHECK RANGE OF ANSWER
ASKN5A:	CAMN	N,DFAULT	;SKIP IF NOT DEFAULT VALUE
	JRST	ASKN6		;IF DEFAULT NOT IN RANGE, MUST BE SPECIAL TERMINATOR
	CAML	N,MINLIM	;LESS THAN MIN?
	CAMLE	N,MAXLIM	;NO, EXCEED MAX?
	RJRST	<TTYOUT	<? Must be in range *>,MINLIM
	 	TTYOUT	<-*@>,MAXLIM
	 	AOJA	LV,ASKAGN>  ;ASK AGAIN AT NEXT LONGER MODE
ASKN6:	JRST	ASKXIT		;STANDARD ASK EXIT - RESTORE ORIGINAL
				; HELP LEVEL, POP QUESTION ADR, AND RETURN

;ROUTINE TO ASK QUESTION AND GET STRING FOR ANSWER
;CALL:	ASKSTR	<QUESTION*>,X

ASKSTR:	PUSHJ	P,ASKBG		;STANDARD ASK ROUTINE BEGINNING
				; SAVE ADR OF QUESTION AND N ON STACK, OUTPUT CRLF
				; TO FILE, OUTPUT QUESTION AS COMMENT TO FILE

;LOOP TO ASK QUESTION OVER AGAIN AFTER REQUEST FOR HELP
ASKST1:	MOVE	N,(P)		;RESTORE ORIGINAL N IN CASE THIS IS LOOP
				; SO * SUBSTITUTION WILL BE THE SAME
	HRRZ	T1,-1(P)	;ADDRESS OF MESSAGE
	PUSHJ	P,TTROUT	;TYPE IT ON TTY
	PUSHJ	P,TTYIN		;WAIT FOR INPUT, OUTPUT TO FILE
				; AS COMMENT
	  JRST	ASKST1		;/HELP TYPED, REASK AT DESIRED HELP MODE
	JRST	ASKXIT		;COMMON EXIT FROM ASK ROUTINES
				; POP OLD N AND QUESTION ADR, RESTORE HELP LEVEL
;ROUTINE TO ASK FOR M-N<EOL> OR M<EOL> ON REPEATED LINES UNTIL BLANK LINE
; SYNTAX AND OUTPUT TO FILE
;CALL:	FILOUT	<DEFINE	MAC???>	;START MACRO DEFINITION IN FILE
;	ASKMN	<ASK MESSAGE@>
;	RETURN WHEN ALL ANSWERS HAVE BEEN CHECKED AND OUTPUT

ASKMN:	MOVEI	R,^D8		;ASSUME OCTAL RADIX FOR IO
	PUSHJ	P,FILLAB	;OUTPUT LEFT ANGLE BRACKET, CRLF TO FILE
				; AS BEG OF MACRO DEFINITION
	PUSHJ	P,ASKBG		;STANDARD ASK ROUTINE BEGINNING
				; SAVE ADR OF QUESTION AND N ON STACK, OUTPUT CRLF
				; TO FILE, OUTPUT QUESTION AS COMMENT TO FILE

;LOOP TO ASK QUESTION IN CASE OF ERROR OR /HELP
ASKM0:	MOVE	N,(P)		;RESTORE ORIGINAL N IN CASE THIS IS LOOP
				; SO * SUBSTITUTION WILL BE THE SAME
	HRRZ	T1,-1(P)	;ADR OF MESSAGE
	PUSHJ	P,TTROUT	;OUTPUT TO TTY

;LOOP TO GET NEXT LINE OF INPUT
ASKMLP:	PUSHJ	P,TTYIN		;GET TTY LINE
	  JRST	ASKM0		;/HELP TYPED, ASK AGAIN
	JUMPE	CH,ASKPXT	;NO, DID HE TYPE A BLANK LINE MEANING ALL DONE?
	TLZ	F,(F.INFO);
	PUSHJ	P,GETMN		;NO, SCAN FOR M OR M-N AND STOP ON NON-BREAK
	RJUMPN	CH,<TTYOCT <? Type octal M-N or M@>
		AOJA	LV,ASKM0>  ;RAISE LEVEL OF VERBOSITY AND ASK AGAIN
	FILSTR	<L *@>;	;OUTPUT SAME STRING HE TYPED IN WITH MACRO
				; NAME PRECEDING IT SO COMMON CAN
				; REDEFINE AS IT PLEASES.
	JRST	ASKMLP		;AND GO GET NEXT LINE OF INPUT


;ROUTINE TO ASK FOR M-N,P<EOL>, GET REPEATED LINES OF INPUT
; UNTIL BLANK LINE, ANS OUTPUT TO FILE
;CALL:	FILOUT	<DEFINE	MAC???>	;START MACRO DEFINITON IN FILE
;	ASKMNP	<ASK MESSAGE@>
;	RETURN WHEN ALL ANSWERS HAVE BEEN CHECKED AND OUTPUT

ASKMNP:	MOVEI	R,^D8		;ASSUME OCTAL RADIX FOR IO
	PUSHJ	P,FILLAB	;OUTPUT LEFT ANGLE BRACKET, CRLF TO FILE
				; AS BEG OF MACRO DEFINITION
	PUSHJ	P,ASKBG		;STANDARD ASK ROUTINE BEGINNING
				; SAVE ADR OF QUESTION AND N ON STACK, OUTPUT CRLF
				; TO FILE, OUTPUT QUESTION AS COMMENT TO FILE

;LOOP TO ASK FOR MULTI LINE INPUT AGAIN IN CASE OF ERROR
ASKP0:	MOVE	N,(P)		;RESTORE ORIGINAL N IN CASE THIS IS LOOP
				; SO * SUBSTITUTION WILL BE THE SAME
	HRRZ	T1,-1(P)	;ADR OF MESSAGE
	PUSHJ	P,TTROUT	;OUTPUT TO  TTY
;LOOP TO GET NEXT LINE OF INPUT
ASKPLP:	PUSHJ	P,TTYIN		;GET NEXT LINE FROM TTY
	  JRST	ASKP0		;/HELP TYPED, ASK AGAIN
	JUMPE	CH,ASKPXT	;NO, BLANK LINE MEANING END
	TLO	F,(F.INFO)
	PUSHJ	P,GETMN		;NO, GET M OR M-N
	CAIE	CH,","		;IS BREAK A COMMA?
	JRST	ASKPE		;NO, ERROR, PRINT MESAGE AND ASK AGAIN
	PUSHJ	P,GETOCT	;GET OCTAL P
	JUMPE	CH,ASKP1	;IS THIS END OF STRING?
ASKPE:	TTYOUT	<? Type octal M-N,P or M,P@>
	AOJA	LV,ASKP0	;RAISE LEVEL AND ASK AGAIN

ASKP1:	FILSTR	<L *@>;	;OUTPUT TO FILE ENTIRE ANSWER WITH MACRO
				; NAME PRECEDING IT WHICH COMMON WILL DEFINE
				; AS IT PLEASES.
	JRST	ASKPLP		;AND GO GET ANOTHER LINE OF INTPUT
;ROUTINE TO ASK FOR M-N OR ALL, GET REPEATED LINES OF INPUT
;UNTIL BLANK LINE, AND OUTPUT TO FILE
;CALL: - SEE ASKMN

ASKTMN:	MOVEI	R,^D8		;RADIX 8
	PUSHJ	P,FILLAB	;PUT OUT RIGHT BRACKET
	PUSHJ	P,ASKBG		;STD BEGINNING

ASKTM0:	MOVE	N,(P)		;RESTORE N
	HRRZ	T1,-1(P)	;ADDR OF MSG
	PUSHJ	P,TTROUT	;OUTPUT TO TTY

ASKTLP:	PUSHJ	P,TTYIN		;GET LINE OF INPUT
	  JRST	ASKTM0		;/HELP WAS TYPED
	JUMPE	CH,ASKPXT	;EXIT IF NULL LINE
	PUSHJ	P,GETTMN	;GET ANSWERS
	RJUMPN	CH,<TTYOCT <? Type octal M-N or M@>
		     AOJA LV,ASKTM0>	;GIVE HIM HELP
	FILSTR	<KN X,*@>
	JRST	ASKTLP		;ASK AGAIN

;ROUTINE TO GET M-N OR "ALL"

GETTMN:	PUSHJ	P,GETOCT	;GET OCTAL NUMBER
	CAIN	CH,"A"		;SEE IF START OF ALL
	JRST	GETTM1
	CAIE	CH,"-"		;CHECK DASH
	POPJ	P,		;NO - ERROR RETURN
	MOVEI	CH,","		;CONVERT TO MAKE MACRO HAPPY
	DPB	CH,B		;PUT IN STRING
	PJRST	GETOCT		;GET 2ND AND RETURN

GETTM1:	PUSHJ	P,GETWRD	;GET REST OF WORD
	MOVSI	N,'ALL'		;CORRECT ANSWER
	CAME	WD,[SIXBIT "LL"] ;REMAINDER CORRECT?
	MOVEI	CH,"A"		;NO - GIVER ERROR
	POPJ	P,		;RETURN
;ROUTINE TO SETUP ALL ASK ROUTINES
; OUTPUTS CRLF TO FILE, OUTPUT QUESTION AS COMMENT, PUT ADR OF QUESTION ON STACK
; PUT ARG FOR * SUBSTITUTION (N) ON STACK SO QUESTION CAN BE REASKED.
;CALL:	MOVEI	T1,ADR OF QUESTION
;	PUSHJ	P,ASKBG
;	RETURN HERE WITH T1 ON END OF LIST

ASKBG:	EXCH	T1,(P)		;SAVE ADR OF MESSAGE ON STACK
	PUSH	P,N		;SAVE ARG FOR * SUBSTITUTION IN CASE
				; OF ERROR AND QUESTION MUST BE REASKED
				; COMMON ASK EXIT(ASKXIT) WILL POP THESE OFF
	PUSH	P,T1		;SAVE RETURN ON END
	HRRZ	T1,-2(P)	;ADR OF QUESTION
	PUSHJ	P,ASKMIC	;PASS STRING ON TO MIC
	PUSHJ	P,FCRLF		;OUTPUT CRLF TO FILE
	HRRZ	T1,-2(P)	;ADR OF QUESTION
	PJRST	FILCOM		;OUTPUT AS A COMMENT, PUTTING ; IN FRONT
				; OF EVERY LINE IN QUESTION

;HERE TO EXIT ASKMN AND ASKMNP
ASKPXT:	PUSHJ	P,FILRAB	;OUTPUT RIGHT ANGLE BRACKET,CRLF TO FILE

;HERE TO EXIT FROM ALL ASK ROUTINES
ASKXIT:	TLZ	F,(F.SUPP)	;CLEAR FILE OUTPUT SUPPRESSION
	MOVE	LV,SAVLV	;RESTORE VERBOSITY LEVEL BEFORE QUESTION ASKED
				; OR AS SET BY /HELP:XXX
	POP	P,T1		;THROW AWAY * SUBSTITUTION ARG( AC N)
				; N HAS ANSWER IN IT NOW
	POP	P,T1		;POP OFF T1
	JRST	FILOT2		;CLEAR LF FLAG SO FOLLOWING OUTPUT WONT
				; ACCIDENTALLY GET ; IN FRONT. THEN RETURN.
;THIS PAGE OUTPUTS A PROMPT STRING TO THE MIC FILE AS A COMMENT
;CALLED WITH PROMPT STRING IN T1, PRESERVES T1

ASKMIC:	SKIPN	MICFLG		;MIC FILE?
	 POPJ	P,		;NOPE
	PUSH	P,T1		;SAVE QUESTION
	PUSHJ	P,MICNL		;DELIMIT COMMENT IN .MIC FILE
	MOVEI	CH,";"
	PUSHJ	P,MICPUT
	HRRZ	T1,(P)		;GET ADDRESS OF QUESTION
	HRLI	T1,(POINT 7,,)	;FOR MIC
ASKMC1:	ILDB	CH,T1		;GET A CHAR
	JUMPE	CH,ASKMC2	;STOP HERE
	CAIN	CH,"["		;REALLY STOP HERE
	 JRST	ASKMC2		;NEXT
	CAIN	CH,"*"		;SUBSTITUTE?
	 JRST	ASKMCS		;YES
	 CAIE	CH,"@"		;IGNORE <CR><LF> FLAGS
	CAIN	CH,15		;CR?
	 JRST	ASKMC1		;IGNORE
	CAIN	CH,12		;LF?
	 RJRST	<PUSHJ	P,MICNL	;YES, NEW LINE
		 MOVEI	CH,";"
		 PUSHJ	P,MICPUT
		 JRST	ASKMC1>
	PUSHJ	P,MICPUT	;LOG AS A COMMENT
	CAIE	CH,")"		;REALLY STOP HERE
	 JRST	ASKMC1		;LOOP FOR PROMPT
	JRST	ASKMC2		;STOP

ASKMCS:	TLNN	N,770000	;NUMBER?
	 JRST	ASKMCN		;YES
	PUSH	P,T1
	MOVE	T1,[POINT 6,N]
ASKMS1:	ILDB	CH,T1		;GET NEXT LETTER
	JUMPE	CH,ASKMSE	;EXIT IF DONE
	ADDI	CH," "-' '	;MAKE ASCII
	PUSHJ	P,MICPUT	;OUTPUT
	TLNE	T1,770000	;DONE?
	 JRST	ASKMS1		;NO
ASKMSE:	POP	P,T1		;RESTORE STRING POINTER
	JRST	ASKMC1		;NEXT CHAR OF STRING

ASKMCN:	PUSH	P,T1
	MOVE	T1,N
	PUSHJ	P,MICNUM	;OUTPUT
	POP	P,T1
	JRST	ASKMC1		;CONTINUE

MICNUM:	IDIVI	T1,(R)		;RADIX DIVIDE
	HRLM	T2,(P)
	SKIPE	T1
	 PUSHJ	P,MICNUM
	HLRZ	CH,(P)
	ADDI	CH,"0"
	PJRST	MICPUT

ASKMC2:	PUSHJ	P,MICNL		;CRLF
	POP	P,T1		;RESTORE QUESTION
	POPJ	P,
SUBTTL	GET ROUTINES - SCAN AND CHECK IN CORE STRINGS

;ROUTINE TO GET OCTAL LINE NUMBER OR "CTY"
;CALL:	MOVE	B,BYTE POINTER
;	PUSHJ	P,GETLIN
;	ALWAYS RETURN, N=VALUE OR SIXBIT CTY
;	STOP IN FIRST NON-OCTAL CHAR OR NON-CTY
;	CALLER MUST CHECK FOR LEGAL BREAK CHARACTER

GETLIN:	PUSHJ	P,GETOCT	;GET OCTAL NUMBER
	JUMPN	N,CPOPJ		;RETURN IF GOT SOME VALUE
	CAIN	CH,"C"+40	;IS IT LOWER CASE C?
	TRC	CH,40		;YES, CONVERT IT
	CAIE	CH,"C"		;IS BREAK "C"?
	POPJ	P,		;NO, MAYBE 0 OR CR, LET CALLER CHECK
	PJRST	GETMN1		;SEE IF REST IS CTY

;ROUTINE TO SYNTAX CHECK M-N OR M FOLLOWED BY ANY BREAK
;CALL:	MOVE	B,BYTE POINTER
;	PUSHJ	P,GETMN
;	ALWAYS RETURN HERE, BREAK IN CH

GETMN:	PUSHJ	P,GETOCT	;GET OCTAL LINE NUMBER
	CAIN	CH,"C"+40	;IS IT LOWER CASE C?
	TRC	CH,40		;YES, CONVERT IT
	CAIN	CH,"C"		;SKIP IF NOT START OF CTY
	JRST	GETMN1		;YES, SEE IF IS CTY
	CAIE	CH,"-"		;IS BREAK -?
	POPJ	P,		;NO, LET CALLER CHECK FURTHER
	MOVEI	CH,","		;YES, CHANGE TO , SO MACRO WILL ACCEPT
	DPB	CH,B		;IN OUTPUT FILE
	PJRST	GETOCT		;GET SECOND OCTAL DIGIT

GETMN1:	PUSHJ	P,GETWRD	;YES, GET REST OF WORD
	MOVSI	N,'CTY'		;ASSUME CTY
	CAMN	WD,[SIXBIT /TY/]  ;IS IT REST OF CTY?
	JRST	NULL		;INSERT A NULL
	MOVEI	CH,"C"		;NO, RETURN ORIGINAL BREAK FOR CALLER
				; TO GET ERROR WHEN CHECKS IT
	POPJ	P,		;RETURN, CALLER CHECK FOR BREAK
NULL:	TLNN	F,(F.INFO)	;ARE WE EXPECTING MORE INFO TO FOLLOW "CTY"?
	MOVEI	CH,0		;PUT A NULL IN THE BUFFER
	DPB	CH,B		; TO BE AN EOL
	POPJ	P,		;RETURN

;ROUTINE TO GET DECIMAL FROM STRING
;CALL:	MOVE	B,BYTE POINTER
;	PUSHJ	P,GETDEC
;	ALWAYS RETURN HERE, BREAK IN CR, VALUE IN N
;CALLER MUST CHECK FOR PROPER BREAK

GETDEC:	MOVEI	R,12		;SET RADIX TO DECIMAL
	PJRST	GETNUM		;GET NUMBER


;ROUTINE TO GET OCTAL NUMBER FROM STRING
;SAME CALL AS GETDEC

GETOCT:	MOVEI	R,10		;SET RADIX TO OCTAL
				; FALL INTO GETNUM

;ROUTINE TO GET NUMBER FROM STRING
;CALL:	MOVE	R,RADIX
;	MOVE	B,BYTE POINTER
;	PUSHJ	P,GETNUM
;	ALWAYS RETURN HERE, BREAK IN CH, VALUE IN N
;CALLER MUST CHECK FOR PROPER BREAK, GETNUM STOPS ON FIRST NON-NUMERIC

GETNUM:	MOVEI	N,0		;SET VALUE TO 0
	PUSHJ	P,SKBLNK	;SKIP LEADING BLANKS(SPACES AND TABS)
	TLNE	F,(F.NEG)	;CAN CALLER HACK A NEGATIVE NUMBER?
	CAIE	CH,"-"		;NEGATIVE VALUE?
	JRST	GETN0		;NOPE, DON'T GET INTO TROUBLE
	HRLI	R,-1		;YES, REMEMBER
	ILDB	CH,B		;GET NEXT CHAR IN STRING
GETN0:	JUMPE	CH,GETN1	;IS THIS END OF STRING
	CAIL	CH,"0"		;LESS THAN 0?
	CAIL	CH,"0"(R)	;LESS THAN RADIX
	JRST	GETN1		;YES, DONE (SKIP TO FIRST NON-BLANK)
	IMULI	N,(R)		;MULTIPLY OLD NUMBER BY RADIX
	ADDI	N,-"0"(CH)	;ADD IN VALUE OF THIS CHAR
	ILDB	CH,B		;GET NEXT CHAR IN STRING
	JRST	GETN0		;GET ANOTHER CHAR
GETN1:	SKIPGE	R		;NEGATIVE VALUE ENTERED?
	MOVNS	N		;YES, NEGATE RESULT
	TLZ	F,(F.NEG)	;FORGET YOU TOLD ME I CAN DO THIS
	JUMPE	CH,CPOPJ	;DONE IF END OF LINE
	PJRST	SKBLK1		;SKIP TO FIRST NON-BLANK AND RETURN
;ROUTINE TO GET A WORD FROM AN ASCIZ STRING.  FILTERS OUT TAB, SPACE
; STOPS ON ANY NON-ALPHA NUMERIC, EXCEPT DOT, CALLER MUST CHECK FOR LEGAL BREAK
;CALL:	MOVE	B,BYTE POINTER
;	PUSHJ	P,GETWRD
;	RETURN WITH SIXBIT WD LEFT JUSTIFIED, BREAK IN CH

GETWRD:	PUSH	P,[ILDB CH,B]	;INSTRUCTION TO GET NEXT CHAR
	PUSHJ	P,GETSKB	;SKIP LEADING BLANKS(SPACES, TABS)
	MOVEI	WD,0		;SET WORD TO 0 FOR RETURN
	MOVE	T1,[XWD	440600,WD] ;SET SIX BIT BYTE POINTER TO WD

;LOOP TO ACCUMULATE AFTER LEADING SPACES AND TABS
GETWLP:	JUMPE	CH,GETWX1	;END OF STRING?
	TLNN	F,(F.PER)	;ARE SYMBOL CHARACTERS ALLOWED IN NAMES?
	JRST	GETWD1		;NO, (MUST BE SCANNING FILE NAMES)
	CAIN	CH,"."		;PERIOD(CAN BE PART OF SYMBOL)
	JRST	GETWD3		;YES, ACCEPT AS PART OF SYMBOL
	CAIE	CH,"%"		;CHECK FOR PERCENT SIGN
	CAIN	CH,"$"		;CHECK FOR DOLLAR SIGN
	JRST	GETWD3		;YES, ACCEPT AS PART OF SYMBOL
GETWD1:	CAIL	CH,"0"		;LESS THAN 0?
	CAILE	CH,"9"		;LESS THAN OR EQUAL TO 9?
	JRST	GETWD2		;YES, SEE IF LETTER?
	JRST	GETWD3		;NO, NUMBER, STORE

;HERE IF NOT NUMBER
GETWD2:	CAIL	CH,"A"+40	;LOWER CASE?
	TRC	CH,40		;YES, CONVERT TO UPPER CASE
	CAIL	CH,"A"		;LESS THAN A
	CAILE	CH,"Z"		;LESS THAN OR EQUAL TO Z?
	PJRST	GETWRX		;SKIP TRAILING BLANKS TO FIRST NON-BLANK
				; AND RETURN TO CALLER
;HERE IF A LETTER OR NUMBER - CONVERT TO SIXBIT AND STORE
GETWD3:	SUBI	CH,40		;CONVERT TO SIXBIT
	TLNE	T1,770000	;OVERFLOWED WD YET?
	IDPB	CH,T1		;NO, STORE NEXT SIXBIT CHAR
	XCT	(P)		;GET NEXT CHAR
	JRST	GETWLP		;AND CHECK IT

GETWRX:	PUSHJ	P,SKBLK1	;RETURN FIRST NON-BLANK AFTER TRAILING SPACES
GETWX1:	POP	P,(P)
	POPJ	P,
GETSKB:	XCT	-1(P)		;GET NEXT CHAR
GETSK1:	CAIE	CH," "		;SPACE?
	CAIN	CH,"	"	;TAB?
	JRST	GETSKB		;YES, GET NEXT CHAR
	POPJ	P,		;NO, FOUND NON-BLANK
;ROUTINE TO GET TTY LINE, AND SCAN FOR DEV:PI
; WHERE DEV IS 3 CHAR OR LESS AND PI IS # FOR 0-7
;CALL:	PUSHJ	P,GETDPI
;	  ERROR RETURN, /HELP , DEV TOO LONG, OR PI TOO BIG
;	OK RETURN, BREAK IN CH, WD=0 IF JUST CR TYPED

GETDPI:	PUSHJ	P,TTYIN		;GET NEXT LINE
	  POPJ	P,		;/HELP TYPED, REASK IN DESIRED HELP MODE
	MOVEI	WD,0		;SET JUST CR TYPED INDICATION
	JUMPE	CH,CPOPJ1	;JUST A BLANK LINE?
	PUSHJ	P,GETWRD	;NO, GET FIRST WORD
	JUMPE	WD,ASKDPE	;ARE THERE ANY CHAR IN DEVICE NAME?
	CAIE	CH,","		;IS BREAK CHAR COMMA?
	POPJ	P,		;NO, ERROR
	TRNE	WD,777777	;IS DEVICE 3 CHAR OR LESS?
ASKDPE:	RJRST	<TTYOUT	<? Device-mnemonic must be 3 char or less@>
		 POPJ	P,>	;GO TRY AGAIN
	PUSHJ	P,GETOCT		;GET PI NO.
	MOVE	T1,M.CPU		;MAX NUMBER OF CPUS
	IMULI	T1,SM.PI		;NUMBER OF PI CHANNELS PER CPU
	MOVE	T2,M.CPU		;NUMBER OF CPUS
	ADDI	T1,-1(T2)	;ACCOUNT FOR CHANNEL 0
	CAILE	N,(T1)		;LEGAL PI?
	RJRST	<MOVE N,T1	;GET MAXIMUM LEGAL PI
		 TTYOCT	<? PI-channel must be * or less@>
		 POPJ	P,>	;GO TRY AGAIN
	JRST	CPOPJ1		;YES, GIVE LEGAL RETURN


;ROUTINE TO SKIP LEADING BLANKS(SPACES AND TABS)
;CALL:	MOVE	B,BYTE POINTER
;	PUSHJ	P,SKBLNK	OR SKBLK1 IF FIRST CHAR ALREADY IN CH
;	FIRST NON-BLANK RETURNED IN CH

SKBLNK:	ILDB	CH,B		;GET NEXT CHAR
SKBLK1:	CAIE	CH," "		;SPACE?
	CAIN	CH,"	"	;TAB?
	JRST	SKBLNK		;YES, GET NEXT CHAR
	POPJ	P,		;NO, RETURN WITH FIRST NON-BLANK IN CH
SUBTTL	TTY INPUT ROUTINES

;ROUTINE TO ACCEPT 1 LINE FROM TTY, MOVE IT TO ASCSTR
;REMOVE EOLS, AND COMMENTS, AND ADD A NULL TO MAKE IT ASCIZ
; LOOK FOR /H AND HANDLE IT
;OUTPUT LINE WITH PRECEDING ; TO FILE
;CALL:	PUSHJ	P,TTYIN
;	  NON SKIP RETURN IF USER TYPES /HELP, CALLER MUST REASK QUESTION
;	    LEVEL SET AS USER WISHES IN LV FOR THIS QUESTION,
;	    AND IN SAVLV FOR FUTURE
;	SKIP RETURN WITH B SETUP AS BYTE POINTER TO BEG OF STRING
;	CH = 0 IF JUST A BLANK LINE TYPED
;	N = NUMBER OF CHARACTERS NOT COUNTING EOLS OR NULLS
;	B = BYTE POINTER TO STRING JUST READ IN


TTYIN:	TLO	F,(F.COM)	;FLAG OUTPUT TO FILE AS COMMENTS SO ALL
				; CALLS TO FILOUT WILL PUT PRECEDING ;
	PUSHJ	P,TTYGET	;GET NEXT CHAR, OUTPUT TO FILE, SKIP COMMENTS, EOL=0
	MOVEI	N,0		;SETUP LENGTH OF STRING TO 0
	MOVE	B,[XWD 440700,ASCSTR] ;BYTE POINTER
	PUSH	P,T1		;PRESERVE REGISTER
	MOVE	T1,B		;KEEP TRACK OF NON-BLANKS

;LOOP TO COPY CHARS FROM TTY TO CORE BUFFER(ASCSTR)
TTYINB:	IDPB	CH,B		;STORE AWAY
	JUMPE	CH,TTYINC	;IF EOL CHAR, RETURN
	CAIE	CH," "		;IF THIS IS A SPACE,
	CAIN	CH,011		;OR A TAB,
	CAIA			;(YES)
	MOVE	T1,B		;NO, REMEMBER LAST NON-BLANK SEEN
	PUSHJ	P,TTYGET	;GET NEXT CHAR
	CAIGE	N,MP.LMX	;LESS THAN MAX LINE LENGTH?
				; ASCSTR ALWAYS HAS ROOM FOR NULL
	AOJA	N,TTYINB	;YES, OK TO STORE NEXT CHAR
	POP	P,T1		;RESTORE REGISTER WE USE
	TLZ	F,(F.COM!F.BANG) ;CLEAR FLAG FOR FILE COMMENTS
	TTYOUT	<? Line too long@>
	AOJA	LV,FILOT2	;INCREASE LEVEL BY 1 FOR THIS QUESTION
				; AND PRETEND /HELP TYPED BY GIVING NO-SKIP
				; RETURN SO CALLER WILL REASK QUESTION

;HERE WHEN STRING ALL STORED IN CORE BUFFFER
TTYINC:	CAMN	T1,B		;HAVE WE CAUGHT UP YET?
	JRST	TTYIND		;YES, EXAMINE RESULTS
	IDPB	CH,T1		;NO, ADVANCE THE POINTER (STORE A NULL)
	SOJA	N,TTYINC	;DECREMENT COUNTER & TRY AGAIN

;HERE WHEN ACCOUNTED FOR TRAILING BLANKS
TTYIND:	POP	P,T1		;RESTORE OUR REGISTER
	TLZ	F,(F.COM!F.BANG) ;CLEAR FLAG FOR FILE COMMENTS
	MOVE	B,[XWD 440700,ASCSTR] ;BYTE POINTER TO CORE BUFFER
	PUSHJ	P,SKBLNK	;SKIP BLANKS(SPACE, TAB)
	CAIN	CH,"/"		;IS FIRST NON-BLANK A SLASH?
	JRST	TTYINH		;YES, GO DO /HELP
	MOVE	B,[XWD 440700,ASCSTR] ;SETUP BYTE POINTER TO
				; BEG OF CORE BUFFER FOR CALLER
	TLZ	F,(F.COM)	;CLEAR COMMENT FLAG
	JRST	CPOPJ1		;GIVE NON-HELP RETURN
;HERE ON LEADING / FROM TTYIN ROUTINE - SEE IF /HELP
; REST OF INPUT LINE ALEADY COPIED TO FILE AND CORE BUFFER(ASCSTR)
; OK TO DESTROY ASKTAB+0,... SINCE GOING TO GIVE NON-SKIP RETURN
TTYINH:	PUSH	P,N		;SAVE CCALLERS N IN CASE * SUBSTITUTION
				; WHEN QUESTION REASKED
	MOVEI	T1,[ASCIZ /(HELP)/] ;SETUP ONLY CHOICE AS IF PROMPT
	PUSHJ	P,SETASK	;IN CHOICES TABLE(ASKTAB)
	PUSHJ	P,FNDAS1	;SCAN CHARS AFTER / TO SEE IF HELP
				; OR ABBREV(ALLOW ANY BREAK)
	AOJA	LV,TTYIH1	;NO, GIVE HIM HELP WITH HELP
				; AT NEXT LONGER HELP LEVEL
	PJUMPE	CH,RAISE1	;IS BREAK EOL?(IF YES, JUST INCREASE
				; LEVEL OF VERBOSITY BY 1 FOR THIS QUESTION
				; BY ADDING TO LV BUT NOT TO SAVLV
	CAIE	CH,":"		;IS BREAK COLON?
	AOJA	LV,TTYIH1	;NO, ASK HELP QUESTION
				; AT NEXT LONGER MODE
	MOVEI	T1,[ASCIZ /(,SHORT,PROMPT,LONG)/] ;SETUP UP CHOICES TO /HELP:
				; N=0 MEANS JUST CR TYPED
	PUSHJ	P,SETASK	;IN ASKTAB+0,1,...
	PUSHJ	P,FNDASK	;FIND THE ONE HE TYPED
	  AOJA	LV,TTYIH1	;NOT FOUND, INCREASE HELP LEVEL
	JUMPE	N,RAISE1	;DID HE TYPE JUST CR?
				; IF YES, JUST INCREASE LEVEL FOR THIS QUESTION
	SUBI	N,2		;NO, FORM -1,0,1 FOR SHORT,PROMPT,LONG
	TLZ	F,(F.COM)	;CLEAR COMMENT FLAG
	JRST	HELP0		;GO STORE NEW PERMANENT HELP LEVEL

;HERE TO RAISE LEVEL 1 FOR THIS QUESTION ONLY
RAISE1:	TLZ	F,(F.COM)	;CLEAR COMMENT FLAG
	AOJA	LV,HELP1	;INCREMENT LEVEL BY ONE, BUT DO NOT
				; REMEMBER IN MEMORY(SAVLV)
				; AND RETURN
TTYIH1:	TLZA	F,(F.COM)	;CLEAR COMMENT FLAG AND GO TO TTYHP1

;ROUTINE TO TYPE HELP QUESTION
; CALLED AT BEGINNING ONCE ONLY AND WHENEVER /HELP:XXX MISTYPED
;CALL:	PUSHJ	P,TTYHLP

TTYHLP:	PUSH	P,N		;SAVE CALLER N INCASE * SUBSTITUTION
				; WHEN QUESTION REASKED
TTYHP1:	MOVEI	N,MP.MVN	;MONITOR VERSION NUMBER FOR THIS MONGEN
				; TELL USER SO HE GETS PROPER MONGEN
	ASKLST	<MONGEN for * monitors
	
MONGEN  will  generate  any  known TOPS-10 configuration.  For information 
about which configurations are supported, please refer to the SPD.
	
/HELP (PROMPT,SHORT,LONG) [In the following dialogue:
	
All numbers are decimal unless stated otherwise
Unique abbreviations are allowed everywhere to all questions
/HELP or reasks a question in the next longer mode
/HELP:xxx sets the mode permanently.
Modes are:
SHORT is short
PROMPT has choices in ()
LONG has choices in () and an explanation in []]>
	CAIN	N,1		;ANSWER 1(SHORT)
	SETOM	N		;YES, SET LEVEL TO SHORT
	CAIN	N,2		;ANSWER 2(LONG)?
	MOVEI	N,1		;YES, SET LEVEL TO LONG

;HERE TO STORE NEW PERMANENT HELP LEVEL
HELP0:	MOVEM	N,SAVLV		;SET PERMANENT LEVEL OF HELP
	MOVE	LV,N		;SET CURRENT LEVEL TO THE SAME
HELP1:	POP	P,N		;RESTORE ORIGINAL N(IN CASE THIS
				; IS HELP IN MIDDLE OF A QUESTION)
	POPJ	P,		;GIVE NON-SKIP RETURN SO QUESTION
				; WILL BE REASKED

;ROUTINE TO GET ONE CHAR FROM TTY, CHECK FOR EOLS, PUT CHAR IN  FILE
; AND SKIP OVER COMMENTS. ALSO CHECK FOR /HELP

TTYGET:	PUSHJ	P,TTYGT1	;GET NEXT CHAR FROM TTY AND PUT IN FILE
	  JRST	MICEOL		;IT WAS EOL, TELL MIC
	TLNN	F,(F.BANG)	;"!" LEGAL IN THIS INPUT LINE?
	CAIE	CH,"!"		;NO, DO WE HAVE ONE TO START A COMMENT?
	CAIN	CH,";"		;CHECK FOR SEMI-COLON ALSO
	JRST	TTYGT0		;READ COMMENT
	PUSHJ	P,MICPTD	;A GOOD CHARACTER, LOG IT AND RETURN
	POPJ	P,		;NO, RETURN

;LOOP TO THROW AWAY COMMENTS USER TYPED IN AFTER ANSWER
TTYGT0:	PUSHJ	P,TTYGT1	;YES, GET NEXT CHAR
	  JRST	MICEOL		;IT WAS AN EOL, RETURN WITH F.COM CLEARED
	JRST	TTYGT0		;NOT AN EOL, THROW IT AWAY AND GET NEXT CHAR

;ROUTINE TO GET ONE CHAR FROM TTY, CHECK FOR EOL, PUT CHAR IN FILE
;CALL:	PUSHJ	P,TTYGT1
;	  EOL RETURN CH=0, F.COM CLEARED(MAKE FILE OUTPUT NO LONGER BE COMMENTS)
;	NOT AN EOL RETURN, CH IS CHAR

TTYGT1:	SKIPE	INIFLG		;IF TTY NOT INITED
	 JRST	[INCHWL	CH	;FETCH WITH PAIN
		 JRST	TTGT2A]
	SOSG	TIBUF+2		;DECREMENT INPUT TTY BUFFER COUNT
	RJRST	<IN	TTYCHN,	;GET NEXT BUFFER FROM MONITOR
		 JRST	TTYGT2	;NO ERRORS
		 STATO	TTYCHN,IO.EOF ;END OF FILE ON TTY?
		 JRST	TTYGT2	;NO, IGNORE ERROR
		 JRST	TTYZ>	;YES, SET CONTROL Z FLAG
TTYGT2:	ILDB	CH,TIBUF+1	;GET NEXT CHAR FROM BUFFER
TTGT2A:	JUMPE	CH,TTYGT1	;IS IT NULL?
	CAIE	CH,C.RUB	;IGNORE RUBOUTS
	CAIN	CH,C.CR		;IS IT CR?
	JRST	TTYGT1		;YES, SKIP
	CAIL	CH,C.LF		;LESS THAN LINE FEED?
	CAILE	CH,C.CR		;NO, LESS THAN CARRIAGE RETURN?
	SKIPA			;NO, NOT AN EOL
	JRST	TTYEOL		;YES, CONSIDER AS EOL
	CAIE	CH,C.ESC	;ESCAPE?
	CAIL	CH,C.ALT1	;OLD ALTMODE?
	JRST	TTYEOL		;YES, TREAT AS EOL
	CAIE	CH,C.CONC	;CONTROL C?
	CAIN	CH,C.CONZ	;CONTROL Z?
	JRST	TTYZ		;YES, SET FLAG(OLDER MONITORS STORE ^Z IN BUFFER)
	PUSHJ	P,FILPUT	;STORE CHAR IN FILE
	JRST	CPOPJ1		;AND SKIP RETURN

;HERE WHEN CONTROL Z SEEN OF END OF FILE SET ON TTY
TTYZ:	CLOSE	TTYCHN,		;TURN OFF EOF FOR TTY
				; CLEAR EOF SO CAN DO MORE INPUTS
	TLO	F,(F.CONZ)	;FLAG CONTROL Z SEEN
TTYEOL:	PUSHJ	P,FCRLF		;OUTPUT CRLF TO FILE
	MOVEI	CH,0		;RETURN 0 AS EOL CHAR
	POPJ	P,		;GIVE EOL RETURN
SUBTTL	OUTPUT ROUTINES - TTY AND FILE

;ROUTINE TO TYPE INTERNAL MONGEN ERROR ON TTY AND FILE, THEN EXIT TO MONITOR
;USE TTCALL IN CASE TTY COULD NOT BE INITED
;CALL:	EREXIT	<MESSAGE>,

EREXIT:	PUSH	P,T1		;SAVE ADR OF MESSAGE
	OUTSTR	[ASCIZ /
? Internal MONGEN error - /]
	OUTSTR	(T1)		;THE CALLERS MESSAGE
	FILOUT	<@? Internal MONGEN error - >
	POP	P,T1		;RESTORE MESSAGE ADR
	PUSHJ	P,FILOUT	;OUTPUT TO FILE
	EXIT			;EXIT TO MONITOR


;ROUTINE TO OUTPUT TO FILE IN DECIMAL AND SUBSTITUTE FOR *
;CALL:	MOVEI	T1,ADR OF MESSAGE
;	PUSHJ	P,FILDEC
;	ALWAYS RETURN HERE, N PRESERVED

FILDC2:	TLO	F,(F.2DEC)	;ASK FOR AT LEAST TWO CHARS OUTPUT
FILDEC:	MOVEI	R,12		;SET RADIX TO DECIMAL
	PJRST	FILOT1		;DO OUTPUT AND SUBSTITUTION

;ROUTINE TO OUTPUT TO FILE AND SUBSTITUTE FOR *
; VALUE OR SIXBIT IN N
;CALL:	MOVEI	T1,ADR OF ASCIZ STRING TO OUTPUT
;	MOVE	N,NUMBER OR LEFT JUSTIFIED SIXBIT
;	PUSHJ	P,FILOUT
;	ALWAYS	RETURN HERE, N PRESERVED

FILCOM:	TLOA	F,(F.COM)	;SET FLAG TO PRECEDE ALL LINE WITH ;
				; AS A COMMENT IN FILE
FILOUT:	MOVEI	R,10		;SET OUTPUT RADIX TO OCTAL FOR MACRO
FILOT1:	HRLI	T1,440700	;FORM LH OF BYTE POINTER
	PUSH	P,[ILDB CH,T1]	;INSTRUCTION TO GET NEXT CHAR
FILOLP:	XCT	(P)		;GET NEXT CHAR IN OUTPUT MESSAGE
	PJUMPE	CH,FILT2A	;RETURN IF END OF STRING
	CAIN	CH,"*"		;NOT EOS, IS IT ASTERISK?
	PUSHJ	P,EITAST	;YES, SUBSTITUTE N FOR IT
	  PUSHJ	P,FILPUT	;ARG TO EITAST OR OUTPUT CHAR
	JRST	FILOLP		;LOOP AND GET NEXT CHAR


;ROUTINE TO REPLACE A "DOT" IN A SYMBOL WITH THE VALUE OF CPUN

FILCPU:	MOVEI	R,10		;OUTPUT RADIX
FILCP0:	HRLI	T1,440700	;FORM A BYTE POINTER
	PUSH	P,T1		;SAVE IT
FILCP1:	ILDB	CH,(P)		;GET NEXT CHARACTER IN OUTPUT
	PJUMPE	CH,FILT2A	;JUMP IF LAST
	PUSH	P,N		;SAVE ARGUMENT
	CAIN	CH,"*"		;SUBSTITUTE N?
	JRST	FILCP2		;YES
	MOVE	N,CPUN		;CURRENT CPU NUMBER
	CAIN	CH,"."		;A DOT?
FILCP2:	PUSHJ	P,EITAST	;YES, CONVERT CPU NUMBER
	  PUSHJ	P,FILPUT	;OUTPUT CHARACTER OR CPU NUMBER
	POP	P,N		;RESTORE ARGUMENT
	JRST	FILCP1		;LOOP OVER ENTIRE STRING

;HERE ON END OF STRING
FILT2A:	POP	P,(P)		;REMOVE INSTRUCTION FROM STACK
FILOT2:	TLZ	F,(F.COM!F.2DEC) ;NOW CLEAR FLAG SO NEXT CALLER CAN USE
				; FILOUT OR FILCOM WITHOUT HAVING TO SET OR CLEAR
				; TO INDICATE COMMENT OR NOT
	POPJ	P,		;RETURN


;ROUTINE TO OUTPUT TO BOTH FILE AND TTY
; SUBSTITUTE FOR * VALUE OR SIXBIT IN N, PRECEDE EACH
; LINE IN FILE WITH ; SO A COMMENT
;CALL:	MOVEI	T1,ADR OF ASCIZ STRING
;	PUSHJ	P,BTHOUT	FOR DECIMAL OR BTHOCT FOR OCTAL
;	ALWAYS RETURN HERE, N PRESERVED

BTHOCT:	SKIPA	R,[EXP 10]	;OCTAL RADIX
BTHOUT:	MOVEI	R,12		;OCTAL OUTPUT FOR FILE
	PUSH	P,T1		;SAVE ADR OF ASCIZ MESSAGE
	PUSHJ	P,ASKMIC	;STORE IN MIC FILE
	PUSHJ	P,FILCOM	;OUTPUT TO FILE AS A COMMENT
	POP	P,T1		;RESTORE ADR OF MESSAGE AND
	JRST	TTROUT		;REPEAT OUTPUT, BUT TO TTY: THIS TIME


;ROUTINE TO OUTPUT TO TTY IN DECIMAL
; SUBSTITUTE FOR * VALUE OR SIXBIT IN N
; OUTPUT INSIDE PARENS AND BRACKETS DEPENDING ON HELP LEVEL
;CALL:	MOVEI	T1,ADR OF ASCIZ STRING
;	PUSHJ	P,TTYOUT
;	ALWAYS RETURN HERE, N PRESERVED

TTYOCT:	MOVEI	R,10		;OCTAL RADIX(RARE) FOR TTY
	JRST	TTROUT		;GO DO REST OF TTYOUT

TTYOUT:	MOVEI	R,12		;SET RADIX TO DECIMAL FOR PEOPLE
TTROUT:	HRLI	T1,440700	;FORM LH OF BYTE POINTER
	PUSH	P,[ILDB CH,T1]	;INSTRUCTION TO GET NEXT CHAR
TTYOLP:	XCT	(P)		;GET NEXT CHAR INTO CH
	PJUMPE	CH,TTYNOW	;IF EOL, FORCE OUT TTY NOW
	CAIN	CH,"["		;LEFT BRACKET?
	TLO	F,(F.LBRK)	;YES, FLAG INSIDE EXPLANATION
	TLNE	F,(F.LBRK)	;ARE WE INSIDE AN EXPLANATION?
	JUMPLE	LV,TTYSBK	;YES, IS HELP LEVEL SHOR OR PROMPT?
	CAIN	CH,"("		;NO, LONG MODE, IS THIS CHAR LEFT PAREN?
	TLO	F,(F.LPAR)	;YES, FLAG INSIDE PROMPTING
	TLNE	F,(F.LPAR)	;ARE WE INSIDE PROMPTING?
	JUMPL	LV,TTYSPR	;YES, IS HELP LEVEL SHORT?

;HERE IF HELP LEVEL PERMITS THESE CHARS TO BE OUTPUT
	CAIN	CH,"*"		;NO, IS IT ASTRISCK?
	PUSHJ	P,EITAST	;YES, SUBSTITUTE N FOR IT
	  PUSHJ	P,TTYPUT	;ARG TO EITAST OR OUTPUT CHAR ROUTINE

;HERE TO SUPPRESS PROMPTING INSIDE PARENS(SHORT MODE ONLY)
TTYSPR:	CAIN	CH,")"		;WAS CHAR JUST OUTPUT RIGHT PAREN?
	TLZ	F,(F.LPAR)	;YES, CLEAR INSIDE PROMPTING FLAG

;HERE TO SUPPRESS EXPLANATION INSIDE BRACKETS(SHORT AND PROMPT MODES)
TTYSBK:	CAIN	CH,"]"		;WAS CHAR JUST OUTPUT RIGHT BRACKET?
	TLZ	F,(F.LBRK)	;YES, CLEAR INSIDE EXPLANATION
	JRST	TTYOLP		;LOOP AND GET NEXT CHAR
;ROUTINE TO SUBSTITUTE FOR * IN OUTPUT TO FIL OR TTY USING N
;CALL:	MOVE	N,[SIXBIT / /] OR DECIMAL NUMBER
;	MOVEI	R,RADIX
;	MOVE	T1,BYTE POINTER
;	CAIN	CH,"*"
;	PUSHJ	P,EITAST
;	  PUSHJ	P,FILPUT OR TTYPUT
;	RETURN	HERE WITH T1 AND N PRESERVED

EITAST:	PUSH	P,T1		;SAVE BYTE POINTER TO STRING
	TLNN	N,770000	;DOES N HAVE A SIXBIT ARG?
	JRST	EITAS2		;NO, OUTPUT AS A NUMBER

;HERE TO OUTPUT N AS SIXBIT FOR *
	MOVE	WD,[XWD 440600,N] ;SETUP BYTE POINTER TO SIXBIT ARG
EITAS1:	ILDB	CH,WD		;GET NEXT SIXBIT CHAR
	JUMPE	CH,TPOPJ1	;IS IT END OF SIXBIT?
	ADDI	CH,40		;CONVERT TO ASCII
	XCT	@-1(P)		;OUTPUT CHAR TO TTY OR FIL ACCORDING
				; TO ARG IN CALLING SEQUENCE
	TLNE	WD,770000	;BYTE POINTER EXHAUSTED WD?
	JRST	EITAS1		;NO, KEEP GETTING SIXBIT CHARS
	JRST	TPOPJ1		;YES, RETURN

;HERE TO CONVERT N AND OUTPUT ACCORDING TO CURRENT RADIX
EITAS2:	MOVE	WD,@-1(P)	;GET ADR OF CHAR PUT ROUTINE FOR TTY OR FILE
				; (TTYPUT OR FILPUT)
	MOVE	T1,N		;MOVE NO. TO DOUBLE AC
	CAIG	N,^D9		;SKIP IF GREATER THAN TWO CHARS
	TLNN	F,(F.2DEC)	;ONE CHAR, SKIP IF WANT AT LEAST TWO
	JRST	EITAS3		;GO AHEAD AS PLANNED
	MOVEI	CH,"0"		;OUTPUT LEADING ZERO
	PUSHJ	P,(WD)		;OUTPUT IT
EITAS3:	PUSHJ	P,EITSUB	;CALL RECURSIVE OUTPUT ROUTINE
TPOPJ1:	POP	P,T1		;RSTORE BYTE POINTER
CPOPJ1:	AOS	(P)		;SET FOR SKIP RETURN
CPOPJ:	POPJ	P,		;RETURN

EITSUB:	IDIVI	T1,(R)		;DIVIDE REMAINING NUMBER BY RADIX
	HRLM	T2,(P)		;SAVE REMAINDER ON STACK
	JUMPE	T1,EITSB1	;REMAINING NUMBER ALL GONE?
	PUSHJ	P,EITSUB	;NO, DIVIDE REMAINING NUMBER BY RADIX AGAIN
EITSB1:	HLRZ	CH,(P)		;GET MOST RECENT CHAR CONVERTED
	ADDI	CH,"0"		;CONVERT TO ASCII
	PJRST	(WD)		;OUTPUT CHAR TO TTY OR FIL AS SPECIFIED
				; IN CALLING SEQUENCE
				; RETURN TO EITSB1 UNTIL ALL CHAR OUTPUT
;ROUTINE TO OUTPUT JUST A STRING AND SUBSTITUTE ASCSTR FOR *
;CALL:	FILSTR	<MESSAGE*MESSAGE@>

FILSTR:	HRLI	T1,440700	;FORM LH OF BYTE POINTER
STRLOP:	ILDB	CH,T1		;GET NEXT CHAR
	JUMPE	CH,CPOPJ	;END OF STRING?
	CAIN	CH,"*"		;IS THIS ASTERISK?
	JRST	STRSUB		;YES, SUBSTITUTE STRING IN ASCSTR
	PUSHJ	P,FILPUT	;NO, STORE THIS CHAR IN FILE OUTPUT BUFFER
	JRST	STRLOP		;GO GET NEXT CHAR

STRSUB:	PUSH	P,T1		;SAVE BYTE POINTER SO FAR
	MOVEI	T1,ASCSTR	;SETUP TO OUTPUT FROM WHERE USER TYPED IN
	PUSHJ	P,FILOUT	;OUTPUT STRING TO FILE
	POP	P,T1		;RESTORE BYTE POINTER TO WHERE LEFT OFF
	JRST	STRLOP		;GO GET NEXT CHAR(SKIP OVER * ITSELF)

;ROUTINE TO OUTPUT LEFT ANGLE BRACKET CRLF TO FILE
;CALL:	PUSHJ	P,FILLAB

FILLAB:	MOVEI	CH,"<"		;LEFT ANGLE BRACKET
	PUSHJ	P,FILPUT	;PUT IN OUTPUT FILE
	PJRST	FCRLF		;OUTPUT CRLF TO FILE

;ROUTINE TO OUTPUT RIGHT ANGLE BRACKET CRLF TO FILE
;CALL:	PUSHJ	P,FILRAB

FILRAB:	MOVEI	CH,">"		;RIGHT ANGLE BRACKET
	PUSHJ	P,FILPUT	;PUT IN OUTPUT FILE
				; FALL INTO FCRLF
;ROUTINE TO OUTPUT CRLF TO FILE
;CALL:	PUSHJ	P,FCRLF

FCRLF:	MOVEI	CH,C.CR		;OUTPUT CR
	PUSHJ	P,FILPUT	;TO FILE
	MOVEI	CH,C.LF		;THEN LINE FEED
				; FALL INTO FILPUT
;ROUTINE TO OUTPUT 1 CHAR TO OUTPUT FILE, IF @ SUBSTITUTE CRLF
; OUTPUT TO TTY TOO IF DEBUGGING FLAG IS SET(DEBUG)
;INSERT PRECEDING ; IF FIRST CHAR ON A LINE AND F.COM SET
;CALL:	MOVEI	CH,CHAR
;	PUSHJ	P,FILPUT
;	RETURN CH PRESERVED

FILPUT:	TLNN	F,(F.SUPP)	;FILE OUTPUT SUPPRESSED?
	TLNN	F,(F.OFO)	;OUTPUT FILE OUTPUT YET?
	POPJ	P,		;NO, MUST BE ASKING QUESTION ABOUT OUTPUT FILE
	CAIN	CH,"@"		;YES, IS THIS CHAR THE CRLF CHAR?
	PJRST	FCRLF		;YES, OUTPUT CRLF TO FILE AND RETURN
	SKIPE	DEBUG		;NO, ARE WE DEBUGGING?
	TLOE	F,(F.TF)	;YES, IS THIS THE FIRST CHAR TO FIL
				; AFTER TTY OUTPUT?
	JRST	FILPU1		;NO, LEFT ANGLE ALREADY OUTPUT
	PUSH	P,CH		;YES, SAVE CHAR
	MOVEI	CH,"<"		;FLAG START OF OUTPUT WITH LEFT ANGLE
	PUSHJ	P,TTYPU1	;ON TTY
	POP	P,CH		;RESTORE REAL FIRST CHAR TO FILE
FILPU1:	TLZE	F,(F.FLF)	;WAS LAST CHAR OUTPUT TO FILE A LF?
	TLNN	F,(F.COM)	;YES, SHOULD THIS LINEN BE A COMMENT IN FILE?
	JRST	FILPU2		;NO, SO OUTPUT IT
	PUSH	P,CH		;YES, SAVE FIRST CHAR OF LINE
	MOVEI	CH,";"		;INSTEAD PUT OUT SEMI-COLON AS COMMENT CHAR
	PUSHJ	P,FILPU3	; AS FIRST CHAR ON LINE
	MOVEI	CH,";"		;OUTPUT 2 ; IN CASE COMMENT IS IN MACRO
	PUSHJ	P,FILPU3	;SO WONT SAVE COMMENT IN MACRO EXPANSION
	MOVEI	CH,"	"	;TAB
	PUSHJ	P,FILPU3	;OUTPUT TAB
	POP	P,CH		;RESTORE FIRST CHAR OF COMMENT
FILPU2:	CAIN	CH,C.LF		;IS THIS CHAR A LINE FEED?
	TLO	F,(F.FLF)	;YES, FLAG LAST CHAR OUTPUT WAS A LINE FEED
				; FOR NEXT CALL TO FILPUT
FILPU3:	SKIPE	DEBUG		;DEBUGGING SO WANT TO SEE FILE OUTPUT
	PUSHJ	P,TTYPU1	;YES, OUTPUT TO TTY TOO
	SOSG	FOBUF+2		;DECREMENT BUFFER COUNTER
	PUSHJ	P,[OUT	FILCHN,	;BUFFER FULL, GIVE TO MONITOR
		   POPJ	P,	;NO ERRORS
		   JRST FILERR]	;FILE ERROR, COMPLAIN AND START OVER
	IDPB	CH,FOBUF+1	;STORE CHAR IN BUFFER
	POPJ	P,		;RETURN
;ROUTINE TO OUTPUT CRLF TO TTY
;CALL:	PUSHJ	P,TCRLF

TCRLF:	MOVEI	CH,C.CR		;CR CHAR
	PUSHJ	P,TTYPUT	;OUTPUT TO TTY
	MOVEI	CH,C.LF		;LINE FEED CHAR
				; FALL INTO TTYPUT ROUTINE

;ROUTINE TO OUTPUT 1 CHAR TO TTY, IF @ SUBSTITUTE CRLF
;CALL:	MOVEI	CH,CHAR
;	PUSHJ	P,TTYPUT
;	RETURN CH PRESERVED

TTYPUT:	CAIN	CH,"@"		;IS THIS THE CRLF CHAR?
	PJRST	TCRLF		;YES, OUTPUT CRLF ON TTY AND RETURN
	SKIPE	DEBUG		;NO, ARE WE DEBUGGING?
	TLZN	F,(F.TF)	;YES, IS THIS FIRST CHAR ON TTY AFTER FIL?
	JRST	TTYPU1		;NO, OK TO OUTPUT
	PUSH	P,CH		;YES, SAVE REAL FIRST CHAR
	MOVEI	CH,">"		;AND INDICATE TERMINATION OF FILE OUTPUT
	PUSHJ	P,TTYPU1	;OUTPUT TO TTY
	POP	P,CH		;RESTORE REAL FIRST TTY CHAR

;SUBROUTINE TO REALLY OUTPUT 1 CHAR TO TTY
TTYPU1:	SKIPE	INIFLG		;IF TTY NOT INITED
	 JRST	TTYPU0		;DO IT SLOW WAY
	SOSG	TOBUF+2		;ROOM IN THIS OUTPUT BUFFER?
	OUTPUT	TTYCHN,		;NO, SO OUTPUT 
	IDPB	CH,TOBUF+1	;THEN STORE THIS CHAR IN BUFFER
	POPJ	P,		;RETURN

TTYPU0:	OUTCHR	CH		;YUCK
	POPJ	P,

;SUBROUTINE TO FORCE OUT CURRENT BUFFER NOW
;CALL:	PUSHJ	P,TTYNOW

TTYNOW:	SKIPN	INIFLG
	OUTPUT	TTYCHN,		;GIVE BUFFER TO MONITOR
	POP	P,(P)		;REMOVE INSTRUCTION FROM STACK
	POPJ	P,		;RETURN
;SUBROUTINE TO HANDLE EOL ON TTY INPUT FOR MIC
MICEOL:	SKIPN	MICFLG		;MIC FILE?
	 POPJ	P,		;NOPE
	PUSH	P,CH
	TLNE	F,(F.CONZ)
	 PUSHJ	P,[MOVEI CH,"^"
		   PUSHJ P,MICPTD
		   MOVEI CH,"Z"
		   PJRST MICPTD]
	MOVEI	CH,15		;CR
	PUSHJ	P,MICPTD
	MOVEI	CH,12		;LF
	PUSHJ	P,MICPTD
	POP	P,CH
	POPJ	P,

;SUBROUTINE TO PUT THE MIC FILE ON A NEW LINE
MICNL:	SKIPGE	MICFLG		;CRLF NEEDED?
	 POPJ	P,		;NOPE
	PUSH	P,T1
	PUSH	P,CH
	MOVEI	T1,[BYTE (7)15,12,0]
	PUSHJ	P,MICSTR
	POP	P,CH
	POP	P,T1
	POPJ	P,

;SUBROUTINE TO OUTPUT A STRING TO MIC
MICSTR:	HRLI	T1,(POINT 7,,)
MICST1:	ILDB	CH,T1
	JUMPE	CH,CPOPJ
	PUSHJ	P,MICPUT
	JRST	MICST1
;SUBROUTINE TO OUTPUT A SIXBIT WORD TO MIC
MICSIX:	MOVE	T2,T1		;COPY
MICSX1:	JUMPE	T2,CPOPJ	;EXIT IF DONE
	SETZ	T1,		;REMOVE JUNK
	LSHC	T1,6		;NEXT CHAR
	MOVEI	CH," "-' '(T1)	;MAKE ASCII
	PUSHJ	P,MICPUT	;TYPE
	JRST	MICSX1		;CONTINUE

;SUBROUTINE TO OUTPUT "*" IF IN COL 0, THEN 1 CHAR TO MIC
MICPTD:	SKIPL	MICFLG		;IN COL 0?
	 JRST	MICPUT		;NO
	HRLI	CH,"*"
	TLNE	F,(F.CONZ)
	 TLC	CH,"*"^!"="
	MOVSS	CH
	PUSHJ	P,MICPUT
	HLRZS	CH
;	JRST	MICPUT

;SUBROUTINE TO OUTPUT 1 CHAR TO MIC
MICPUT:	SKIPN	MICFLG		;FILE OK?
	 POPJ	P,		;NOPE
	SOSG	MOBUF+2		;ROOM IN THIS OUTPUT BUFFER?
	OUTPUT	MICCHN,		;NO, SO OUTPUT 
	IDPB	CH,MOBUF+1	;THEN STORE THIS CHAR IN BUFFER
	MOVMS	MICFLG		;NOT IN COL 0
	CAIN	CH,12		;UNLESS LF
	 SETOM	MICFLG		;IN WHICH CASE, WE ARE
	POPJ	P,		;RETURN
SUBTTL	DATA STORAGE

;CONSTANTS:

;DEFAULT FILE NAMES:
FILTAB:	SIXBIT	/SYSCNF/	;SYSGEN
	SIXBIT	/F/		;FGEN

;DISPATCH TABLE:
GENTAB:	EXP	SYSGEN		;SYSGEN
	EXP	FGEN		;FGEN


LSTD44:	I,,PAR			;INDEX BY DC44 NUMBER
	I,,PAP			;PA611R AND PA611P
	I,,LPC			;END LPC11
	I,,PCR			;END PC11 READERS
	I,,PCP			;AND PC11 PUNCHES
TYPDEV=.-LSTD44-1
;VARIABLES:
; THESE ARE STRICTLY INTERNAL TO MONGEN AND ARE NEVER OUTPUT IN FILE
;ONES NOT CLEARED IN MAIN LOOP, INSTEAD SET TO INITIAL VALUES ONLY ON GET.
; THUS ^C START DOES NOT INITIALIZE:


HELPF:	-1		;FLAG TO TYPE /HELP ONLY ONCE THRU LOOP OR START
DEBUG:	0		;PATCH NON-ZERO TO DEBUG BY HAVING FIL OUTPUT TO TTY TOO
			; COME OUT ON TTY INSIDE <>
SAVLV:	0		;CURRENT PERMANENT VERBOSITY LEVEL FOR ASKING QUESTIONS
			; AC LV MAY BE DIFFERENT IF USER HAS CHANGED
			; LEVEL FOR THIS QUESTION ONLY
			; LEVELS ARE -1 FOR SHORT, 0 FOR PROMPT,
			; AND 1 OR GREATER FOR LONG
			; INITIALLY SET TO PROMPT ON A GET

BITTBL:
ZZ==-1			;START BIT NUMBERING
REPEAT ^D36,<EXP 1B<<ZZ==ZZ+1>>> ;BUILD INDEXABLE LIST OF BITS
IF2,PURGE ZZ
SUBTTL	IMPURE STORAGE FOR FGEN


FTINI:	BLOCK	1	;INITIALIZATION FLAG
FTMOD:	BLOCK	1	;OUTPUT MODE FLAG
FTNAM:	BLOCK	1	;FEATURE TEST TO ADD OR CHANGE
FTCFG:	BLOCK	1	;FEATURE TEST CONFIG BITS
FTTXT:	BLOCK	MP.FTL	;FEATURE TEST DESCRIPTIVE TEXT

FTINAM:	BLOCK	FTLEN	;FEATURE TEST NAMES
FTICFG:	BLOCK	FTLEN	;FEATURE TEST CONFIG BITS
FTCTXT:	BLOCK	MP.FTA*<<MP.FTL/5>+1> ;CUSTOMER DESCRIPTIVE TEXT STORAGE
RUNDEV:	BLOCK	1	;DEVICE FROM RUN OR GET
RUNPPN:	BLOCK	1	;DIRECTORY FROM RUN OR GET
RUNPTH:	BLOCK	.PTMAX	;PATH BLOCK POINTED TO BY RUNPPN IF SFD
MOBUF:	BLOCK	3	;MIC OUTPUT BUFFER
MICFLG:	BLOCK	1	;0 IF MIC FILE NOT OPEN
MICBUF:	BLOCK	NMICBF*203	;BUFFERS FOR MIC FILE
INIFLG:	BLOCK	1		;FLAG FOR TTY NOT INIT'D YET

;VARIABLES CLEARED EACH TIME THROUGH MAIN LOOP FOR A NEW GEN:

VARBEG:			;FIRST LOC CLEARED ON MAIN LOOP
PDLIST:	BLOCK	MP.PDL+1	;PD LIST
ASKTAB:	BLOCK	MP.AMX+1	;TABLE TO STOR POSSIBLE ANSWERS
				; SETUP BY ASKLST WITH PROMPTING INSIDE ()
				; LAST ENTRY MUST BE ZERO AS FLAG OF END
				; FIRST ENTRY MAYBE 0 TO MEAN NO DEFAULT
				; IE (,ANS0,ANS1,...)
ASCSTR:	BLOCK	<MP.LMX+4+1>/5	;STRING FOR TTY INPUT LINE(SEE TTYIN)
			; ENOUGH ROOM FOR MP.LMX CHAR, PLUS NULL
SAVN:	BLOCK	1	;PLACE TO SAVE MATCH INDEX IN ASKLST SUB
CNFIND:	BLOCK	1	;INDEX OF SYSTEM TYPE
MINLIM:	BLOCK	1	;MIN VALUE FOR ASK QUESTION.  SET BY NOS. INSIDE ()
			; WHICH PRECED A DASH.
MAXLIM:	BLOCK	1	;MAX VALUE FOR ASK QUESTION.  SET BY NOS. INSIDE
			; WHICH FOLLOW A DASH.
DFAULT:	BLOCK	1	;DEFAULT FOUND FIRST INSIDE () IN ASK QUESTION
			; BY SETLST ROUTINE
WCHGEN:	BLOCK	1	;WHICH GEN, 0=SYS, 1=F
WCHNAM:	BLOCK	1	;WHICH GEN NAME, LH=SIXBIT SYS, F
CPU:	BLOCK	1	;LOOP COUNTER FOR CPU LOOP
CPUN:	BLOCK	1	;LOOP COUNTER FOR DEVICES ON CPUS OTHER THAN 0
SMP:	BLOCK	1	;FLAG FOR MULTI-CPU MONITOR GENERATION
UNAUTC:	BLOCK	1	;FLAG WHETHER TO ASK ABOUT OBSOLETE HARDWARE
DLSCAN:	BLOCK	1	;FLAG WHETHER TO ASK ABOUT DATA-LINE SCANNERS
DTA:	BLOCK	1	;LOOP COUNTER FOR DTA LOOP
RX20:	BLOCK	1	;LOOP COUNTER FOR RX20 LOOP
STANAM:	BLOCK	1	;SYSTEM-WIDE STATION NAME
MAXRTY:	BLOCK	1	;MAXIMUM POSSIBLE M.RTTY
M.TLTL:	BLOCK	1	;LOCAL LINES TALLY FOR MAXRTY
M.XTL:	BLOCK	1	;DA28 LINES TALLY FOR MAXRTY
M.RTTY:	BLOCK	1	;ANSWER TO NUMBER OF REMOTE TTYS IN SYSTEM

MDTBUF:	BLOCK	MP.AQB	;QUESTION TEXT BUFFER
MDTSYM:	BLOCK	1	;M.XXXX SYMBOL ADDRESS
MDTSIX:	BLOCK	1	;SIXBIT REPRESENTATION OF M.XXXX
MDTKON:	BLOCK	1	;SIXBIT DRIVER NAME
MDTBIT:	BLOCK	1	;FLAGS
MDTTXT:	BLOCK	1	;ADDRESS OF INTRODUCTORY TEXT
MDTRES:	BLOCK	SM.CPU	;STORAGE FOR PER-CPU COUNTERS
Z.MDTB==.		;START OF MONGEN'ED DEVICE DATA TO ZERO
MDTCPU:	BLOCK	1	;CPU
MDTDVC:	BLOCK	1	;DEVICE CODE/IVI
MDTUNI:	BLOCK	1	;MASSBUS UNIT NUMBER
MDTDRV:	BLOCK	1	;DRIVE NUMBER
MDTFLG:	BLOCK	1	;-1 IF ALL DRIVES ON KONTROLLER
			; 0 IF NOT SPECIFIED
			; 1 IF NO DRIVES ON KONTROLLER
MDTUAD:	BLOCK	1	;UNIBUS ADDRESS OF KONTROLLER
Z.MDTE==.-1		;END OF MONGEN'ED DEVICE DATA TO ZERO
UCMBGN:			;FIRST WORD OF USER DEFINED COMMAND BLOCK
UCMCMD:	BLOCK	1	;COMMAND NAME
UCMPRG:	BLOCK	1	;PROGRAM NAME
UCMADR:	BLOCK	1	;DISPATCH ADDRESS
UCMBP1:	BLOCK	1	;INITIAL BYTE POINTER TO FLAGS/UNIQUE BITS
UCMBP2:	BLOCK	1	;FINAL BYTE POINTER TO FLAGS/UNIQUE BITS
UCMEND==.-1		;END OF BLOCK

TCLASS:	BLOCK	1	;TTY CLASS BEING DEFINED
TLENG:	BLOCK	1	;FORMS LENGTH
TWIDTH:	BLOCK	1	;CARRIAGE WIDTH
TFILL:	BLOCK	1	;FILLER CLASS
TANSLV:	BLOCK	1	;PURE ANSI PART OF DECLVL
TDECLV:	BLOCK	1	;FULL CONFORMANCE LEVEL TO DEC STD 070
TBACKP:	BLOCK	1	;BACKSPACE-SPACE-BACKSPACE RUBOUT TABLE
TERASE:	BLOCK	1	;ERASURE TABLE POINTER
CLSCHB:	BLOCK	TCRLEN	;CLASS CHARACTERISTICS

TTYPE:	BLOCK	1	;TTY TYPE BEING DEFINED
TCATTR:!		;CLASS ATTRIBUTES
TONATR:	BLOCK	ATRLEN	;ATTRIBUTES TO IOR
TOFATR:	BLOCK	ATRLEN	;ATTRIBUTES TO ANDCAM
CURCHR:!		;CURRENT CHARACTERISTICS BLOCK IN PARSE
CURATR:	BLOCK	1	;CURRENT ATTRIBUTES BLOCK IN PARSE

;FILE 4 WORD ENTER BLOCK:
OUTNAM:	BLOCK	1	;FILE NAME
OUTEXT:	BLOCK	1	;FILE EXTENSION
OUTDAT:	BLOCK	1	;FILE DATE
OUTPPN:	BLOCK	1	;FILE PROJECT, PROGRAMMER NUMBER
SAVPPN:	BLOCK	1	;SAVE PPN FOR MESSAGE AFTER ENTER
;BUFFER HEADERS:
TIBUF:	BLOCK	3	;TTY INPUT BUFFER HEADER
TOBUF:	BLOCK	3	;TTY OUTPUT BUFFER HEADER
FOBUF:	BLOCK	3	;FILE OUTPUT BUFFER HEADER
FHIBUF:	BLOCK	3	;FGEN AUXILIARY HELP FILE INPUT BUFFER HEADER

;BUFFERS
FILBUF:	BLOCK	NFILBF*203	;BUFFERS FOR OUTPUT FILE
;VARIABLES WHICH ARE ALSO OUTPUT IN FILE AS SYMBOLS

;***************************************************************
;NOTE:	MACRO REQUIRES A ; AFTER ANGLE BRACKET IN CALL, ELSE TAB
; SNEAKS IN BETWEEN SYMBOL AND ;
;***************************************************************

;MACRO TO DEFINE CONSECUTIVE VARIABLES USED BY AOS(N) TRICK
;ORDER MUST BE THE SAME AS IN PROMPTING ANSWERS INSIDE PARENS

DEFINE	V (A)<
IRP (A) <M.'A:	BLOCK	1
>>

V <RTCO>;			;INCLUDE MONITOR OVERHEAD IN RUNTIME
V <EMRT>;			;EBOX/MBOX RUNTIME ACCOUNTING
V <XPI>;			;EXCLUDE PI TIME FROM USER RUNTIME
V <CPU>;			;NO. OF CPUS
V <KL10>;			;KL10 CPU
V <KS10>;			;KS10 CPU
V <C0SN,C1SN,C2SN,C3SN,C4SN,C5SN>;  ;CPU SERIAL NOS.
V <MON,DAY,YEAR>;		;MONTH, DAY, YEAR SYMBOLS
V <LOK>;			;INCLUDE LOCK UUO

;AUTOCONFIGURED DEVICES
Z.ATOB:!			;START OF AUTOCONFIGURED DEVICE STORAGE
V <CDP,CP10>;					;CARD PUNCH
V <CDR,CR10,CR20,DCR>;				;CARD READER
V <DISK,DPX,DRX,DSX,FHX,FSX,MDX,RAX,RNX,RPX>;	;DISKS
V <ENET>;					;ETHERNET
V <LPT,LP10,LP20,DLP>;				;LINE PRINTERS
V <PTP,PTR>;					;PAPER TAPE PUNCH/READER
V <PLT,XY10>;					;PLOTTERS
V <SA10>;					;SA10 SERVICE
V <SCA>;					;SCA SERVICE
V <TAPE,TS10,TX01,TM10,TC10,TM02,DX20,TM78>;	;TAPES
Z.ATOE==.-1			;END OF AUTOCONFIGURED DEVICE STORAGE

V <SETS>;			;DISK SET MASK
V <DTEN>;			;TOTAL NUMBER OF DTE20S
;HDWGEN:
V <VP10,340,VBXC>;		;TYPE OF DISPLAY
V <DAS78,D78L,0D78,1D78,2D78,3D78,4D78,5D78,6D78,7D78>;	;DAS78
V <DN6D,D60L,0D60,1D60,2D60,3D60,4D60,5D60,6D60,7D60,8D60,9D60,AD60,BD60>;	;DN60

;TTYGEN:
V <DC10,DC68,DC76>;		;TYPE OF TERMINAL COMMUNICATIONS EQUIPMENT
V <TTG0,TTG1,DSG0,DSG1,68L0,68L1,D70N,D71N,D72N,D73N,D74N,D75N,D76N,D77N>
V <DZNL>;
V <TTDN>;			;TOTAL NUMBER OF RSX20-F TERMINALS
	DEFINE	BLOK4(PREFIX,POSTFX)
<	IRP	PREFIX
<
PREFIX:
ZZZ=0
	REPEAT	8,<
	WORD	(PREFIX,\ZZZ,POSTFX)
ZZZ=ZZZ+1
>	;;END OF REPEAT 4
	WORD	(PREFIX,8,POSTFX)
	WORD	(PREFIX,9,POSTFX)
	WORD	(PREFIX,A,POSTFX)
	WORD	(PREFIX,B,POSTFX)
>	;;END OF IRP PREFIX
>	;;END OF DEFINE BLOK4

	DEFINE	WORD(A,B,C)
<A'B'C:	EXP	0
>

;NOTE THE POSTFIX IS A NOOP FOR PREFIXES OF 5 CHARACTERS E.G. TYPNU
M.DC44:	EXP	0	;NUMBER OF DC44S
TYPNUM:	EXP	0	;TOTAL NUMBER OF DC44 FRONT END DEVICES
	BLOK4	<TYPNU,PAR,PAP,LPC,PCR,PCP>,N

M.DC75:	EXP	0	;NUMBER OF DC75S OF DAS85S
M.0D85:	EXP	0	;SYMBOL INDICATING PORT PRESENT
M.1D85:	EXP	0
M.2D85:	EXP	0
M.3D85:	EXP	0
M.4D85:	EXP	0
M.5D85:	EXP	0
M.6D85:	EXP	0
M.7D85:	EXP	0
M.D78N:	EXP	0	;COUNT OF NUMBER OF DAS78S IN THE SYSTEM
M.DN60:	EXP	0	;COUNT OF GENERIC DN60 DEVICES
M.DN6K:	EXP	0	;COUNT OF KS10/DUP DN60 DEVICES
M.DN6R:	EXP	0	;COUNT OF KS10 DMR DN60 DEVICES
M.DN6S:	EXP	0	;COUNT OF KL10/DTE BASED DN60 DEVICES
M.KDPN:	EXP	0
M.DMRN:	EXP	0
M.DN8S:	EXP	0
M.DDCN:	EXP	0
M.CONN:	EXP	0	;ACCUMULATES DEFAULT # OF CONNECTS
VAREND==.-1		;LAST LOC TO CLEAR IN MAIN LOOP FOR NEW GEN
	END	BEGINA
